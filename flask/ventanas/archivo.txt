Java precisamente

Peter Sestoft

La prensa del MIT

Cambridge, Massachusetts Londres, Inglaterra



Copyright © 2002 Instituto Tecnológico de Massachusetts

Reservados todos los derechos. Ninguna parte de este libro puede reproducirse de ninguna forma por ningún medio electrónico o mecánico (incluidas fotocopias, grabaciones o almacenamiento y recuperación de información) sin el permiso por escrito del editor.

Este libro fue ambientado en Times por el autor usando . Impreso y encuadernado en los Estados Unidos de América.

Datos de catalogación en publicación de la Biblioteca del Congreso Sestoft, Peter.

Precisamente Java/Peter Sestoft.

pag. cm.

Incluye referencias bibliográficas e índice.

ISBN 0-262-69276-7 (pbk.: papel alk.)



1. Java (Lenguaje de programación informática) I. Título.

QA76.73.J38 S435 2002

005.13'3—dc21 2002016516



Tabla de contenido



Prefacio

Este libro ofrece una descripción concisa del lenguaje de programación Java 2, versiones 1.3 y 1.4. Es una referencia rápida para el lector que ya ha aprendido (o está aprendiendo) Java a partir de un libro de texto estándar y que desea conocer el lenguaje con más detalle. El libro presenta todo el lenguaje de programación Java y partes esenciales de las bibliotecas de clases: las clases de colección y las clases de entrada y salida. Las reglas generales se muestran principalmente en las páginas de la izquierda, y los ejemplos correspondientes se muestran únicamente en las páginas de la derecha. Todos los ejemplos son fragmentos de programas Java legales. Los programas de ejemplo completos, listos para ejecutar, están disponibles en el sitio web del libro.

<>.

El libro no cubre la recolección de basura, la finalización y las referencias débiles, la reflexión, los detalles de los números de punto flotante IEEE754 o Javadoc.

Agradecimientos Gracias a Rasmus Lund, Niels Hallenberg, Hans Henrik Løvengreen, Christian Gram, Jan Clausen, Anders Peter Ravn, Bruce Conrad, Brendan Humphreys, Hans Rischel y Ken

Friis Larsen por sus útiles comentarios, sugerencias y correcciones. Un agradecimiento especial a Rasmus Lund por permitirme adaptar su diagrama de colecciones para este libro. Gracias también a la Real Universidad Veterinaria y Agrícola y a la Universidad TI de Copenhague, Dinamarca, por su apoyo.



Convenciones de notación



Capítulo 1: Ejecución de Java: compilación, carga y ejecución

Antes de poder ejecutar un programa Java, se debe compilar y cargar. El compilador comprueba que el programa Java sea legal: que el programa se ajuste a la sintaxis (gramática) de Java, que los operadores (como

+) son operandos aplicados (como 5 y x) del tipo correcto, y así sucesivamente. Si es así, el compilador genera los llamados archivos de clase. Luego, la ejecución comienza cargando los archivos de clase necesarios.

Por lo tanto, ejecutar un programa Java implica tres etapas: compilación (verifica que el programa esté bien formado), carga (carga e inicializa clases) y ejecución (ejecuta el código del programa).



Capítulo 2: Nombres y Nombres Reservados

Un nombre legal (de una variable, método, campo, parámetro, clase, interfaz o paquete) comienza con una letra o signo de dólar ($) o guión bajo (_) y continúa con cero o más letras o signos de dólar o guiones bajos o dígitos. (0–9). Evite los signos de dólar en los nombres de las clases. Las letras mayúsculas y minúsculas son

considerado distinto. Un nombre legal no puede ser uno de los siguientes nombres reservados:



Capítulo 3: Convenciones de nomenclatura de Java

A menudo se siguen las siguientes convenciones de nomenclatura, aunque Java no las aplica:

Si un nombre se compone de varias palabras, entonces cada palabra (excepto posiblemente la primera) comienza con una letra mayúscula. Ejemplos: setLayout, addLayoutComponent.

Los nombres de variables, campos y métodos comienzan con una letra minúscula. Ejemplos: vehículo, myVehicle.

Los nombres de clases e interfaces comienzan con una letra mayúscula. Ejemplos: Cubo, ColorCube.

Las constantes con nombre (es decir, variables y campos finales) se escriben completamente en mayúsculas y las partes de los nombres compuestos están separadas por guiones bajos (_). Ejemplos: CENTRO, MAX_VALUE.

Los nombres de los paquetes son secuencias de nombres en minúsculas separados por puntos. Ejemplo: java.awt.event. Para mayor singularidad, a menudo tienen el prefijo de nombres de dominio inversos, como en com. sun.xml.util.



Capítulo 4: Comentarios y diseño del programa

Los comentarios no tienen ningún efecto sobre la ejecución del programa, pero pueden insertarse en cualquier lugar para ayudar a los humanos a comprender el programa. Hay dos formas: comentarios de una línea y comentarios delimitados. El diseño del programa no tiene ningún efecto en la ejecución del programa por parte de la computadora, pero se utiliza para ayudar a los humanos a comprender la estructura del programa.

Ejemplo 1: comentarios



comentario de clase {



// Este es un comentario de una línea; se extiende hasta el final de la línea.



/* Este es un comentario delimitado que se extiende a lo largo de varias líneas.

*/



int /* Este comentario delimitado se extiende sobre parte de una línea */ x = 117;



}





Ejemplo 2: estilo de diseño de programa recomendado



Por razones de espacio, este estilo de diseño no siempre se sigue en este libro. Diseño de clase { // Declaración de clase

ent a;







Diseño (int a) {



esto.a = a; // cuerpo de una línea



}







int sum(int b) { // Cuerpo de varias líneas

if (a > 0) { // Declaración if

devolver a + b; // declaración única

} else if (a < 0) { // Anidado if-else, declaración de bloque int res = -a + b;

regire res * 117;

} else { // a == 0 // Terminal else, declaración de bloque int sum = 0;

for (int i=0; i<10; i++) { // Suma del bucle For += (b - i) * (b - i);

}

suma de devolución;

}

}



fecha de verificación booleana estática (int mes, int día) { int longitud;

switch (mth) { // Declaración de cambio

caso 2: // Longitud de caso único = 28; romper;



caso 4: caso 6: caso 9: caso 11: // Longitud de caso múltiple = 30; romper;

caso 1: caso 3: caso 5: caso 7: caso 8: caso 10: caso 12: longitud = 31; romper;

predeterminado: devuelve falso;

}

return (día >= 1) && (día <= duración);

}

}



Capítulo 5: Tipos

Un tipo es un conjunto de valores y operaciones sobre ellos. Un tipo es un tipo primitivo o un tipo de referencia.

Tipos primitivos

Un tipo primitivo es booleano o uno de los tipos numéricos char, byte, short, int, long, float y double. Los tipos primitivos, literales de ejemplo (es decir, constantes), tamaño en bits (donde 8 bits equivalen a 1 byte) y rango de valores, se muestran en la siguiente tabla:

Los tipos de números enteros son exactos dentro de su rango. Usan representación en complemento a 2 con signo (excepto char), por lo que cuando el número más positivo en un tipo es max, entonces el número más negativo es -max-

1. Los tipos de punto flotante son inexactos y siguen IEEE754, con el número de dígitos significativos

indicado por "sigdig". Para secuencias de escape de caracteres como \u0000, consulte la página 8.

Los literales enteros (de tipo byte, char, short, int o long) se pueden escribir en tres bases diferentes:

Para todos los tipos primitivos existen clases contenedoras correspondientes (tipos de referencia), a saber, booleano y carácter, así como byte, corto, entero, largo, flotante y doble, donde los últimos seis tienen la superclase común Número. Para usar un valor primitivo, como 17, donde se espera un objeto, use un objeto de su clase contenedora, como new Integer(17).

Tipos de referencia

Un tipo de referencia es un tipo de clase definido por una declaración de clase (sección 9.1), o un tipo de interfaz definido por una declaración de interfaz (sección 13.1), o un tipo de matriz (sección 5.3).

Un valor de tipo de referencia es nulo o una referencia a un objeto o matriz. El valor especial nulo

denota "ningún objeto". El nulo literal, que denota el valor nulo, puede tener cualquier tipo de referencia.



Tipos de matriz

Un tipo de matriz tiene la forma t[], donde t es cualquier tipo. Un tipo de matriz t[] es un tipo de referencia. Por lo tanto, un valor de tipo de matriz t[] es nulo o es una referencia a una matriz cuyo tipo de elemento es precisamente t (cuando t es un tipo primitivo), o es un subtipo de t (cuando t es un tipo de referencia).

Subtipos y compatibilidad

Un tipo t1 puede ser un subtipo de un tipo t2, en cuyo caso t2 es un supertipo de t1. Intuitivamente, esto significa que se puede utilizar cualquier valor v1 de tipo t1 cuando se espera un valor de tipo t2. Cuando t1 y t2 son tipos de referencia, t1 debe proporcionar al menos la funcionalidad (métodos y campos) proporcionada por t2. En particular, cualquier valor v1 de tipo t1 puede estar vinculado a una variable, campo o parámetro x2 de tipo t2, por ejemplo, mediante la asignación x2 = v1 o mediante el paso de parámetros. También decimos que los tipos t1 y t2 son compatibles. Las siguientes reglas determinan cuándo un tipo t1 es un subtipo de un tipo t2:

Cada tipo es un subtipo de sí mismo.

Si t1 es un subtipo de t2 y t2 es un subtipo de t3, entonces t1 es un subtipo de t3.

char es un subtipo de int, long, float y double.

byte es un subtipo de short, int, long, float y double.

short es un subtipo de int, long, float y double.

int es un subtipo de long, float y double.

long es un subtipo de float y double.

float es un subtipo de double.

Si t1 y t2 son clases, entonces t1 es un subtipo de t2 si t1 es una subclase de t2.

Si t1 y t2 son interfaces, entonces t1 es un subtipo de t2 si t1 es una subinterfaz de t2.

Si t1 es una clase y t2 es una interfaz, entonces t1 es un subtipo de t2 siempre que t1 (sea una subclase de una clase que) implemente t2 o implemente una subinterfaz de t2.

El tipo de matriz t1 [] es un subtipo del tipo de matriz t2 [] si el tipo de referencia t1 es un subtipo del tipo de referencia t2.

Cualquier tipo de referencia t, incluido cualquier tipo de matriz, también es un subtipo de clase Objeto predefinida.

Ningún tipo primitivo es un subtipo de un tipo de referencia. Ningún tipo de referencia es un subtipo de un tipo primitivo.



Firmas y Subsunción

Una firma tiene la forma m(t1,..., tn), donde m es el nombre de un método o constructor y (t1,..., tn) es una lista de tipos (ejemplo 25). Cuando el método se declara en la clase T y no se hereda de una superclase, entonces su firma extendida es m(T, t1,..., tn); esto se usa en llamadas a métodos (sección 11.11).

Decimos que una firma sig1 = m(t1,..., tn) subsume la firma sig2 = m(u1,..., un) si cada ui es un subtipo de ti. También decimos que sig2 es más específico que sig1. Tenga en cuenta que el nombre del método my el número n de tipos deben ser los mismos en las dos firmas. Dado que cada tipo ti es un subtipo de sí mismo, cada firma se subsume a sí misma. En una colección de firmas puede haber una que esté subsumida por todas las demás; dicha firma se denomina firma más específica. Ejemplos:

m (doble, doble) se subsume a sí mismo y m(doble, int) y m(int, doble) y

m(int,int).

m (doble le, int) se subsume a sí mismo y m(int, int).

m(int, double) se subsume a sí mismo y m(int, int).

m (doble, int) no incluye a m (int, doble), ni al revés.

La colección m(double, int), m(int, int) tiene la firma más específica m(int, int).

La colección m(double, int), m(int, double) no tiene una firma más específica.



Capítulo 6: Variables, parámetros, campos y alcance

Descripción general

Una variable se declara dentro de un método, constructor, bloque inicializador o declaración de bloque (sección 12.2). La variable sólo se puede utilizar en esa declaración de bloque (o método, constructor o bloque inicializador), y sólo después de su declaración.

Un parámetro es un tipo especial de variable: se declara en la lista de parámetros de un método o constructor y se le asigna un valor cuando se llama al método o constructor. El parámetro sólo se puede utilizar en ese método o constructor, y sólo después de su declaración.

Un campo se declara dentro de una clase, pero no dentro de un método, constructor o bloque inicializador de la clase. Se puede utilizar en cualquier parte de la clase, también textualmente antes de su declaración.



Valores vinculados a variables, parámetros o campos

Una variable, parámetro o campo de tipo primitivo contiene un valor de ese tipo, como el booleano falso, el entero 117 o el número de punto flotante 1. 7. Una variable, parámetro o campo de tipo de referencia t tiene el valor especial nulo o contiene una referencia a un objeto o matriz. Si es un objeto, entonces la clase de ese objeto debe ser t o una subclase de t.

Declaraciones de variables

El propósito de una variable es mantener un valor durante la ejecución de una declaración de bloque (o método, constructor o bloque inicializador). Una declaración de variable tiene una de las formas

tipo de modificador de variable varname1, varname2, ...;

tipo de modificador de variable varname1 = inicializador1, ...;

Un modificador de variable puede ser final o estar ausente. Si una variable se declara final, entonces se debe inicializar o asignar como máximo una vez en tiempo de ejecución (exactamente una vez si alguna vez se usa): es una constante con nombre. Sin embargo, si la variable tiene un tipo de referencia, entonces el objeto o matriz al que apunta la variable aún puede modificarse. Un inicializador de variable puede ser una expresión o un inicializador de matriz (sección 8.2).

La ejecución de la declaración de variable reservará espacio para la variable, luego evaluará el inicializador, si lo hay, y almacenará el valor resultante en la variable. A diferencia de un campo, a una variable no se le asigna un valor predeterminado cuando se declara, pero el compilador verifica que se le haya asignado un valor antes de usarla.



Alcance de variables, parámetros y campos

El alcance de un nombre es la parte del programa en la que el nombre es visible. El alcance de una variable se extiende desde justo después de su declaración hasta el final de la declaración del bloque más interno. El alcance de un método o parámetro de constructor es el cuerpo completo del método o constructor. Para una variable de control x declarada en una declaración for

para (int x = ...; ...; ...) cuerpo

el alcance es la declaración for completa, incluidos el encabezado y el cuerpo.

Dentro del alcance de una variable o parámetro x, no se puede redeclarar x. Sin embargo, se puede declarar una variable x dentro del alcance de un campo x, ocultando así el campo. Por lo tanto, el alcance de un campo x es toda la clase, excepto cuando esté sombreado por una variable o parámetro del mismo nombre, y excepto los inicializadores que preceden a la declaración del campo (sección 9.1).

Ejemplo 3: Declaraciones de variables public static void main(String[] args) { int a, b, c;

int x = 1, y = 2, z = 3; relación interna = z/x;

doble PI final = 3,141592653589; booleano encontrado = falso;

final int maxyz;



si (z > y) maxyz = z; de lo contrario maxyz = y;

}





Ejemplo 4: alcance de campos, parámetros y variables

Este programa declara cinco variables o campos, todos llamados x, y muestra dónde está cada uno dentro del alcance (visible). Las variables y los campos están etiquetados como #1, ..., #5 como referencia.



alcance de clase {



... //



void ml(int x) { // Declaración del parámetro x (#1)



... // x #1 en alcance



} //



... //



vacío m2(int v2) { //



... // x #5 en alcance



} //



... //



vacío m3 (int v3) { //



... // x #5 en alcance



intx; // Declaración de la variable x (#2)



... // x #2 en alcance



} //



... //



vacío m4 (int v4) { //



... // x #5 en alcance



{ //



intx; // Declaración de la variable x (#3)



... // x #3 en alcance



} //



... // x #5 en alcance



{ //



intx; // Declaración de la variable x (#4)



... // x #4 en alcance



} //



... // x #5 en alcance



} //



... //



intx; // Declaración del campo x (#5)



... // x #5 en alcance



}



Capítulo 7: Cuerdas

Una cadena es un objeto de la clase predefinida String. Un literal de cadena es una secuencia de caracteres entre comillas dobles: "Nueva York", "A38", "", etc. Internamente, un carácter se almacena como un número usando

la codificación de caracteres Unicode, cuyos códigos de caracteres del 0 al 127 coinciden con la antigua codificación de caracteres ASCII. Los literales de cadena y los literales de caracteres pueden utilizar secuencias de escape de caracteres:

Una secuencia de escape de caracteres representa un solo carácter. Dado que la letra A tiene el código 65 (decimal), que se escribe 101 en octal y0041 en hexadecimal, la cadena literal "A\101\u0041" es lo mismo que "AAA". Si s1 y s2 son expresiones de tipo String y v es una expresión de cualquier tipo, entonces

s1.length () de tipo int es la longitud de s1, es decir, el número de caracteres en s1.

s1.equals (s2) de tipo booleano es verdadero si s1 y s2 contienen la misma secuencia de caracteres y falso en caso contrario; equalsIgnoreCase es similar pero no distingue entre minúsculas y mayúsculas.

s1.charAt (i) de tipo char es el carácter en la posición i en s1, contando desde 0. Si el índice i es menor que 0, o mayor o igual que s1.length (), entonces se lanza StringIndexOutOfBoundsException.

s1.toString () de tipo String es el mismo objeto que s1.

String.valueOf (v) devuelve la representación de cadena de v, que puede tener cualquier tipo primitivo (sección 5.1) o tipo de referencia. Cuando v tiene un tipo de referencia y no es nulo, se convierte usando v.toString(); si es nulo, se convierte en la cadena "nulo". Cualquier clase C hereda de Object un método toString predeterminado que produce cadenas de la forma C@2a5734, donde 2a5734 es alguna dirección de memoria, pero toString puede anularse para producir cadenas más útiles.

s1 + s2 tiene el mismo significado que s1.concat (s2): construye la concatenación de s1

y s2, una nueva Cadena que consta de los caracteres de s1 seguidos de los caracteres de s2.

s1 + v y v + s1 se evalúan convirtiendo v en una cadena con String.valueOf (v), usando así v.toString () cuando v tiene un tipo de referencia y luego concatenando las cadenas resultantes.

s1.compareTo(s2) devuelve un entero negativo, cero o un entero positivo, según que s1 preceda, sea igual o siga a s2 en el orden lexicográfico habitual basado en la codificación de caracteres Unicode. Si s1 o s2 es nulo, se lanza la excepción NullPointerException. El método compareToIgnoreCase es similar pero no distingue entre minúsculas y mayúsculas.

Se describen más métodos String en la documentación de la biblioteca de clases Java [3].

Ejemplo 5: Igualdad de cadenas y la sutileza del operador (+)



Cadena s1 = "abc";

Cadena s2 = s1 + ""; // Nuevo objeto, pero contiene el mismo texto que s1 String s3 = s1; // Mismo objeto que s1



Cadena s4 = s1.toString(); // Mismo objeto que s1



// Las siguientes declaraciones imprimen falso, verdadero, verdadero, verdadero, verdadero: System.out.println("objetos idénticos s1 y s2: " + (s1 == s2)); System.out.println("objetos idénticos s1 y s3: " + (s1 == s3)); System.out.println("objetos idénticos s1 y s4: " + (s1 == s4)); System.out.println("s1 y s2 contienen el mismo texto: " + (s1.equals(s2))); System.out.println("s1 y s3 contienen el mismo texto: " + (s1.equals(s3)));

// Estas dos declaraciones imprimen 35A y A1025 porque (+) es asociativo por la izquierda: System.out.println(10 + 25 + "A"); // Igual que (10 + 25) + "A" System.out.println("A" + 10 + 25); // Igual que ("A" + 10) + 25



Ejemplo 6: concatenar todos los argumentos de la línea de comando

Al concatenar muchas cadenas, utilice un búfer de cadenas (capítulo 19 y ejemplo 84). público estático vacío principal (String [] argumentos) {

Cadena res = "";

for (int i=0; i<args.length; i++) res += args [i]; System.out.println(res);

}





Ejemplo 7: contar el número de e en una cadena



recuento estático (cadenas)



cuenta interna = 0;

for (int i=0; i<s.length(); i++) if (s.charAt(i) == 'e') ecount++;

cuenta de devolución;

}





Ejemplo 8: Determinar si las cadenas aparecen en orden lexicográficamente creciente



booleano estático ordenado (String[] a) para (int i=1; i<a.length; i++)

si (a[i-1].compareTo(a[i]) > 0)

falso retorno;

devolver verdadero;

}





Ejemplo 9: uso de una clase que declara un método toString

La clase Point (ejemplo 16) declara un método toString que devuelve una cadena de coordenadas del punto. El operador (+) llama implícitamente al método toString para formatear los objetos Point.



Punto p1 = nuevo Punto(10, 20), Punto p2 = nuevo Punto(30, 40);



System.out.println("p1 es " + pl); // Imprime: p1 es (10, 20) System.out.println("p2 es " + p2); // Imprime: p2 es (30, 40) p2.move(7, 7);

System.out.println("p2 es " + p2); // Imprime: p2 es (37, 47)



Capítulo 8: Matrices

Una matriz es una colección indexada de variables, llamadas elementos. Una matriz tiene una longitud determinada ℓ ≥ 0 y un tipo de elemento determinado t. Los elementos están indexados por los números enteros 0, 1,...,ℓ - 1. El valor de una expresión de tipo de matriz u[] es nulo o una referencia a una matriz cuyo tipo de elemento t es un subtipo de u. Si u es un tipo primitivo, entonces t debe ser igual a u.

Creación y acceso a matrices

Se crea (asigna) una nueva matriz de longitud ℓ con tipo de elemento t usando una expresión de creación de matriz:

nueva t[ℓ]

donde ℓ es una expresión de tipo int. Si el tipo t es un tipo primitivo, todos los elementos de la nueva matriz se inicializan a 0 (cuando t es byte, char, short, int o long) o 0.0 (cuando t es flotante o doble) o falso (cuando t es booleano). ). Si t es un tipo de referencia, todos los elementos se inicializan a nulo.

Si ℓ es negativo, se lanza la excepción NegativeArraySizeException.

Sea a una referencia del tipo de matriz u[], a una matriz con longitud ℓ y tipo de elemento t. Entonces

a.length de tipo int es el longitud ℓ de a, es decir, el número de elementos en a.

La expresión de acceso a la matriz a[i] denota el elemento número i de a, contando desde 0; este

La expresión tiene tipo u. La expresión entera i se llama índice de matriz. Si el valor de i es menor que 0 o mayor o igual que a.length, entonces se lanza la excepción ArrayIndexOutOfBoundsException.

Cuando t es un tipo de referencia, cada asignación de elemento de matriz a[i] = e verifica que el valor de e sea nulo o una referencia a un objeto cuya clase C sea un subtipo del tipo de elemento t. Si este no es el caso, se lanza la excepción ArrayStoreException. Esta verificación se realiza antes de cada asignación de elementos de la matriz en tiempo de ejecución, pero solo para los tipos de referencia.



Inicializadores de matriz

Una variable o campo de tipo matriz se puede inicializar en la declaración, utilizando una matriz existente o un inicializador de matriz para el valor inicial. Un inicializador de matriz es una lista separada por comas de cero o más expresiones encerradas entre llaves {...}:

t[] x = { expresión, ..., expresión }

El tipo de cada expresión debe ser un subtipo de t. La evaluación del inicializador provoca que se asigne una nueva matriz distinta, cuya longitud es igual al número de expresiones. Luego las expresiones se evalúan de izquierda a derecha y sus valores se almacenan en la matriz, y finalmente la matriz se vincula a x. Por lo tanto, x no puede aparecer en las expresiones: no se ha inicializado cuando se evalúan.

Los inicializadores de matrices también se pueden utilizar en relación con expresiones de creación de matrices:

nuevo t[] { expresión, ..., expresión }

Las matrices multidimensionales pueden tener inicializadores anidados (ejemplo 14). Tenga en cuenta que no hay constantes de matriz: se crea una nueva matriz distinta cada vez que se evalúa un inicializador de matriz.

Ejemplo 10: creación y uso de matrices unidimensionales



La primera mitad de este ejemplo lanza un dado mil veces y luego imprime las frecuencias de los resultados. La segunda mitad crea e inicializa una matriz de objetos String.



int[] frecuencia = nuevo int[6]; // Todo inicializado a 0

for (int i=0; i<1000; i++) { // Tira los dados, cuenta las frecuencias int die = (int) (1 + 6 * Math.random());

frecuencia[die-1] += 1;

}

para (int c=1; c<=6; c++)

System.out.println(c + " apareció " + frecuencia[c-1] + "veces");



Número de cadena [] = nueva cadena [20]; // Crea una matriz de elementos nulos

for (int i=0; i<número.longitud; i++) // Rellenar con cadenas "A0", ..., "A19" número[i] "A" + i;

for (int i=0; i<número.longitud; i++) // Imprimir cadenas



System.out.println(número[i]);





Ejemplo 11: Verificación del tipo de asignación de elementos de matriz en tiempo de ejecución

Este programa compila, pero en tiempo de ejecución a[2] =d arroja ArrayStoreException, ya que la clase del objeto vinculado a d (es decir, Doble) no es un subtipo del tipo de elemento de a (es decir, Integer).



Número[] a = nuevo entero[10]; // Longitud 10, tipo de elemento Entero Doble d = new Double(3.14); // Tipo Doble, clase Doble Entero i = new Integer(117); // Tipo Entero, clase Número Entero n = i; // Tipo Número, clase Entero

a[0] = yo; // OK, Integer es un subtipo de Integer



un[1] = norte; // OK, Integer es un subtipo de Integer



a[2] = re; // No, Doble no es subtipo de Entero





Ejemplo 12: uso de una matriz inicializada

El método checkdate aquí se comporta igual que checkdate en el ejemplo 2. La matriz debe declararse fuera del método; de lo contrario, se crea una nueva matriz distinta para cada llamada al método.



int estático [] días = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };



fecha de verificación booleana estática (int mes, int día)

{ return (mes >= 1) && (mes <= 12) && (día >= 1) && (día <= días[mes-1]); }



Ejemplo 13: creación de una cadena a partir de una matriz de caracteres

Al reemplazar el carácter cl por el carácter c2 en una cadena, el resultado se puede construir en una matriz de caracteres porque se conoce su longitud. Esto es un 50 por ciento más rápido que el ejemplo 85, que utiliza un búfer de cadena.



Cadena estática reemplazarCharChar(String s, char cl, char c2) {

char[] res = nuevo char[s.length()]; para (int i=0; i<s.length(); i++)

si (s.charAt(i) == cl)

res[i] = c2; demás

res[i] = s.charAt(i);

devolver nueva cadena (res); // Una cadena que contiene los caracteres de res

}



Matrices multidimensionales

Los tipos de matrices multidimensionales se escriben t[] [], t[] [] [], etc. Se crea (asigna) una matriz rectangular de n dimensiones de tamaño ℓ1 × ℓ2 × ... × ℓn utilizando la expresión de creación de matriz

nuevo t[ℓ1] [ℓ2] ... [ℓn]

Una matriz multidimensional a de tipo t[] [] es de hecho una matriz unidimensional de matrices; su componente

las matrices tienen tipo t[]. Por lo tanto, una matriz multidimensional no tiene por qué ser rectangular y no es necesario crear todas las dimensiones a la vez. Para crear solo las primeras k dimensiones de tamaño ℓ1 × ℓ2 × ... × ℓk de una matriz de n dimensiones, deje los últimos corchetes (n – k) vacíos:

nuevo t[ℓ1] [ℓ2] ... [ℓk] [] ... []

Para acceder a un elemento de una matriz a de n dimensiones, utilice n expresiones de índice: a[i1] [i2] ... [in].



Las matrices de clase de utilidad

La clase Arrays del paquete java.util proporciona métodos de utilidad estáticos para comparar, completar, ordenar y buscar matrices, y para crear una colección (capítulo 20) a partir de una matriz. Los métodos binarioBuscar, igualar, llenar y ordenar a re sobrecargado también en matrices de tipo byte, char, short, int, long, float, double, Object; y es igual y rellena también el tipo booleano. Las versiones de Objeto de binarioSearch y sort utilizan el método compareTo de los elementos de la matriz, a menos que se proporcione un objeto Comparador explícito (sección 20.8).

Lista estática asList (Objeto [] a) devuelve una vista java.util.List de los elementos de a, en orden de índice. La lista resultante implementa RandomAccess (sección 20.2 y ejemplo 94).

static int binarioSearch (byte[] a, byte k) devuelve un índice i>=0 para el cual a[i] ==k, si corresponde; de lo contrario, devuelve i<0 de modo que (-i-1) sería la posición adecuada para k. La matriz a debe ordenarse, como por sort(a), o de lo contrario el resultado no estará definido.

static int binarioSearch(Object[] a, Object k) funciona como el método anterior, pero compara elementos de la matriz usando su método compareTo (sección 20.8 y ejemplo 94).

static int binarioSearch (Objeto[] a, Objeto k, Comparador cmp) funciona como el método anterior, pero compara elementos de matriz usando el método cmp.compare (sección 20.8).

booleano estático es igual (byte[] a1, byte[] a2) devuelve verdadero si a1 y a2 tienen la misma longitud y contienen los mismos elementos, en el mismo orden.

Los valores booleanos estáticos (Objeto[] a1, Objeto[] a2) funcionan como el método anterior, pero compara elementos de la matriz usando su método igual (sección 20.8).

El relleno vacío estático (byte[] a, byte v) establece todos los elementos de a en v.

conjuntos de relleno de vacío estático (byte[] a, int from, int to, byte v)

a[de..(a-1)] a v.

La clasificación estática estática (byte [] a) ordena la matriz mediante clasificación rápida.

static void sort (Object[] a) ordena la matriz a usando mergesort, comparando los elementos de la matriz usando su método compareTo (sección 20.8).

La clasificación estática de vacío (Objeto[] a, Comparador cmp) funciona como el método anterior, pero compara elementos de la matriz utilizando el método cmp.compare (sección 20.8).

clasificación vacía estática (byte[] a, int from, int to) ordena a[from..(to-1)].

Ejemplo 14: creación de matrices multidimensionales



Considere esta matriz rectangular de 3 por 2 y esta matriz bidimensional "irregular" (triangular inferior):



El siguiente programa muestra dos formas (r1, r2) de crear la matriz rectangular y tres formas (t1, t2, t3) de crear la matriz "irregular":



doble[][] r1 = nuevo doble [3] [2];

doble[][] r2 = nuevo doble [3] []; para (int i=0; i<3; i++)

r2[i] = nuevo doble[2];

doble[][] t1 = nuevo doble [3][]; para (int i=0; i<3; i++)

t1[i] = nuevo doble[i+1];

doble[][] t2 = { { 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0, 0.0 } };

doble[][] t3 = nuevo doble[][] { { 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0, 0.0 } };





Ejemplo 15: uso de matrices multidimensionales

El material genético de los organismos vivos se encuentra en el ADN, conceptualmente una cadena AGCTTTTCA de nucleótidos A, C, G y T. Un triple de nucleótidos, como el AGC, se denomina codón; un codón puede codificar un amino



ácido. Este programa cuenta las frecuencias de los 4∙4∙4 = 64 codones posibles, utilizando una matriz tridimensional freq. La matriz auxiliar de Nuc se traduce de las letras de nucleótidos (A,C,G,T) a los índices (0,1,2,3) utilizados en frecuencia. La matriz toNuc se traduce de índices a letras de nucleótidos al imprimir las frecuencias.

static void codonfreq(String s) { int[] fromNuc = new int[128];

for (int i=0; i<fromNuc.length; i++) fromNuc[i] = -1;

deNuc['a'] = deNuc['A'] = 0; deNuc['c'] = deNuc['C'] = 1;

deNuc['g'] = deNuc['G'] = 2; deNuc['t'] = deNuc['T'] = 3;

int[][][] frecuencia = nuevo int [4][4][4];

for (int i=0; i+2<s.length(); i+=3) { int nuc1 = fromNuc[s.charAt(i)]; int nuc2 = fromNuc[s.charAt(i+1)];

int nuc3 = fromNuc[s.charAt(i+2)]; frecuencia[nuc1][nuc2][nuc3] += 1;

}

carácter final[] toNuc = { 'A', 'C', 'G', 'T' }; para (int i=0; i<4; i++)

para (int j=0; j<4; j++) {

para (int k=0; k<4; k++)

System.out.print(" "+toNuc[i]+toNuc[j]+toNuc[k]+": " + frecuencia[i][j][k]);

Sistema.out.println();

}

}



Capítulo 9: Clases

Declaraciones de clase y órganos de clase

Una declaración de clase de clase C tiene la forma

modificadores-de-clase clase C cláusula-extendida cláusula-implementos cuerpo-clase

Una declaración de clase C introduce un nuevo tipo de referencia C. El cuerpo de la clase puede contener declaraciones de campos, constructores, métodos, clases anidadas, interfaces anidadas y bloques inicializadores. Las declaraciones de una clase pueden aparecer en cualquier orden:

{

Declaraciones de campo Declaraciones de constructor Declaraciones de método Declaraciones de clase Declaraciones de interfaz Bloques inicializadores

}

Un campo, método, clase anidada o interfaz anidada se denomina miembro de la clase. Un miembro puede ser declarado estático. Un miembro no estático también se denomina miembro de instancia.

El alcance de un miembro es el cuerpo completo de la clase, excepto cuando esté sombreado por una variable o parámetro o por un miembro de una clase o interfaz anidada. El alcance de un campo (estático) no incluye los inicializadores (estáticos) que preceden a su declaración, pero el alcance de un campo estático sí incluye todos los inicializadores no estáticos. No puede haber dos clases o interfaces anidadas con el mismo nombre, ni dos campos con el mismo nombre, pero un campo, un método y una clase (o interfaz) pueden tener el mismo nombre.

Por código estático mExpresiones y declaraciones ean en inicializadores de campos estáticos, bloques de inicializadores estáticos y métodos estáticos. Por código no estático nos referimos a expresiones y declaraciones en constructores, inicializadores de campos no estáticos, bloques inicializadores no estáticos y métodos no estáticos. El código no estático se ejecuta dentro de un objeto actual, al que se puede hacer referencia como este (sección 11.10). El código estático no puede hacer referencia a miembros no estáticos ni a this, solo a miembros estáticos.

Clases de nivel superior, clases anidadas, clases de miembros y clases locales

Una clase de nivel superior es una clase declarada fuera de cualquier otra clase o declaración de interfaz. Una clase anidada es una clase declarada dentro de otra clase o interfaz. Hay dos tipos de clases anidadas: una clase local se declara dentro de un método, constructor o bloque inicializador; una clase miembro no lo es. Una clase miembro no estática, o una clase local en un miembro no estático, se denomina clase interna, porque un objeto de la clase interna contendrá una referencia a un objeto de la clase circundante. Véase también la sección 9.11.

Modificadores de clase

Para una clase de nivel superior, los modificadores de clase pueden ser una lista pública y como máximo una lista abstracta y final. Para una clase miembro, los modificadores de clase pueden ser una lista estática, y como máximo una lista abstracta y final, y como máximo una lista privada, protegida y pública. Para una clase local, los modificadores de clase pueden ser, como máximo, abstractos y finales.

Ejemplo 16: Declaración de clase

Se declara que la clase Point tiene dos campos no estáticos x e y, un constructor y dos métodos no estáticos. Se utiliza en el ejemplo 41.



clase Punto { int x, y;





Punto(int x, int y) { this.x = x; esto.y = y; }



movimiento vacío (int dx, int dy) { x += dx; y += dy; }







public String toString() { return "(" + x + ", " + y + ")"; }



}





Ejemplo 17: Clase con miembros estáticos y no estáticos

La clase SPoint declara un campo estático allpoints y dos campos no estáticos xey. Por lo tanto, cada objeto SPoint tiene sus propios campos xey, pero todos los objetos comparten el mismo campo de todos los puntos en la clase SPoint.

El constructor inserta el nuevo objeto (this) en el objeto ArrayList allpoints (sección 20.2). El método no estático getIndex devuelve el índice del punto en la lista de la matriz. El método estático getSize devuelve el número de SPoints creados hasta el momento. El método estático getPoint devuelve el iésimo punto en la lista de matriz. La clase SPoint se utiliza en el ejemplo 48.



punto de clase {



ArrayList estático todos los puntos = nuevo ArrayList(); entero x, y;





SPoint(int x, int y) { allpoints.add(this); esto.x = x; esto.y = y; } movimiento vacío (int dx, int dy) { x += dx; y += dy; }

cadena pública toString() { return "(" + x + ","+ y + ")"; } int getIndex() { return allpoints.indexOf(esto); }

static int getSize() { { return allpoints.size(); }



Punto estático getPoint(int i) { return (Punto)todos los puntos.get(i); }



}





Ejemplo 18: Clases de nivel superior, miembros y locales

Véanse también los ejemplos 31 y 36.



clase TLC { // clase de nivel superior TLC clase estática SMC { ... } // clase de miembro estático





clase NMC {...} // Clase de miembro no estático (interno)







void nm() { // Método no estático en TLC



clase NLC {...} // Clase local (interna) en el método



}



static void sm() { // Método estático en TLC



clase SLC {...} // Clase local en el método



}



}





Los modificadores de clase público, final, resumen

Si una clase C de nivel superior se declara pública, entonces se puede acceder a ella fuera de su paquete (capítulo 17).

Si una clase C se declara final, no se pueden declarar subclases de C y, por lo tanto, no se puede anular ningún método declarado en C. Esto es útil para evitar que subclases maliciosas violen las invariantes de representación de datos.

Si una clase C se declara abstracta, entonces no se puede crear instancias de ella, pero sí se pueden crear instancias de subclases no abstractas de C. Una clase abstracta puede declarar constructores y tener inicializadores que se ejecutarán al crear instancias de subclases no abstractas. Una clase abstracta puede declarar métodos abstractos y no abstractos; una clase no abstracta no puede declarar métodos abstractos. Una clase no puede ser abstracta y final al mismo tiempo, porque no se pueden crear objetos a partir de esa clase.

Subclases, superclases, jerarquía de clases, herencia y anulación

Una clase C puede declararse como subclase de la clase B mediante una cláusula ampliada de la forma

la clase C extiende B {...}

En este caso, C es una subclase y por tanto un subtipo (sección 5.4) de B y sus supertipos. La clase C hereda todos los métodos y campos (incluso los privados, aunque no son accesibles en la clase C), pero no los constructores, de B.

La clase B se denomina superclase inmediata de C. Una clase puede tener como máximo una superclase inmediata. La clase predefinida Objeto es una superclase de todas las demás clases; El objeto de clase no tiene superclase. Por lo tanto, las clases forman una jerarquía de clases en la que cada clase es descendiente de su superclase inmediata, excepto Objeto, que está en la cima.

Para realizar alguna inicialización, un constructor de la subclase C puede, como primera acción, llamar explícitamente a un constructor de la superclase inmediata B, utilizando esta sintaxis:

super(lista-real);

Puede aparecer una llamada de constructor de superclase super(...) en ly al comienzo de un constructor. Si un constructor C(...) en la subclase C no llama explícitamente a super(...) como su primera acción, entonces implícitamente llama al constructor predeterminado sin argumentos B() en la superclase B como su primera acción, como si fuera por

súper(). En este caso, B debe tener un constructor B() no privado y sin argumentos. Por el contrario, si no hay un constructor sin argumentos B() en B, entonces C(...) en C debe usar super(...) para llamar explícitamente a algún otro constructor en B.

La declaración de C puede anular (redeclarar) cualquier método no final m heredado de B declarando un nuevo método m con exactamente la misma firma. Un método B anulado m puede denominarse super.m dentro de los constructores, métodos no estáticos e inicializadores no estáticos de C.

El método primordial m en C

debe ser al menos tan accesible (sección 9.7) como el método anulado en B;

debe tener la misma firma y tipo de retorno que el método anulado en B;

debe ser estático si y sólo si el método anulado en B es estático;

o no tiene una cláusula de lanzamiento o tiene una cláusula de lanzamiento que no cubre más clases de excepción que la cláusula de lanzamiento (si la hay) del método anulado en B.

Sin embargo, la declaración de una clase C no puede volver a declarar un campo f heredado de B, sino sólo declarar un campo adicional con el mismo nombre (sección 9.6). El campo B anulado puede denominarse super.f dentro de los constructores, métodos no estáticos e inicializadores no estáticos de C.

Ejemplo 19: clases abstractas, subclases y anulaciones

La clase abstracta Vessel modela la noción de un recipiente (para contener líquidos): tiene un contenido de campo que representa su contenido real, un método abstracto de capacidad para calcular su capacidad máxima y un método para llenar más, pero solo hasta su capacidad. (el exceso se perderá). La clase abstracta tiene



subclases Tanque (un recipiente rectangular), Cubo (un recipiente cúbico, subclase de Tanque) y Barril (un recipiente cilíndrico).

Las subclases implementan el método de capacidad, heredan el campo de contenido y el método de llenado de la superclase y anulan el método toString (heredado de la clase Objeto) para imprimir cada objeto de recipiente de manera apropiada.



buque de clase abstracta { contenido doble;

capacidad doble abstracta();



relleno vacío (doble cantidad) { contenido = Math.min(contenido + cantidad, capacidad()); }



}



clase Tanque extiende Recipiente { doble largo, ancho, alto;

Tanque (doble largo, doble ancho, doble altura)



{ this.length = longitud; this.width = ancho; this.height = altura; } doble capacidad() { retorno largo * ancho * alto; }

cadena pública a cadena ()



{ return "tanque (" + largo + ", " + ancho + ", " + alto + ")"; }



}



clase Cubo extiende Tanque {



Cubo(doble cara) { super(lado, lado, lado);



public String toString() { return "cubo (" + longitud + ")"; }



}



clase Barril extiende Vaso { radio doble, altura;

Barril(doble radio, doble altura) { this.radius = radio; this.height = altura; doble capacidad() { altura de retorno * Math.PI * radio * radio; }

public String toString() { return "barril (" + radio + ", " + altura + ")"; }



}





Ejemplo 20: uso de la jerarquía de embarcaciones del ejemplo 19

La llamada vs[i].capacity() es legal sólo porque el método capacidad, aunque abstracto, se declara en la clase Vessel (ejemplo 19):



public static void main(String[] args) { Vessel vl = new Barrel(3, 10);



Buque v2 = tanque nuevo (10, 20, 12); Buque v3 = nuevo Cubo(4); Buque[] vs = {vl, v2, v3};

v1.relleno(90); v1.rellenar(10); v2.rellenar(100); v3.rellenar(80);



doble suma = 0;

for (int i=0; i<vs.length; i++) suma += vs [i] .capacity();

System.out.println("La capacidad total es " + suma);

for (int i=0; i<vs.length; i++) System.out.println("número de embarcación " + i + ": " + vs[i]);

}



Declaraciones de campo en clases

El propósito de un campo es contener un valor dentro de un objeto (si no estático) o una clase (si es estático). Un campo debe declararse en una declaración de clase. Una declaración de campo tiene una de las formas

modificadores de campo tipo fieldnamel, fieldname2,...; modificadores de campo tipo fieldnamel = inicializador1,...;

Los modificadores de campo pueden ser una lista de los modificadores estático, final, transitorio (sección 21.11) y volátil y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7). Si un campo f en la clase C se declara estático, entonces f está asociado con la clase C y se puede hacer referencia a él independientemente de cualquier objeto de la clase C. El campo se puede denominar C.f o o.f, donde o es una expresión de tipo C, o, en la declaración de C, como f. Si un campo f en la clase C no se declara estático, entonces f se asocia con un objeto (también llamado instancia) de la clase C, y cada instancia tiene su propia instancia del campo. Se puede hacer referencia al campo como o.f, donde o es una expresión de tipo C, o, en código no estático en la declaración de C, como f.

Si un campo f en la clase C se declara final, el campo no se puede modificar después de la inicialización. Si f tiene un tipo de referencia y apunta a un objeto o matriz, los campos del objeto o los elementos de la matriz aún pueden modificarse. La inicialización debe ocurrir en el d declaración o en un bloque inicializador (sección 9.10), o (si el campo no es estático) precisamente una vez en cada constructor de la clase C.

Un inicializador de campo puede ser una expresión o un inicializador de matriz (sección 8.2). Un inicializador de campo estático sólo puede hacer referencia a miembros estáticos de C y no puede generar excepciones marcadas (capítulo 14).

A un campo se le asigna un valor inicial predeterminado dependiendo de su tipo t. Si t es un tipo primitivo, el campo se inicializa a 0 (cuando t es byte, char, short, int o long) o 0,0 (cuando t es flotante o doble) o falso (cuando t es booleano). Si t es un tipo de referencia, el campo se inicializa a nulo.

Los campos estáticos se inicializan cuando se carga la clase. Primero, a todos los campos estáticos se les dan sus valores iniciales predeterminados, luego se ejecutan los bloques inicializadores estáticos (sección 9.10) y los inicializadores de campos estáticos, en orden de aparición en la declaración de clase.

Los campos no estáticos se inicializan cuando se llama a un constructor, momento en el cual todos los campos estáticos ya se han inicializado (sección 9.9).

Si una clase C declara un campo no estático f, y C es una subclase de una clase B que tiene un campo no estático f, entonces cada objeto de la clase C tiene dos campos, ambos llamados f: uno es el campo B f declarado en el superclase B, y uno es el campo C f declarado en el propio C. A qué campo se hace referencia mediante un acceso al campo o.f está determinado por el tipo de o (sección 11.9).

Los modificadores de acceso de miembros privado, protegido, público

Un miembro (campo o método o clase o interfaz anidada) siempre es accesible en la clase en la que está declarado, excepto cuando esté sombreado por una variable, parámetro o campo (de una clase anidada). Los modificadores de acceso privado, protegido y público determinan dónde más se puede acceder al miembro.

Si un miembro se declara privado en la clase de nivel superior C o en una clase anidada dentro de C, es accesible en C y sus clases anidadas, pero no en sus subclases fuera de C ni en otras clases. Si un miembro de la clase C se declara protegido, es accesible en todas las clases del mismo paquete (capítulo 17) que C y en las subclases de C, pero no en las que no son subclases de otros paquetes. Si un miembro de la clase C no se declara privado, protegido o público, tiene acceso al paquete, o acceso predeterminado, y sólo es accesible en clases dentro del mismo paquete que C, no en clases de otros paquetes. Si un miembro de la clase C es



declarado público, es accesible en todas las clases, incluidas las clases de otros paquetes. Así, en orden de accesibilidad creciente, tenemos acceso privado, acceso a paquetes (o predeterminado), acceso protegido y acceso público.

Ejemplo 21: Declaraciones de campo

La clase SPoint (ejemplo 17) declara un campo estático todos los puntos y dos campos no estáticos x e y. El ejemplo 30 declara un campo estático ps de tipo de matriz double[]. Su inicializador de campo asigna una matriz de seis elementos y la vincula a ps, y luego el bloque inicializador (sección 9.10) almacena algunos números en la matriz. La clase Barrel en el ejemplo 80 declara dos campos no estáticos, radio y altura. Los campos son definitivos y por tanto deben inicializarse (lo cual se hace en el constructor).





Ejemplo 22: Varios campos con el mismo nombre

Un objeto de clase C aquí tiene dos campos no estáticos llamados vf, uno declarado en la superclase B y otro declarado en el propio C. De manera similar, un objeto de clase D tiene tres campos no estáticos llamados vf. La clase B y la clase C tienen cada una un campo estático llamado sf. La clase D no declara un campo estático sf, por lo que en la clase D el nombre sf se refiere al campo estático sf en la superclase C. Los ejemplos 35 y 45 utilizan estas clases.



clase B // Un campo no estático vf, un sf estático



{ int vf; estático int sf; B(int yo) { vf = yo; sf = i+1; } }







la clase C extiende B // Dos campos no estáticos vf, uno estático sf



{ int vf; estático int sf; C(int i) { super(i+20); vf = yo; sf = i+2; } }







la clase D extiende C // Tres campos no estáticos vf



{ int vf; D(int i) { super(i+40); vf = yo; sf = i+4; } }





Ejemplo 23: Modificadores de acceso de miembros

La jerarquía de embarcaciones en el ejemplo 19 no es satisfactoria porque todos pueden leer y modificar los campos de un objeto de embarcación. El ejemplo 80 presenta una versión mejorada de la jerarquía en la que (1) el campo de contenido en Vessel se hace privado para evitar modificaciones, (2) un nuevo método público getContents permite leer el campo y (3) los campos de Tank y Barrel son declarado protegido para permitir el acceso desde subclases declaradas en otros paquetes.

Dado que el contenido del campo en Vessel es privado, no es accesible en las subclases (Tank, Barrel, ...), pero las subclases aún heredan el campo. Por lo tanto, cada objeto de subclase de recipiente tiene espacio para almacenar el campo, pero puede cambiarlo y acceder a él sólo utilizando los métodos fill y getContents heredados de la superclase abstracta.





Ejemplo 24: Accesibilidad de miembros privados



Se puede acceder a un miembro privado en cualquier lugar dentro de la clase de nivel superior adjunta (y solo allí). acceso a clase {

int estático privado x; clase estática SI {

privado estático int y = x; // Accede al privado x desde la clase adjunta



}



vacío estático m() {



int z = SI.y; // Accede al privado y desde la clase anidada



}



}





Declaraciones de métodos

Se debe declarar un método dentro de una clase. Una declaración de método que declara el método m tiene la forma

modificadores-de-método tipo-de-retorno m (lista-formal) arroja-cláusula-cuerpo-del-método

La lista formal es una lista separada por comas de cero o más declaraciones de parámetros formales, de la forma

modificador-parámetro tipo nombre-parámetro

El modificador de parámetro puede ser final, lo que significa que el parámetro no se puede modificar dentro del método o puede estar ausente. El tipo es cualquier tipo. El nombre del parámetro es cualquier nombre, pero los nombres de los parámetros deben ser distintos. Un parámetro formal es una variable inicializada; su alcance es el cuerpo del método.

El nombre del método m junto con la lista t1,..., tn de tipos de parámetros declarados en la lista formal

determine la firma del método m(t1,..., tn). El tipo de retorno no forma parte de la firma del método.

Una clase puede declarar más de un método con el mismo nombre de método, siempre que tengan firmas de método diferentes. Esto se llama sobrecarga del nombre del método.

El cuerpo del método es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. En particular, el cuerpo del método puede contener declaraciones de retorno. Si el tipo de retorno es nulo, el método no devuelve un valor y ninguna declaración de retorno en el cuerpo del método puede tener un argumento de expresión. Si el tipo de retorno no es nulo sino un tipo, el método debe devolver un valor: no debe ser posible que la ejecución llegue al final del cuerpo del método sin ejecutar una declaración de retorno. Además, cada declaración de retorno debe tener un argumento de expresión cuyo tipo sea un subtipo del tipo de retorno.

Los modificadores de método pueden ser abstractos o una lista de estáticos, finales, sincronizados (sección 15.2) y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7).

Si un método m en la clase C se declara estático, entonces m está asociado con la clase C; se puede hacer referencia a él sin ningún objeto. El método puede llamarse como C.m(...) o como o.m(...), donde o es una expresión cuyo tipo es un subtipo de C, o, dentro de los métodos, constructores, inicializadores de campo y bloques inicializadores en C, simplemente como m(...). Un método estático sólo puede hacer referencia a campos y métodos estáticos de la clase.

Si un método m en la clase C no se declara estático, entonces m está asociado con un objeto (instancia) de la clase

C. Fuera de la clase, el método debe llamarse como o.m(...), donde o es un objeto de clase C o una subclase, o, dentro de métodos no estáticos, inicializadores de campos no estáticos y bloques de inicializadores no estáticos en C, simplemente como metro(...). Un método no estático puede hacer referencia a todos los campos y métodos de la clase C, sean estáticos o no.

Si un método m en la clase C se declara final, no se puede anular (redefinir) en las subclases.

Si un método m en la clase C se declara abstracto, la clase C debe ser abstracta (y por lo tanto no se puede crear una instancia). Un método abstracto no puede ser estático, final ni sincronizado, y su declaración tiene esta forma, sin un cuerpo de método:

modificadores de métodos abstractos tipo de retorno m (lista-formal) cláusula de lanzamiento;

La cláusula throws de un método o constructor tiene la forma

lanza E1, E2, ...

donde El, E2,... son los nombres de los tipos de excepción que cubren todas las excepciones marcadas que el método o constructor puede generar. Si la ejecución puede generar la excepción e, entonces e es una excepción no verificada (capítulo 14) o una excepción verificada cuya clase es un subtipo de uno de El, E2,...

Ejemplo 25: Sobrecarga de nombres de métodos y firmas

Esta clase declara cuatro métodos sobrecargados m cuyas firmas (sección 5.5) son m(int) y m(boolean) y m(int, double) y m(double, double). Algunos de los métodos sobrecargados son estáticos, otros no. Los métodos sobrecargados pueden tener diferentes tipos de retorno, como se muestra aquí.

El ejemplo 50 explica las llamadas a métodos.

Sería legal declarar un método adicional con la firma m(double, int), pero entonces la llamada al método m(10, 20) se volvería ambigua e ilegal. Es decir, no hay forma de determinar si llamar a m(int, double) o m(double, int).



sobrecarga de clase {



doble m(int i) { return i; }



booleano m(booleano b) { return !b; }



estático doble m(int x, doble y) { return x + y + 1; } estática doble m(doble x, doble y) { return x + y + 3; }







}



}





Ejemplo 26: Anulación de método

En la jerarquía de embarcaciones (ejemplo 19), las clases Tank y Barrel anulan el método toString heredado de la superclase universal Object, y la clase Cube anula toString heredado de la clase Tank.





Ejemplo 27: Anulación y sobrecarga de métodos

La clase C1 declara el método sobrecargado ml con firmas ml(double) y ml(int), y el método m2 con firma m2(int). La subclase C2 oculta el método ml(double) de C1 y sobrecarga m2 declarando una variante adicional. Las llamadas a estos métodos se muestran en el ejemplo 51.



clase Cl {



ml vacío estático (doble d) { System.out.println("lld"); } void ml(int i) { System.out.println("lli"); }

void m2(int i) { System.out.println("12i"); }



}







clase C2 extiende C1 {



estadoy; // Accede al privado y desde la clase anidada



}



}





Declaraciones de métodos

Se debe declarar un método dentro de una clase. Una declaración de método que declara el método m tiene la forma

modificadores-de-método tipo-de-retorno m (lista-formal) arroja-cláusula-cuerpo-del-método

La lista formal es una lista separada por comas de cero o más declaraciones de parámetros formales, de la forma

modificador-parámetro tipo nombre-parámetro

El modificador de parámetro puede ser final, lo que significa que el parámetro no se puede modificar dentro del método o puede estar ausente. El tipo es cualquier tipo. El nombre del parámetro es cualquier nombre, pero los nombres de los parámetros deben ser distintos. Un parámetro formal es una variable inicializada; su alcance es el cuerpo del método.

El nombre del método m junto con la lista t1,..., tn de tipos de parámetros declarados en la lista formal

determine la firma del método m(t1,..., tn). El tipo de retorno no forma parte de la firma del método.

Una clase puede declarar más de un método con el mismo nombre de método, siempre que tengan firmas de método diferentes. Esto se llama sobrecarga del nombre del método.

El cuerpo del método es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. En particular, el cuerpo del método puede contener declaraciones de retorno. Si el tipo de retorno es nulo, el método no devuelve un valor y ninguna declaración de retorno en el cuerpo del método puede tener un argumento de expresión. Si el tipo de retorno no es nulo sino un tipo, el método debe devolver un valor: no debe ser posible que la ejecución llegue al final del cuerpo del método sin ejecutar una declaración de retorno. Además, cada declaración de retorno debe tener un argumento de expresión cuyo tipo sea un subtipo del tipo de retorno.

Los modificadores de método pueden ser abstractos o una lista de estáticos, finales, sincronizados (sección 15.2) y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7).

Si un método m en la clase C se declara estático, entonces m está asociado con la clase C; se puede hacer referencia a él sin ningún objeto. El método puede llamarse como C.m(...) o como o.m(...), donde o es una expresión cuyo tipo es un subtipo de C, o, dentro de los métodos, constructores, inicializadores de campo y bloques inicializadores en C, simplemente como m(...). Un método estático sólo puede hacer referencia a campos y métodos estáticos de la clase.

Si un método m en la clase C no se declara estático, entonces m está asociado con un objeto (instancia) de la clase

C. Fuera de la clase, el método debe llamarse como o.m(...), donde o es un objeto de clase C o una subclase, o, dentro de métodos no estáticos, inicializadores de campos no estáticos y bloques de inicializadores no estáticos en C, simplemente como metro(...). Un método no estático puede hacer referencia a todos los campos y métodos de la clase C, sean estáticos o no.

Si un método m en la clase C se declara final, no se puede anular (redefinir) en las subclases.

Si un método m en la clase C se declara abstracto, la clase C debe ser abstracta (y por lo tanto no se puede crear una instancia). Un método abstracto no puede ser estático, final ni sincronizado, y su declaración tiene esta forma, sin un cuerpo de método:

modificadores de métodos abstractos tipo de retorno m (lista-formal) cláusula de lanzamiento;

La cláusula throws de un método o constructor tiene la forma

lanza E1, E2, ...

donde El, E2,... son los nombres de los tipos de excepción que cubren todas las excepciones marcadas que el método o constructor puede generar. Si la ejecución puede generar la excepción e, entonces e es una excepción no verificada (capítulo 14) o una excepción verificada cuya clase es un subtipo de uno de El, E2,...

Ejemplo 25: Sobrecarga de nombres de métodos y firmas

Esta clase declara cuatro métodos sobrecargados m cuyas firmas (sección 5.5) son m(int) y m(boolean) y m(int, double) y m(double, double). Algunos de los métodos sobrecargados son estáticos, otros no. Los métodos sobrecargados pueden tener diferentes tipos de retorno, como se muestra aquí.

El ejemplo 50 explica las llamadas a métodos.

Sería legal declarar un método adicional con la firma m(double, int), pero entonces la llamada al método m(10, 20) se volvería ambigua e ilegal. Es decir, no hay forma de determinar si llamar a m(int, double) o m(double, int).



sobrecarga de clase {



doble m(int i) { return i; }



booleano m(booleano b) { return !b; }



estático doble m(int x, doble y) { return x + y + 1; } estática doble m(doble x, doble y) { return x + y + 3; }







}



}





Ejemplo 26: Anulación de método

En la jerarquía de embarcaciones (ejemplo 19), las clases Tank y Barrel anulan el método toString heredado de la superclase universal Object, y la clase Cube anula toString heredado de la clase Tank.





Ejemplo 27: Anulación y sobrecarga de métodos

La clase C1 declara el método sobrecargado ml con firmas ml(double) y ml(int), y el método m2 con firma m2(int). La subclase C2 oculta el método ml(double) de C1 y sobrecarga m2 declarando una variante adicional. Las llamadas a estos métodos se muestran en el ejemplo 51.



clase Cl {



ml vacío estático (doble d) { System.out.println("lld"); } void ml(int i) { System.out.println("lli"); }

void m2(int i) { System.out.println("12i"); }



}







clase C2 extiende C1 {



estadoc void ml(doble d) { System.out.println("21d"); } void ml(int i) { System.out.println("21i"); }

void m2(doble d) { System.out.println("22d"); }



}



Declaraciones de constructor

El propósito de un constructor en la clase C es inicializar nuevos objetos (instancias) de la clase. A

La declaración del constructor en la clase C tiene la forma.

modificadores-constructor C(lista-formal) lanza-cláusula cuerpo-constructor

Los modificadores del constructor pueden ser una lista de, como máximo, privado, protegido y público (sección 9.7); un constructor no puede ser abstracto, final o estático. Un constructor no tiene tipo de retorno.

Los constructores se pueden sobrecargar de la misma manera que los métodos: la firma del constructor (una lista de los tipos de parámetros en la lista formal) se usa para distinguir los constructores en la misma clase. Un constructor puede llamar a otro constructor sobrecargado en la misma clase usando la sintaxis:

esto (lista-real)

pero un constructor no puede llamarse a sí mismo, directa o indirectamente. Una llamada a this(...) a otro constructor, si está presente, debe ser la primera acción de un constructor, antes de cualquier declaración o declaración.

El cuerpo del constructor es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. El cuerpo del constructor puede contener declaraciones de retorno, pero ninguna declaración de retorno puede tomar un argumento de expresión.

Una clase que no declara explícitamente un constructor declara implícitamente un valor predeterminado público y sin argumentos.

constructor cuya única acción (implícita) es llamar al constructor de la superclase (sección 9.5):

público C() { super(); }

La cláusula throws del constructor especifica las excepciones marcadas que puede lanzar el constructor, de la misma manera que para los métodos (sección 9.8).

Cuando new crea un nuevo objeto en la memoria (sección 11.7), los campos no estáticos del objeto reciben valores iniciales predeterminados según su tipo. Luego se llama a un constructor para inicializar aún más el objeto, y sucede lo siguiente: primero, se llama a algún constructor de superclase (explícita o implícitamente, consulte los ejemplos 29 y 52) exactamente una vez, luego los inicializadores de campos no estáticos y los bloques de inicializadores no estáticos se ejecutan una vez por semana. orden de aparición en la declaración de clase y, finalmente, se ejecuta el cuerpo del constructor (excepto la llamada explícita al constructor de la superclase, si corresponde). La llamada a un constructor de superclase provocará una llamada a un constructor de su superclase, y así sucesivamente, hasta llegar a Object().

Bloques inicializadores, inicializadores de campo e inicializadores

Además de los inicializadores de campo (sección 9.6), una clase puede contener bloques de inicializador. Los bloques inicializadores se pueden utilizar cuando los inicializadores o constructores de campos no son suficientes. Usamos el término inicializador para referirnos a inicializadores de campo así como a bloques de inicializador. Un bloque inicializador estático tiene la forma

declaración de bloque estático

Los bloques inicializadores estáticos y los inicializadores de campos estáticos se ejecutan, en orden de aparición en la declaración de clase, cuando se carga la clase. Un bloque inicializador no estático es simplemente una declaración de bloque independiente. Los bloques inicializadores no estáticos se ejecutan después del constructor cuando se crea un objeto (sección 9.9).

Un inicializador no puede lanzar una excepción marcada (capítulo 14). Si la ejecución de un inicializador estático genera una excepción (no marcada) durante la carga de la clase, esa excepción se descarta y en su lugar se genera la excepción ExceptionInInitializerError.

Ejemplo 28: Sobrecarga del constructor; Llamar a otro constructor

Agregamos un nuevo constructor a la clase Point (ejemplo 16), sobrecargando así sus constructores. El antiguo constructor tiene la firma Punto(int, int) y el nuevo Punto(Punto). El nuevo constructor hace una copia del punto p llamando al antiguo constructor usando la sintaxis this(p.x, p.y).

clase Punto { int x, y;





Punto(int x, int y) // Constructor sobrecargado



{ esto.x = x; esto.y = y; }



Punto(Punto p) // Constructor sobrecargado



{ this(p.x, py); } // Llama al primer constructor







movimiento vacío (int dx, int dy)



{ x += dx; y += dy; }







cadena pública a cadena ()



{ return "(" + x + ", " + y + ")"; }



}





Ejemplo 29: Llamar a un constructor de superclase

El constructor de la subclase ColoredPoint (ejemplo 71) llama al constructor de su superclase usando la sintaxis super(x, y).



Ejemplo 30: Inicializadores de campo y bloques de inicializador

Aquí el inicializador de campo estático asigna una matriz y la vincula al campo ps. El bloque inicializador estático llena la matriz con una secuencia creciente de números pseudoaleatorios, luego los escala para que el último número sea 1,0 (esto es útil para generar tiradas de un dado cargado aleatoriamente). Esto no se puede hacer utilizando únicamente el inicializador de campo.

Se podrían eliminar las dos apariciones de static para obtener otro ejemplo, con un campo no estático ps, un inicializador de campo no estático y un bloque inicializador no estático. Sin embargo, es más común que un constructor inicialice los campos no estáticos.



clase EjemploInicializador {



doble estático [] ps = nuevo doble [6];







static { // Bloque inicializador estático



doble sum = 0;

for (int i=0; i<ps.length; i++) // Rellenar con números aleatorios crecientes ps[i] = suma += Math.random();

for (int i=0; i<ps.length; i++) // Escala para que el último elemento ps sea 1,0 ps[i] /= sum;

}

...

}



Clases anidadas, clases de miembros, clases locales y clases internas

Una clase anidada no estática, es decir, una clase miembro no estática NMC o una clase local NLC en un miembro no estático, se denomina clase interna. Un objeto de una clase interna siempre contiene una referencia a un objeto de la clase envolvente C, llamado objeto envolvente. Se puede hacer referencia a ese objeto como C.this (ejemplo 36), por lo que se puede hacer referencia a un miembro no estático x del objeto circundante como C.this.x.

Una clase interna o clase local no puede tener miembros estáticos. Más precisamente, todos los campos estáticos también deben ser finales, y los métodos y clases anidadas en una clase interna o local deben ser no estáticos.

Una clase anidada estática, es decir, una clase miembro estática SMC o una clase local en un miembro estático, no tiene ningún objeto envolvente y no puede hacer referencia a miembros no estáticos de la clase envolvente C. Esta es la restricción estándar para los miembros estáticos de una clase ( apartado 9.1). Una clase de miembro estático puede tener a su vez miembros estáticos y no estáticos.

Si una clase local hace referencia a variables o parámetros formales en el método, constructor o inicializador adjunto, esas variables o parámetros deben ser finales.



Clases anónimas

Una clase anónima es un tipo especial de clase local; por lo tanto, debe declararse dentro de un método, constructor o inicializador. Se puede declarar una clase anónima y crear exactamente una instancia, utilizando la sintaxis de expresión especial.

nuevo cuerpo de clase C (lista real)

donde C es un nombre de clase. Esto crea una subclase anónima de la clase C, con el cuerpo de clase dado (sección 9.1). Además, crea un objeto de esa subclase anónima y llama al constructor de C apropiado con los argumentos en lista-actual, como si fuera super(lista-actual). Una clase anónima no puede declarar sus propios constructores.

Cuando I es el nombre de una interfaz, la sintaxis de expresión similar

nuevo yo()

cuerpo de clase

crea una clase local anónima, con el cuerpo de clase dado (sección 9.1), que debe implementar la interfaz I, y también crea un objeto de esa clase anónima. Tenga en cuenta que la lista de parámetros después de I debe estar vacía.

Ejemplo 31: Clases miembro y clases locales class TLC { // Clase de nivel superior static int sf;

int nf;



clase estática SMC { // Clase de miembro estático static int ssf = sf + TLC.sf; // puede tener miembros estáticos

int snf = sf + TLC.sf; // no se pueden utilizar miembros TLC no estáticos



}



clase NMC { // clase de miembro no estático (interno)



int nnf1 = sf + nf; // puede usar miembros TLC no estáticos int nnf2 = TLC.sf + TLC.this.nf; // no puede tener miembros estáticos

}



void nm() { // Método no estático en TLC



clase NLC { // Clase local (interna) en el método



int m(int p) { return sf+nf+p; } // puede usar miembros TLC no estáticos



} } }





Ejemplo 32: un iterador como clase local

Los sufijos del método devuelven un objeto de la clase local SuffixIterator, que implementa la interfaz Iterator (sección 20.7) para enumerar los sufijos no vacíos de la cadena s:



clase LocalInnerClassExample { public static void main(String[] args) { Iterador seq = sufijos(args[0]);

mientras (seq.hasNext()) System.out.println(seq.next());

}



Sufijos de iterador estático (cadena final s) { clase SuffixIterator implementa Iterador {

int índice inicial=0;

public boolean hasNext() { return startindex < s.length (); } objeto público siguiente() { return s.substring(startindex++); }

public void remove() { lanzar nueva UnsupportedOperationException(); }

}

devolver nuevo SuffixIterator();

}

}





Ejemplo 33: un iterador como clase local anónima

Alternativamente, podemos usar una clase local anónima en los sufijos de métodos: sufijos de iterador estáticos (cadenas finales) {

devolver



nuevo iterador () {



int índice inicial=0;

public boolean hasNext() { return startindex < s.length (); } objeto público siguiente() { return s.substring (startindex+ + ); }

public void remove() { lanzar nueva UnsupportedOperationException(); }

};

}



Capítulo 10: Clases y objetos en la computadora

¿Qué es una clase?

Conceptualmente, una clase representa un concepto, una plantilla para crear instancias (objetos). En la computadora, una clase es un trozo de memoria, que se reserva una vez, cuando la clase se carga en tiempo de ejecución. Una clase tiene las siguientes partes:

El nombre de la clase.

Espacio para todos los miembros estáticos de la clase.

Una clase se puede dibujar como un cuadro. La clase de encabezado SPoint proporciona el nombre de la clase y el cuadro en sí contiene los miembros estáticos de la clase:



¿Qué es un objeto?

Conceptualmente, un objeto es una instancia de un concepto (una clase). En la computadora, un objeto es un trozo de memoria, reservado por una expresión de creación de objeto new C(...); ver sección 11.7. Cada evaluación de una expresión de creación de objetos new C(...) crea un objeto distinto, con su propia porción de memoria de la computadora. Un objeto tiene las siguientes partes:

Una referencia a la clase C del objeto; esta es la clase C utilizada al crear el objeto.

Espacio para todos los miembros no estáticos del objeto.

Un objeto se puede dibujar como una caja. . El encabezado: SPoint proporciona la clase del objeto (subrayada) y el resto del cuadro contiene los miembros no estáticos del objeto:



Objetos internos

Cuando NIC es una clase interna (una clase miembro no estática o una clase local en código no estático) en una clase C, entonces un objeto de clase NIC es un objeto interno. Además de la clase del objeto y los campos no estáticos, un objeto interno siempre contendrá una referencia a un objeto envolvente, que es un objeto de la clase envolvente más interna C. La referencia del objeto envolvente se puede escribir C.this en programas Java.

Por otro lado, un objeto de una clase anidada estática no contiene ninguna referencia a un objeto circundante.

Ejemplo 34: Objetos y Clases

Esta es la memoria de la computadora al final del método principal en el ejemplo 48, usando la clase SPoint del ejemplo 17. Las variables p y s se refieren al mismo objeto, la variable q es nula y la variable r se refiere al objeto más a la derecha. Ninguna variable se refiere al objeto del medio; será eliminado por el recolector de basura.







Ejemplo 35: Objetos con múltiples campos del mismo nombre

Esta es la memoria de la computadora al final del método principal en el ejemplo 45, usando las clases del ejemplo 22. Las clases B y C tienen cada una un único campo estático sf; la clase D no tiene ninguno. Los dos objetos de



cada uno de la clase C tiene dos campos no estáticos vf (llamados B/vf y C/vf a continuación), y el objeto de clase D tiene tres campos no estáticos vf.







Ejemplo 36: Objetos internos

El ejemplo 31 declara una clase TLC con un miembro no estático (interno) de clase NMC y un miembro estático de clase SMC. Si creamos un objeto TLC, dos objetos NMC y un objeto SMC,



TLC oo = nuevo TLC();



TLC.NMC iolio1 = oo.nuevo NMC(), io2 = oo.nuevo NMC(); TLC.SMC sio = nuevo TLC.SMC();

entonces la memoria de la computadora contendrá estos objetos (las clases no se muestran)





Capítulo 11: Expresiones

Descripción general

Se evalúa una expresión para obtener un valor (como 117). Además, la evaluación de una expresión puede cambiar el estado de la computadora: los valores de las variables, campos y elementos de la matriz, el contenido de los archivos, etc. Más precisamente, la evaluación de una expresión.

termina normalmente, produciendo un valor; o

termina abruptamente lanzando una excepción; o

no termina en absoluto (por ejemplo, porque llama a un método que no termina). Las expresiones se crean a partir de literales (constantes anónimas), variables, campos, operadores, llamadas a métodos, accesos a matrices, expresiones condicionales, el nuevo operador, etc.; consulte la tabla de formas de expresión en la página opuesta.

Se debe distinguir el tipo en tiempo de compilación de una expresión de la clase en tiempo de ejecución de un objeto. Una expresión tiene un tipo (capítulo 5) inferido por el compilador. Cuando se trata de un tipo de referencia t y el valor de la expresión es un objeto o, entonces la clase del objeto o será un subtipo de t pero no necesariamente igual a t. Por ejemplo, la expresión (Número) (nuevo Integer (2) ) tiene tipo Número, pero su valor es un objeto cuya clase es Integer, una subclase de Número.





Tabla de formas de expresión

La tabla de formas de expresión muestra la forma, el significado, la asociatividad, los tipos de argumentos (operandos) y los tipos de resultados de las expresiones. Las expresiones se agrupan según la precedencia, como lo indican las reglas horizontales, desde la precedencia alta hasta la precedencia baja. Los formularios de mayor prioridad se evalúan antes que los de menor prioridad. Se pueden utilizar paréntesis para enfatizar o forzar un orden particular de evaluación.

Cuando un operador (como +) es asociativo por la izquierda, una secuencia el + e2 + e3 de operadores se evalúa como si estuviera entre paréntesis (el + e2) + e3. Cuando un operador (como =) es asociativo por la derecha, una secuencia el = e2 = e3 de operadores se evalúa como si estuviera entre paréntesis el = (e2 = e3).

En las columnas de tipo de argumento y tipo de resultado de la tabla, el número entero representa cualquiera de char, byte, short, int o long; y numérico significa entero, flotante o doble.

Para un operador con un operando entero o numérico, el tipo de promoción es doble si el operando tiene tipo doble; es flotante si el operando es de tipo flotante; es largo si el operando es de tipo largo; en caso contrario es int (es decir, si el operando es de tipo byte, char, short o int).

Para un operador con dos operandos enteros o numéricos (excepto los operadores de turno; sección 11.4), el tipo de promoción es doble si algún operando tiene tipo doble; de lo contrario, es flotante si algún operando tiene tipo flotante; de lo contrario, es largo si algún operando tiene el tipo largo; de lo contrario es int.

Antes de realizar la operación, los operandos se promocionan, es decir, se convierten al tipo de promoción.

mediante una conversión de tipo ensanchado (sección 11.12.1).

Si el tipo de resultado también se proporciona como numérico, es igual al tipo de promoción. Por ejemplo, 10/3 tiene tipo

int, mientras que 10/3.0 tiene tipo double y c + (byte)1 tiene tipo int cuando c tiene tipo char.



Tabla de formas de expresión



Tabla de formas de expresión





Operadores aritméticos

El valor de la expresión postincremento x++ es el de x, y su efecto es incrementar x en 1; y de manera similar para el postdecremento x--. El valor de la expresión de preincremento. ++x es el de x+1, y su efecto es incrementar x en 1; y de manera similar para el predecremento --x.

La división de enteros el/e2 se trunca, es decir, se redondea hacia cero, por lo que 10/3 es 3 y (-10)/3 es -3. El resto entero x%y es igual a x-(x/y)*y cuando y es distinto de cero; tiene el mismo signo que x. La división de enteros o el resto por cero genera la excepción ArithmeticException. El desbordamiento de enteros no genera una excepción, sino que se ajusta. Por lo tanto, en el tipo int, la expresión 2147483647+1 se evalúa como - 2147483648 y la expresión -2147483648-1 se evalúa como 2147483647.

El resto de punto flotante x%y es aproximadamente igual a x- (((int) (x/y))*y cuando y es distinto de cero. La división de punto flotante por cero y el desbordamiento de punto flotante no generan excepciones, pero producen valores especiales IEEE754. (de tipo flotante o doble) como Infinity o NaN ("no es un número").



Operadores logicos

Los operadores == y ! = requieren que los tipos de operandos sean compatibles: uno debe ser un subtipo del otro. Dos valores de tipo primitivo son iguales (por = =) si representan el mismo valor después de la conversión a su supertipo común. Por ejemplo, 10 y 10,0 son iguales. Dos valores de tipo de referencia son iguales (por ==) si ambos son nulos, o ambos son referencias al mismo objeto o matriz, creado por la misma ejecución del nuevo operador. Por lo tanto, no utilice == o ! = para comparar cadenas: dos cadenas s1 y s2 pueden contener la misma secuencia de caracteres y, por lo tanto, ser iguales en s1.equals (s2), pero ser objetos distintos y, por lo tanto, desiguales en s1==s2 (ejemplo 5).

Los operadores lógicos && y || realizar una evaluación abreviada: si e1 se evalúa como verdadero en el&&e2, entonces se evalúa e2 para obtener el valor de la expresión; de lo contrario, se ignora e2 y el valor de la expresión es falso. Por el contrario, si e1 se evalúa como falso en e1 || e2, luego se evalúa e2 para obtener el valor de la expresión; de lo contrario, se ignora e2 y el valor de la expresión es verdadero. Por

Por el contrario, los operadores & (lógico estricto y) y ^ (lógico estricto exclusivo-o) y | (lógico estricto o) siempre evalúa ambos operandos, independientemente del valor del operando de la izquierda. Generalmente el atajo

operadores && y || son preferibles.



Operadores bit a bit y operadores de turno

Los operadores ~ (complemento bit a bit) y & (bit a bit y) y ^ (bit a bit exclusivo-o) y | (bit a bit o) se puede utilizar en operandos de tipo entero. Los operadores trabajan en paralelo en todos los bits de la representación en complemento a 2 de los operandos. Por lo tanto, ~n es igual a (-n) -1 y también es igual a (-1) ^n.

Los operadores de desplazamiento << y >> y >>> desplazan los bits de la representación en complemento a 2 del primer argumento. Los dos operandos se promocionan (sección 11.1) por separado y el tipo de resultado es el tipo de promoción (int o long) del primer argumento. Por lo tanto, la operación de cambio siempre se realiza en un

Valor de 32 bits (int) o de 64 bits (long). En el primer caso, la duración del desplazamiento está entre 0 y 31 según lo determinado por los cinco bits menos significativos del segundo argumento; en el último caso, está entre 0 y 63 según lo determinado por los seis bits menos significativos del segundo argumento.

El desplazamiento a la izquierda n<<s es igual a n*2*2* ... *2 donde hay s multiplicaciones. El desplazamiento a la derecha con signo n>>s de un n no negativo es igual a n/2/2/.../2 donde hay s divisiones; el desplazamiento a la derecha con signo de un n negativo es igual a ~((~n)>>s). El desplazamiento a la derecha sin signo n>>>s de un n no negativo es igual a n>>s; el desplazamiento a la derecha con signo de un n negativo es igual a (n>>s) + (2<<~s) si n tiene el tipo int, y (n>>s) + (2L<<~s) si tiene el tipo long, donde 2L es la constante larga con valor 2. Véase el ejemplo 68 para un uso inteligente y complejo de operadores bit a bit: buen estilo en un pequeño procesador integrado, pero no en general.

Ejemplo 37: Operadores aritméticos



public static void main(String[] args) { int max = 2147483647;

int mínimo = -2147483648;



println(max+1) // Impresiones: -2147483648



println(min-1) // Impresiones: 2147483647



imprimirln(-min); // Impresiones: -2147483648 print( 10/3); println(10/(-3)); // Imprime: 3 -3 print((-10)/3); println((-10)/(-3)); // Impresiones: -3 3 imprimir( 10%3); println(10%(-3)); // Imprime: 1 1 print((-10)%3); println((-10)%(-3)); // Impresiones: -1 -1

}



impresión vacía estática (int i) { System.out.print(i + " "); } static void println(int i) { System.out.println(i + " "); }

Ejemplo 38: Operadores lógicos

Debido a la evaluación abreviada de &&, esta expresión del ejemplo 12 no evalúa los días de acceso a la matriz [mes-1] a menos que 1 ≤ mes ≤ 12, por lo que el índice nunca está fuera de los límites:

(mes >= 1) && (mes <= 12) && (día >= 1) && (día <= días[mes-1])

Este método devuelve verdadero si y es un año bisiesto, es decir, si y es múltiplo de 4 pero no de 100, o es un múltiplo

de 400:



año bisiesto booleano estático (int y)

{ devolver y % 4 == 0 && y % 100 != 0 || y % 400 ==0; }



Ejemplo 39: Operadores bit a bit y operadores de turno



clase bit a bit {



public static void main (String [] args) lanza una excepción {



}

static void println4(int n) { para (int i=3; i>=0; i--)

System.out.print(n >> i & 1);

Sistema.out.println();

}

}



Expresiones de asignación

En la tarea expresa ion x = e, el tipo de e debe ser un subtipo del tipo de x. El tipo de expresión es el mismo que el tipo de x. La asignación se ejecuta evaluando la expresión x y luego e, y almacenando el valor de e en la variable x, después de una conversión ampliada (sección 11.12) si es necesario.

Cuando e es una constante de tiempo de compilación de tipo byte, char, short o int, y x tiene el tipo byte, char o short, se realiza automáticamente una conversión estrecha, siempre que el valor de e esté dentro del rango representable en x ( apartado 5.1). El valor de la expresión x = e es el de x después de la asignación.

El operador de asignación es asociativo derecho, por lo que la asignación múltiple x = y = e tiene el mismo significado que x = (y = e), es decir, evalúa la expresión e, asigna su valor a y y luego a x. Cuando e tiene un tipo de referencia (tipo de objeto o tipo de matriz), solo se almacena una referencia al objeto o matriz en

X. Por tanto, la asignación x = e no copia el objeto o matriz (ejemplo 41).

Cuando x y e tienen el mismo tipo, la asignación compuesta x += e es equivalente a x = x + e; sin embargo, x se evalúa solo una vez, por lo que en a[i++] += e la variable i se incrementa solo una vez. Cuando el tipo de x es t, diferente del tipo de e, entonces x += e es equivalente a x = (t) (x + e), en el cual el resultado intermedio (x + e) se convierte al tipo t ( sección 11.12); nuevamente x se evalúa solo una vez. Los otros operadores de asignación compuestos -=, *=, etc., son similares.

Dado que la asignación se asocia a la derecha, y el valor de suma += e es el de la suma después de la asignación, se puede escribir ps[i] = suma += e para incrementar primero la suma en e y luego almacenar el resultado en ps[i ] (ejemplo 30).



Expresiones condicionales

La expresión condicional e1 ? e2: e3 es legal si e1 tiene tipo booleano, y e2 y e3 tienen tipos numéricos, o ambos tienen tipo booleano, o ambos tienen tipos de referencia compatibles. La expresión condicional se evalúa evaluando primero el. Si e1 se evalúa como verdadero, entonces se evalúa e2 (y no e3); de lo contrario se evalúa e3. El valor resultante es el valor de la expresión condicional.



Expresiones de creación de objetos

La expresión de creación de objetos.

nueva C (lista real)

crea un nuevo objeto de clase C y luego llama a ese constructor en clase C cuya firma coincide con los argumentos en la lista actual. La lista real se evalúa de izquierda a derecha para obtener una lista de valores de argumentos. Estos valores de argumento están vinculados a los parámetros del constructor, se crea un objeto de la clase en la memoria, los campos no estáticos reciben valores iniciales predeterminados según su tipo, se llama explícita o implícitamente a un constructor de superclase (ejemplos 29 y 52), todo Los inicializadores de campo no estáticos y los bloques inicializadores se ejecutan en orden de aparición y, finalmente, se ejecuta el cuerpo del constructor para inicializar el objeto. El valor de la expresión de llamada al constructor es el objeto recién creado, cuya clase es C.

Cuando C es una clase interna en la clase D, y o se evalúa como un objeto de clase D, entonces se puede crear un objeto C dentro de o usando la sintaxis o.new C (lista-actual); ver ejemplo 36.



Expresiones de prueba de instancia

La prueba de instancia e instancia de t se evalúa evaluando e a un valor v. Si v no es nulo y es una referencia a un objeto de clase C, donde C es un subtipo de t, el resultado es verdadero; de lo contrario falso.

Ejemplo 40: Ampliación, reducción y truncamiento en asignaciones

La asignación d = 12 realiza una ampliación de 12 de int a double. Las asignaciones b = 123 y b2 = 123+1 realizan una reducción implícita de int a byte, porque los lados derechos son constantes de tiempo de compilación. La asignación b2 = b1+1 sería ilegal porque b1+1 no es una constante de tiempo de compilación. La asignación b2 = 123+5 sería ilegal porque, aunque 123+5 es una constante de tiempo de compilación, su valor no se puede representar como un byte (cuyo rango es —128..127).

doble d;



d = 12; // Ampliación de la conversión de int a doble byte b1 = 123; // Reducir la conversión de int a byte byte b2;

b2 = 123 + 1; // Legal: 123+1 es una constante de tiempo de compilación b2 = (byte)(b1 + 1); // Legal: (byte)(b1 + 1) tiene tipo byte

int x = 0;



x+= 1,5; // Equivalente a: x = (int) (x + 1,5); por lo tanto suma 1 a x





Ejemplo 41: La tarea no copia objetos

Este ejemplo utiliza la clase Punto del ejemplo 16. La asignación (y el paso de parámetros) copia solo la referencia, no el objeto:



Punto p1 = nuevo Punto(10, 20);



System.out.println("p1 es " + p1); // Imprime: p1 es (10, 20) Punto p2 = p1; // p1 y p2 se refieren al mismo objeto p2.move (8, 8);

System.out.println("p2 es " + p2); // Imprime: p2 es (18, 28) System.out.println("p1 es " + p1); // Imprime: p1 es (18, 28)



Ejemplo 42: Operadores de asignación compuestos

Calcule el producto de todos los elementos de la matriz xs:



multiplicación doble estática (doble [] xs) {



doble pinchazo = 1,0;

para (int i=0; i<xs.length; i++)

prod *= xs[i]; // Equivalente a: prod = prod * xs[i]

devolver el empujón;

}





Ejemplo 43: expresión condicional

Devuelve el valor absoluto de x (siempre no negativo):



estática doble absoluta (doble x)

{ return (x >= 0 ? x : -x); } Ejemplo 44: Creación de objetos y prueba de instancia



Número n1 = nuevo entero(17); Número n2 = nuevo Doble(3.14);

// Se imprimen las siguientes declaraciones: falso, verdadero, falso, verdadero. System.out.println("n1 es un Doble: " + (n1 instancia de Doble)); System.out.println("n2 es un Doble: " + (n2 instancia de Doble)); System.out.println("nulo es un Doble: " + (instancia nula de Doble)); System.out.println("n2 es un Número: " + (n2 instancia de Número));

Expresiones de acceso a campos

Un acceso al campo debe tener una de estas tres formas: f

C.f.

de

donde C es una clase y o una expresión de tipo de referencia.

Una clase puede tener varios campos con el mismo nombre f (sección 9.6, ejemplo 22 y ejemplo 45).

Ejemplo 45: Acceso al campo

Aquí ilustramos el acceso a campos estáticos y no estáticos en las clases B, C y D del ejemplo 22. Tenga en cuenta que el campo al que hace referencia una expresión de forma o.vf u o.sf está determinado por el tipo de expresión o, no por el clase del objeto al que o evalúa.



público estático vacío principal (String[] args) {



C c1 = nuevo C(100); // c1 tiene tipo C; el objeto tiene clase C B b1 = c1; // b1 tiene tipo B; El objeto tiene clase C.

imprimir(C.sf, B.sf); // Impresiones: 102 121



imprimir(c1.sf, b1.sf); // Impresiones: 102 121



imprimir(c1.vf, b1.vf); // Impresiones: 100 120



C c2 = nuevo C(200); // c2 tiene tipo C; el objeto tiene clase C B b2 = c2; // b2 tiene tipo B; El objeto tiene clase C.

imprimir(c2.sf, b2.sf); // Impresiones: 202 221



imprimir(c2.vf, b2.vf); // Impresiones: 200 220



imprimir(c1.sf, b1.sf); // Impresiones: 202 221



imprimir(c1.vf, b1.vf); // Impresiones: 100 120



D d3 = nuevo D(300); // d3 tiene tipo D; el objeto tiene clase D C c3 = d3; // c3 tiene tipo C; el objeto tiene clase D

B b3 = d3; // b3 tiene tipo B; el objeto tiene clase D print(D.sf, C.sf, B.sf); // Impresiones: 304 304 361

imprimir(d3.sf, c3.sf, b3.sf); // Impresiones: 304 304 361



imprimir(d3.vf, c3.vf, b3.vf); // Impresiones: 300 340 360



}



impresión vacía estática (int x, int y) { System.out.println(x+" "+y); }



impresión vacía estática (int x, int y, int z) { System.out.println(x+" "+y+" "+z); }





Un acceso a campo f debe hacer referencia a un campo estático o no estático declarado o heredado por una clase cuya declaración encierra la expresión de acceso al campo (cuando f no ha sido sombreada por un campo en una clase envolvente anidada, o por una variable o parámetro de la mismo nombre). La clase que declara el campo es la clase objetivo TC.

Un acceso a campo C.f debe hacer referencia a un campo estático en la clase C o una superclase de C. Esa clase es la clase objetivo TC.

Un acceso al campo of, donde la expresión o tiene tipo C, debe hacer referencia a un campo estático o no estático en la clase C o una superclase de C. Esa clase es la clase objetivo TC. Para evaluar el acceso al campo se evalúa la expresión o para obtener un objeto. Si el campo es estático, el objeto se ignora y el valor de o.f es el campo TC f. Si el campo no es estático, el valor de o no debe ser nulo y el valor de o.f se encuentra como el valor del campo TC f en el objeto o.

Es informativo contrastar un acceso a un campo no estático y una llamada a un método no estático (sección 11.11):

En un acceso de campo no estático, el campo al que se hace referencia está determinado por el tipo (en tiempo de compilación)

de la expresión objeto o.

En una llamada no estática a un método no privado o.m(...), el método llamado está determinado por la clase (en tiempo de ejecución) del objeto de destino: el objeto al que se evalúa o.



El objeto actual hace referencia a esto

El nombre puede usarse en código no estático para referirse al objeto actual (sección 9.1). Cuando se ejecuta código no estático en un objeto determinado, la referencia del objeto se refiere al objeto en su conjunto. Por lo tanto, cuando f es un campo y m es un método (declarado en la clase envolvente más interna), entonces this.f significa lo mismo que f (cuando f no ha sido sombreado por una variable o parámetro del mismo nombre), y this .m(...) significa lo mismo que m(...).

Cuando C es una clase interna en una clase D adjunta, entonces dentro de C la notación D. Esto se refiere al objeto D que encierra el objeto C interno. Vea el ejemplo 31 donde TLC.this.nf se refiere al campo nf de la clase adjunta TLC.

Ejemplo 46: Usar esto al hacer referencia a campos sombreados



Un uso común de esto es referirse a campos (this.x y this.y) que han sido sombreados por parámetros (x e y), especialmente en constructores; vea la clase Punto (ejemplo 16):



clase Punto { int x, y;

Punto(int x, int y) { this.x = x; esto.y = y; }



... }





Ejemplo 47: Usar esto para pasar el objeto actual a un método

En la clase SPoint (ejemplo 17), la referencia del objeto actual this se usa en el constructor para agregar el objeto recién creado a la lista de matriz allpoints, y se usa en el método getIndex para buscar el objeto actual en la lista de matriz:



punto de clase {



ArrayList estático todos los puntos = nuevo ArrayList(); entero x, y;

SPoint(int x, int y) { allpoints.add(this); esto.x = x; esto.y = y; } int getIndex() { return allpoints.indexOf(esto); }

... }





Expresiones de llamada a métodos

Una expresión de llamada a un método, o invocación de un método, debe tener una de estas cinco formas:

m(lista-actual) super.m(lista-actual) C.m(lista-actual) C.super.m (lista-actual)

o.m(lista-actual)

donde m es el nombre de un método, C es el nombre de una clase y o es una expresión de tipo de referencia. La lista real es una lista de expresiones posiblemente vacía separada por comas, denominada argumentos o parámetros reales. La firma de llamada es csig = m(t1,..., tn), donde (t1,..., tn) es la lista de tipos de los n argumentos en la lista real.

Determinar qué método se llama realmente mediante una llamada a un método es complicado porque (1) los nombres de los métodos pueden estar sobrecargados y cada versión del método tiene una firma distinta; (2) los métodos pueden anularse, es decir, reimplementarse en subclases; (3) los métodos que son tanto no estáticos como no privados se llaman mediante envío dinámico, dado un objeto de destino; y (4) una llamada a un método en una clase anidada puede llamar a un método declarado en alguna clase adjunta.

La sección 11.11.1 describe la evaluación de argumentos y el paso de parámetros, suponiendo el caso simple en el que está claro qué método m se está llamando. La sección 11.11.2 describe cómo determinar qué método se llama en el caso general.



Llamada al método: paso de parámetros

Esta sección considera la evaluación de una llamada a un método m (lista real) cuando está claro qué método m se llama y se centra en el mecanismo de paso de parámetros.

La llamada se evalúa evaluando las expresiones en la lista real de izquierda a derecha para obtener los valores de los argumentos. Estos valores de argumentos luego se vinculan a los parámetros correspondientes en la lista formal del método, en orden de aparición. Se produce una conversión ampliada (sección 11.12) si el tipo de una expresión de argumento es un subtipo del tipo de parámetro correspondiente del método.



Java usa llamada por valor para vincular valores de argumentos a parámetros formales, por lo que el parámetro formal contiene una copia del valor del argumento. Por tanto, si el método cambia el valor de un parámetro formal, este cambio no afecta al argumento. Para un argumento de tipo de referencia, el parámetro contiene una copia de la referencia del objeto o de la referencia de matriz y, por lo tanto, el parámetro se refiere al mismo objeto o matriz que la expresión del argumento real. Por lo tanto, si el método cambia ese objeto o matriz, los cambios serán visibles después de que el método regrese (ejemplo 49).

Se debe llamar a un método no estático con un objeto de destino, por ejemplo como o.m (lista-actual), donde el objeto de destino es el valor de o, o como m(lista-actual), donde el objeto de destino es la referencia del objeto actual. . En cualquier caso, durante la ejecución del cuerpo del método, éste estará vinculado al objeto de destino.

Un método estático no se llama con un objeto de destino y es ilegal usar el identificador this dentro del cuerpo de un método estático.

Cuando los valores de los argumentos se han vinculado a los parámetros formales, se ejecuta el cuerpo del método. El valor de la expresión de llamada al método es el valor devuelto por el método si su tipo de retorno no es nulo; de lo contrario, la expresión de llamada al método no tiene valor. Cuando el método regresa, se descartan todos los parámetros y variables locales del método.

Ejemplo 48: Llamar a métodos no sobrecargados ni anulados

Este programa utiliza la clase SPoint del ejemplo 17. Los métodos estáticos getSize y getPoint se pueden llamar anteponiéndolos con el nombre de clase SPoint o una expresión de tipo SPoint, como q. Se les puede llamar antes de que se haya creado cualquier objeto. El método no estático getIndex debe llamarse con un objeto, como en r.getIndex(); luego, el método se ejecuta con la referencia del objeto actual vinculada a r.



System.out.println("Número de puntos creados: " + SPoint.getSize ()); PuntoP = nuevo PuntoP(12, 123);

PuntoPunto q = nuevo PuntoPunto(200, 10); PuntoPunto r = nuevo PuntoPunto(99, 12); Punto s = p;

q = nulo;



System.out.println("Número de puntos creados: " + SPoint.getSize());

System.out.println("Número de puntos creados: " + q.getSize ()); System.out.println("r es el número de punto " + r.getIndex());

para (int i=0; i<SPoint.getSize(); i++)

System.out.println("El número de punto " + i + " es " + Punto.getPoint(i));





Ejemplo 49: El paso de parámetros copia referencias, no objetos ni matrices

En la llamada al método m(p, d, a) que se muestra aquí, la referencia del objeto contenida en p se copia al parámetro pp de m, por lo que p y pp se refieren al mismo objeto, el número entero contenido en d se copia a dd, y la referencia de matriz contenida en a se copia a aa. Al final del método m, el estado de la memoria de la computadora es el siguiente:



Cuando regresa el método m, sus parámetros pp, dd y aa se descartan. Las variables p, d y a no se modifican, pero el objeto y la matriz a la que apuntan p y a sí se modifican.



public static void main(String[] args) { Punto p = nuevo Punto(10, 20);

int[] a = nuevo int [5];



int d = 8;



System.out.println("p es " + p); // Imprime: p es (10, 20)



System.out.println("a[3] es " + a[3]); // Imprime: a[3] es 0 m (p, d, a);

System.out.println("p es " + p); // Imprime: p es (18, 28) System.out.println("d es " + d); // Imprime: d es 8 System.out.println("a[3] es " + a[3]); // Imprime: a[3] es 22

}



vacío estático m(Punto pp, int dd, int[] aa) { pp.move(dd, dd);

dd = 117;



aa[3] = 22;



}







Llamada al método: determinar qué método se llama

En general, los métodos pueden estar sobrecargados y sobrecargados. dden. La sobrecarga se resuelve en tiempo de compilación encontrando la firma del método aplicable y accesible más específica para la llamada. La anulación (para métodos no estáticos) se maneja en tiempo de ejecución buscando en la jerarquía de clases hacia arriba, comenzando con la clase del objeto en el que se llama el método.

En tiempo de compilación: determine el tipo de destino y la firma

Encuentre el tipo de objetivo TC. Si la llamada al método tiene la forma m(lista-actual), el tipo de destino TC es la clase envolvente más interna que contiene un método llamado m que es visible (no sombreado por un método m, independientemente de la firma, en una clase intermedia). Si la llamada al método tiene la forma super.m(lista-actual), el tipo de destino TC es la superclase de la clase envolvente más interna. Si la llamada al método tiene la forma C.super.m(lista-actual), el tipo de destino TC es la superclase de la clase envolvente C. Si la llamada al método tiene la forma C.m(lista-actual), entonces TC es C. Si la llamada al método tiene la forma o.m(lista-actual), entonces TC es el tipo de expresión o.

Encuentra la firma del objetivo tsig. Un método de la clase TC es aplicable si su firma incluye la firma de llamada csig (sección 5.5). Si un método es accesible está determinado por sus modificadores de acceso (sección 9.7). Considere el conjunto de métodos de CT que son aplicables y accesibles. La llamada es ilegal (método desconocido) si no existe tal método. La llamada es ilegal (ambigua) si hay más de un método cuya firma extendida m(T, u1,..., un) es más específica, es decir, uno cuya firma extendida está incluida en todas las demás. Así, si la llamada es legal, hay exactamente una firma extendida más específica; de ahí obtenemos la firma objetivo tsig = m(u1,..., un).

Determine si el método llamado es estático. Si la llamada al método tiene la forma C.m(lista-actual), el método llamado debe ser estático. Si la llamada al método tiene la forma m(lista-actual) u o.m(lista-actual) o super.m(lista-actual) o C.super.m(lista-actual), usamos el tipo de destino TC y la firma tsig para determinar si el método llamado es estático o no estático.

En tiempo de ejecución: determine el objeto de destino (si no estático) y ejecute el método

Si el método es estático, no se necesita ningún objeto de destino: el método a llamar es el método con firma tsig en la clase TC. Sin embargo, cuando m es estático en una llamada al método o.m(lista-actual), la expresión o debe evaluarse de todos modos, pero su valor se ignora.



Si el método no es estático, determine el objeto de destino; estará vinculado al objeto que hace referencia a this durante la ejecución del método. En el caso de m(lista-actual), el objeto de destino es this (si TC es la clase más interna que incluye la llamada al método), o TC.this (si TC es una clase externa que contiene la llamada al método). En el caso de super.m (lista-actual), el objeto de destino es este. En el caso de C.super.m(actual-list), el objeto de destino es C.this. En el caso o.m(lista-actual), la expresión o debe evaluarse como una referencia de objeto. Si no es nulo, ese objeto es el objeto de destino; de lo contrario, se lanza la excepción NullPointerException. Si el método no es privado, se busca en la jerarquía de clases para determinar qué método llamar, comenzando con la clase RTC del objeto de destino. Si no se encuentra un método con firma tsig en la clase RTC, entonces se busca la superclase inmediata de RTC, y así sucesivamente. Este procedimiento de búsqueda se denomina despacho dinámico. Si el método es privado, debe estar en la clase de destino TC y no es necesaria ninguna búsqueda.

Cuando se ha determinado el método, los argumentos se evalúan y vinculan como se describe en la sección 11.11.1.

Ejemplo 50: Llamar a métodos sobrecargados

Aquí llamamos a los métodos sobrecargados m declarados en el ejemplo 25. La llamada m(10, 20) tiene la firma de llamada m(int, int) y por lo tanto llama al método con la firma m(int, double), que es el más específico aplicable. . Por lo tanto, las dos primeras líneas llaman al método con firma m(int, double), y las dos últimas llaman al método con firma m(double, double).



System.out.println(m(10, 20)); // Impresiones: 31,0



System.out.println(m(10, 20.0)); // Impresiones: 31,0



System.out.println(m(10.0, 20)); // Impresiones: 33,0



System.out.println(m(10.0, 20.0)); // Impresiones: 33,0





Ejemplo 51: Llamar a métodos anulados y sobrecargados

Aquí usamos las clases C1 y C2 del ejemplo 27. El tipo de destino de c1.m1(i) es la clase C1, que tiene un método no estático con firma m1(int), por lo que la llamada es a un método no estático; el objeto de destino tiene clase C2, por lo que el método llamado es m1(int) en C2; y de manera bastante similar para c2.m1(i). El tipo de destino para c1.m1(d) es la clase C1, que tiene un método estático con firma m1(double), por lo que la llamada es a un método estático y el objeto vinculado a c1 no importa. De manera similar, para c2.m1(d), cuyo tipo de destino es C2, llama a m1(doble) en C2, que anula m1(doble) en C1.

La llamada c1.m2(i) tiene tipo de destino C1 y llama a m2(int). Sin embargo, una llamada c2.m2(i), cuya clase objetivo es C2, sería ambigua e ilegal: las firmas extendidas aplicables son m2(C1, int) y m2(C2, double), ninguna de las cuales es mo re específico que el otro.



int yo = 17; doble d = 17,0;

C2 c2 = nuevo C2(); // Tipo C2, clase de objeto C2 C1 c1 = c2; // Tipo C1, clase de objeto C1

c1.m1(i); c2.m1(i); c1.m1(d); c2.m1(d); // Impresiones: 21i 21i 11d 21d c1.m2(i); // Impresiones: 12i

Ejemplo 52: Llamar a métodos anulados desde un constructor

Si d2 es un objeto de la clase D2, entonces llamar a d2.m2() llamará al método m2 heredado de la superclase D1. La llamada m1() en m2 es equivalente a this.m1(), donde esto es igual a d2, por lo que se llama al método m1 declarado en la clase D2. Por lo tanto, la llamada d2.m2() imprimirá D1.m2 y luego D2.m1:7. Imprime 7 porque el campo f se inicializa a 7 en el constructor D2().

Quizás lo más sorprendente es que la creación d2 = new D2() de un objeto de clase D2 imprimirá D1.m2 y luego D2.m1:0. ¿Por qué imprime 0 y no 7? La primera acción del constructor D2() es hacer una llamada implícita al constructor de la superclase D1(), incluso antes de ejecutar la asignación f = 7. Por lo tanto, f seguirá



tiene su valor predeterminado 0 cuando el método m1 en D2 se llama desde el método m2 en D1, que a su vez se llama desde el constructor D1().



clase D1 { D1() { m2(); }

void ml () { System.out.println("D1.m1 "); }



void m2 () { System.out.print("D1.m2 "); m1 () ; }



}







clase D2 extiende D1 { int f;

D2() { f = 7; }



void m1() { System.out.println("D2.m1:" + f); }



}







Escriba expresiones de conversión y conversión de tipos

Una conversión de tipo convierte un valor de un tipo a otro. Una conversión ampliada convierte de un tipo a un supertipo. Una conversión de restricción convierte de un tipo a otro tipo. Esto requiere una conversión de tipo explícita (excepto en una asignación x = e o inicialización donde e es una constante entera en tiempo de compilación; consulte la sección 11.5).



Tipo de conversión entre tipos primitivos

Cuando e es una expresión de tipo primitivo y t es un tipo primitivo, entonces se realiza una conversión de tipos de e a t usando la expresión

(t)e

Esta expresión, cuando es legal, tiene tipo t. Las conversiones de tipos legales entre tipos primitivos se muestran en la siguiente tabla, donde C marca una conversión de estrechamiento que requiere una conversión de tipo (t)e, W marca una conversión de ampliación que preserva el valor y L marca una conversión de ampliación que puede causar una pérdida de precisión.



Una conversión de enteros estrechada descarta aquellos bits (más significativos) que no pueden representarse en el tipo de entero más pequeño. La conversión de un tipo entero a un tipo de punto flotante (flotante o doble) produce una aproximación de punto flotante del valor entero. La conversión de un tipo de punto flotante a un tipo entero descarta la parte fraccionaria del número; es decir, se redondea hacia cero. Al convertir un número de punto flotante demasiado grande a long o int, el resultado es la mejor aproximación (es decir, el mayor número representable positivo o negativo del tipo); La conversión a byte, short o char se realiza convirtiendo a int y luego al tipo solicitado. El tipo primitivo booleano no se puede convertir a ningún otro tipo. Una conversión de tipos entre tipos primitivos nunca falla en tiempo de ejecución.



Tipo de conversión entre tipos de referencia

Cuando e es una expresión de tipo de referencia y t es un tipo de referencia (clase o interfaz o tipo de matriz), a

el tipo de conversión de e a t se realiza usando la expresión

(t)e

Esta expresión tiene tipo t. Se evalúa evaluando e con un valor v. Si v es nulo o es una referencia a un objeto o matriz cuya clase es un subtipo de t, entonces la conversión de tipos se realiza correctamente con el resultado v; de lo contrario, se lanza la excepción ClassCastException. La conversión de tipos es ilegal cuando no es posible que tenga éxito en tiempo de ejecución, por ejemplo, cuando e tiene el tipo Doble y t es booleano: ninguna de estas clases es un subtipo de la otra.



Capítulo 12: Declaraciones

Descripción general

Una declaración puede cambiar el estado de la computadora: el valor de las variables, los campos, los elementos de la matriz, el contenido de los archivos, etc. Más precisamente, la ejecución de una declaración.

termina normalmente (lo que significa que la ejecución continuará con la siguiente declaración, si corresponde); o

termina abruptamente lanzando una excepción; o

sale ejecutando una declaración de retorno (si está dentro de un método o constructor); o

sale de un interruptor o bucle ejecutando una instrucción break (si está dentro de un interruptor o bucle); o

sale de la iteración actual de un bucle y comienza una nueva iteración ejecutando un continuar

declaración (si está dentro de un bucle); o

no termina en absoluto, por ejemplo, ejecutando while (true) {}.



Declaraciones de expresión

Una declaración de expresión es una expresión seguida de un punto y coma:

expresión ;

Se ejecuta evaluando la expresión e ignorando su valor. Las únicas formas de expresión que pueden usarse legalmente de esta manera son expresiones de asignación (sección 11.5), expresiones de incremento y decremento (sección 11.2), expresiones de llamada a métodos (sección 11.11) y expresiones de creación de objetos (sección 11.7).

Por ejemplo, una declaración de asignación x=e; es una expresión de asignación x=e seguida de un punto y coma.

De manera similar, una declaración de llamada a un método es una expresión de llamada a un método seguida de un punto y coma. El valor devuelto por el método, si lo hubiera, se descarta; El método se ejecuta sólo por su efecto secundario. t.





Declaraciones de bloque

Una declaración de bloque es una secuencia de cero o más declaraciones o declaraciones de variables o declaraciones de clases, en cualquier orden, encerradas entre llaves:

{

declaraciones

declaraciones-de-clase declaraciones-variables

}



12.2 Declaraciones de bloque

Una declaración de bloque es una secuencia de cero o más declaraciones o declaraciones de variables o declaraciones de clases, en cualquier orden, encerradas entre llaves:

{

declaraciones

declaraciones-de-clase declaraciones-variables

}



Declaraciones de elección

La declaración si

Una declaración if tiene la forma

si (condición)

verdadera rama



La condición debe ser de tipo booleano y truebranch es una declaración. Si la condición se evalúa como verdadera, entonces se ejecuta truebranch; de lo contrario, no.



La declaración si-si no

Una declaración if-else tiene la forma:

si (condición)

verdadera rama

demás

rama falsa

La condición debe ser de tipo booleano y truebranch y falsebranch son declaraciones. si condición

se evalúa como verdadero, luego se ejecuta truebranch; de lo contrario, se ejecuta falsebranch.



La declaración de cambio

Una declaración de cambio tiene la forma

cambiar (expresión) { caso constante1: rama1 caso constante2: rama2

...

predeterminado: rama

}

La expresión debe ser de tipo int, short, char o byte. Cada constante debe ser una expresión constante en tiempo de compilación, que consta únicamente de literales, variables finales, campos finales declarados con inicializadores de campo explícitos y operadores. No pueden haber dos constantes que tengan el mismo valor. El tipo de cada constante debe ser un subtipo del tipo de expresión.

Cada rama está precedida por una o más cláusulas case y es una secuencia posiblemente vacía de declaraciones, generalmente terminada por break o return (si está dentro de un método o constructor) o continue (dentro de un bucle). La cláusula por defecto puede omitirse.

La instrucción de cambio se ejecuta de la siguiente manera: La expresión se evalúa para obtener un valor v. Si v es igual a una de las constantes, entonces se ejecuta la rama correspondiente. Si v no es igual a ninguna de las constantes, entonces se ejecuta la rama siguiente al valor predeterminado; si no hay una cláusula predeterminada, no se ejecuta nada. Si no se sale de una rama mediante interrupción, retorno o continuación, entonces la ejecución continúa con la siguiente rama en el cambio independientemente de las cláusulas case, hasta que salga una rama o finalice el cambio.

Ejemplo 53: Declaraciones de bloque

Todos los cuerpos de los métodos y los cuerpos de los constructores son declaraciones de bloque. En el método sum del ejemplo 2, la rama verdadera de la segunda declaración if es una declaración de bloque. El método m4 en el ejemplo 4 contiene dos declaraciones de bloque, cada una de las cuales contiene una declaración (local) de la variable x.





Ejemplo 54: Declaración única if-else

Este método se comporta igual que el absoluto en el ejemplo 43:

estática doble absoluta(doble x) {si (x >= 0)

devolver x;

demás

devolver -x;

}





Ejemplo 55: Secuencia de declaraciones if-else

No podemos usar un modificador aquí, porque un modificador solo puede funcionar en tipos de números enteros (incluido char): static int wdaynol(String wday) {

si (wday.equals("lunes")) devuelve 1;



de lo contrario, si (wday.equals("Martes")) devuelve 2; de lo contrario, si (wday.equals ("miércoles")) devuelve 3; de lo contrario, si (wday.equals ("jueves")) devuelve 4; de lo contrario, si (wday.equals("Viernes")) devuelve 5; de lo contrario, si (wday.equals("Sábado")) devuelve 6; de lo contrario, si (wday.equals("Domingo")) devuelve 7;

de lo contrario, devuelve -1; // Aquí solía significar "no encontrado"



}





Ejemplo 56: Una declaración de cambio

Aquí podríamos haber usado una secuencia de sentencias if-else, pero un cambio es más rápido y claro: static String findCountry(int prefix) {

cambiar (prefijo) {



caso 1: devolver "América del Norte"; caso 44: devolver "Gran Bretaña"; caso 45: devolver "Dinamarca"; caso 299: devolver "Groenlandia"; caso 46: devolver "Suecia";

caso 7: devolver "Rusia"; caso 972: devolución de "Israel"; predeterminado: devolver "Desconocido";

}



}





Declaraciones de bucle

La declaración para

Una declaración for tiene la forma

para (inicialización; condición; paso) cuerpo

donde inicialización es una declaración de variable (sección 6.2) o una expresión, condición es una expresión de tipo booleano, paso es una expresión y cuerpo es una declaración. De manera más general, la inicialización y el paso también pueden ser listas de expresiones separadas por comas; las expresiones en dicha lista se evalúan de izquierda a derecha cuando se evalúa la lista. La inicialización, la condición y el paso pueden estar vacíos. Una condición vacía es equivalente a verdadera. Por lo tanto, para (;;) cuerpo significa "ejecutar siempre el cuerpo". La declaración for se ejecuta de la siguiente manera:

Se ejecuta la inicialización.

Se evalúa la condición. Si es falso, el ciclo termina.

Si es verdad, entonces



El cuerpo es ejecutado.

El paso se ejecuta. c.La ejecución continúa en (2).



La declaración while

Una declaración while tiene la forma

mientras (condición)

cuerpo

donde condición es una expresión de tipo booleano y cuerpo es una declaración. Se ejecuta de la siguiente manera:

Se evalúa la condición. Si es falso, el ciclo termina.

Si es cierto, entonces a. Se ejecuta el cuerpo.

b.La ejecución continúa en (1).



La declaración de hacer mientras

Una declaración do- while tiene la forma

hacer

cuerpo

mientras (condición);

donde condición es una expresión de tipo booleano y cuerpo es una declaración. El cuerpo se ejecuta al menos una vez, porque la instrucción do- while se ejecuta de la siguiente manera:

El cuerpo es ejecutado.

Se evalúa la condición. Si es falso, el ciclo termina.

Si es cierto, entonces la ejecución continúa en (1).

Ejemplo 57: bucles for anidados

Este programa imprime un triángulo de asteriscos de cuatro líneas (*): for (int i=1; i<=4; i++) {

for (int j=1; j<=i; j++) System.out.print("*");

Sistema.out.println();

}





Ejemplo 58: Búsqueda de matriz usando un bucle while

Este método se comporta igual que wdayno1 en el ejemplo 55: static int wdayno2(String wday) {

int i=0;

while (i < días_días.longitud && ! días.equals(días_días[i])) i++;

// Ahora i >= wdays.length o wday igual a wdays[i] if (i < wdays.length)

devolver i+1;

demás

devolver -1; // Aquí solía significar "no encontrado"

}



cadena final estática [] wdays =

{ "Lunes martes Miércoles Jueves Viernes Sábado Domingo" };





Ejemplo 59: Bucle infinito debido a un punto y coma mal colocado

Aquí, un punto y coma mal colocado (;) crea una declaración de cuerpo de bucle vacío, donde el incremento i++ no es parte del bucle. Por lo tanto, no terminará sino que se repetirá para siempre.



int i=0;



mientras (i<10); yo ++;





Ejemplo 60: uso de do- while

Tira un dado y calcula la suma hasta que salga 5 o 6. Aquí podemos usar do- while pero while suele ser más seguro porque prueba la condición del bucle antes de ejecutar el cuerpo del bucle.



static int suma de espera() { int suma = 0, ojos; hacer {

ojos = (int) (1 + 6 * Math.random());



suma += ojos;

} mientras (ojos < 5); suma de devolución;

}



Devoluciones, declaraciones etiquetadas, salidas y excepciones

La declaración de devolución

La forma más simple de declaración de devolución, sin un argumento de expresión, es

devolver;

Esa forma de declaración de retorno debe ocurrir dentro del cuerpo de un método cuyo tipo de retorno sea nulo, o dentro del cuerpo de un constructor. La ejecución de la declaración de retorno sale del método o constructor y continúa la ejecución en el lugar desde donde se llamó al método o constructor.

Alternativamente, una declaración de devolución puede tener un argumento de expresión:

expresión de retorno;

Esa forma de declaración de retorno debe ocurrir dentro del cuerpo de un método (no constructor) cuyo tipo de retorno sea un supertipo del tipo de expresión. La declaración de retorno se ejecuta de la siguiente manera: Primero, la expresión se evalúa con algún valor v. Luego sale del método y continúa la ejecución en la expresión de llamada al método que llamó al método; el valor de esa expresión será v.



Declaraciones etiquetadas

Una declaración etiquetada tiene la forma

etiqueta: declaración

donde etiqueta es un nombre. El alcance de la etiqueta es declaración, donde se puede usar en pausa (sección 12.6.3) y continuar (sección 12.6.4). La etiqueta no se puede reutilizar dentro de una declaración, excepto dentro de una clase local.



La declaración de ruptura

Una declaración de interrupción es legal sólo dentro de un interruptor o bucle y tiene una de las formas

romper;

romper etiqueta;

La ejecución de la interrupción sale del interruptor o bucle más interno y continúa la ejecución después de ese interruptor o bucle. La ejecución de romper etiqueta sale de la declaración adjunta que tiene etiqueta etiqueta y continúa la ejecución después de esa declaración. Dicha declaración debe existir en el método, constructor o bloque inicializador más interno.



La declaración de continuación

Una declaración de continuación es legal sólo dentro de un bucle y tiene una de las formas

continuar;



continuar etiqueta;

La ejecución de continuar finaliza la iteración actual del bucle envolvente más interno y continúa la ejecución en el paso de los bucles for (sección 12.5.1) o la condición en los bucles while y do- while (secciones 12.5.2 y 12.5.3). La ejecución de continuar etiqueta finaliza la iteración actual del bucle circundante que tiene etiqueta etiqueta y continúa la ejecución en el paso o la condición. Debe haber dicho bucle en el método, constructor o bloque inicializador más interno.

Ejemplo 61: Uso de return para finalizar un bucle antes

Este método se comporta igual que wdayno2 en el ejemplo 58:



estático int wdayno3 (cadena wday) {

for (int i=0; i < wdays.length; i++) if (wday.equals(wdays[i]))

devolver i+1;

devolver -1; // Aquí solía significar "no encontrado"

}





Ejemplo 62: Uso de break para finalizar un bucle antes de tiempo



doble pinchazo = 1,0;

for (int i=0; i<xs.length; i++) { prod *= xs[i];

si (prod == 0.0) romper;

}





Ejemplo 63: Usar continuar para iniciar una nueva iteración

Este método decide si la consulta es una subcadena del objetivo. Cuando se encuentra una discrepancia entre las cadenas, continuar inicia la siguiente iteración del bucle for externo, incrementando así j:

subcadena booleana estática1 (consulta de cadena, destino de cadena) { siguiente posición:

for (int j=0; j<=target.length()-query.length(); j++) { for (int k=0; k<query.length(); k++)

si (destino.charAt(j+k)! = consulta.charAt(k))

continuar con la siguiente posición; devolver verdadero;

}

falso retorno;

}





Ejemplo 64: Uso de break para salir de un bloque de declaración etiquetado

Este método se comporta como la subcadena1 del ejemplo 63. Utiliza break para salir del bloque de declaración completo etiquetado como esta posición, omitiendo así la primera declaración de retorno e iniciando una nueva iteración del bucle for externo:



subcadena booleana estática2 (consulta de cadena, destino de cadena) {

para (int j=0; j<=target.length()-query.length(); j++) esta posición: {

para (int k=0; k<query.length(); k++)

si (destino.charAt(j+k) != consulta.charAt(k))

romper esta posición; devolver verdadero;

}

falso retorno;

}



La declaración de lanzamiento

Una declaración de lanzamiento tiene la forma

lanzar expresión;

donde el tipo de expresión debe ser un subtipo de clase Throwable (capítulo 14). La declaración de lanzamiento se ejecuta de la siguiente manera: La expresión se evalúa para obtener un objeto de excepción v. Si es nulo, entonces se lanza una NullPointerException; de lo contrario, se lanza el objeto de excepción v. Por tanto, una excepción lanzada nunca es nula. En cualquier caso, la declaración de bloque adjunta termina abruptamente (capítulo 14). La excepción lanzada puede quedar atrapada en una declaración try-catch que la incluye dinámicamente (sección 12.6.6). Si no se detecta la excepción, se cancelará toda la ejecución del programa y la información de la excepción se imprimirá en la consola (por ejemplo, en el símbolo del sistema o en la consola Java dentro de un navegador web).



La declaración try-catch-finally

Una declaración try-catch se utiliza para detectar excepciones (particulares) generadas por la ejecución de un bloque de código. Tiene la siguiente forma:

intentar

cuerpo

atrapar (El x1) catchbody1

atrapar (E2 x2) cuerpo receptor2

...

finalmente finalmente cuerpo

donde E1, E2, ... son nombres de tipos de excepción, x1, x2, ... son nombres de variables y body, catchbodyi y finalmentebody son declaraciones de bloque (sección 12.2). Puede haber cero o más cláusulas catch y la cláusula finalmente puede estar ausente, pero debe estar presente al menos una cláusula catch o finalmente.

Decimos que Ei coincide con el tipo de excepción E si E es un subtipo de Ei (posiblemente igual a Ei).

La declaración try-catch-finally se ejecuta ejecutando el cuerpo. Si la ejecución del cuerpo termina normalmente, o sale por retorno, interrupción o continuación (cuando está dentro de un método, constructor, conmutador o bucle), entonces las cláusulas catch se ignoran. Si el cuerpo termina abruptamente lanzando la excepción e de clase E, entonces se ubica el primer Ei coincidente (si lo hay), la variable xi se vincula a e y se ejecuta el catchbodyi correspondiente. El catchbodyi puede terminar normalmente, o hacer un bucle, o salir ejecutando return o break o continue, o lanzar una excepción (posiblemente xi); si no hay una cláusula finalmente, esto determina cómo termina toda la declaración try-catch. Una excepción e lanzada nunca es nula (sección 12.6.5), por lo que se garantiza que xi tampoco será nula. Si no hay ningún Ei coincidente, entonces toda la declaración try-catch termina abruptamente con la excepción e.

Si hay una cláusula finalmente, finalmente el cuerpo se ejecutará independientemente de si la ejecución del cuerpo terminó normalmente, independientemente de si el cuerpo salió ejecutando return o break o continue (cuando está dentro de un método o constructor o interruptor o bucle), independientemente de si cualquier excepción lanzada por el cuerpo fue capturada por una cláusula catch, e independientemente de si la cláusula catch salió ejecutando return o break o continue o lanzando una excepción. Si la ejecución definallybody termina normalmente, entonces todo el try-catch-finally termina según lo determine body (o catchbodyi, si uno se ejecutó y terminó abruptamente o salió). Si la ejecución de finalmente cuerpo termina abruptamente, eso determina cómo termina todo el intento-catch-finalmente (ejemplo 74).

Ejemplo 65: Lanzar una excepción para indicar un error

En lugar de devolver el valor de error falso -1 como en el método wdayno3 (ejemplo 61), lanza una excepción WeekdayException (ejemplo 73). Tenga en cuenta la cláusula throws (sección 9.8) en el encabezado del método.

static int wdayno4(String wday) lanza WeekdayException { para (int i=0; i < wdays.length; i++)

si (wday.equals(wdays[i]))

devolver i+1;

lanzar una nueva excepción de día semanal (wday);

}



Ejemplo 66: una declaración try-catch

Este ejemplo llama al método wdayno4 (ejemplo 65) dentro de una declaración try-catch que detecta excepciones de la clase WeekdayException (ejemplo 73) y su superclase Exception. La segunda cláusula catch se ejecutará (por ejemplo) si los argumentos de acceso a la matriz [0] fallan porque no hay un argumento de línea de comando (ya que ArrayIndexOutOfBoundsException es una subclase de Exception). Si se detecta una excepción, se vincula a la variable x y se imprime mediante una llamada implícita (capítulo 7) al método toString de la excepción.



público estático vacío principal (String [] args) { intentar {

System.out.println(args[0] + " es el número del día de la semana " + wdayno4(args[0]));



} catch (WeekdayException x) { System.out.println("Problema del día de la semana: " + x);

} catch (Excepción x) { System.out.println("Otro problema: " + x);

}



}





Ejemplo 67: una declaración de prueba final

Este método intenta leer tres líneas de un archivo de texto (sección 21.4), cada una de las cuales contiene un único número de punto flotante. Independientemente de si algo sale mal durante la lectura (fin de archivo prematuro, número mal formado), la cláusula final cerrará los lectores antes de que regrese el método. Lo haría incluso si la declaración de devolución estuviera dentro del bloque try.



static double[] readRecord(String filename) lanza IOException { Reader freader = new FileReader(filename); BufferedReader empanizador = nuevo BufferedReader(freader); doble[] res = nuevo doble[3];

intentar {



res[0] = nuevo D doble(breader.readLine()).doubleValue(); res[1] = nuevo Double(breader.readLine()).doubleValue(); res[2] = nuevo Double(breader.readLine()).doubleValue();

} finalmente { Breader.close();

}



devolver resolución;



}



La declaración de afirmación

La declaración de afirmación tiene una de las siguientes formas:

afirmar expresión-booleana;

afirmar expresión-booleana: expresión;

La expresión booleana debe ser de tipo booleano. La expresión debe ser de tipo booleano, char, double, float, int, long u Object.

Bajo la ejecución normal de un programa, una declaración de afirmación no tiene ningún efecto. Sin embargo, las aserciones se pueden habilitar en tiempo de ejecución especificando la opción -ea o -enableassertions al ejecutar un programa C (capítulo 16):

java -enableassertions C

Cuando las aserciones están habilitadas en tiempo de ejecución, cada ejecución de la declaración de aserción evaluará la expresión booleana. Si el resultado es verdadero, la ejecución del programa continúa normalmente. Si el resultado es falso, la afirmación falla y se generará un AssertionError; además, en la segunda forma de la declaración de afirmación, la expresión se evaluará y su valor se pasará al constructor AssertionError apropiado. Por lo tanto, el valor de la expresión se informará junto con la excepción en caso de que falle la aserción. Esto simplifica la resolución de problemas en un programa que no funciona correctamente.

Un AssertionError señala el fallo de una suposición fundamental en el programa y no debe ser detectado por una declaración try-catch en el programa; se le debe permitir propagarse al nivel superior. Una declaración de afirmación puede tener dos propósitos: documentar la suposición del programador sobre el estado en un determinado punto del programa y verificar (en tiempo de ejecución) que esa suposición se cumpla (siempre que el programa se ejecute usando la opción enableassertions).

Se puede poner una declaración de afirmación después de un fragmento de código particularmente complicado, para comprobar que ha logrado lo que se suponía que debía hacer (ejemplo 68).

Ejemplo 68: uso de afirmar para especificar y verificar el resultado de un algoritmo

La raíz cuadrada entera de x ≥ 0 es un número entero y tal que y2 ≤ x y (y + 1)2 > x. La condición previa x ≥ 0 siempre se verifica mediante una declaración if. La poscondición en y se especifica mediante una declaración de afirmación, y

comprobó si las afirmaciones están habilitadas en tiempo de ejecución, lo cual es tranquilizador, dado que la corrección no es demasiado obvia. La afirmación utiliza conversiones largas para evitar el desbordamiento aritmético.

static int sqrt(int x) { // Algoritmo de Borgerding, Hsieh, Ulery if (x < 0)

lanzar nueva IllegalArgumentException("sqrt: argumento negativo");

temperatura int, y = 0, b = 0x8000, bshft = 15, v = x;; hacer {

if (v >= (temp = (y<<1)+b << bshft--)) { y += b; v-= temperatura;

}

} mientras ((b >>= 1) > 0);

afirmar (largo)y * y <= x && (largo)(y+1)*(y+1) > x; devolver y;

}





En una clase que tiene una invariante de representación de datos, se puede afirmar la invariante al final de cada método de la clase (ejemplo 69).

Ejemplo 69: uso de afirmar para especificar y verificar invariantes

Una lista de palabras es una secuencia de palabras que se formatean como una línea de texto. Su longitud es el número mínimo de caracteres necesarios para formatear las palabras y los espacios entre palabras, es decir, la longitud de las palabras más el número de palabras menos 1. Los métodos que cambian la lista de palabras utilizan declaraciones de afirmación para especificar la invariante de longitud. y verifíquelo si las afirmaciones están habilitadas en tiempo de ejecución.



clase Lista de palabras {



cadenas de LinkedList privadas = nueva LinkedList();



longitud int privada = -1; // Invariante: es igual a la longitud de las palabras más los espacios entre palabras



public int longitud() { longitud de retorno; }







public void addLast(String s) { cadenas.addLast(s);

longitud += 1 + s.longitud();



afirmar longitud == calcularLongitud() + cadenas.tamaño() - 1;



}







cadena pública eliminarPrimero() {



Cadena res = (Cadena)cadenas.removeFirst(); longitud -= 1 + res.longitud();

afirmar longitud == calcularLongitud() + cadenas.tamaño() - 1; devolver resolución;

}



private int computeLength() { ... } // Para comprobar solo el invariante



}





No se deben usar declaraciones de afirmación para verificar la validez de la entrada del usuario o los argumentos de métodos o constructores públicos, porque la verificación se realizaría solo si las afirmaciones están habilitadas en tiempo de ejecución. En su lugar, utilice sentencias if ordinarias y genere una excepción en caso de error.

La declaración de afirmación se introdujo en Java 2, versión 1.4, y no se puede utilizar en compiladores de Java anteriores. Un programa que utilice la declaración de afirmación debe compilarse (sección 16) con la opción - fuente 1.4, de la siguiente manera:

javac -source 1.4 miprog.java

Un algoritmo para formatear una secuencia de palabras en un texto con un margen derecho recto debe producir líneas de una longitud especificada lineWidth, a menos que solo haya una palabra en la línea o que la línea sea la última. Este requisito se puede expresar y verificar mediante una declaración de afirmación (consulte el archivo de ejemplo para obtener detalles sobre el algoritmo de formato):

afirmar res.length()==lineWidth || número de palabras==1 || !wordIter.hasNext();



Capítulo 13: Interfaces

Declaraciones de interfaz

Una interfaz describe campos y métodos pero no los implementa. Una declaración de interfaz puede contener Contiene descripciones de campos, descripciones de métodos, declaraciones de clases y declaraciones de interfaces, en cualquier orden.

interfaz-modificadores interfaz I extiende-cláusula {

descripciones de campos descripciones de métodos declaraciones de clases declaraciones de interfaz

}

Una interfaz puede declararse en el nivel superior o dentro de una clase o interfaz, pero no dentro de un método, constructor o inicializador. En el nivel superior, los modificadores de interfaz pueden ser públicos o estar ausentes. También se puede acceder a una interfaz pública fuera de su paquete. Dentro de una clase o interfaz, los modificadores de interfaz pueden ser estáticos (siempre entendidos implícitamente) y, como máximo, públicos, protegidos o privados.

La cláusula de extensión puede estar ausente o tener la forma

extiende I1, I2, ...

donde I1, I2, ... es una lista no vacía de nombres de interfaces. Si la cláusula de extensión está presente, entonces la interfaz I describe todos los miembros descritos por I1, I2,..., y la interfaz I es una subinterfaz (y por lo tanto un subtipo) de I1, I2,. Interfaz Puedo describir campos y métodos adicionales pero no puedo anularlos

miembros heredados.

Una descripción de campo en una interfaz declara una constante con nombre y debe tener la forma

modificadores de descripción de campo tipo f = inicializador;

donde modificadores de descripción de campo es una lista de elementos estáticos, finales y públicos, ninguno de los cuales necesita darse explícitamente, ya que todos se entienden implícitamente. El inicializador de campo debe ser una expresión que incluya únicamente literales y operadores, y miembros estáticos de clases e interfaces.

Una descripción de método para el método m debe tener la forma

modificadores-desc-método tipo-retorno m (lista-formal) cláusula-lanzamientos;

donde modificadores-desc-método es una lista de abstractos y públicos, los cuales se entienden y no es necesario proporcionarlos explícitamente.

Una declaración de clase dentro de una interfaz siempre es implícitamente estática y pública.



Clases que implementan interfaces

Se puede declarar que una clase C implementa una o más interfaces mediante una cláusula de implementación: la clase C implementa I1, I2, ...

cuerpo de clase

En este caso, C es un subtipo (sección 5.4) de I1, I2, etc., y C debe declarar todos los métodos descritos por I1, I2. con exactamente las firmas prescritas y los tipos de devolución. Una clase puede implementar

cualquier número de interfaces. Campos, clases e interfaces declarados en I1, I2. Se puede utilizar en clase C.

Ejemplo 70: Tres declaraciones de interfaz

La interfaz Colored describe el método getColor, la interfaz Drawable describe el método draw y Coloured-Drawable describe ambos. Los métodos son implícitamente públicos.



importar java.awt.*;



interfaz Coloreada { Color getColor(); } interfaz dibujable { void draw(Gráficos g); }

interfaz ColouredDrawable extiende Colored, Drawable {}





Ejemplo 71: Clases que implementan interfaces

Los métodos getColor y draw deben ser públicos como en las declaraciones de la interfaz (ejemplo 70).



clase ColoredPoint extiende Point implementa Colored { Color c;

ColoredPoint(int x, int y, Color c) { super(x, y); esto.c = c; } Color público getColor() { return c; }

}







clase ColoredDrawablePoint extiende ColoredPoint implementa ColoredDrawable { Color c;

ColoredDrawablePoint(int x, int y, Color c) { super(x, y, c); } public void draw(Gráficos g) { g.fillRect(x, y, 1, 1); }

}







clase ColoredRectangle implementa ColoredDrawable {



entero x1, x2, y1, y2; // (x1, y1) esquina superior izquierda, (x2, y2) esquina inferior derecha Color c;





ColoredRectangle(int x1, int y1, int x2, int y2, Color c)



{ esto.x1 = x1; esto.y1 = y1; esto.x2 = x2; esto.y2 = y2; esto.c = c; } Color público getColor() { return c; }

dibujo vacío público (Gráficos g) { g.drawRect(x1, y1, x2-x1, y2-y1; }



}





Ejemplo 72: Uso de interfaces como tipos

Un valor coloreado tiene un método getColor; un valor ColoredDrawable tiene un método getColor y un

método de dibujo:

colores de impresión vacíos estáticos (Colored[] cs) { for (int i=0; i<cs.length; i++)

System.out.println(cs[i].getColor().toString());

}

dibujo vacío estático (Gráficos g, ColoredDrawable[] cs) { for (int i=0; i<cs.length; i++) {

g.setColor(cs[i] getColor());

cs[i].draw(g);

}

}



Capítulo 14: Excepciones, marcadas y no marcadas

Una excepción es un objeto de un tipo de excepción: una subclase de la clase Throwable. Se utiliza para señalar y describir una situación anormal durante la ejecución del programa. La evaluación de una expresión o la ejecución de una declaración puede terminar abruptamente al generar una excepción, ya sea ejecutando una declaración de lanzamiento (sección 12.6.5) o ejecutando una operación primitiva, como la asignación a un elemento de matriz, que puede generar un excepción.

Una excepción lanzada puede quedar atrapada en una declaración try-catch que la incluye dinámicamente (sección 12.6.6). Si no se detecta la excepción, se cancelará toda la ejecución del programa y la información de la excepción se imprimirá en la consola. Lo que se imprime está determinado por el método toString de la excepción.

Hay dos tipos de excepciones: marcadas (aquellas que deben declararse en la cláusula throws de un método o constructor; consulte la sección 9.8) y no marcadas (aquellas que no necesitan ser declaradas). Si la ejecución de un método o del cuerpo del constructor puede generar una excepción marcada de la clase E, entonces la clase E o un supertipo de E deben decretarse. indicado en la cláusula throws del método o constructor.

La siguiente tabla muestra parte de la jerarquía de clases de excepción.



Ejemplo 73: Declaración de una clase de excepción marcada

Esta es la clase de excepciones lanzadas por el método wdayno4 (ejemplo 65). Pasar una cadena al constructor de la superclase (es decir, la clase Exception) hace que el método toString agregue esa cadena al nombre de la excepción.



class WeekdayException extiende Exception { public WeekdayException(String wday) { super("Día de la semana ilegal: " + wday);

}



}





Ejemplo 74: Todas las rutas a través de una declaración try-catch-finally

Para ejercitar las 18 rutas a través de la instrucción try-catch-finally (sección 12.6.6) en el método m del siguiente programa, ejecútelo con cada uno de estos argumentos de línea de comando: 101 102 103 201 202 203 301 302

303 411 412 413 421 422 423 431 432 433. La cláusula try termina normalmente en los argumentos 1yz, sale por retorno en 2yz y genera una excepción en 3yz y 4yz. La cláusula catch ignora las excepciones lanzadas en 3yz pero captura aquellas lanzadas en 4yz; la cláusula catch termina normalmente en 41z, sale por retorno en 42z y genera una excepción en 43z. La cláusula finalmente termina normalmente en xy1, sale por retorno en xy2 y genera una excepción en xy3.

Las salidas mediante declaraciones break y continue se manejan de manera similar al retorno; Se podría construir un ejemplo más complicado para ilustrar su interacción.



clase TryCatchFinalmente {



public static void main (String[] args) lanza una excepción



{ System.out.println(m(Integer.parseInt(args[0] ))); }







Cadena estática m (int a) lanza excepción {intenta {

System.out.print("intentar...");



if (a/100 == 2) devuelve "devuelto del intento";



if (a/100 == 3) lanza una nueva excepción ("lanzada por intento");



if (a/100 == 4) throw new RuntimeException("lanzado por intento");



} catch (RuntimeException x) { System.out.print("catch...");

if (a/10%10 == 2) devuelve "regresado de la captura";



if (a/10%10 == 3) lanza una nueva excepción ("lanzada por captura");



} finalmente { System.out.println("finalmente");

if (a%10 == 2) return "regresó finalmente";



if (a%10 == 3) lanza una nueva excepción ("lanzada por finalmente");



}



retorno "terminado normalmente con " + a;



}



}



Capítulo 15: Subprocesos, ejecución simultánea y sincronización

Hilos y ejecución concurrente

Los capítulos anteriores describieron la ejecución secuencial de programas, en los que se evalúan expresiones y se ejecutan declaraciones una tras otra: consideraron solo un único hilo de ejecución, donde un hilo es una actividad secuencial independiente. Un programa Java puede ejecutar varios subprocesos al mismo tiempo, es decir, potencialmente superponiéndose en el tiempo. Por ejemplo, una parte de un programa puede continuar computando mientras otra parte está bloqueada esperando una entrada (ejemplo 75).

Ejemplo 75: múltiples subprocesos

El programa principal crea un nuevo hilo, lo vincula a u y lo inicia. Ahora se ejecutan dos subprocesos al mismo tiempo: uno ejecuta main y otro ejecuta run. Mientras el método principal está bloqueado esperando la entrada del teclado, el nuevo hilo sigue incrementando i. El nuevo hilo ejecuta rendimiento() para asegurarse de que el otro hilo pueda ejecutarse (cuando no esté bloqueado).



class Incrementer extiende Thread { public int i;

ejecución pública vacía() {



Para Siempre



yo ++; // incremento i



producir();



}



} }







clase ThreadDemo {



public static void main(String[] args) lanza IOException { Incrementer u = new Incrementer();

u.start();



System.out.println("Presione Enter repetidamente para obtener el valor actual de i:"); para (;;) {

Sistema.en.read(); // Espere la entrada del teclado System.out.println(u.i);

} } }





Un hilo se crea y controla utilizando un objeto de la clase Thread que se encuentra en el paquete java.lang. Un hilo ejecuta el método public void run() en un objeto de una clase que implementa la interfaz Runnable, que también se encuentra en el paquete java.lang. Para cada hilo (actividad secuencial independiente) hay un objeto Thread controlador único, por lo que a menudo se piensa que los dos son idénticos.

Una forma de crear y ejecutar un hilo es declarar una clase U como una subclase de Thread, sobrescribiendo su (trivial) método de ejecución. Luego cree un objeto u de clase U y llame a u.start(). Esto permitirá que el hilo ejecute u.run() simultáneamente con otros hilos (ejemplo 75).



Alternativamente, declare una clase C que implemente Runnable, cree un objeto o de esa clase, cree un objeto de hilo u = new Thread(o) de o y ejecute u.start (). Esto permitirá que el hilo ejecute o.run() simultáneamente con otros hilos (ejemplo 79).

Los subprocesos pueden comunicarse entre sí a través de un estado compartido, es decir, mediante el uso y la asignación de campos estáticos, campos no estáticos, elementos de matriz y tuberías (sección 21.15). Según el diseño de Java, los subprocesos no pueden utilizar variables locales ni parámetros de métodos para la comunicación.

Estados y transiciones de estado de un hilo

Un hilo está vivo si se ha iniciado y no ha muerto. Un hilo muere al salir de su método run(), ya sea regresando o lanzando una excepción. Un hilo activo se encuentra en uno de los estados Habilitado (listo para ejecutarse), Ejecutando (realmente ejecutándose), Suspendido (wesperando un tiempo de espera), Unirse (esperando a que muera otro hilo), Bloqueando (intentando obtener el bloqueo en el objeto o) o Esperando (para recibir una notificación sobre el objeto o). Las transiciones de estado del hilo se muestran en la siguiente tabla y en la figura de la página opuesta:

Estados y transiciones de estado de un hilo. La transición de un hilo de un estado a otro puede ser causada por una llamada a un método realizada por el propio hilo (que se muestra en la fuente monoespaciada), por una llamada a un método posiblemente realizada por otro hilo (que se muestra en la fuente monoespaciada inclinada); y por tiempos de espera y otras acciones.









Bloqueos y la declaración sincronizada

Los subprocesos concurrentes se ejecutan de forma independiente. Por lo tanto, cuando varios subprocesos simultáneos acceden a los mismos campos o elementos de matriz, existe un riesgo considerable de crear un estado inconsistente (ejemplo 77). Para evitar esto, los subprocesos pueden sincronizar el acceso al estado compartido, como objetos y matrices. Se asocia un único candado con cada objeto, matriz y clase. Un candado puede ser mantenido por como máximo un hilo a la vez. Un hilo puede solicitar explícitamente el bloqueo de un objeto o matriz ejecutando una declaración sincronizada, que tiene esta forma:

declaración de bloque sincronizada (expresión)

La expresión debe tener tipo de referencia. La expresión debe evaluarse como una referencia no nula o; de lo contrario, se lanza una NullPointerException. Después de la evaluación de la expresión, el hilo se bloquea en el objeto o; vea la figura en la página anterior. Cuando el hilo obtiene el bloqueo en el objeto o (si es que alguna vez lo hace), el hilo pasa a estar Habilitado y puede pasar a Ejecutarse, por lo que se ejecuta la declaración de bloqueo. Cuando la declaración de bloque termina o se sale mediante return, break, continue o lanzando una excepción, entonces se libera el bloqueo en o.

Una declaración de método no estático sincronizado (sección 9.8) es una abreviatura de un método cuyo cuerpo tiene la forma

sincronizado (esto)

cuerpo del método

Es decir, el hilo ejecutará el cuerpo del método sólo cuando haya obtenido el bloqueo en el objeto actual. Liberará el bloqueo cuando abandone el cuerpo del método.

Una declaración de método estático sincronizado (sección 9.8) en la clase C es una abreviatura de un método cuyo cuerpo tiene la forma

sincronizado (clase C)

cuerpo del método

Es decir, el hilo ejecutará el cuerpo del método solo cuando haya obtenido el bloqueo en el objeto C.class, que es el objeto único de la clase Class asociado con la clase C. Mantendrá el bloqueo hasta que abandone el cuerpo del método. y suéltelo en ese momento.

Los constructores e inicializadores no se pueden sincronizar.

La exclusión mutua solo se garantiza si todos los subprocesos que acceden a un objeto compartido lo bloquean antes de su uso. Por ejemplo, si agregamos un método roguetransfer no sincronizado a un objeto bancario (ejemplo 77), ya no podemos estar seguros de que un subproceso que llama al método sincronizado transfer tenga acceso exclusivo al objeto bancario: cualquier número de subprocesos podría estar ejecutando roguetransfer en al mismo tiempo.



Un monitor es un objeto cuyos campos son privados y son manipulados únicamente por métodos sincronizados del objeto, de modo que todo acceso a los campos está sujeto a sincronización (ejemplo 78).

Si un hilo u necesita esperar a que alguna condición se cumpla, o que un recurso esté disponible, puede liberar temporalmente su bloqueo en el objeto o llamando a o.wait(). El hilo debe mantener el bloqueo en el objeto o; de lo contrario, se lanza la excepción IllegalMonitorStateException. El hilo u se agregará al conjunto de espera de o, es decir, el conjunto de hilos que esperan notificación sobre el objeto o. Esta notificación debe provenir de otro hilo que haya obtenido el bloqueo en o y que ejecute o.notify() u o.notifyAll(). El hilo de notificación no libera su bloqueo en o. Después de recibir la notificación, debe volver a bloquear o antes de poder continuar. Por lo tanto, cuando regrese la llamada de espera, el subproceso u mantendrá el bloqueo en o tal como antes de la llamada (ejemplo 78).

Para conocer las reglas detalladas que rigen el comportamiento de subprocesos Java no sincronizados, consulte el capítulo 17 de la Especificación del lenguaje Java [1].

Ejemplo 76: Exclusión mutua

Un hilo de impresora imprime siempre un (-) seguido de un (/). Si creamos y ejecutamos dos subprocesos de impresora simultáneos usando new Printer().start() y new Printer().start(), entonces solo uno de los subprocesos puede mantener el bloqueo en el objeto mutex a la vez, por lo que ningún otro símbolo puede hacerlo. imprimirse entre (-) y (/) en una iteración del bucle for. Por lo tanto, el programa debe imprimir -/-/-/-/-/-/-/ y así sucesivamente. Sin embargo, si se elimina la sincronización, es posible que se imprima --//--/-/-//--// y así sucesivamente. La llamada Util.pause(n) pausa el hilo durante 200 ms, mientras que Util.pause (100, 300) lo pausa entre 100 y 300 ms. Esto se hace sólo para hacer más fácilmente observable la no determinación inherente de la concurrencia no sincronizada.



La impresora de clase extiende el hilo {



Objeto estático mutex = nuevo Objeto(); ejecución pública vacía() {

para (;;) {



sincronizado (mutex) { System.out.print("-"); Util.pausa(100, 300); System.out.print("/");

}



Util.pausa(200);



} } }





Ejemplo 77: Métodos sincronizados en un objeto



El objeto Banco aquí tiene dos cuentas. El dinero se repite y ser transferido de una cuenta a otra por empleados. Es evidente que la cantidad total de dinero debería permanecer constante (en 30 euros). Esto es válido cuando el método de transferencia se declara sincronizado, porque sólo un empleado puede acceder a las cuentas a la vez. Si se elimina la declaración sincronizada, la suma será diferente de 30 la mayor parte del tiempo, porque es probable que un empleado sobrescriba los depósitos y retiros del otro.



banco de clase {



cuenta privada int1 = 10, cuenta2 = 20; transferencia nula pública sincronizada (monto int) { int nuevo1 = cuenta1 - monto;



Util.pausa(10);



cuenta1 = nueva1; cuenta2 = cuenta2 + monto; System.out.println("La suma es " + (cuenta1+cuenta2));

} }







class Clerk extiende Thread { banco privado banco;

Secretario público(Banco banco) { this.bank = banco; } ejecución pública vacía() {

Para Siempre



transferencia.bancaria(Util.random(-10, 10)); // transferir dinero Util.pause(200, 300); // entonces tómate un descanso

} } }







... Banco banco = nuevo Banco();



... nuevo Empleado(banco).start(); nuevo Empleado(banco).start();





Operaciones en hilos

El hilo actual, cuyo estado es En ejecución, puede llamar a estos métodos, entre otros. Se describen más métodos Thread en la documentación de la biblioteca de clases Java [3].

Thread.yield() cambia el estado del subproceso actual de En ejecución a Habilitado y, por lo tanto, permite que el sistema programe otro subproceso habilitado, si lo hubiera.

Thread.sleep(n) duerme durante n milisegundos: el hilo actual pasa a Dormir y después de n milisegundos se habilita. Puede generar InterruptedException si el hilo se interrumpe mientras duerme.

Thread.currentThread() devuelve el objeto del hilo actual.

Thread.interrupted() devuelve y borra el estado de interrupción del hilo actual: verdadero si no ha habido ninguna llamada a Thread.interrupted() y no se ha lanzado ninguna InterruptedException desde la última interrupción; de lo contrario falso.

Sea u un hilo (un objeto de una subclase de Thread). Entonces

u.start() cambia el estado de u a Habilitado para que se llame a su método de ejecución cuando un procesador esté disponible.

u.interrupt() interrumpe el hilo u: si u está en ejecución, habilitado o bloqueado, entonces su estado de interrupción se establece en verdadero. Si está durmiendo o uniéndose, se habilitará, y si está esperando, se bloqueará; en estos casos, lanzará InterruptedException cuando se convierta en Ejecución (y el estado de interrupción se establezca en falso).

u.isInterrupted() devuelve el estado interrumpido de u (y no lo borra).

u.join() espera a que muera el hilo u; puede generar InterruptedException si el hilo actual se interrumpe mientras se espera.

u.join(n) funciona como u. join() pero se agota el tiempo de espera y regresa después de n milisegundos como máximo. No hay indicación de si la llamada se devolvió debido a un tiempo de espera o porque usted murió.



Operaciones sobre objetos bloqueados

Un hilo que mantiene el bloqueo de un objeto o puede llamar a los siguientes métodos, heredados por o de la clase Objeto.

o.wait() libera el bloqueo en o, cambia su propio estado a Esperando y se agrega al conjunto de subprocesos que esperan notificación en o. Cuando se le notifica (si es que alguna vez lo hace), el hilo debe obtener el bloqueo en o, de modo que cuando regresa la llamada de espera, nuevamente mantiene el bloqueo en o. Puede generar InterruptedException si el hilo se interrumpe mientras se espera.

o.wait(n) funciona como o.wait() excepto que el hilo cambiará de estado a Bloqueo después de n milisegundos, independientemente de si ha habido una notificación en o. No hay indicación de si el cambio de estado fue causado por un tiempo de espera o por una notificación.

o.notify () elige un hilo arbitrario entre los hilos que esperan notificación en o (si corresponde) y cambia su estado a Bloqueo. El hilo elegido en realidad no puede obtener el bloqueo en o hasta que el hilo actual lo haya liberado.

o.notifyAll() funciona como o.notify(), excepto que cambia el estado a Bloqueo para todos los subprocesos que esperan notificación en o.

Ejemplo 78: Productores y consumidores comunicándose a través de un monitor

Un búfer tiene espacio para un número entero y tiene un método put para almacenar en el búfer (si está vacío) y un método get para leer desde el búfer (si no está vacío); es un monitor (sección 15.2). Un hilo que llama a get debe obtener el bloqueo en el búfer. Si encuentra que el búfer está vacío, llama a esperar para (liberar el bloqueo y) esperar hasta que se haya puesto algo en el búfer. Si otro subproceso llama a put y, por lo tanto, notifica, entonces el subproceso receptor comenzará a competir por el bloqueo del búfer nuevamente y, si lo obtiene, continuará ejecutándose. Aquí hemos utilizado una declaración sincronizada en el cuerpo del método (en lugar de sincronizar el método, como es normal para un monitor) para enfatizar que la sincronización, esperar y notificar a todos los trabajos en el mismo objeto de búfer.



búfer de clase



contenidos privados int;



booleano privado vacío = verdadero; public int get() { sincronizado (esto) {

mientras (vacío)



prueba { this.wait(); } captura (Excepción interrumpida x) {}; vacío = verdadero;

this.notificar(); devolver contenidos;

} }



public void put(int v) { sincronizado (esto) { mientras (!vacío)

prueba { this.wait(); } captura (Excepción interrumpida x) {} ; vacío = falso;

contenido = v;



this.notificar();



} }



}





Ejemplo 79: Animación gráfica utilizando la interfaz ejecutable

La clase AnimatedCanvas aquí es una subclase de Canvas y, por lo tanto, no puede ser también una subclase de Thread. En su lugar, declara un método de ejecución e implementa la interfaz Runnable. El constructor crea un objeto Thread u a partir del objeto AnimatedCanvas this y luego inicia el hilo. El nuevo hilo ejecuta el método de ejecución, que duerme y repinta repetidamente, creando así una animación.



clase AnimatedCanvas extiende Canvas implementa Runnable { AnimatedCanvas() { Thread u = new Thread(this); u.start(); }





public void run() { // Desde la interfaz Ejecutable para (;;) { // Dormir y repintar para siempre

prueba { Thread.sleep(100); } captura (Excepción interrumpida e) { }



...



repintar();



}



}







pintura vacía pública (Gráficos g) {...} // De la clase Canvas



...



}



Capítulo 16: Compilación, archivos fuente, nombres de clases y archivos de clases

Un programa Java consta de uno o más archivos fuente (con el sufijo de nombre de archivo .java). Un archivo fuente puede contener una o más declaraciones de clase o interfaz. Un archivo fuente puede contener como máximo una declaración de una clase o interfaz pública de nivel superior, que luego debe tener el mismo nombre que el archivo (menos el sufijo del nombre del archivo). Un compilador de Java compila un archivo fuente myprog.java en archivos de clase Java (con el sufijo de nombre de archivo .class):

javac miprog.java

Esto crea un archivo de clase para cada clase o interfaz declarada en el archivo fuente myprog.java. Una clase o interfaz C declarada en una declaración de nivel superior produce un archivo de clase llamado C.class. Una clase anidada o interfaz D declarada dentro de la clase C produce un archivo de clase llamado C$D.class. Una clase D local declarada dentro de un método en la clase C produce un archivo de clase llamado C$1$D.class o similar.

Una clase C de Java que declara el método public static void main(String[] args) se puede ejecutar utilizando el sistema de tiempo de ejecución de Java escribiendo una línea de comando del formulario

JavaCarg1arg2...

Esto ejecutará el cuerpo del método main con los argumentos de la línea de comando arg1, arg2,... vinculados a los elementos de la matriz args[0], args[1],... dentro del método main (ejemplos 6 y 84).



Capítulo 17: Paquetes y archivos Jar

Los archivos fuente de Java se pueden organizar en paquetes. Cada archivo fuente en el paquete p debe comenzar con la declaración

paquete p;

y debe almacenarse en un subdirectorio llamado p. Una clase declarada en un archivo fuente sin declaración de paquete pertenece al paquete predeterminado anónimo. Un archivo fuente que no pertenece al paquete p puede hacer referencia a la clase C del paquete p utilizando el nombre calificado p. C, en el que el nombre de clase C tiene el prefijo del nombre del paquete. Para evitar el uso del prefijo del nombre del paquete, el archivo fuente puede comenzar con una declaración de importación (posiblemente después de una declaración de paquete) de una de estas formas:

importar pc; importar p.*;

El primero permite que C se use sin calificar, sin el nombre del paquete, y el segundo permite que todos

Las clases e interfaces accesibles en el paquete p se utilizarán sin calificar. El paquete de biblioteca de clases Java java. lang se importa implícitamente en todos los archivos fuente, como si se importara java. lang.*, por lo que todo java. Las clases lang se pueden utilizar sin calificar en archivos fuente de Java. Tenga en cuenta que java. lang es un nombre de paquete compuesto, por lo que la clase java. idioma. La cadena se declara en el archivo java/lang/String. Java.

Los archivos en p y sus subdirectorios se pueden colocar en un archivo jar llamado p. jar usando el programa jar:

jar vcf p.jar p

Los paquetes en un archivo jar pueden estar disponibles para otros programas Java moviendo el archivo al directorio /usr/java/j2sdk1.4.0/jre/lib/ext o similar en Unix, o al directorio c:\jdk1.4 \jre\lib\ext o similar en MS Windows. El archivo jar puede contener más de un paquete; sólo necesita contener archivos de clase (no archivos fuente); y su nombre no es significativo.

Ejemplo 80: La jerarquía de embarcaciones como paquete

El barco del paquete contiene aquí parte de la jerarquía de barcos (ejemplo 19). Los campos de las clases Tanque y Barril son definitivos, por lo que no se pueden modificar después de la creación del objeto. Están protegidos, por lo que se puede acceder a ellos en subclases declaradas fuera del paquete del buque, como se muestra en el archivo Usevessels.java, que se encuentra en el paquete predeterminado anónimo, no en el paquete del buque.

El archivo buque/Vessel.java



buque de carga;



clase abstracta pública Buque {contenido doble privado;

capacidad doble abstracta pública(); Relleno público de vacío final (cantidad doble)

{ contenido = Math.min(contenido + cantidad, capacidad()); } public final double getContents() { devolver contenido; }

}

El archivo buque/Tank.java



buque de carga;



El tanque de clase pública extiende el recipiente {protegido final doble largo, ancho, alto;

Tanque público (doble l, doble w, doble h) { longitud = 1; ancho = ancho; altura = h; } public double capacidad() { return largo * ancho * alto; }

cadena pública a cadena ()



{ return "tanque (l,w,h) = (" + largo + ", " + ancho + ", " + alto + ")"; }



}

El archivo buque/Barrel.java



buque de carga;



clase pública Barril extiende Vasija {protegido doble radio final, altura;

Barril público (doble r, dou ble h) { radio = r; altura = h; }



capacidad doble pública() { altura de retorno * Math.PI * radio * radio; }



public String toString() { return "barril (r, h) = (" + radio + ", " + altura + ")"; }



}

El archivo Usevessels.java

La subclase Cube de la clase Tank puede acceder a la longitud del campo porque ese campo está declarado protegido en Tank arriba. El método principal no se modifica respecto del ejemplo 20.



buque de importación.*;



clase Cubo extiende Tanque {



Cubo público (doble cara) { super(lado, lado, lado); }



public String toString() { return "cubo(s) = (" + longitud + ")"; }



}



buques de uso de clase {



público estático vacío principal (String[] args) {...}



}



Capítulo 18: Funciones matemáticas

Class Math proporciona métodos estáticos para calcular funciones matemáticas estándar. Los números de coma flotante (dobles y flotantes) incluyen infinitos positivos y negativos, así como no números (NaN), siguiendo el estándar IEEE754 [6]. También hay una distinción entre cero positivo y cero negativo, que aquí se ignora.

Los métodos matemáticos devuelven números no numéricos (NaN) cuando se aplican a argumentos ilegales y devuelven infinitos en caso de desbordamiento; no lanzan excepciones. Además, los métodos devuelven NaN cuando se aplican a argumentos NaN, excepto donde se indique, y se comportan de manera sensata cuando se aplican a infinitos positivos o negativos.

Los ángulos se dan y devuelven en radianes, no en grados. Los métodos que redondean al entero más cercano redondearán al entero par más cercano en caso de empate.

Los métodos abs, min y max también están sobrecargados con argumentos float, int y long.

El doble estático E es la constante e ≈ 2,71828, la base del logaritmo natural.

El doble PI estático es la constante π ≈ 3,14159, la circunferencia de un círculo con diámetro 1.

abs doble estático (doble x) es el valor absoluto: x si x>=0 y -x si x<0.

acos doble estático (doble x) es el arco coseno de x, en el rango [0,π], para - 1<=x<=1.

asin doble estático (doble x) es el arco seno de x, en el rango [—π/2,π/2], para - 1<=x<=1.

atan doble estático (doble x) es el arco tangente de x, en el rango [—π/2,π/2].

El doble atan2 estático (doble y, doble x) es el arco tangente de y/x en el

cuadrante del punto (x, y), en el rango ] — π,π]. Cuando x es 0, el resultado es π/2 con el mismo signo que y.

techo doble estático (doble x) es el valor doble integral más pequeño>=x.

cos doble estático (doble x) es el coseno de x, en el rango [—1,1].

exp doble estática (doble x) es el exponencial de x, es decir, e elevado a x.

piso doble estático (doble x) es el valor doble integral más grande <= x.

IEEEremanente doble estático (doble x, doble y) es el resto de x/y,

es decir, x-y*n, donde n es el entero matemático más cercano a x/y.

El doble registro estático (doble x) es el logaritmo natural (en base e) de x, para x>=0.

El máximo doble estático (doble x, doble y) es el mayor de x e y.

static double min(doble x, doble y) es el más pequeño de xey.

potencia doble estática(doble x, doble y) es x elevado a la potencia y, es decir, xy. Si y es 0,

entonces el resultado es 1,0. Si y es 1, entonces el resultado es x. Si x<0 e y no son integrales, entonces el resultado es NaN.

static double random() devuelve un número pseudoaleatorio distribuido uniformemente en [0,1[.

rint doble estático (doble x) es el valor doble integral más cercano a x.

ronda larga estática (doble x) es el valor largo más cercano a x.

static int round(float x) es el valor int más cercano a x.

El doble pecado estático (doble x) es el seno de x radianes.

static double sqrt(doble x) es la raíz cuadrada positiva de x, para x>=0.

La doble tangente estática (doble x) es la tangente de x radianes.

static double toDegrees(doble r) es el número de grados correspondientes a r

radianes.

doble estático a Radianes (doble d) es el número de radianes correspondientes a d

grados.

Ejemplo 81: Factorial de punto flotante

Este método calcula la función factorial n! = 1∙2∙3∙∙∙(n—1)∙n usando logaritmos. doble hecho estático (int n) {



doble resolución = 0,0;

para (int i=1; i<=n; i++)



res += Math.log(i); devolver Math.exp(res);

}





Ejemplo 82: Generación de números pseudoaleatorios gaussianos

Este ejemplo utiliza la transformación de Box-Muller para generar N números pseudoaleatorios gaussianos, o normalmente distribuidos, con media 0 y desviación estándar 1.

para (int i=0; i<N; i+=2) {

doble x1 = Math.random(), x2 = Math.random();

print(Math.sqrt(-2 * Math.log (x1)) * Math.cos(2 * Math.PI * x2)); print(Math.sqrt (-2 * Math.log(x1)) * Math.sin(2 * Math.PI * x2));

}





Ejemplo 83: Funciones matemáticas: infinitos, NaN y casos especiales

print("Argumentos ilegales, resultados NaN:"); imprimir(Math.sqrt(-1)); //NaN

print(Math.log(-1)); // NaN print(Math.pow(-1, 2.5)); // NaN print(Math.acos(1.1)); // NaN print("Resultados infinitos:"); imprimir(Math.log(0)); // -Infinidad

print(Math.pow(0, -1)); // Impresión infinita(Math.exp(1000.0)); // Infinito (desbordamiento) print("Argumentos infinitos:");

doble infinito = Doble.POSITIVE_INFINITY; print(Math.sqrt(infinito)); // Impresión infinita(Math.log(infinito)); // Impresión infinita(Math.exp(-infinity)); // 0.0 print("Argumentos NaN y casos especiales:"); doble nan = Math.log(-1); pagrint(Math.sqrt(nan)); //NaN

print(Math.pow(nan, 0)); // 1.0 (caso especial)



imprimir(Math.pow(0, 0)); // 1.0 (caso especial) print(Math.round(nan)); // 0 (caso especial)

print(Matemáticas.ronda(1E50)); // 9223372036854775807 (Largo.MAX_VALUE)



// Para todo (x, y) excepto (0.0, 0.0):

// signo(cos(atan2(y, x))) == signo(x) && signo(sin(atan2(y, x))) == signo(y) for (doble x=-100; x<= 100;x+=0,125) {



for (doble y=-100; y<=100; y+=0,125) { doble r = Math.atan2(y, x);

if (!(signo(Math.cos(r))==signo(x) && signo(Math.sin(r))==signo(y))) print("x = " + x + "; y = " + y);

}

}



Capítulo 19: Búfers de cadena

Un objeto String s1, una vez creado, no se puede modificar. Usando s1 + s2 se puede agregar otra cadena s2 a s1, pero eso crea un nuevo objeto de cadena, copiando todos los caracteres de s1 y s2; no hay forma de extender s1 agregándole más caracteres. Así para concatenar n

cadenas cada una de longitud k mediante concatenación repetida de cadenas (+), copiamos k+2k+3k+∙∙∙∙∙+nk = kn(n+ 1)/2 caracteres, y el tiempo requerido para hacer esto es proporcional a kn2, que crece rápidamente a medida que n crece.

Los buffers de cadenas, que son objetos de la clase predefinida StringBuffer, proporcionan cadenas extensibles y modificables. Se pueden agregar caracteres a un búfer de cadena sin copiar los caracteres que ya están en el búfer de cadena; el búfer de cadena se amplía de forma automática y eficiente según sea necesario. Para concatenar n cadenas, cada una de ellas de longitud k utilizando un búfer de cadenas, solo se requiere un tiempo proporcional a kn, considerablemente más rápido que kn2 para n grande. Por lo tanto, para construir gradualmente una cadena, utilice un búfer de cadena. Esto es

sólo es necesario para la concatenación repetida en un bucle, como en el ejemplo 6. La expresión s1 + ∙∙∙ + sn es eficiente; en realidad significa new StringBuffer() .append(s1) ∙∙∙ append (sn)

.Encadenar().

Sea sb un StringBuffer, s un String y v una expresión de cualquier tipo. Entonces

new StringBuffer() crea un nuevo buffer de cadena vacío.

sb.append(v) agrega la representación de cadena del valor v al búfer de cadena, convirtiendo v mediante String.valueOf(v), consulte el capítulo 7. Extiende sb según sea necesario. Devuelve alguien

sb.charAt(int i) devuelve el carácter número i (contando desde cero) en el búfer de cadena.

Lanza String-IndexOutOfBoundsException si i<0 o i>=sb.length().

sb.delete(from, to) elimina los caracteres con índice from.. (to-1) del

búfer de cadena, reduciendo su longitud en caracteres de destino. Lanza

StringlndexOutOfBoundsException si desde<0 o desde>hacia o hacia>sb.length(). Devuelve alguien

sb.insert(from, v) inserta la representación de cadena de v obtenida por String.valueOf(v) en el búfer de cadena, comenzando en la posición from y extendiendo sb según sea necesario. Devuelve alguien Lanza StringlndexOutOf-BoundsException si es de <0 o de> sb.length().

sb.length() de tipo int es la longitud de sb, es decir, la cantidad de caracteres actualmente

en alguien

sb.replace(from, to, s) reemplaza los caracteres con índice from.. (to-1) en el búfer de cadena por la cadena s, extendiendo sb si es necesario. Lanza StringlndexOutOfBoundsException si desde<0 o desde>hacia o desde>sb.length().

Devuelve alguien

sb.reverse() invierte la secuencia de caracteres en el búfer de cadena. Devuelve alguien

sb.setCharAt(i, c) establece el carácter en el índice i a c. Lanza

StringlndexOutOfBoundsException si i<0 o i>=sb.length().

sb.toString() de tipo String es una nueva cadena que contiene los caracteres actualmente en sb.

El método de agregar es rápido, pero eliminar, insertar y reemplazar puede ser lento cuando sea necesario.

para mover grandes partes del búfer de cadena, cuando desde y hacia son mucho más pequeños que

longitud().

Las operaciones en un objeto StringBuffer son seguras para subprocesos: varios subprocesos simultáneos (capítulo 15) pueden modificar el mismo búfer de cadena sin que su estado interno sea inconsistente.

Se describen más métodos StringBuffer en la documentación de la biblioteca de clases Java [3].

Ejemplo 84: Concatenar eficientemente todos los argumentos de la línea de comando

Cuando hay muchos (más de 50) argumentos de línea de comando, esto es mucho más rápido que el ejemplo 6.

público estático vacío principal (String [] argumentos) {



StringBuffer res = nuevo StringBuffer();

for (int i=0; i<args.length; i++) res.append(args[i]); System.out.println(res.toString());

}



Ejemplo 85: Reemplazo de apariciones de un carácter por una cadena

Para reemplazar las apariciones del carácter c1 con la cadena s2 en la cadena s, es mejor usar un búfer de cadena para el resultado, ya que el tamaño de la cadena resultante no se conoce de antemano. Esto también funciona bien cuando se reemplaza un carácter cl con otro carácter c2, pero en ese caso la longitud del resultado se conoce de antemano (es igual a la longitud de s) y se puede usar una matriz de caracteres en su lugar (ejemplo 13). Resolver este problema mediante la concatenación repetida de cadenas (usando res += s2) sería muy lento. Cadena estática reemplazarCharString(String s, char c1, String s2) {

StringBuffer res = nuevo StringBuffer(); para (int i=0; i<s.length(); i++)

si (s.charAt(i) == cl)

res.append(s2); demás

res.append(s.charAt(i)); devolver res.toString();

}





Ejemplo 86: Reemplazo ineficiente de apariciones de un carácter por una cadena

El problema del ejemplo 85 también se puede resolver destructivamente mmodificando un búfer de cadena con reemplazo. Sin embargo, usar reemplazar repetidamente es ineficaz: para una cadena de 200.000 caracteres aleatorios, este método es aproximadamente 100 veces más lento que el del ejemplo 85.

vacío estático reemplazarCharString (StringBuffer sb, char cl, String s2) {



int yo = 0; // Ineficiente

while (i < sb.length()) { // Ineficiente

if (sb.charAt(i) == cl) { // Ineficiente

sb.replace(i, i+1, s2); // Ineficiente

yo += s2.longitud(); // Ineficiente

} else // Ineficiente

yo += 1; // Ineficiente

} } // Ineficiente





Ejemplo 87: Rellenar una cadena a un ancho determinado

Una cadena s puede rellenarse con espacios para asegurarse de que tenga un ancho mínimo determinado. Esto resulta útil para alinear números en columnas cuando se utiliza una fuente de paso fijo (ejemplo 103).

padLeft de cadena estática (cadena s, ancho int) {



StringBuffer res = nuevo StringBuffer();

for (int i=ancho-s.longitud(); i>0; i--) res.append(' ');

devolver resolución.Ejemplo 87: Rellenar una cadena a un ancho determinado

Una cadena s puede rellenarse con espacios para asegurarse de que tenga un ancho mínimo determinado. Esto resulta útil para alinear números en columnas cuando se utiliza una fuente de paso fijo (ejemplo 103).

padLeft de cadena estática (cadena s, ancho int) {



StringBuffer res = nuevo StringBuffer();

for (int i=ancho-s.longitud(); i>0; i--) res.append(' ');

devolver res.append(s).toString();

}



Capítulo 20: Colecciones y mapas

Descripción general

El paquete de biblioteca de clases Java java.util proporciona clases de colección y clases de mapas:

Una colección, descrita por la interfaz Colección (sección 20.1), se utiliza para agrupar y manejar muchos elementos distintos como un todo.

Una lista, descrita por la interfaz Lista (sección 20.2), es una colección cuyos elementos se pueden recorrer en orden de inserción. Implementado por las clases LinkedList (para listas enlazadas, colas de dos extremos y pilas) y ArrayList (para matrices y pilas dinámicamente extensibles).

Un conjunto, descrito por la interfaz Conjunto (sección 20.3), es una colección que no puede contener elementos duplicados. Implementado por las clases HashSet y LinkedHashSet.

Un conjunto ordenado, descrito por la interfaz SortedSet (sección 20.4), es un conjunto cuyos elementos están ordenados: o los elementos implementan el método compareTo especificado por la interfaz Comparable, o el orden del conjunto viene dado explícitamente por un objeto de tipo Comparador (sección 20.8). Implementado por la clase TreeSet.

Un mapa, descrito por la interfaz Mapa (sección 20.5), representa un mapeo de una clave a como máximo un valor para cada clave. Implementado por las clases HashMap, IdentityHashMap y LinkedHashMap.

Un mapa ordenado, descrito por la interfaz SortedMap (sección 20.6), es un mapa cuyas claves están ordenadas, como para SortedSet. Implementado por la clase TreeMap.

Las relaciones entre las interfaces estándar y las clases de implementación concretas y las clases abstractas intermedias se muestran en la siguiente figura. Las clases de implementación definidas por el usuario se pueden definir convenientemente como subclases de las clases abstractas; consulte la documentación de la biblioteca de clases Java en el paquete java.util [3]. Las flechas continuas indican las relaciones de subinterfaz y subclase, y las flechas discontinuas indican la relación de "implementos" entre una clase y una interfaz.



Ejemplo 88: uso de la colección concreta y las clases de mapas

Aquí creamos instancias de cinco clases de colección concretas y les agregamos algunos elementos String. Para cada colección, llamamos al método transversal en el ejemplo 91 para imprimir sus elementos.

También creamos instancias de tres clases de mapas concretas y les agregamos algunas entradas. Para cada mapa, nosotros

llame a atravesar por separado en el conjunto de claves y la colección de valores de ese mapa.

Tenga en cuenta que TreeSet, que implementa SortedSet, garantiza que los elementos se recorrerán en el orden especificado por el método compareTo (sección 20.8) de los elementos, y LinkedHashSet garantiza que los elementos se recorrerán en orden de inserción, mientras que HashSet no proporciona tal garantía. .

De manera similar, un TreeMap garantiza el recorrido en el orden de las claves y LinkedHashMap garantiza el recorrido en el orden de inserción de las claves, mientras que HashMap no garantiza ningún orden en particular.



importar java.util.*;







colección de clasesTodos {



público estático vacío principal (String [] argumentos) {



Lista /* de String */ list1 = new LinkedList();



lista1.add("lista"); list1.add("dup"); lista1.add("x"); list1.add("dup"); atravesar(lista1); // Debe imprimir: lista dup x dup

Lista /* de String */ list2 = new ArrayList();



lista2.add("lista"); list2.add("dup"); lista2.add("x"); list2.add("dup"); atravesar(lista2); // Debe imprimir: lista dup x dup

Conjunto /* de String */ set1 = new HashSet();



set1.add("conjunto"); set1.add("dup"); set1.add("x"); set1.add("dup"); atravesar(conjunto1); // Puede imprimir: x dup set

SortedSet /* de String */ set2 = new TreeSet();



set2.add("conjunto"); set2.add("dup"); set2.add("x"); set2.add("dup"); atravesar(conjunto2); // Debe imprimir: dup set x LinkedHashSet /* of String */ set3 = new LinkedHashSet(); set3.add("conjunto"); set3.add("dup"); set3.add("x"); set3.add("dup"); atravesar(conjunto3); // Debe imprimir: configurar dup x

Mapa /* de cadena a cadena */ ml = new HashMap();



m1.put("mapa", "J"); ml.put("dup", "K"); m1.put("x", "M"); m1.put("dup", "L"); atravesar(m1.keySet()); // Puede imprimir: x dup map traverse(m1.values()); // Puede imprimir: M L J

SortedMap /* de cadena a cadena */ m2 = new TreeMap();



m2.put("mapa", "J"); m2.put("dup", "K"); m2.put("x", "M"); m2.put("dup", "L"); atravesar(m2.keySet()); // Debe imprimir: dup map x traverse(m2.values()); // Debe imprimir: L J M

LinkedHashMap /* de cadena a cadena */ m3 = new LinkedHashMap(); m3.put("mapa", "J"); m3.put("dup", "K"); m3.put("x", "M"); m3.put("dup", "L"); atravesar(m3.keySet()); // Debe imprimir: map dup x traverse(m3.values()); // Debe imprimir: J L M

}







recorrido vacío estático (coll colección) {...}



}



La interfaz de colección

La interfaz de Colección describe los siguientes métodos:

boolean add(Object o) agrega el elemento o a la colección; devuelve verdadero si se agregó el elemento, falso si la colección no permite duplicados y contiene un elemento iguala o ya.

boolean addAll(Collection coll) agrega todos los elementos de coll a la colección; devoluciones

Es cierto si se agregó algún elemento.

void clear() elimina todos los elementos de la colección.

boolean contiene (Objeto o) devuelve verdadero si algún elemento de la colección es igual a o.

boolean containsAll(Collection coll) devuelve verdadero si la colección contiene todos los elementos de coll.

boolean isEmpty() devuelve verdadero si la colección no tiene elementos.

Iterator iterator() devuelve un iterador (sección 20.7) sobre los elementos de la colección.

boolean remove(Object o) elimina una única instancia del elemento o de la colección; devuelve verdadero si la colección contenía dicho elemento.

boolean removeAll(Collection coll) elimina todos aquellos elementos que también están en coll; devuelve verdadero si se eliminó algún elemento. Ningún elemento de la colección resultante es igual a un elemento de coll.

boolean retenciónAll(Collection coll) retiene sólo aquellos elementos que también están en

colear; devuelve verdadero si se eliminó algún elemento.

int size() devuelve el número de elementos de la colección.

Object[] toArray() devuelve una matriz de todos los elementos de la colección.

Object[] toArray(Object[] a) funciona como el anterior, pero el tipo de elemento de la matriz es el de a.

Los elementos de una colección y las claves y valores de un mapa deben ser objetos o matrices. Para elementos de tipo primitivo, como int, utilice una clase contenedora como Integer (sección 5.1).

Cuando se inserta un elemento de clase C en una colección, se convierte al tipo Objeto, y cuando se extrae nuevamente, (generalmente) se vuelve a convertir al tipo C. Estas conversiones se verifican solo en tiempo de ejecución, no por el compilador. por lo tanto, los programas que utilizan colecciones se escriben esencialmente de forma dinámica: el compilador de Java no le impedirá agregar una cadena a un conjunto de objetos enteros. Por esta razón, se recomienda documentar los tipos de elementos de colección previstos mediante comentarios del programa y utilizar conversiones explícitas (sección 11.12) siempre que se extraiga un elemento de una colección o mapa.

Una vista de una colección co1 es otra colección co2 que hace referencia a la misma estructura de datos subyacente. Como consecuencia, las modificaciones de co1 afectan al co2 y las modificaciones del co2 afectan al co1.

Una colección no modificable no admite modificación: las operaciones agregar, borrar, eliminar, establecer, etc. arrojan UnsupportedOperationException. La clase de utilidad Colecciones (sección 20.9) proporciona métodos estáticos para crear una vista no modificable de una colección determinada.

Una colección sincronizada es segura para subprocesos: varios subprocesos simultáneos pueden acceder a ella y modificarla de forma segura. Por motivos de eficiencia, las clases de colección estándar no están sincronizadas, por lo que la modificación simultánea de una colección puede hacer que su estado interno sea inconsistente. La clase de utilidad Colecciones (sección 20.9) proporciona métodos estáticos para crear una vista sincronizada de una colección determinada. Todo acceso simultáneo a una colección debe pasar por su vista sincronizada. Un iterador (sección 20.7) obtenido de una colección sincronizada no proporciona automáticamente una iteración sincronizada; se debe usar sincronizado (coll) {...} para garantizar explícitamente el acceso exclusivo a la colección durante la ejecución del bloque {...} que realiza la iteración.





La interfaz List y las implementaciones LinkedList y ArrayList

La interfaz Lista amplía la interfaz Colección con operaciones para acceso basado en posición usando índices 0,1,2,... y proporciona especificaciones más precisas de algunos métodos:

void add(int i, Object o) agrega el elemento o en la posición i, aumentando el índice de cualquier

elemento a la derecha por 1. Lanza IndexOutOfBoundsException si i<0 o i>size ().

boolean addAll(int i, Collection coll) agrega todos los elementos de coll a la lista,

comenzando en la posición i; devuelve verdadero si se agregó algún elemento. Lanza IndexOutOfBoundsException si i<0 o i>size().



booleano igual (Objeto o) devuelve verdadero si o es una Lista con elementos iguales en el mismo orden.

El objeto get(int i) devuelve el elemento en la posición i; lanza IndexOutOfBoundsException si i<0 o i>=size().

int hashCode() devuelve el código hash de la lista, que es una función de los códigos hash de

los elementos y su orden en la lista.

int indexOf(Object o) devuelve el menor índice i para el cual el elemento en la posición i

es igual a o; devuelve —1 si la lista no contiene dicho elemento.

int lastIndexOf(Object o) devuelve el mayor índice i para el cual el elemento en

la posición i es igual a o; devuelve —1 si la lista no contiene dicho elemento.

ListIterator listIterator() devuelve un iterador de lista, que es un iterador bidireccional.

Object remove(int i) elimina el elemento en la posición i y lo devuelve; lanza IndexOutOfBoundsException si i<0 o i>=size().

Conjunto de objetos (int i, Objeto o) establece el elemento en la posición i a o y devuelve el

elemento previamente en la posición i; lanza IndexOutOfBoundsException si i<0 o i>=size ().

List subList(int from, int to) devuelve una lista de los elementos en posiciones desde...(a-1), como una vista de la lista subyacente. Lanza IndexOutOfBoundsException si es de <0 o de> ao a>tamaño().

La clase LinkedList implementa todas las operaciones descritas por la interfaz List y tiene lo siguiente

constructores. La implementación es una lista doblemente enlazada, por lo que se puede acceder, agregar y eliminar elementos de manera eficiente en cualquier extremo de la lista. Por lo tanto, proporciona métodos adicionales para obtener, agregar y eliminar basados en la posición llamados addFirst, addLast, getFirst, getLast, removeFirst y removeLast. Los últimos cuatro arrojan NoSuchElementException si la lista está vacía.

LinkedList() crea una nueva LinkedList vacía.

LinkedList(Collection coll) crea una nueva LinkedList de los elementos proporcionados por

iterador de coll.

La clase ArrayList implementa todas las operaciones descritas por la interfaz List y tiene los siguientes constructores. La implementación utiliza una matriz subyacente (ampliada según sea necesario para contener los elementos), que permite un acceso eficiente basado en la posición en cualquier lugar de la lista. La clase ArrayList implementa la interfaz RandomAccess solo para indicar que se garantiza que el acceso a los elementos por índice será rápido, a diferencia de LinkedList. La clase ArrayList proporciona toda la funcionalidad proporcionada originalmente por la clase Vector (que es una subclase de AbstractList e implementa List y RandomAccess).

ArrayList() crea una nueva lista vacía.

ArrayList(Collection coll) crea una nueva ArrayList de los elementos proporcionados por

iterador de coll.



La interfaz Set y las implementaciones HashSet y LinkedHashSet

La interfaz Set describe los mismos métodos que la interfaz Collection. Los métodos add y addAll deben asegurarse de que un conjunto no contenga duplicados: no hay dos elementos iguales y como máximo un elemento nulo. Además, los métodos equals y hashCode tienen especificaciones más precisas para los objetos Set:

booleano igual (Objeto o) devuelve verdadero si o es un conjunto con el mismo número de elementos y cada elemento de o también está en este conjunto.

int hashCode() devuelve el código hash del conjunto: la suma de los códigos hash de sus elementos no nulos.

Para los argumentos de conjunto, addAll calcula la unión del conjunto, containsAll calcula la inclusión del conjunto, removeAll

calcula la diferencia de conjuntos y retenerTodo calcula la intersección de conjuntos (ejemplo 97).

La clase HashSet implementa la interfaz Set y tiene los siguientes constructores. Las operaciones en un Hash-Set se basan en los métodos iguales y hashCode de los objetos elemento.

HashSet() crea un conjunto vacío.

HashSet(Collection coll) crea un conjunto que contiene los elementos de coll, sin duplicados.



La clase LinkedHashSet es una subclase de HashSet y funciona de la misma manera, pero además garantiza que su iterador atraviesa los elementos en orden de inserción (en lugar del orden impredecible proporcionado por HashSet). Fue introducido en Java 2, versión 1.4.





La interfaz SortedSet y la implementación TreeSet

La interfaz SortedSet amplía la interfaz Set. Las operaciones en un SortedSet se basan en el orden natural de los elementos definidos por su método compareTo, o en un objeto Comparador explícito proporcionado cuando se creó el conjunto (sección 20.8), como para TreeSet a continuación.

Comparator comparador() devuelve el comparador asociado con este conjunto ordenado, o

nulo si utiliza el orden natural (sección 20.8) de los elementos.

El objeto primero() devuelve el menor elemento; lanza NoSuchElementException si el conjunto está vacío.

SortedSet headSet(Objeto a) devuelve el conjunto de todos los elementos estrictamente menores que a. El conjunto resultante es una vista del conjunto subyacente.

El objeto last() devuelve el elemento más grande; lanza NoSuchElementException si el conjunto está vacío.

SortedSet subSet(Objeto de, Objeto a) devuelve el conjunto de todos los elementos mayores o iguales a desde y estrictamente menores que a. El conjunto resultante es una vista del conjunto subyacente.

SortedSet tailSet(Objeto de) devuelve el conjunto de todos los elementos mayores o iguales a desde. El conjunto resultante es una vista del conjunto subyacente.

La clase TreeSet implementa la interfaz SortedSet y tiene los siguientes constructores. La implementación utiliza árboles binarios equilibrados, por lo que se garantiza que todas las operaciones serán eficientes.

TreeSet() crea un conjunto vacío y ordena los elementos utilizando su método compareTo.

TreeSet(Collection coll) crea un conjunto que contiene los elementos de coll, sin duplicados, ordenando los elementos usando su método compareTo.

TreeSet(Comparator cmp) crea un conjunto vacío y ordena elementos usando cmp.

TreeSet(SortedSet s) crea un conjunto que contiene los elementos de s, ordenando los elementos como en s.



La interfaz del mapa y la implementación de HashMap

La interfaz del Mapa describe los siguientes métodos. Un mapa puede considerarse una colección de entradas, donde una entrada es un par (k, v) de una clave k y un valor v, los cuales deben ser objetos o matrices. Por lo tanto, para utilizar valores de tipo primitivo, como int, como claves o valores, se debe utilizar la clase contenedora correspondiente, como Integer (sección 5.1). Un mapa no puede contener dos entradas con la misma clave.

void clear() elimina todas las entradas de este mapa.

boolean containsKey(Object k) devuelve verdadero si el mapa tiene una entrada con la clave k.

boolean containsValue(Object v) devuelve verdadero si el mapa tiene unn entrada con valor v.

Set EntrySet() devuelve una vista establecida de las entradas del mapa; cada entrada tiene tipo Map.Entry

(vea abajo).

booleano igual a (Objeto o) devuelve verdadero si o es un mapa con el mismo conjunto de entradas.

Object get(Object k) devuelve el valor v en la entrada (k, v) con la clave k, si corresponde; de lo contrario nulo.

int hashCode() devuelve el código hash del mapa, calculado como la suma de los códigos hash de las entradas devueltas por EntrySet().

boolean isEmpty() devuelve verdadero si este mapa no contiene entradas, es decir, size() es cero.

Set keySet() devuelve una vista establecida de las claves en el mapa.

Object put(Object k, Object v) modifica el mapa para que contenga la entrada (k, v); devuelve el valor previamente asociado con la clave k, si corresponde; de lo contrario devuelve nulo.

void putAll(Mapa mapa) copia todas las entradas del mapa a este mapa.

Object remove(Object k) elimina la entrada de la clave k del mapa, si corresponde; devuelve el valor previamente asociado con k, si lo hubiera; de lo contrario devuelve nulo.

int size() devuelve el número de entradas, que es igual al número de claves, en el mapa.

Valores de colección() devuelve una vista de colección de los valores en el mapa. La interfaz Map.Entry (ejemplo 92) describe operaciones en las entradas del mapa:

El objeto getKey() devuelve la clave en esta entrada.



El objeto getValue() devuelve el valor de esta entrada.

La clase HashMap implementa la interfaz Map y tiene los siguientes constructores. Las operaciones en un HashMap se basan en los métodos iguales y hashCode de los objetos clave.

HashMap() crea un HashMap vacío.

HashMap (mapa de mapa) crea un HashMap que contiene el mapa de entradas.

La clase LinkedHashMap es una subclase de HashMap y funciona de la misma manera, pero además garantiza que su iterador recorra las entradas en el orden de inserción de claves (en lugar del orden impredecible proporcionado por HashMap). Fue introducido en Java 2, versión 1.4.

La clase IdentityHashMap implementa la interfaz Map pero compara claves usando igualdad de referencia (==) en lugar del método igual. Fue introducido en Java 2, versión 1.4.



La interfaz SortedMap y la implementación de TreeMap

La interfaz SortedMap amplía la interfaz Map. Las operaciones en un SortedMap se basan en el orden natural de las claves definidas por su método compareTo o en un objeto Comparador explícito proporcionado cuando se creó el mapa (sección 20.8), como para TreeMap a continuación.

Comparator comparador() devuelve el comparador asociado con este mapa ordenado, o

nulo si utiliza el orden natural (sección 20.8) de las claves.

El objeto firstKey() devuelve la menor clave en este mapa ordenado; lanza NoSuchElementException si el mapa está vacío.

SortedMap headMap(Objeto a) devuelve el mapa ordenado de todas las entradas cuyas claves son estrictamente menores que a. El mapa resultante es una vista del mapa subyacente.

El objeto lastKey() devuelve la clave más grande en este mapa ordenado; lanza NoSuchElementException si el mapa está vacío.

SortedMap subMap(Object from, Object to) devuelve el mapa ordenado de todas las entradas cuyas claves son mayores o iguales que from y estrictamente menores que to. El mapa resultante es una vista del mapa subyacente.

SortedMap tailMap(Object from) devuelve el mapa ordenado de todas las entradas cuyas claves son mayores o iguales que from. El mapa resultante es una vista del mapa subyacente.

La clase TreeMap implementa la interfaz SortedMap y tiene los siguientes constructores. La implementación utiliza árboles binarios ordenados equilibrados, por lo que se garantiza que todas las operaciones serán eficientes.

TreeMap() crea un mapa vacío y ordena las entradas utilizando el método compareTo de las claves.

TreeMap(Mapa mapa) crea un mapa que contiene las entradas del mapa, ordenando las entradas usando el

método compareTo de las claves.

TreeMap(Comparator cmp) crea un mapa vacío y ordena las entradas usando cmp en las claves.

TreeMap(SortedMap s) crea un mapa que contiene las entradas de s, ordenando las entradas como en

s.

Ejemplo 89: Construyendo una concordancia

Este método lee palabras (tokens alfanuméricos) de un archivo de texto y crea una concordancia, que muestra para cada palabra los números de línea de sus apariciones. El índice de concordancia resultante es un SortedMap de String a SortedSet of Integer.

static SortedMap buildIndex (nombre de archivo de cadena) lanza IOException { Reader r = new BufferedReader (new FileReader (nombre de archivo)); StreamTokenizer stok = nuevo StreamTokenizer(r); stok.quoteChar('"'); stok.ordinaryChars('!', '/');

stok.nextToken();



Índice de SortedMap = nuevo TreeMap(); // Asignar de cadena a conjunto de enteros while (stok.ttype != StreamTokenizer.TT_EOF) {



if (stok.ttype == StreamTokenizer.TT_WORD) { SortedSet ts;

if (index.containsKey(stok.sval)) // Si la palabra tiene un conjunto, obtenlo ts = (SortedSet)index.get(stok.sval);

demás {



ts = nuevo TreeSet(); // De lo contrario, crea uno index.put(stok.sval, ts);

}



ts.add(new Integer(stok.lineno()));



}



stok.nextToken();



}



índice de retorno;



}





Ejemplo 90: Almacenamiento del resultado de una consulta de base de datos

Este método ejecuta una consulta a la base de datos, utilizando clases del paquete java.sql. Devuelve el resultado de la consulta como ArrayList con un elemento por cada fila del resultado. Cada fila se almacena como un HashMap, asignando un resultado fnombre de campo a un objeto (por ejemplo, un número entero o una cadena) que contiene el valor de ese campo en esa fila. Esta es una forma sencilla y útil de separar la consulta de la base de datos del procesamiento del resultado de la consulta (pero puede resultar demasiado ineficaz si el resultado de la consulta es muy grande).



ArrayList estático getRows (conexión de conexión, consulta de cadena) lanza SQLException {

Declaración stmt = conn.createStatement(); ResultSet rset = stmt.executeQuery(consulta); ResultSetMetaData rsmd = rset.getMetaData(); int recuento de columnas = rsmd.getColumnCount();

ArrayList queryResult = nuevo ArrayList(); // Lista de mapas de cadena a objeto while (rset.next()) {

Fila del mapa = nuevo HashMap();

for (int i=1; i<=columncount; i++) row.put(rsmd.getColumnName(i), rset.getObject(i)); queryResult.add(fila);

}

devolver resultado de la consulta;

}



Pasando por una colección: iterador

La interfaz Iterator proporciona una forma estandarizada de revisar los elementos de las colecciones. Un iterador normalmente se crea y utiliza como se muestra en el ejemplo 91. El cuerpo del bucle while no debe modificar el iterador ni la colección subyacente; si es así, el resultado es impredecible. De hecho, las clases concretas ArrayList, LinkedList, HashMap, HashSet, TreeMap y TreeSet producen iteradores rápidos: si la colección subyacente se modifica estructuralmente (excepto mediante el método remove del iterador) después de que se ha obtenido un iterador, entonces se genera una excepción ConcurrentModificationException. arrojado. La interfaz Iterator describe los siguientes métodos:

Ejemplo 91: iteración sobre una colección

Este método imprime los elementos de la colección dada; se llama en el ejemplo 88. Esta es la forma prototípica de iterar sobre una colección. La declaración de elem y el tipo emitido inmediatamente dentro del bucle while muestra que esperamos que los elementos de la colección tengan la clase String.



recorrido vacío estático (coll de colección) { Iterador iter = coll.iterator();

mientras (iter.hasNext()) {



Elemento de cadena = (Cadena)iter.next(); System.out.print(elem + " ");

}



Sistema.out.println();



}





boolean hasNext() devuelve verdadero si una llamada a next() devolverá un nuevo elemento.

Object next() devuelve el siguiente elemento y avanza más allá de ese elemento, si lo hay; lanza NoSuchElementException si no hay ningún elemento siguiente.

void remove() elimina el último elemento devuelto por el iterador; Lanza IllegalStateException si el iterador aún no ha devuelto ningún elemento o si el elemento ya se ha eliminado. Lanza UnsupportedOperationException si no se admite la eliminación.

Un iterador obtenido de una Lista recorrerá los elementos en el orden de la lista. Un iterador obtenido de SortedSet, o de las claves o valores de un SortedMap, recorrerá los elementos en el orden de los elementos del conjunto o de las claves del mapa. Un iterador obtenido de un HashSet recorrerá los elementos en un orden impredecible. Un iterador proporciona toda la funcionalidad proporcionada originalmente por la interfaz de enumeración, pero tiene nombres de método diferentes (más cortos).





Códigos de igualdad, comparación y hash

Los elementos de una colección deben tener el método igual. Si los elementos tienen un método hashCode, se pueden utilizar como elementos HashSet o claves HashMap. Si tienen el método compareTo descrito por la interfaz java.lang.Comparable, se pueden utilizar como elementos TreeSet o claves TreeMap. Las clases contenedoras de tipo primitivo (sección 5.1) y la clase String tienen métodos iguales, hashCode y compareTo.

booleano igual (Objeto o) determina la igualdad de dos objetos. Lo utilizan ArrayList, LinkedList, HashSet y HashMap. Debería satisfacer o.equals(o); si o1.equals(o2), entonces también o2.equals(o1); y si o1.equals(o2) y o2.equals(o3), entonces también o1.equals(o3) para o1, o2 y o3 no nulos.

int hashCode() devuelve el código hash de un objeto. Es utilizado por HashSet y HashMap. Debería satisfacer que si o1.equals(o2), entonces o1.hashCode () ==o2.hashCode().

int compareTo(Object o), descrito por la interfaz Comparable, realiza una comparación de tres vías de dos objetos: o1.compareTo(o2) es negativo si o1 es menor que o2, cero si o1 y o2 son iguales, y positivo si o1 es mayor que o2. se llama natural



ordenamiento de elementos y lo utilizan, por ejemplo, TreeSet y TreeMap, a menos que se haya proporcionado un Comparador cuando se creó el conjunto o mapa. Debe satisfacer que o01.compareTo(o2) ==0 siempre que o1.equals(o2).

int compare(Objeto o1, Objeto o2), descrito por la interfaz Comparador, realiza una comparación de tres vías de dos objetos: es negativo si o1 es menor que o2, cero si o1 y o2 son iguales, y positivo si o1 es mayor que o2. Se puede utilizar para definir ordenamientos de elementos no estándar al crear TreeSets y TreeMaps (ejemplo 95). Debe satisfacer que compare(o1, o2) ==0 siempre que o1.equals(o2).

Ejemplo 92: Impresión de una concordancia

Se supone que el índice del mapa es una concordancia creada en el ejemplo 89. El método imprime una lista alfabética de las palabras y, para cada palabra, sus números de línea. Se crea un iterador para recorrer las palabras y, para cada palabra, se crea un iterador independiente para recorrer las palabras.los números de línea.



static void printIndex(SortedMap index) { Iterador wordIter = index.entrySet().iterator(); mientras (palabraIter.hasNext()) {

Map.Entry entrada = (Map.Entry)wordIter.next(); System.out.print((String)entry.getKey() + ": "); SortedSet lineNoSet = (SortedSet)entry.getValue(); Iterador lineNoIter = lineNoSet.iterator();

mientras (lineNoIter.hasNext()) System.out.print((Integer)lineNoIter.next() + " "); Sistema.out.println();

} }





Ejemplo 93: Una clase que implementa comparable

Un objeto Hora representa la hora del día entre 00:00 y 23:59. La llamada al método t1.compareTo(t2) devuelve un número negativo si t1 es anterior a t2, un número positivo si t1 es posterior a t2 y cero si son al mismo tiempo. Los métodos compareTo, equals y hashCode satisfacen los requisitos de la sección 20.8.



clase Tiempo implementa Comparable {privado int hh, mm; // Reloj de 24 horas

Tiempo público (int hh, int mm) { this.hh = hh; esto.mm = mm; }







public int compareTo(Objeto o) { Tiempo t = (Tiempo)o;

devolver hh != t.hh ? hh - t.hh : mm - t.mm;



}







booleano público es igual (Objeto o) {



Tiempo t = (Tiempo)o;

return hh == t.hh && mm == t.mm;

}

public int hashCode() { return 60 * hh + mm; }

}



Las colecciones de clases de servicios públicos

Las colecciones de clases proporcionan métodos de utilidad estáticos. Los métodos binarioSearch, max, min y sort.

También tenemos versiones que toman un argumento Comparador adicional y lo usan para comparar elementos.

Existen métodos estáticos similares a sincronizadoList y unmodifiableList para crear una vista sincronizada o no modificable (sección 20.1) de una Colección, Conjunto, SortedSet, Mapa o SortedMap.

static int binarioSearch(List lst, Object k) devuelve un índice i>=0 para el cual lst.get(i) es igual a k, si corresponde; de lo contrario, devuelve i<0 de modo que (-i-1) sería la posición adecuada para k. Esto es rápido para ArrayList pero lento para LinkedList. La lista lista debe estar ordenada, como por clasificación (lst).

La copia vacía estática (List dst, List src) agrega todos los elementos de src a dst, en orden.

La enumeración de enumeración estática (coll de colección) devuelve una enumeración sobre coll.

relleno vacío estático (Lista lst, Objeto o) establece todos los elementos de lst en o.

static Object max(Collection coll) devuelve el mayor elemento de coll. Lanza NoSuchElementException si coll está vacío.

static Object min(Collection coll) devuelve el menor elemento de coll. Lanza NoSuchElementException si coll está vacío.

Lista estática nCopies(int n, Object o) devuelve una lista no modificable con n copias de

o.

static void reverse(List lst) invierte el orden de los elementos en lst.

static Comparator reverseOrder() devuelve un comparador que es el inverso del orden natural implementado por el método compareTo de elementos o claves.

static void shuffle (List lst) permuta aleatoriamente los elementos de lst.

static boolean replaceAl(List lst, Object o1, Object o2) reemplaza todos los elementos iguales a o1 por o2 en lst; devuelve verdadero si se reemplazó un elemento.

static void rotar (Lista lista, int d) gira la lista a la derecha en d posiciones, por lo que -1

gira una posición hacia la izquierda. Gira una sublista si se aplica a una vista de sublista (sección 20.2).

static void shuffle(List lst, Random rnd) permuta aleatoriamente los elementos de

Por último estoy usando rnd para generar números aleatorios.

static Set singleton(Object o) devuelve un conjunto no modificable que contiene solo o.

Lista estática singletonList(Object o) devuelve una lista no modificable que contiene solo o.

static Map singletonMap(Object k, Object v) devuelve un mapa no modificable que contiene solo la entrada (k, v).

Lista estática lista sincronizada (Lista lst) devuelve una vista sincronizada de lst.

static void sort(List lst) ordena lst usando mergesort y el ordenamiento natural de elementos. Esto es rápido en todas las listas.

static void swap(List lst, int i, int j) intercambia los elementos de la lista en las posiciones i y j. Lanza IndexOutOfBoundsException a menos que 0 <= i, j and i, j

< lst.tamaño().

Lista estática unmodifiableList(List lst) devuelve una vista no modificable de lst.

Ejemplo 94: Establecer prueba de membresía usando HashSet o búsqueda binaria

Imagine que queremos excluir los nombres reservados de Java (capítulo 2) de la concordancia creada en el ejemplo 89, por lo que necesitamos una forma rápida de reconocer dichos nombres. El método isKeyword1 usa un HashSet creado a partir de una matriz de 52 elementos de palabras clave Java, mientras que el método isKeyword2 usa una búsqueda binaria en la matriz ordenada. El HashSet es en este caso de dos a cinco veces más rápido.



clase Establecer membresía {



cadena estática final [] matriz de palabras clave =



{ "resumen", "afirmar", "booleano", "romper", "byte", ..., "mientras" };



palabras clave estáticas finales = new HashSet(Arrays.asList(keywordarray));







booleano estático esPalabraClave1 (ID de cadena)



{ return palabras clave.contiene(id); }







booleano estático isKeyword2 (ID de cadena)

{ return Arrays.binarySearch(keywordarray, id) >= 0; }

}





Ejemplo 95: un comparador de cadenas explícito

La concordancia producida en el ejemplo 89 utiliza el método compareTo integrado de String, que ordena todas las letras mayúsculas antes que todas las minúsculas. Por lo tanto, colocaría la cadena "Crear" antes de "agregar" antes de "crear". La clase Comparador declarada aquí es mejor porque ordena las cadenas para que aparezcan una al lado de la otra si difieren.ffer solo en caso de que: pondría "agregar" antes de "Crear" antes de "crear". Para usarlo en el ejemplo 89, el nuevo TreeMap() en ese ejemplo debe reemplazarse por el nuevo TreeMap(nuevo IgnoreCaseComparator()).



clase IgnoreCaseComparator implementa Comparador { public int comparar(Objeto o1, Objeto o2) {

Cadena sl = (Cadena)o1, s2 = (Cadena)o2; int res = s1.compareToIgnoreCase(s2); si (res! = 0)

devolver resolución; demás

devolver s1.compareTo(s2);



} }





Ejemplo 96: Obtención de un submapa

Una agenda es un mapa ordenado cuyas claves son objetos de tiempo (ejemplo 93). Podemos extraer esa parte de la agenda que se refiere a las horas a partir de las 12:00:00:



Agenda SortedMap = new TreeMap(); // Mapa de hora a cadena datebook.put(new Time(12, 30), "Almuerzo");

datebook.put(new Time(15, 30), "Pausa para el café de la tarde"); agenda.put(nueva Hora( 9, 0), "Conferencia"); datebook.put(new Time(13, 15), "Reunión de la junta directiva"); SortedMap pm = agenda.tailMap(nueva hora(12, 0)); Iterador iter = pm.entrySet().iterator();



mientras (iter.hasNext()) {



Map.Entry entrada = (Map.Entry)iter.next(); System.out.println((Time)entry.getKey() + " " + (String)entry.getValue());

}





Elegir la clase de colección o clase de mapa adecuada

La elección adecuada de una colección o clase de mapa depende de las operaciones que necesita realizar en ella y de la frecuencia de esas operaciones. No existe una mejor opción universal.

Se deben utilizar LinkedList (sección 20.2) o ArrayList (sección 20.2 y ejemplo 90) para recopilar elementos para iteración secuencial en orden de índice, permitiendo duplicados.

HashSet (sección 20.3 y ejemplo 94) y HashMap (sección 20.5 y ejemplo 90) son buenas opciones predeterminadas cuando se necesita acceso aleatorio por elemento o clave, y no se necesita acceso secuencial en orden de elementos o claves. LinkedHashSet y LinkedHashMap garantizan adicionalmente el acceso secuencial (utilizando sus iteradores) en el orden de inserción de elementos o claves.

TreeSet (sección 20.4 y ejemplo 89) o TreeMap (sección 20.6 y ejemplo 89) deben usarse para acceso aleatorio por elemento o clave, así como para iteración en orden de elemento o clave.

LinkedList, no ArrayList, debe usarse para algoritmos de listas de trabajo (ejemplo 97), colas, colas de doble extremo y pilas.

Ejemplo 97: un algoritmo de lista de trabajo

Algunos algoritmos utilizan la llamada lista de trabajo, que contiene subproblemas aún por resolver. Por ejemplo, dado un conjunto SS de conjuntos de enteros, calcule su cierre de intersección, es decir, el conjunto mínimo TT tal que SS sea un subconjunto de TT y tal que para dos conjuntos cualesquiera T1 y T2 en TT, su intersección T1 ⋂ T2 también está en TT. Por ejemplo, si SS es {{2,3},{1,3},{1,2}}, entonces TT es

{{2,3},{1,3},{1,2},{3},{2},{1},{}}.

El conjunto TT se puede calcular poniendo todos los elementos de SS en una lista de trabajo, luego seleccionando repetidamente un elemento S de la lista de trabajo, agregándolo a TT, y para cada conjunto T que ya está en TT, agregando la intersección de S y T a la lista de trabajo. si aún no está en TT. Cuando la lista de trabajo está vacía, TT está cerrada por la intersección.

El cierre épsilon de un estado de un autómata finito no determinista (NFA) se puede calcular utilizando el mismo enfoque; consulte el texto completo del programa subyacente al ejemplo 98.

estático Establecer intersecciónCerrar(Establecer SS) { Lista de trabajo LinkedList = nueva LinkedList(SS); Establecer TT = nuevo Hashset();

mientras (!lista de trabajo.isEmpty()) {

Establecer S = (Establecer)lista de trabajo.removeLast(); Iterador TTIter = TT.iterador();

mientras (TTIter.hasNext()) {

Establecer TS = nuevo TreeSet((Set)TTIter.next()); TS.retenerTodo(S); // Intersección de T y S if (!TT.contains(TS))

lista de trabajo.add(TS);

} TT.añadir(S);



}

volver TT;

}



ArrayList, no LinkedList, debe usarse para acceso aleatorio get(i) o set(i, o) por índice.

HashSet o HashMap deben usarse para conjuntos o mapas cuyos elementos o claves son colecciones, porque las clases de colección implementan métodos hashCode útiles (ejemplo 98).

Ejemplo 98: Uso de conjuntos como claves en un HashMap

El algoritmo estándar para convertir un autómata finito no determinista (NFA) en un autómata finito determinista (DFA) crea estados de autómata compuestos que son conjuntos de números enteros. Es preferible sustituir dichos estados compuestos por números enteros simples. Este método toma como argumento una colección de estados compuestos y devuelve un renombrador, que es un mapa de nombres de estados compuestos (Conjuntos de enteros) a nombres de estados simples (Enteros).

Mapa estático mkRenamer (estados de colección) { Renombrador del mapa = new HashMap();

Iterador iter = estados.iterador(); mientras (iter.hasNext()) {

Establecer k = (Establecer)iter.next();

renamer.put(k, nuevo entero(renamer.size()));

}

cambio de nombre de retorno;

}



Para mapas cuyas claves son pequeños enteros no negativos, utilice matrices ordinarias (capítulo 8).

El tiempo de ejecución o la complejidad temporal de una operación en una colección generalmente se da en notación O, como función del tamaño n de la colección. Así, O(1) significa tiempo constante, O(logn) significa tiempo logarítmico (tiempo proporcional al logaritmo de n) y O(n) significa tiempo lineal (tiempo proporcional a n). Para acceder, agregar o eliminar un elemento, estos corresponden aproximadamente a muy rápido, rápido y lento.

En la siguiente tabla, n es el número de elementos de la colección, i es un índice entero y d esla distancia desde un índice i hasta el extremo más cercano de una lista, es decir, min(i,n-i). Por lo tanto, agregar o eliminar un elemento de una LinkedList es rápido cerca de ambos extremos de la lista, donde d es pequeño, pero para una ArrayList es rápido solo cerca del final, donde n-i es pequeño. El subíndice a indica complejidad amortizada: en una larga secuencia de operaciones, el tiempo promedio por operación es O(1), aunque cualquier operación individual podría tomar un tiempo O(n).





Capítulo 21: Entrada y salida

Descripción general

La entrada y salida secuencial utiliza objetos llamados flujos. Hay dos tipos de flujos: flujos de caracteres y flujos de bytes, también llamados flujos de texto y flujos binarios. Los flujos de caracteres se utilizan para la entrada de archivos de texto y la salida legible por humanos a archivos de texto, impresoras, etc., utilizando caracteres Unicode de 16 bits. Los flujos de bytes se utilizan para la entrada y salida compacta y eficiente de datos primitivos (int, double, ...), así como de objetos y matrices, en formato legible por máquina.

Hay clases separadas para manejar flujos de caracteres y flujos de bytes. Las clases para la entrada y salida de caracteres se denominan Lectores y Escritores. Las clases para entrada y salida de bytes se denominan InputStreams y OutputStreams. Este capítulo describe la entrada y salida utilizando el paquete java.io. Java 2, versión 1.4, proporciona funciones adicionales en el paquete java.nio, que no se describen aquí.

Se pueden crear subclases de las clases de flujo, anulando los métodos heredados para obtener clases de flujo especializadas. No discutiremos más cómo hacerlo aquí.

Las cuatro jerarquías de clases de flujo se muestran en la siguiente tabla, y las clases de entrada y salida relacionadas se muestran en la misma línea. La tabla muestra, por ejemplo, que BufferedReader y FilterReader son subclases de Reader y que LineNumberReader es una subclase de BufferedReader. Las clases de resúmenes se muestran en cursiva.



Las clases DataInputStream, ObjectInputStream y RandomAccessFile implementan la interfaz Datalnput, y las clases DataOutputStream, ObjectOutputStream y RandomAccessFile implementan la interfaz DataOutput (sección 21.10).

La clase ObjectInputStream implementa la interfaz ObjectInput y la clase ObjectOutputStream implementa la interfaz ObjectOutput (sección 21.11).





Crear transmisiones a partir de otras transmisiones

Una secuencia se puede crear directamente (por ejemplo, se puede crear un FileInputStream y asociarlo con un archivo con nombre en el disco, para leerlo desde ese archivo) o se puede crear a partir de una secuencia existente para proporcionar funciones adicionales (por ejemplo, se puede crear un BufferedInputStream). creado en términos de FileInputStream, para una entrada más eficiente). En cualquier caso, un flujo de entrada o un lector tiene una fuente subyacente de datos para leer, y un flujo de salida o un escritor tiene un sumidero de datos subyacente para escribir. La siguiente figura muestra cómo se pueden definir los flujos en términos de flujos existentes o en términos de otros datos.

Las clases de flujo se dividen en dos líneas: flujos de caracteres (arriba) frente a flujos de bytes (abajo) y flujos de entrada (izquierda) frente a flujos de salida (derecha). Las flechas muestran qué secuencias se pueden crear a partir de otras secuencias. Por ejemplo, la flecha de InputStream a InputStreamReader muestra que se puede crear un InputStreamReader a partir de un InputStream. La flecha de Reader a BufferedReader muestra que se puede crear un BufferedReader a partir de un Reader. Dado que un InputStreamReader es un lector, se puede crear un BufferedReader a partir de un InputStream existente (como System.in) en dos pasos, como se muestra en el ejemplo 99. Por otro lado, no hay forma de crear un PipedOutputStream a partir de un archivo o un nombre de archivo; Se debe crear un PipedOutputStream directamente, o a partir de un PipedInputStream existente, y de manera similar para otras tuberías (sección 21.15).

Ejemplo 99: Un ejemplo completo de entrada y salida



importar java.io.*;



clase Ejemplo BásicoIO {



public static void main (String[] args) lanza IOException {



BufferedReader r = nuevo BufferedReader (nuevo InputStreamReader (System.in)); recuento int = 0;

Cadena s = r.readLine();

while (s != null && !s.equals ("")) { recuento++;

s = r.readLine();

}

System.out.println("Ingresó " + recuento + "líneas no vacías");

} }









Tipos de métodos de entrada y salida

La siguiente tabla resume las convenciones de nomenclatura para los métodos de las clases de entrada y salida, así como sus características principales, como su comportamiento al final del flujo.



Importaciones, excepciones, seguridad de subprocesos

Un programa que utiliza las clases de entrada y salida debe contener la declaración de importación import java.io.*;

La mayoría de las operaciones de entrada y salida pueden generar una excepción de la clase IOException o una de sus subclases, todas las cuales son excepciones verificadas (capítulo 14). Por lo tanto, un método que realiza entrada o salida debe hacerlo en un bloque try-catch (sección 12.6.6) o debe contener la declaración throws IOException (sección 9.8).

La implementación estándar de entrada-salida es segura para subprocesos: múltiples subprocesos simultáneos (capítulo 15) pueden leer o escribir de forma segura en el mismo flujo sin corromperlo. Sin embargo, la documentación de la biblioteca de clases Java no es explícita sobre este punto, por lo que probablementeDeberíamos evitar usar la misma secuencia de múltiples subprocesos o sincronizar explícitamente en la secuencia.

Ejemplo 100: Entrada-Salida: Doce ejemplos en uno



Este ejemplo ilustra la entrada y salida con archivos de texto legibles por humanos; entrada y salida de valores primitivos con archivos binarios; entrada y salida de arrays y objetos con archivos binarios; entrada y salida de valores primitivos con archivos binarios de acceso aleatorio; entrada y salida utilizando cadenas y buffers de cadenas; salida a salida estándar y error estándar; y entrada desde entrada estándar.

Aunque estos breves ejemplos no utilizan el almacenamiento en búfer, la entrada y salida de archivos, sockets, etc., deben utilizar el almacenamiento en búfer para mayor eficiencia (sección 21.12).



// Escribe números y palabras en el archivo "f.txt" en formato legible por humanos: PrintWriter pwr = new PrintWriter(new FileWriter("f.txt")); pwr.print(4711); pwr.print(' '); pwr.print("genial"); pwr.cerrar();

// Lee números y palabras del archivo de texto legible por humanos "f.txt": StreamTokenizer stok = new StreamTokenizer(new FileReader("f.txt")); int tok = stok.nextToken();

mientras (tok! = StreamTokenizer.TT_EOF)



{ System.out.println(stok.sval); tok = stok.nextToken (); }



// Escribe valores primitivos en un archivo binario "p.dat":



DataOutputStream dos = new DataOutputStream(new FileOutputStream("p.dat")); dos.writeInt(4711); dos.writeChar(' '); dos.writeUTF("genial"); dos.cerrar();

// Leer valores primitivos del archivo binario "p.dat":



DataInputStream dis = nuevo DataInputStream(nuevo FileInputStream("p.dat")); System.out.println(dis.readInt()+"|"+dis.readChar()+"|"+ dis.readUTF());

// Escribe un objeto o matriz en el archivo binario "o.dat":



ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("o.dat")); oos.writeObject(nuevo int[] { 2, 3, 5, 7, 11 }); oos.cerrar();

// Leer objetos o matrices del archivo binario "o.dat":



ObjectInputStream ois = new ObjectInputStream(new FileInputStream("o.dat")); int[] ia = (int[])(ois.readObject());



System.out.println(ia[0]+","+ia[1]+","+ia[2]+","+ia[3]+","+ia[4]);



// Lee y escribe partes del archivo "raf.dat" en orden arbitrario:



RandomAccessFile raf = new RandomAccessFile("raf.dat", "rw"); raf.writeDouble(3.1415); raf.writeInt(42);

raf.seek(0); System.out.println(raf.readDouble() + " " + raf.readInt());



// Lee desde un String s como si fuera un archivo de texto:



Lector r = nuevo StringReader("abc");



System.out.println("abc: " + (char)r.read() + (char)r.read() + (char)r.read());



// Escribe en un StringBuffer como si fuera un archivo de texto:



Escritor sw = nuevo StringWriter(); sw.write('d'); sw.write('e'); sw.write('f'); System.out.println(sw.toString());

// Escribe caracteres en salida estándar y error estándar:



System.out.println("salida estándar"); System.err.println("error estándar");



// Leer caracteres de la entrada estándar (el teclado):



System.out.print("Escriba algunos caracteres y presione Enter: ");



BufferedReader bisr = nuevo BufferedReader (nuevo InputStreamReader (System.in)); Respuesta de cadena = bisr.readLine();

System.out.println("Escribiste: '" + respuesta + "'");



// Lee un byte de la entrada estándar (el teclado):



System.out.print("Escriba un carácter y presione Enter: "); byte b = (byte)System.in.read();

System.out.println("El primer byte de su entrada es: " + b);





Entrada secuencial de caracteres: lectores

La clase abstracta Reader y sus subclases (todas con nombres que terminan en Reader) se utilizan para la entrada secuencial orientada a caracteres. Además de las clases que se muestran aquí, consulte BufferedReader (sección 21.12) y LineNumber-Reader (ejemplo 105). La clase Reader tiene los siguientes métodos:

void close() vacía y cierra la secuencia y cualquier secuencia subyacente. Cualquier operación posterior, excepto cerrar, generará IOException.

void mark(int limt) marca la posición de entrada actual, permitiendo al menos limt

caracteres que se leerán antes de llamar a restablecer.

boolean markSupported() es verdadero si el lector admite la configuración de marcas y el restablecimiento a la última marca.

int read() lee un carácter (con código 0... 65535) y lo devuelve. Se bloquea hasta que la entrada esté disponible, o se alcance el final de la secuencia (y luego devuelva -1), o se produzca un error (y luego genere IOException).



int read(char[] b) lee como máximo caracteres b.length en b y devuelve el número de caracteres leídos. Devuelve inmediatamente si b.length es 0; de lo contrario, se bloquea hasta que al menos un carácter esté disponible; devuelve -1 al final de la transmisión.

int read(char[] b, int i, int n) funciona como el anterior, pero se lee en buf[i..(i+n-1)]. Lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.

boolean ready() devuelve verdadero si la siguiente lectura u omisión no se bloquea.

void reset() restablece la secuencia a la posición de la última llamada a marcar.

int skip (int n) omite como máximo n caracteres y devuelve el número de caracteres omitidos; devuelve 0 al final de la transmisión.



Lectura de caracteres de una secuencia de bytes: InputStreamReader

Un InputStreamReader es un lector (un flujo de entrada de caracteres) que lee un flujo de entrada de bytes y ensambla bytes en caracteres mediante una codificación de caracteres. Realiza una entrada almacenada en búfer desde el flujo subyacente. Un InputStreamReader tiene la sAlgunos métodos como Lector (sección 21.4), y también este constructor y método:

InputStreamReader(InputStream is) crea un flujo de entrada de caracteres (un lector) a partir del flujo de entrada de bytes, utilizando la codificación de caracteres estándar de la plataforma.

String getEncoding() devuelve el nombre canónico de la codificación de caracteres utilizada por este InputStreamReader, por ejemplo, "IS08859_1" o "Cp1252".



Entrada secuencial de caracteres desde un archivo: FileReader

Un FileReader es un flujo de entrada de caracteres almacenado en búfer asociado con un archivo (secuencial) y equivalente a un InputStreamReader creado a partir de un FileInputStream. Tiene los mismos métodos que InputStreamReader y estos constructores:

FileReader (nombre de cadena) crea un flujo de entrada de caracteres asociado con el archivo nombrado en el sistema de archivos. Lanza FileNotFoundException si el archivo nombrado no existe, es un directorio o no se puede abrir por algún otro motivo.

FileReader (archivo de archivo) crea una secuencia de entrada de caracteres a partir del archivo dado en el sistema de archivos.

FileReader (FileDescriptor fd) crea un flujo de entrada de caracteres a partir del descriptor de archivo.





Salida de caracteres secuenciales: escritores

La clase abstracta Writer y sus subclases (todas con nombres que terminan en Writer) se utilizan para salida secuencial orientada a caracteres. Tienen los siguientes métodos:

void close() vacía y cierra la secuencia.

void Flush() en realidad escribe datos en la secuencia o archivo subyacente y luego los vacía.

escritura vacía (char[] b) escribe el contenido de la matriz de caracteres b.

escritura vacía (char[] b, int i, int n) escribe n caracteres desde b comenzando en la posición

i; lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.

void write (int c) escribe un solo carácter, es decir, los dos bytes de orden inferior de c.

escritura nula (String s) escribe la cadena s.

escritura nula (String s, int i, int n) escribe n caracteres desde s comenzando en la posición

i; lanza StringIndexOutOfBoundsException si i<0 o n<0 o i+n>s.length.

Escribir caracteres en una secuencia de bytes: OutputStreamWriter

Un OutputStreamWriter es un escritor (flujo de salida de caracteres) que escribe en un flujo de salida de bytes, convirtiendo caracteres en bytes mediante una codificación de caracteres. Realiza una salida almacenada en búfer al flujo subyacente. Un OutputStreamWriter tiene los mismos métodos que un Writer (sección 21.5), y además estos constructores y método:

OutputStreamWriter (OutputStream os) crea un OutputStream Writer que escribe en el sistema operativo de transmisión utilizando la codificación de caracteres predeterminada de la plataforma.

OutputStreamWriter (OutputStream os, String enc) crea un OutputStreamWriter que escribe en el sistema operativo de transmisión utilizando la codificación de caracteres especificada por enc.



String getEncoding() devuelve el nombre canónico de la codificación de caracteres utilizada por este OutputStreamWriter, por ejemplo, "IS08859_1" o "Cp1252".



Salida secuencial de caracteres a un archivo: FileWriter

Un FileWriter es un flujo de salida de caracteres almacenado en búfer asociado con un archivo (secuencial), equivalente a un OutputStreamWriter creado a partir de un FileOutputStream. Tiene los mismos métodos que OutputStreamWriter y estos constructores:

FileWriter (nombre de cadena) crea un flujo de salida de caracteres y lo asocia con el archivo nombrado en el sistema de archivos. Si el archivo existe, lo trunca; de lo contrario, intenta crear un nuevo archivo vacío. Lanza FileNotFoundException si el archivo nombrado es un directorio o no se puede abrir o crear por algún otro motivo.

FileWriter (archivo de cadena, anexo booleano) funciona como el método anterior, pero si agregar es verdadero, no trunca el archivo: en lugar de eso, la salida se agregará al contenido del archivo existente.

FileWriter (archivo) funciona como el método anterior, pero crea el escritor a partir del archivo.

FileWriter (FileDescriptor fd) funciona como el método anterior, pero crea el escritor a partir de fd.





Impresión de datos primitivos en una secuencia de caracteres: PrintWriter

La clase PrintWriter se utiliza para generar datos primitivos en archivos de texto en formato legible por humanos. A diferencia de los métodos de otros escritores, los de PrintWriter nunca arrojan IOException sino que establecen el estado de error. La clase PrintWriter tiene todos los métodos de Writer y además estos constructores y métodos:

PrintWriter(OutputStream os) crea un PrintWriter que imprime en el sistema operativo de transmisión, sin autoflush.

PrintWriter(OutputStream os, boolean flush) crea un PrintWriter que imprime en el sistema operativo de flujo de salida; si vaciar es verdadero, entonces vacía al escritor después de cada llamada a println.

PrintWriter(Writer wr) crea un PrintWriter que imprime en el escritor wr, sin autoflush.

PrintWriter(Writer wr, boolean flush) crea un PrintWriter que imprime en el escritor wr; si vaciar es verdadero, entonces vacía al escritor después de cada llamada a println.

boolean checkError() vacía la secuencia y luego devuelve verdadero si alguna vez ocurrió un error.

void print (boolean b) imprime el booleano b, es decir, verdadero o falso.

void print (char c) imprime el carácter c.

void print (char[] s) imprime los caracteres en s.

void print (doble d) imprime la doble d.

void print (float f) imprime el float f.

void print (int i) imprime el número entero i.

impresión vacía (largal) imprime el número entero largo l.

void print (Object obj) imprime el objeto usando obj.toString().

void print (String s) imprime la cadena s.

void println() imprime una sola nueva línea.

void println(e) funciona como print (e) seguido de println ().



Salida estándar: System.out y System.err son PrintStreams

El flujo de salida estándar System.out y el flujo de error estándar System.err son PrintStreams. PrintStream es una subclase de OutputStream pero además tiene métodos print y println para salida basada en caracteres, al igual que PrintWriter. Estos métodos convierten caracteres a bytes utilizando la codificación predeterminada; para usar otra codificación enc, escriba en su lugar en un PrintWriter creado por new PrintWriter(new OutputStreamWriter(System.out), enc). Los métodos de PrintStream nunca arrojan IOException, pero establecen el estado de error; utilice checkError() para probar el estado del error.



Formato de números para salida de caracteres: formato decimal

El diseño adecuado del texto impreso con PrintWriter requiere un control de formato detallado. El formato de los números se puede controlar utilizando la clase DecimalFormat del paquete java.text. La tabla de la página opuesta muestra algunos patrones de formato decimal y sus efectos.

Hay muchas otras funciones para formatear la salida de texto en el paquete java.text. A diferencia de lenguajes como C, C#, Fortran y Pascal, Java no tiene un mecanismo estándar para alinear números y palabras en columnas. Estos mecanismos producen el resultado deseado sólo con fuentes de paso fijo. En el ejemplo 103 se muestra un método sencillo para rellenar una cadena a la izquierda (para alineación a la derecha).

Ejemplo 101: Imprimir números en un archivo de texto

Simule 1000 tiradas de un dado e imprima el resultado en el archivo de texto dice.txt, 20 números por línea:

PrintWriter pw = nuevo PrintWriter(nuevo FileWriter("dice.txt")); para (int i=1; i<=1000; i++) {

int morir = (int)(1 + 6 * Math.random());

pw.print(morir); pw.print(' ');

si (yo % 20 == 0) pw.println();

}

pw.println();

pw.cerrar(); // Sin esto, el archivo de salida puede estar vacío





Ejemplo 102: Imprimir una tabla HTML

Este ejemplo genera una tabla de conversión de temperatura en HTML. La temperatura Fahrenheit f

corresponde a la temperatura Celsius c = 5•(f - 32)/9. El número de dígitos fraccionarios está controlado por un objeto DecimalFormat. La etiqueta HTML TABLE se utiliza para controlar la alineación de números en columnas.



PrintWriter pw = nuevo PrintWriter(nuevo FileWriter("temperatura.html"));

DecimalFormat ff = nuevo formato Decimal("#0"), cf = nuevo formato Decimal("0.0"); pw.println("<TABLE BORDER><TR><TH>Fahrenheit<TH>Celsius</TR>"); para (doble f=100; f<=400; f+=10) {

doble c = 5 * (f - 32) / 9;

pw.println("<TR ALIGN=RIGHT><TD>" + ff.format(f) + "<TD>" + cf.format(c));

}

pw.println("</TABLE>");

pw.cerrar(); // Sin esto, el archivo de salida puede estar vacío





Ejemplo 103: Imprimir una tabla de texto

Para imprimir una tabla de conversión en formato de texto en una fuente de paso fijo, reemplace la segunda llamada a pw.println en el ejemplo 102 por pw.println(padLeft(ff.format(f), 10) + padLeft(cf.format(c) , 10)), que utiliza el método padLeft del ejemplo 87 para alinear números a la derecha.



Algunos patrones de formato decimal y su efecto









Lectura de datos primitivos de una secuencia de caracteres: StreamTokenizer

Leer palabras y números de una secuencia de caracteres es más complicado que imprimirlos, por lo que no existe una contraparte de entrada de texto para PrintWriter. En su lugar, cree un StreamTokenizer desde un Reader.

Un StreamTokenizer recopila caracteres en tokens. Los caracteres se clasifican como espacios en blanco (que separan fichas), caracteres numéricos (que forman una ficha numérica), caracteres de palabras (que forman una ficha de palabra),



comillas (que delimitan un token de cadena), caracteres de comentario de final de línea (que inician un comentario que se extiende hasta el final de línea) o caracteres comunes (ninguno de los anteriores).

Se puede crear y configurar un StreamTokenizer utilizando este constructor y estos métodos y campos:

StreamTokenizer (Reader r) crea un StreamTokenizer que lee desde la secuencia r.

void commentChar (int ch) le dice al tokenizador que ch es un carácter de comentario de final de línea.

void eolIsSignificant (boolean b) le dice al tokenizador que considere la nueva línea como un token separado de tipo TT_EOL, no como un espacio en blanco, si b es verdadero.

void ordinariaChars (int c1, int c2) le dice al tokenizador que cualquier carácter en el rango c1..c2 (inclusive) es un carácter ordinario: un token de un solo carácter, con ttype establecido en el código del carácter.

void parseNumbers() le dice al tokenizador que reconozca tokens numéricos. Una ficha numérica es una "palabra" que comienza con un dígito decimal (0..9) o un punto decimal (.) o un signo menos (-), y que consta únicamente de estos tres tipos de caracteres, por lo que los números en notación científica 6.02 e23 no se reconocen. Un token numérico tiene el tipo TT_NUMBER.

void quoteChar(int ch) le dice al tokenizador que el carácter ch es un delimitador de cadena. Cuando se encuentra este carácter, ttype se establece en ch y sval se establece en el contenido de la cadena: los caracteres estrictamente entre ch y la siguiente aparición de ch, nueva línea o fin de secuencia.

void resetSyntax() hace que todos los caracteres sean normales; ver ordinarioChars.

void whitespaceChars (int c1, int c2) le dice al tokenizador que todos los caracteres en el rango c1..c2 (inclusive) también son espacios en blanco, es decir, separadores de tokens.

void wordChars (int c1, int c2) le dice al tokenizador que todos los caracteres en el rango

c1..c2 (inclusive) también son caracteres de palabras.

Class StreamTokenizer tiene estos métodos y campos para leer valores:

int lineno() devuelve el número de línea actual, contando desde 1.

int nextToken() lee el siguiente (o primer) token y devuelve su tipo.

double nval es el valor numérico del token numérico actual (cuando ttype es

TT_NÚMERO).

String sval es el valor de cadena del token de palabra actual (cuando ttype es TT_WORD), o el cuerpo de la cadena del token de cadena actual (cuando ttype es un carácter de comillas).

int ttype es el tipo de token actual. El tipo puede ser StreamTokenizer.TT_NUMBER, que indica un número, o StreamTokenizer.TT_WORD, que indica una palabra, o StreamTokenizer.TT_EOL, que indica una nueva línea, o StreamTokenizer.TT_EOF, que indica el final de la transmisión (no más tokens), o una cita. carácter, que indica una cadena (entre comillas), o cualquier otro carácter, que indica ese carácter como un token en sí mismo.

Si bien un StreamTokenizer es útil para leer archivos de texto bastante simples, los archivos de texto más estructurados deben leerse utilizando un lexer y analizador adecuado (consulte los libros de texto comunes para cursos de compilación) o bibliotecas de propósito especial (por ejemplo, para archivos XML o flujos XML).

Ejemplo 104: leer números de un archivo de texto

Se crea un stok StreamTokenizer a partir de un lector de archivos almacenado en búfer y se le indica que reconozca tokens numéricos. Los tokens se leen hasta el final del flujo y los tokens numéricos se suman, mientras que los tokens no numéricos se imprimen en la salida estándar. El almacenamiento en búfer es importante: hace que el programa sea más de 20 veces más rápido.



archivo de suma vacío estático (nombre de archivo de cadena) lanza IOException { Reader r = new BufferedReader (new FileReader (nombre de archivo)); StreamTokenizer stok = nuevo StreamTokenizer(r); stok.parseNumbers();

doble suma = 0; stok.nextToken() ;



mientras (stok.ttype != StreamTokenizer.TT_EOF) {



if (stok.ttype == StreamTokenizer.TT_NUMBER) suma += stok.nval;

demás



System.out.println("No número: " + stok.sval); stok.nextToken();

}



System.out.println("La suma del archivo es " + suma);



}





Ejemplo 105: Leer números de un archivo de texto, línea por línea

Se crea un stok StreamTokenizer a partir de un LineNumberReader y se le dice que reconozca tokens numéricos y nuevas líneas. Los tokens se leen hasta el final de la transmisión y la suma del número de tokens se calcula línea por línea. El número de línea está configurado para contar desde 1 (el valor predeterminado es 0). La clase LineNumberReader es una subclase de BufferedReader y, por lo tanto, ya está almacenada en el búfer. Usar un LineNumberReader es algo redundante, ya que el propio StreamTokenizer proporciona un método lineno().

líneas de suma vacías estáticas (nombre de archivo de cadena) lanza IOException {



LineNumberReader lnr = nuevo LineNumberReader (nuevo FileReader (nombre de archivo)); lnr.setLineNumber(1);

StreamTokenizer stok = nuevo StreamTokenizer(lnr); stok.parseNumbers();

stok.eolIsSignificant(verdadero); stok.nextToken();

while (stok.ttype != StreamTokenizer.TT_EOF) { int lineno = lnr.getLineNumber();

doble suma = 0;



mientras (stok.ttype! = StreamTokenizer.TT_EOL) {



if (stok.ttype == StreamTokenizer.TT_NUMBER) suma += stok.nval;

stok.nextToken();



}



System.out.println("La suma de la línea " + lineno + " es " + suma); stok.nextToken();

}



}



Entrada de bytes secuenciales: InputStream

La clase abstracta InputStream y sus subclases (cuyos nombres terminan en InputStream) se utilizan para la entrada secuencial orientada a bytes. Tienen los siguientes métodos:

int disponible() devuelve el número de bytes que se pueden leer u omitir sin bloquear.

void close() cierra la transmisión.

void mark(int limt) marca la posición de entrada actual, lo que permite leer al menos limt bytes antes de llamar a reset.

boolean markSupported() devuelve verdadero si la secuencia admite marcar y restablecer.

int read() lee un byte (0...255) y lo devuelve, bloqueándolo hasta que la entrada esté disponible; devuelve - 1 al final de la transmisión.

int read (byte[] b) lee como máximo b.length bytes en b, bloqueando hasta que haya al menos un byte disponible; luego devuelve el número de bytes realmente leídos. Devuelve -1 al final de la transmisión.

int read(byte[] b, int i, int n) lee como máximo n bytes en b en la posición i, bloqueando hasta que haya al menos un byte disponible y devuelve el número de bytes realmente leídos. Devuelve -1 al final de la transmisión. Lanza IndexOutOfBoundsException si i<0 o n<0 o

i+n>b. longitud.

void reset() reposiciona la secuencia a la posición en la que se llamó por última vez al método de marca.

long skip (long n) omite como máximo n bytes, se bloquea hasta que hay un byte disponible y devuelve el número de bytes realmente omitidos. Devuelve 0 si se alcanza el final de la secuencia antes de que la entrada esté disponible.

La entrada estándar System.in es un InputStream; para leer caracteres del mismo, cree un InputStreamReader usando el nuevo InputStreamReader (System.in); ver ejemplo 100.



Entrada secuencial de bytes desde archivo: FileInputStream

Un FileInputStream es un InputStream que lee secuencialmente desde un archivo existente en el sistema de archivos.em. Tiene los mismos métodos que InputStream (sección 21.8), y estos constructores y métodos adicionales:

FileInputStream (nombre de cadena) crea un flujo de entrada de bytes y lo asocia con el nombre del archivo en el sistema de archivos. Lanza FileNotFoundException si el archivo no existe, es un directorio o no se puede abrir.

FileInputStream (archivo) funciona como el anterior, pero asocia la secuencia con el archivo.

FileInputStream (FileDescriptor fd) funciona como el anterior, pero asocia la secuencia con fd.

FileDescriptor getFD() devuelve el descriptor de archivo asociado con esta secuencia.



Entrada binaria secuencial de datos primitivos: DataInputStream

La clase DataInputStream proporciona métodos para la entrada binaria secuencial independiente de la máquina de tipos primitivos de Java como int y double. La clase implementa la interfaz DataInput (sección 21.10) y además proporciona este constructor y método estático:

DataInputStream (InputStream es) crea un DataInputStream que lee desde la secuencia.

static String readUTF (DataInput di) lee una cadena codificada en Java UTF-8 de la secuencia di.

La clase DataInputStream también tiene un método readLine, que está en desuso. Para leer líneas de texto de un DataInputStream, cree un InputStreamReader (sección 21.4.1) a partir de él.





Salida de bytes secuenciales: OutputStream

La clase abstracta OutputStream y sus subclases (cuyos nombres terminan en OutputStream) se utilizan para salida secuencial orientada a bytes. Tiene los siguientes métodos:

void close() cierra el flujo de salida.

void flush() vacía el flujo de salida y fuerza que los bytes de salida almacenados en el búfer se escriban en el flujo o archivo subyacente, luego lo vacía.



escritura vacía (byte [] b) escribe b.length bytes de b en el flujo de salida.

escritura vacía (byte[] b, int i, int n) escribe n bytes desde b comenzando en el desplazamiento i en el flujo de salida. Lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.

void write (int b) escribe el byte b(0...255) en el flujo de salida.



Salida secuencial de bytes a un archivo: FileOutputStream

Un FileOutputStream es un OutputStream que escribe secuencialmente en un archivo en el sistema de archivos. Tiene los mismos métodos que OutputStream (sección 21.9) y estos constructores y un método adicional:

FileOutputStream (nombre de cadena) crea un flujo de salida de bytes y lo asocia con el archivo nombrado en el sistema de archivos. Si el archivo existe, lo trunca; de lo contrario, intenta crear el archivo. Lanza FileNotFoundException si el archivo es un directorio o no se puede abrir o crear por algún otro motivo.

FileOutputStream (nombre de cadena, anexo booleano) funciona como el anterior, pero si agregar es verdadero, no trunca el archivo: en su lugar, la salida se agregará al contenido del archivo existente.

FileOutputStream (archivo) funciona como el anterior, pero asocia la secuencia con el archivo.

FileOutputStream(FileDescriptor fd) funciona como el anterior, pero asocia la secuencia con fd.

FileDescriptor getFD() devuelve el descriptor de archivo asociado con esta secuencia.



Salida binaria secuencial de datos primitivos: DataOutputStream

La clase DataOutputStream proporciona métodos para la salida binaria secuencial independiente de la máquina de tipos primitivos de Java como int y double. La clase implementa la interfaz DataOutput (sección 21.10) y proporciona este constructor y método:

DataOutputStream (OutputStream os) crea un DataOutputStream que escribe en el sistema operativo de flujo.

int size() devuelve el número de bytes escritos en este DataOutputStream.



Entrada-Salida Binaria de Datos Primitivos: DataInput y DataOutput

Las interfaces DataInput y DataOutput describen operaciones para entrada y salida orientada a bytes de valores de tipo primitivo, como booleano, int y double. Por lo tanto, el método readInt() de DataInput es adecuado para leer números enteros escritos utilizando el método writeInt (int) de DataOutput. El formato de datos es independiente de la plataforma.

La interfaz DataInput describe los siguientes métodos. Los métodos de lectura y omisión se bloquean hasta que la cantidad requerida de bytes esté disponible y lanzan una excepción EOFException si se llega primero al final de la secuencia.

boolean readBoolean() lee un byte de entrada y devuelve verdadero si es distinto de cero, falso

de lo contrario.

byte readByte() lee un byte de entrada y devuelve un byte en el rango -128...127.

char readChar() lee dos bytes y devuelve un carácter en el rango 0...65535.

double readDouble() lee ocho bytes y devuelve un doble.

float readFloat() lee cuatro bytes y devuelve un flotante.

void readFully (byte[] b) lee exactamente b.length bytes en el búfer b.

void readFully (byte[] b, int i, int n) lee exactamente n bytes en b[i..(i+n- 1)].

int readInt() lee cuatro bytes y devuelve un número entero.

String readLine() lee una línea de caracteres de un byte en el rango 0...255 (no Unicode).

long readLong() lee ocho bytes y devuelve un número entero largo.

short readShort() lee dos bytes y devuelve un entero corto -32768...32676.

int readUnsignedByte() lee un byte y devuelve un número entero en el rango 0...255.

int readUnsignedShort() lee dos bytes y devuelve un número entero en el rango 0...65535.

Cadena readUTF() lee una cadena codificada utilizando el formato UTF-8 modificado de Java.

int skipBytes(int n) omite exactamente n bytes de datos y devuelve n.



La interfaz DataOutput describe los siguientes métodos. Tenga en cuenta que writeInt (i) escribe cuatro bytes que representan el entero Java i, mientras que write(i) escribe un byte que contiene los ocho bits de orden inferior de i.

void write(byte[] b) escribe todos los bytes de la matriz b.

void write(byte[] b, int i, int n) escribe n bytes de la matriz b[i..(i+n-1)].

void write(int v) escribe los ocho bits de orden inferior del byte v.

void writeBoolean(boolean v) escribe un byte: 1 si v es verdadero, en caso contrario 0.

void writeByte(int v) escribe el byte de orden inferior (ocho bits de orden inferior) del entero v.

void writeBytes(String s) escribe el byte de orden inferior de cada carácter en s (no Unicode).

void writeChar(int v) escribe dos bytes (de orden superior, de orden inferior) que representan v.

void writeChars(String s) escribe la cadena s, dos bytes por carácter.

void writeDouble (doble v) escribe ocho bytes que representan v.

void writeFloat(float v) escribe cuatro bytes que representan v.

void writeInt(int v) escribe cuatro bytes que representan v.

void writeLong (long v) escribe ocho bytes que representan v.

void writeShort(int v) escribe dos bytes que representan v.

void writeUTF(String s) escribe dos bytes de información de longitud (bytes), seguidos de la representación UTF-8 modificada por Java de cada carácter en la cadena s.

Ejemplo 106: Entrada y salida binaria de datos primitivos

El método writedata demuestra todas las formas de escribir datos primitivos en una secuencia DataOutput (una secuencia de clase DataInputStream o RandomAccessFile). De manera similar, el método readdata demuestra todas las formas de leer valores primitivos de una secuencia DataInput (una secuencia de clase DataOutputStream o RandomAccessFile). Los métodos se complementan entre sí, por lo que después de escribir una secuencia con writedata, se puede leer usando readdata.



public static void main (String[] args) lanza IOException {



DataOutputStream daos = new DataOutputStream(new FileOutputStream("tmpl.dat")); escribir datos (daos); daos.cerrar();

DataInputStream dais = new DataInputStream(new FileInputStream("tmp1.dat")); leerdatos(estrado);

RandomAccessFile raf = new RandomAccessFile("tmp2.dat", "rw"); escribir datos (raf); raf.seek(0); leerdatos(raf);

}



static void writedata (Salida de datos) lanza IOException {out.writeBoolean(true); // Escribe 1 byte

salida.writeByte(120); // Escribe 1 byte



out.writeBytes("foo"); // Escribe 3 bytes



out.writeBytes("fo"); // Escribe 2 bytes



out.writeChar('A'); // Escribe 2 bytes



out.writeChars("foo"); // Escribe 6 bytes



out.writeDouble(300.1); // Escribe 8 bytes



out.writeFloat(300.2F); // Escribe 4 bytes



salida.writeInt(1234); // Escribe 4 bytes.writeLong(12345L); // Escribe 8 bytes

out.writeShort(32000); // Escribe 2 bytes



out.writeUTF("foo"); // Escribe 2 + 3 bytes

out.writeUTF("Ródano"); // Escribe 2 + 6 bytes out.writeByte(-1); // Escribe 1 byte

out.writeShort(-1); // Escribe 2 bytes

}

datos de lectura vacíos estáticos (entrada de datos) lanza IOException { byte[] buf1 = nuevo byte[3];

System.out.print( in.readBoolean()); // Leer 1 byte System.out.print(" " + in.readByte()); // Leer 1 byte in.readFully(buf1); // Leer 3 bytes

en.readFully(buf1, 0, 2); // Leer 2 bytes System.out.print(" " + in.readChar()); // Leer 2 bytes System.out.print(" " + in.readChar()+in.readChar()+in.readChar()); System.out.print(" " + in.readDouble()); // Leer 8 bytes System.out.print(" " + in.readFloat()); // Leer 4 bytes System.out.print(" " + in.readInt()); // Leer 4 bytes System.out.print(" " + in.readLong()); // Leer 8 bytes System.out.print(" " + in.readShort()); // Leer 2 bytes System.out.print(" " + in.readUTF()); // Leer 2 + 3 bytes System.out.print(" " + in.readUTF()); // Leer 2 + 6 bytes System.out.print(" " + in.readUnsignedByte()); // Leer 1 byte System.out.print(" " + in.readUnsignedShort()); // Leer 2 bytes System.out.println();

}



Serialización de objetos: ObjectInput y ObjectOutput

Las interfaces ObjectInput y ObjectOutput describen operaciones para entrada y salida orientada a bytes de valores de tipo de referencia, es decir, objetos y matrices. Esto también se llama serialización.

Un objeto o matriz se puede serializar (convertir en una secuencia de bytes) si su clase y todas las clases de las que depende el objeto o matriz se han declarado para implementar la interfaz Serializable. La interfaz Serializable no declara ningún método; sólo sirve para mostrar que la clase admite serialización.

Serialización de un objeto o escribe los campos no estáticos (instancia) del objeto, excepto aquellos declarados transitorios, en la secuencia. Cuando se deserializa el objeto, un campo transitorio obtiene el valor predeterminado para su tipo (falso o 0 o 0.0 o nulo). Los campos de clase (campos estáticos) no están serializados.

La serialización a un ObjectOutputStream preserva el intercambio entre los objetos escritos en él y, de manera más general, preserva la forma del gráfico de referencia del objeto. Por ejemplo, si los objetos o1 y o2 se refieren a un objeto común c (entonces o1.c == o2.c), y o1 y o2 están serializados en ObjectOutputStream oos, entonces el objeto c se serializa solo una vez en oos. Cuando o1 y o2 se restauran nuevamente desde oos, entonces c también se restaura, exactamente una vez, por lo que o1.c == o2.c se mantiene como antes. Si o1 y o2 se serializan en dos ObjectOutputStreams diferentes, entonces la restauración de o1 y o2 producirá dos copias distintas de c, por lo que o1.c ! = o2.c. Por lo tanto, el intercambio entre objetos no se conserva en múltiples ObjectOutputStreams. La interfaz ObjectInput tiene todos los métodos especificados por DataInput y los siguientes adicionales. La clase ObjectInputStream implementa ObjectInput. Los métodos disponibles(), close(), read(byte[]), read(byte[], int, int) y skip(int) se comportan como los de la clase InputStream (sección 21.8).

int disponible() devuelve el número de bytes que se pueden leer u omitir sin bloquear.

void close() cierra la transmisión, como en InputStream.

int read() lee un byte, como en InputStream.

int read(byte[] b) lee bytes en b, como en InputStream.

int read(byte[] b, int i, int n) lee en b[i..(i+n-1)], como en InputStream.



El objeto readObject() lee, deserializa y devuelve un objeto, que debe haber sido serializado previamente. Lanza ClassNotFoundException si no se puede encontrar la declaración (archivo de clase) de un objeto que se está deserializar. Lanza ObjectStreamException o una de sus subclases si no se puede leer ningún objeto de la secuencia, por ejemplo, si se encuentra el final de la secuencia antes de que se complete el objeto.

long skip (long n) salta n bytes, como en InputStream.

La interfaz ObjectOutput tiene todos los métodos de la interfaz DataOutput (sección 21.10) y la siguiente. La clase ObjectOutputStream implementa ObjectOutput.

void writeObject(Object obj) escribe el objeto mediante serialización. Todas las clases que se serializan deben implementar la interfaz Serializable; de lo contrario, se lanza NotSerializableException.

Interface Externalizable es una subinterfaz de Serializable que pueden implementar clases que necesitan control total sobre la serialización y deserialización de sus objetos.

Ejemplo 107: La serialización al mismo ObjectOutputStream conserva el uso compartido

Los objetos o1 y o2 se refieren a un objeto compartido c de clase SC. Serializamos o1 y o2 en el mismo archivo usando un único ObjectOutputStream, por lo que obtenemos una única copia del objeto compartido. Cuando deserializamos los objetos y los vinculamos a las variables o1i y o2i, también obtenemos una única copia del objeto SC compartido:



clase SC implementa Serializable { int ci; } clase SO implementa Serializable {

ent i; SCc;



SO(int i, SC c) { this.i = i; esto.c = c; }



void cprint() { System.out.print("i" + i + "c" + c.ci + " "); }



}



...



Archivo f = nuevo Archivo("objetos.dat");



// Crea los objetos y escríbelos en el archivo. SC c = nuevo SC();

SO o1 = nuevo SO(1, c), o2 = nuevo SO(2, c);



o1.c.ci = 3; o2.c.ci = 4; // Actualiza el c compartido dos veces o1.cprint(); o2.cprint(); // Imprime: i1c4 i2c4 OutputStream os = new FileOutputStream(f); ObjectOutputStream oos = nuevo ObjectOutputStream(os); oos.writeObject(o1); oos.writeobject(o2); oos.cerrar();

// Lee los objetos del archivo. InputStream es = nuevo FileInputStream(f);

ObjectInputStream ois = nuevo ObjectInputStream(es);



SO o1i = (SO)(ois.readObject()), o2i = (SO)(ois.readObject()); o1i.cprint(); o2i.cprint(); // Impresiones: i1c4 i2c4

o1i.c.ci = 5; o2i.c.ci = 6; //Actualiza la c compartida dos veces



o1i.cprint(); o2i.cprint(); // Impresiones: i1c6 i2c6





Ejemplo 108: La serialización en ObjectOutputStreams distintos no conserva el uso compartido

Si serializamos los objetos o1 y o2 del ejemplo 107 en el mismo archivo usando dos ObjectOutputStreams diferentes, cada flujo de objetos escribirá una copia del objeto compartido. Cuando deserializamos los objetos, obtenemos dos copias del objeto SC previamente compartido:



// Crea los objetos (como en el ejemplo anterior) y escríbelos en un archivo. ObjectOutputStream oos1 = nuevo ObjectOutputStream(os); oos1.writeObject(o1); oos1.flush();

ObjectOutputStream oos2 = nuevo ObjectOutputStream(os); oos2.writeObject(o2); oos2.cerrar();

// Lee los objetos del archivo, no compartido c. InputStream es = nuevo FileInputStream(f); ObjectInputStream ois1 = nuevo ObjectInputStream(es); SO o1i = (SO)(ois1.readObject());

ObjectInputStream ois2 = nuevo ObjectInputStream(es); Entonces o2i = (SO)(ois2.readObject());

o1i.cprint(); o2i.cprint(); // Impresiones: i1c4 i2c4



o1i.c.ci = 5; o2i.c.ci = 6; // Actualiza dos c diferentes o1i.cprint(); o2i.cprint(); // Impresiones: i1c5 i2c6

Entrada y salida almacenadas en búfer

Escribir un byte o carácter a la vez en un archivo o conexión de red es muy ineficiente. Es mejor recopilar los bytes o caracteres en un búfer y luego escribir todo el búfer en una sola operación. Lo mismo se aplica a la lectura de un archivo o una conexión de red. Sin embargo, el almacenamiento en búfer no acelerará la entrada y salida a matrices de bytes, matrices de caracteres, cadenas o búferes de cadenas.

Para almacenar en buffer un flujo de entrada simple, cree un BufferedInputStream desde is y lea desde ese flujo; y de manera similar para flujos de salida, lectores y escritores.

La operación flux() se puede utilizar en una secuencia almacenada en búfer para solicitar que la salida realmente se escriba.es a la corriente subyacente. Una secuencia almacenada en búfer debe cerrarse correctamente mediante una llamada a close() para garantizar que todos los datos escritos en el búfer finalmente se escriban en la secuencia subyacente.

La clase BufferedReader tiene todos los métodos de la clase Reader (sección 21.4) y estos constructores y métodos:

BufferedReader(Reader rd) crea un lector almacenado en búfer que lee desde rd.

BufferedReader(Reader rd, int sz) crea un lector almacenado en búfer con un búfer de tamaño sz.

Lanza IllegalArgumentException si sz <= 0.

String readLine() lee una línea de texto. Una línea termina con un avance de línea ("\n") o

retorno de carro ("\r") o retorno de carro y avance de línea ("\r\n"). Devuelve la línea sin ningún carácter de terminación de línea; devuelve nulo al final de la secuencia.

La clase BufferedWriter tiene todos los métodos de Writer (sección 21.5) y también estos constructores y métodos:

BufferedWriter (Writer wr) crea un escritor almacenado en búfer que escribe en la secuencia wr.



BufferedWriter (Writer wr, int sz) crea un escritor almacenado en búfer con un búfer de tamaño

talla Lanza IllegalArgumentException si sz <= 0.

void newLine() escribe un separador de línea, como "\n" o "\r\n", según la plataforma.

La clase BufferedInputStream es una subclase de FilterInputStream. Tiene los mismos métodos que InputStream (sección 21.8) y estos constructores:

BufferedInputStream(InputStream is) crea un BufferedInputStream que lee desde la secuencia.

BufferedInputStream(InputStream es, int sz) crea un BufferedInputStream

con tamaño de buffer sz; lanza IllegalArgumentException si sz <= 0.

La clase BufferedOutputStream es una subclase de FilterOutputStream. Tiene los mismos métodos que

OutputStream (sección 21.9) y estos constructores:

BufferedOutputStream (OutputStream os) crea un BufferedOutputStream que escribe en el sistema operativo de transmisión.

BufferedOutputStream (OutputStream os, int sz) crea un

BufferedOutputStream con un búfer de tamaño sz; lanza IllegalArgumentException si sz <= 0.

Ejemplo 109: Búfer de salida



El almacenamiento en búfer puede acelerar las escrituras en FileOutputStream en gran medida. Almacenar en búfer las escrituras en un FileWriter tiene menos efecto, porque un FileWriter es un OutputStreamWriter, que almacena en búfer los bytes convertidos a partir de caracteres escritos antes de escribirlos en un FileOutputStream subyacente. En un experimento, el almacenamiento en búfer hizo que las escrituras en FileOutputStream fueran 18 veces más rápidas y las escrituras en FileWriter solo dos o tres veces más rápidas.



public static void main(String[] args) lanza IOException { OutputStream os1 = new FileOutputStream("tmp1.dat"); writeints("Sin búfer: ", 1000000, os1);

OutputStream os2 = new BufferedOutputStream(new FileOutputStream("tmp2.dat")); writeints("En buffer: ", 1000000, os2);

Escritor wr1 = new FileWriter("tmp1.dat"); writeints("Sin búfer: ", 1000000, wr1);

Escritor wr2 = nuevo BufferedWriter(nuevo FileWriter("tmp2.dat")); writeints("Almacenado en buffer: ", 1000000, wr2);

}







escrituras vacías estáticas (mensaje de cadena, recuento int, sistema operativo OutputStream) lanza IOException {



Temporizador t = nuevo temporizador();

for (int i=0; i<count; i++) os.write(i & 255);

os. cerca();

System.out .println (msg + t.check());

}

escrituras vacías estáticas (mensaje de cadena, recuento int, sistema operativo del escritor) lanza IOException { Timer t = new Timer();

for (int i=0; i<count; i++) os.write(i & 255);



os.cerrar();

System.out.println(msg + t.check());

}





Para lograr eficiencia, normalmente se deben envolver flujos almacenados en búfer alrededor de flujos de archivos y flujos de socket de la siguiente manera:





Archivos de acceso aleatorio: RandomAccessFile

La clase RandomAccessFile se utiliza para la entrada y salida de los llamados archivos de acceso aleatorio. Se puede acceder a los datos de un archivo de acceso aleatorio en cualquier orden, a diferencia de los flujos, que sólo se pueden leer y escribir secuencialmente desde el principio. Por tanto, un archivo de acceso aleatorio es similar a una matriz de bytes extensible almacenada en el sistema de archivos. Un archivo de acceso aleatorio tiene un puntero de archivo asociado, que determina dónde comenzará la siguiente operación de lectura o escritura. Configurar el puntero del archivo permite el acceso aleatorio a todas las partes del archivo (aunque miles o millones de veces más lento que a una matriz de bytes almacenada en la memoria). El puntero del archivo está desplazado desde el principio del archivo; el primer byte del archivo tiene un desplazamiento 0, el último byte del archivo raf tiene un desplazamiento raf.length()-1. La llamada al método seek(pos) establece el puntero del archivo para que apunte al número de byte pos.

La clase RandomAccessFile implementa las interfaces DataInput y DataOutput (sección 21.10) y tiene los siguientes constructores y métodos adicionales. Los métodos read(), read(byte[]) y read (byte[], int, int) se comportan como en InputStream (sección 21.8); en particular, devuelven —1 al final-

del archivo y bloquear hasta que al menos un byte de entrada esté disponible. Los métodos readt() , donde t es un tipo,

comportarse como en DataInput (sección 21.10); en particular, lanzan EOFException al final del archivo.

RandomAccessFile (nombre de cadena, modo de cadena) crea una nueva secuencia de archivos de acceso aleatorio y la asocia con un archivo del nombre indicado en el sistema de archivos. Inicialmente, el puntero del archivo está en el desplazamiento 0. Lanza IOException si el nombre indica un directorio. El modo debe ser "r" para r.sólo lectura o "rw" para lectura y escritura; de lo contrario, se lanza IllegalArgumentException. Si el archivo no existe en el sistema de archivos y el modo es "r", entonces se lanza FileNotFoundException, pero si el modo es "rw", entonces se crea un nuevo archivo vacío si es posible. Si el modo es "r", cualquier llamada a los métodos de escritura generará IOException.

RandomAccessFile (archivo de archivo, modo cadena) funciona como el anterior, pero asocia la secuencia del archivo de acceso aleatorio con el archivo.

void close() cierra la secuencia del archivo.

FileDescriptor getFD() devuelve el descriptor de archivo asociado con la secuencia.

long getFilePointer() devuelve el valor actual del puntero del archivo.

long length() devuelve la longitud del archivo en bytes.

int read() lee un byte, como en InputStream.

int read (byte[] b) lee en la matriz b, como en InputStream.

int read(byte[] b, int i, int n) lee como máximo n bytes en b, como en InputStream.



void seek (pos larga) establece el puntero del archivo en el número de byte pos. Lanza IOException si

pos<0. El puntero del archivo se puede establecer más allá del final del archivo; una escritura posterior ampliará la longitud del archivo.

void setLength(long newlen) establece la longitud del archivo truncándolo o extendiéndolo (al final); en el caso de la extensión, el contenido de la extensión no está definido.

Ejemplo 110: Organización de un archivo de matriz de cadenas para acceso aleatorio



Este ejemplo muestra una manera de implementar el acceso aleatorio a una gran cantidad de textos, como millones de páginas web almacenadas en caché o millones de secuencias de ADN. Definimos un archivo de matriz de cadenas para que tenga tres partes: (1) una secuencia de cadenas, cada una de las cuales está en formato UTF-8 modificado por Java; (2) una secuencia de números enteros largos, que representan los desplazamientos iniciales de las cadenas; y (3) un número entero, que es el número de cadenas en el archivo. (Tenga en cuenta que Java limita la longitud de cada cadena codificada en UTF; usando una representación un poco más complicada en el archivo, podríamos eliminar esta restricción).



Al colocar el número de cadenas y la tabla de desplazamiento de cadenas al final del archivo en lugar de al principio, no necesitamos saber el número de cadenas o la longitud de cada cadena antes de escribir el archivo. Las cadenas se pueden escribir en el archivo de forma incremental y la única estructura que debemos mantener en la memoria es la tabla (ArrayList) de longitudes de cadenas.



static void writeStrings (nombre de archivo de cadena, iterador strIter) lanza IOException {

RandomAccessFile raf = nuevo RandomAccessFile(nombre de archivo, "rw"); raf.setLength(0); // Truncar el archivo ArrayList offsettable = new ArrayList(); // Contiene Longs while (strIter.hasNext()) {

offsettable.add(new Long(raf.getFilePointer())); // Almacenar el desplazamiento de la cadena raf.writeUTF( (String)strIter.next()); // Escribir cadena

}



Iterador iter = offsettable.iterator();



while (iter.hasNext()) // Escribir compensaciones de cadena raf.writeLong(((Long)iter.next()).longValue()); raf.writeInt(offsettable.size()); // Escribe el recuento de cadenas raf.close();

}





Ejemplo 111: Lecturas de acceso aleatorio desde un archivo de matriz de cadenas

La llamada al método readOneString (f, i) lee la cadena número i de un archivo de matriz de cadenas f (ejemplo 110) en tres etapas, utilizando tres llamadas para buscar. Primero, lee la longitud N de la tabla de desplazamiento de los últimos 4 bytes del archivo. En segundo lugar, dado que un int toma 4 bytes y un long toma 8 bytes (sección 5.1), la tabla de desplazamiento de cadena debe comenzar en la posición length()-4-8*N, por lo que el desplazamiento si del número de cadena i se puede leer desde longitud de posición()-4-8*N+8*i. En tercer lugar, la cadena en sí se lee desde el desplazamiento si.



cadena estática readOneString (nombre de archivo de cadena, int i) lanza IOException { final int INTSIZE = 4, LONGSIZE = 8;



RandomAccessFile raf = new RandomAccessFile(nombre de archivo, "r"); raf.seek(raf.length() - INTSIZE);

int N = raf.readInt();



raf.seek(raf.length() - INTSIZE - LONGSIZE * N + LONGSIZE * i); largo si = raf.readLong();

raf.seek(si);



Cadena s = raf.readUTF(); raf.cerrar();

devoluciones;



}



Archivos, directorios y descriptores de archivos

Nombres de ruta en un sistema de archivos: archivo de clase

Un objeto de clase Archivo representa un nombre de ruta, es decir, una ruta de directorio/archivo en el sistema de archivos. El nombre de la ruta puede indicar un directorio, un archivo de datos o nada en absoluto (si no existe ningún archivo o directorio con ese nombre). Incluso si el nombre de la ruta indica un archivo o directorio, un programa determinado puede carecer del permiso para leer o escribir ese archivo o directorio. Estos son algunos de los constructores y métodos de la clase Archivo:

El archivo (cadena pname) crea un nombre de ruta correspondiente a la cadena pname.

boolean existe() devuelve verdadero si existe un archivo o directorio indicado por este nombre de ruta.

String getName() devuelve el nombre de esta ruta como una cadena.

boolean isDirectory() prueba si el archivo indicado por este nombre de ruta es un directorio.

boolean isFile() prueba si el archivo indicado por este nombre de ruta es un archivo normal.

long length() devuelve la longitud del archivo en bytes, o 0 si el archivo no existe.

File[] listFiles() devuelve los archivos y directorios en el directorio indicado por el nombre de la ruta; devuelve nulo en caso de error o si el nombre de la ruta no indica un directorio.

boolean mkdir() crea el directorio nombrado por este nombre de ruta.



Archivo SyObjetos madre: clase FileDescriptor

Un objeto de clase FileDescriptor es un descriptor de archivo, una representación interna de un objeto del sistema de archivos activo, como un archivo abierto o un socket abierto. Se puede obtener un descriptor de archivo de FileInputStream (sección 21.8) o FileOutputStream (sección 21.9). La clase tiene este método:

void sync() solicita que todos los buffers del sistema estén sincronizados con los dispositivos físicos subyacentes; bloques hasta que esto se haya hecho. Lanza SyncFailedException si no se puede hacer.

La clase tiene campos estáticos in, out y err, que son los descriptores de archivos asociados con las secuencias de entrada estándar (System.in), salida estándar (System.out) y error estándar (System.err).





Comunicación de subprocesos: PipedInputStream y PipedOutputStream

Los subprocesos (capítulo 15) se ejecutan simultáneamente y pueden comunicarse de forma asincrónica mediante tuberías internas. Una tubería es un par de PipedInputStream y PipedOutputStream, o un par de PipedReader y PipedWriter. Por el contrario, la comunicación con otros procesos o con ordenadores remotos utiliza InputStreams y OutputStreams, posiblemente obtenidos de sockets del sistema operativo, descritos brevemente en la sección 21.16.



Para crear una tubería, cree un extremo con outpipe = new PipedOutputStream(), luego úselo para crear y conectar el otro extremo con inpipe = new PipedInputStream (outpipe). Cualquiera de los extremos puede crearse primero. Un extremo de tubo sólo se puede conectar una vez.

Un subproceso productor escribe en un PipedOutputStream (o PipedWriter) y un subproceso consumidor lee desde un PipedInputStream (o PipedReader) asociado con PipedOutputStream (o PipedWriter). Si el hilo del productor es rápido y la tubería se llena, entonces la siguiente operación de escritura se bloquea hasta que haya espacio para datos en la tubería. Si el subproceso del consumidor es rápido y no hay datos disponibles en la canalización, la siguiente operación de lectura se bloquea hasta que los datos estén disponibles. Cuando el consumidor o el productor muere y un extremo de la tubería se destruye, la siguiente escritura (o lectura) en el otro extremo de la tubería genera una IOException.

Ejemplo 112: Lectura e impresión de una jerarquía de directorios

La llamada showDir(0, nombre de ruta) imprimirá el nombre de la ruta, y si el nombre de la ruta existe y es un directorio, entonces showDir imprime recursivamente todos sus subdirectorios y archivos. Debido a que la sangría aumenta con cada llamada recursiva, el diseño refleja la estructura del directorio.

showDir vacío estático (int sangría, archivo de archivo) lanza IOException {para (int i=0; i<sangría; i++)

System.out.print('-');

System.out.println(file.getName()); si (archivo.isDirectory()) {

Archivo[] archivos = file.listFiles();

for (int i=0; i<files.length; i++) showDir(sangría+4, archivos[i]);

}

}





Ejemplo 113: Tuberías internas entre roscas



El subproceso productor escribe la secuencia infinita de números primos 2, 3, 5, 7,11,13,... en un PipedOutputStream, mientras que el consumidor (el subproceso principal) lee desde un PipedInputStream conectado a PipedOutputStream. En realidad, el productor escribe en un DataInputStream creado sobre PipedOutputStream, y el consumidor lee desde un DataInputStream creado sobre PipedInputStream, porque queremos enviar números enteros, no solo bytes, a través de la tubería.



PipedOutputStream salida = nuevo PipedOutputStream(); PipedInputStream tubería de entrada = nueva PipedInputStream(salida);

salidas finales de DataOutputStream = nuevo DataOutputStream (salida);



DataInputStream inds = nuevo DataInputStream(tubería de entrada);

// Este hilo genera números primos en outds -> outpipe -> inpipe -> inds: class Producer extends Thread {

ejecución pública vacía() { intentar {

outds.writeInt(2);

for (int p=3; verdadero; p+=2) { int q=3;

mientras (q*q <= p && p%q != 0) q+=2;

si (q*q > p)

{ outds.writeInt(p); System.out.print("."); }

}

} catch (IOException e) { System.out.println("<terminado>: " + e); }

}

}



nuevo Productor().start();

Para Siempre



for (int n=0; n<10; n++) // salida 10 números primos System.out.print(inds.readInt() + " "); // y System.in.read(); // esperar a entrar

}



Comunicación de enchufe

Mientras que un par de subprocesos de Java pueden comunicarse a través de una tubería local (por ejemplo, PipedInputStream), un par de procesos distintos pueden comunicarse a través de sockets. Los procesos pueden estar en la misma máquina o en diferentes máquinas conectadas por una red.

Los sockets se utilizan a menudo en arquitecturas cliente/servidor, donde el proceso del servidor crea un socket de servidor que escucha las conexiones de los clientes. Cuando un cliente se conecta al socket del servidor, se crea un socket nuevo en el lado del servidor y se conecta al socket que el cliente utilizó al conectarse al servidor. La conexión de socket se utiliza para la comunicación bidireccional entre el cliente y el servidor; ambos extremos pueden obtener un flujo de entrada y un flujo de salida del socket.

Aquí hay un constructor y algunos métodos de la clase ServerSocket en el paquete java.net:

ServerSocket (puerto int) crea un socket de servidor en el puerto dado.

Socket Accept() escucha una conexión y la bloquea hasta que se establece una conexión. Crea y devuelve un nuevo Socket cuando se realiza una conexión. Si se establece un tiempo de espera, se lanza la llamada para aceptarInterruptedIOException cuando expira el tiempo de espera.

void close() cierra el socket del servidor.

void setSoTimeout(int tmo) establece el tiempo de espera para que una llamada para aceptar expire después de tmo milisegundos, si es positivo. Desactiva el tiempo de espera (el valor predeterminado) si tmo es cero.

Aquí hay un constructor y algunos métodos de la clase Socket en el paquete java .net:

Socket (String host, int port) crea un socket de cliente y se conecta a un puerto determinado en el host determinado. El host puede ser un nombre ("localhost") o una dirección IP ("127.0.0.1").

void close() cierra el socket.

InetAddress getInetAddress() devuelve la dirección a la que está conectado este socket, como un objeto de la clase java.net.InetAddress; Los métodos getHostName() y getHostAddress() se pueden utilizar para convertir esta dirección en una cadena.

InputStream getInputStream() devuelve el flujo de entrada asociado con este socket.

OutputStream getOutputStream() devuelve el flujo de salida asociado con este socket.

void setSoTimeout (int tmo) establece el tiempo de espera para que una llamada para leer en el flujo de entrada obtenido de este socket expire después de tmo milisegundos, si es positivo. Si tmo es cero, entonces el tiempo de espera está deshabilitado (el valor predeterminado). Si se establece un tiempo de espera, una llamada a lectura arroja InterruptedIOException cuando expira el tiempo de espera.

Las clases Socket y ServerSocket se declaran en el paquete de biblioteca de clases Java java.net. La documentación de la biblioteca de clases Java [3] proporciona más información sobre sockets y sockets de servidor.

Ejemplo 114: Comunicación de socket entre procesos

Este programa de ejemplo se ejecuta como un proceso de servidor o como un proceso de cliente, dependiendo del primer argumento de la línea de comando. El servidor y el cliente pueden ejecutarse en la misma máquina o en diferentes máquinas que se comunican a través de una red. Varios clientes pueden conectarse al mismo servidor. El servidor crea un socket de servidor que acepta conexiones en el puerto 2357. Cuando un cliente se conecta, se crea un nuevo socket de cliente y se recibe un número entero en ese socket. Si el número entero es primo, el servidor responde verdadero en el mismo socket; en caso contrario, falso.

Cada proceso cliente pregunta al servidor sobre la primalidad de los números del 1 al 999 e imprime los que son primos.

Es bastante ineficiente para el cliente crear un nuevo socket para cada solicitud al servidor, pero es suficiente para este ejemplo. Además, almacenar en búfer los flujos de entrada y salida puede acelerar la comunicación del socket (sección 21.12).



importar java.io.*; importar java.net.*;



clase Prueba de socket {



PUERTO int estático final = 2357;







public static void main (String[] args) lanza IOException {

servidor booleano = args.length == 1 && args[0].equals("servidor"); cliente booleano = args.length == 2 && args[0].equals("cliente");

if (servidor) { // Servidor: acepta preguntas sobre primalidad

ServerSocket serversock = nuevo ServerSocket(PUERTO); para (;;) {

Calcetín de enchufe = serversock.accept();

DataInputStream dis = nuevo DataInputStream(sock.getInputStream()); DataOutputStream dos = nuevo DataOutputStream(sock.getOutputStream()); consulta int = dis.readInt();

dos.writeBoolean(isprime(consulta)); revelar(); dos.cerrar();

}

} else if (cliente) { // Cliente: hacer preguntas sobre primalidad

para (int i=1; i<1000; i++) {

Calcetín de socket = nuevo Socket(args[1], PUERTO);

DataOutputStream dos = nuevo DataOutputStream(sock.getOutputStream()); DataInputStream dis = nuevo DataInputStream(sock.getInputStream()); dos.writeInt(i);

if (dis.readBoolean()) System.out.print(i + " ");

dos.cerrar(); revelar();

}

} else { ... } // Ni servidor ni cliente

}

estático booleano isprime(int p) { ... devuelve verdadero si p es primo ... }

}



Referencias

La referencia autorizada sobre el lenguaje de programación Java es J. Gosling, B. Alegría, G. Steele y G. Bracha, La especificación del lenguaje Java, 2ª ed. (Bostón: Addison Wesley, 2000). Busque o descargue en HTML (573 KB) en <>.







Una introducción a todos los aspectos de la programación Java es K. Arnold,J. Gosling y D. Holmes, El lenguaje de programación Java, 3ª ed. (Bostón: Addison Wesley, 2000).



Las bibliotecas de clases Java (o Java Core API) se describen en dos volúmenes de The Java Class Libraries, segunda edición (Boston: Addison Wesley, 1997/98). Volumen 1, por P. Chan, R. Lee y D. Kramer cubren java.io, java.lang, java.math, java.net, java.text y java.util. Volumen 2, por P. Chan y

R. Lee, cubre java.applet, java.awt y java.beans. También está disponible P. Chan, R. Lee y D. Kramer, The Java Class Libraries: 1.2 Suplemento (Boston: Addison Wesley, 1999).



La documentación de la biblioteca de clases se puede descargar (22 MB) en <> o explorar en

<>.



Una guía compacta sobre el estilo de programación Java es The Elements of Java Style (Cambridge: Cambridge University Press, 2000) de A. Vermeulen et al.



La codificación de caracteres Unicode (<>) corresponde a parte del Conjunto de Caracteres Universal (UCS), que es el estándar internacional ISO 10646-1:2000. La UTF-8 es una codificación de longitud variable de UCS, en la que los caracteres ASCII de siete bits se codifican como ellos mismos, descritos en el Anexo R de esta norma.



La aritmética de coma flotante se describe en el estándar ANSI/IEEE para aritmética binaria de coma flotante (IEEENorma 754-1985).

EloperadordeString+ ................................................

Pequeños fallos frecuentes al usar operadores ........................

Operadores de conversión .........................................

Java no tiene "tamaño de" ................................................ .

Volver a hablar acerca de la precedencia................................

Un compendio de operadores .........................................

Control de ejecución ................................................

Verdadero y falso ................................................. ...

Si no ................................................. ..........

devolver ................................................. .......

Iteración................................................. .....

hacer mientras................................................. ........

para ................................................. ..........

romper y continuar ................................................. .

cambiar ................................................. ....... Resultado ................................................ .........

Ejercicios ................................................. ..

4: Inicialización y limpieza .................................

Inicialización garantizada con el constructor ........................

Sobrecargademétodos ........................................ Distinguir métodos sobrecargados ...... ............................

Sobrecarga con tipos primitivos .................................

Sobrecarga en los valores de retorno ................................

Constructores por defecto .........................................

La palabra clave this .......................................... Limpieza: finalización y recolección de basura ....................... ¿Para qué sirve finalizar( )? ........................................

Hay que llevar a cabo la limpieza .................................

La condición de muerto .................................................

Cómo funciona un recolector de basura ................................

Inicialización de miembros ........................................ Especificación de la inicialización ..... ................................

Inicialización de constructores .........................................

Inicialización de arrays ......................................... Arrays multidimensionales .... .................................

Resumen ................................................. .. Ejercicios ................................................ ....

5: Ocultar la implementación ...................................

El paquete: la unidad de biblioteca ................................ Creando nombres de paquete único ...... .........................

Una biblioteca de herramientas a medida .................................

Utilizar el comando import para cambiar el comportamiento ...............

Advertencias relativas al uso de paquetes .................................

índice de contenido xi

Modificadores de acceso en Java ................................. "Amistoso" ("Friendly") .... .........................................

público: acceso a interfaces ........................................

privado: jeso no se toca! ..........................................

protected: "un tipo de amistad" .................................

Interfaz e implementación ........................................ Acceso a clases ...... ........................................ Resumen ......... ..........................................

Ejercicios ................................................. ..

6: Reutilizando clases .........................................

Sintaxis de la composición ........................................

Sintaxis de la herencia ......................................... Inicializando la clase base . ........................................

Combinando la composición y la herencia .......................... Garantizar una buena limpieza .............. ........................

Ocultación de nombres ................................................

Elcción entre composición y herencia ............................. Protegido (protected) ............ .................................Desaerrollo incremental.................. ...................... Conversión hacia arriba ......................... ...............

¿Por qué "conversión hacia arriba"? .................................

Lapalabraclavefinal .......................................... Paradatos ...... .................................................

Métodos constantes................................................

Clases constantes .................................................

Precaución con constantes .........................................

Carga de clases e inicialización .................................

Inicialización con herencia .........................................

Resumen ................................................. .. Ejercicios ................................................ ....

De nueva la conversión hacia arriba ................................

Olvidando el tipo de objetoeto ........................................

El cambio ................................................. .. La ligadura en las llamadas a métodos ................................

Produciendo el comportamiento adecuado ................................

Extensibilidad................................................. .

Superposición frente a sobrecarga ................................ Clases y métodos abstractos ........... .......................... Clases y métodos abstractos .................... ................

Orden de llamadas a constructores .................................

Herencia y finahe( ) .................................................

Comportamiento de métodos polimórficos dentro de constructores .........

xii Piensa en Java

Diseñoconherencia ........................................... Herencia pura frente a extensión . ...................................

Conversión hacia abajo e identificación de tipos en tiempo de ejecución ......

Resumen ................................................. .. Ejercicios ................................................ ....

8: Interfaces y clases internas .................................

Interfaces................................................. .. "Herencia múltiple" en Java .........................................

Extender una interfaz con herencia .................................

Constantes de agrupamiento ........................................

Iniciando atributos en interfaces .................................

Interfaces anidadas ................................................

Clases internas .................................................

Clases internas y conversiones hacia arriba ................................

Ámbitos y clases internas en métodos ................................

Clases internas anónimas .........................................

El enlace con la clase externa .................................

Clases internas estáticas ................................................

Referirse al objeto de la clase externa ................................. Acceso desde una clase múltiplemente anidada ..... ....................

Heredar de clases internas .........................................

¿Pueden superponerse las clases internas? ............................

Identificadores de clases internas ................................

¿Por qué clases internas? ..........................................

Clases internas y sistema de control .................................

Resumen ................................................. ........

Ejercicios ................................................. .......

9: Guardar objetos ................................................

Matrices ................................................. ..........

Los arrays son objetos de primera clase .................................

Devolverunarray................................................

LaclaseArrays.................................................

Rellenarunarray................................................

Copiarunarray.................................................

Comparar matrices ................................................

Comparaciones de elementos de arrays .................................

Ordenar una matriz ................................................. ...

Buscar en un array ordenado ........................................

Resumen de matrices ................................................

Introduccion a los contenedores .................................

Visualizar contenedores................................................

Rellenar contenedores ................................................

Desventaja de los contenedores: tipo desconocido ........................

índice de contenido xiii

En ocasiones funciona de cualquier modo .................................

Hacer un ArrayList consciente de los tipos .................

Iteradores ................................................. .......

Taxonomía de contenedores ........................................

Funcionalidad de la Colección ................................................

Lista de funcionalidades de la interfaz ........................................

Construir una pila a partir de un objeto LinkedList ....................

Construir una cola a partir de un objeto LinkedList ....................

Funcionalidad de la interfaz Set....................................

Conjunto ordenado (SortedSet) .................................

Mapa de Funcionalidad................................................

Mapa ordenado (Sorted Map) ........................................ Hashing y códigos de hash . .........................................

Superponer el método hashCode( ) .................................

Guardar referencias ................................................

El nhjetn HasMap dkhil (WeakHashMa~) .................

Revisando los iteradores ................................................

Elegir una implementación ..........................................

Elegir entre listas ................................................

elegir entreConjuntos .................................................

Elegir entre mapas ................................................

Ordenar y buscar elementos en Listas .................................

Utilidades................................................. .......

Hacer inmodificable una Colección o un Mapa ........................

Sincronizar una Colección o Mapa .................................

Operaciones no soportadas ........................................

Contenedores de Java 1.0/1.1 ........................................

Enumeración de vectores y ................................................

Tabla de picadillo ................................................. ....

Pila(Pila) ................................................ ......

Conjunto de bits (BitSet) ................................................

Resumen ................................................. ........

Ejercicios ................................................. .......

10: Manejo de errores con excepciones ..........................

Excepciones básicas .................................................

Parámetros de las excepciones .................................... . . Capturarunaexcepción................................................

Elbloqueo................................................. ..

Manejadores de excepciones ..................................

Crear sus propias excepciones ........................................

La especificación de excepciones ....................................

Capturar cualquier excepción ........................................

Relanzarunaexcepción................................................

ExcepcionesestándardeJava .................................

xiv Piensa en Java

El caso especial de RuntimeException ................................

Limpiando con finalmente................................................

~¿Paraqué servir finalmente? .........................................

Peligro: la excepción perdida .........................................

Restricciones a las excepciones .........................................

Constructores................................................. ....

Emparejamiento de excepciones ....................................

Guías de cara a las excepciones ....................................

Resumen ................................................. ........

Ejercicios ................................................. .......

11: El sistema de E/S de Java .................................

Archivo de la clase ................................................. ....... Un generador de listados de directorio .................................

Comprobando y creando directorios ................................. Entradaysalida ............ ....................................

TiposdeInputStream................................................

TiposdeOutputStream................................................

Añadir atributos e interfaces útiles ...................................

Leer un InputStream con un FilterInputStream ....................

Escribir en un OutputStream con FilterOutputStream .................

Lectores y escritores .................................................

Fuentes y consumidores de datos ...................................

Modificar el comportamiento del flujo ................................

Clases no cambiadas ................................................

Por sí mismo: RandomAccessFile .................................

Usos típicos de flujos de E/S ........................................

Flujosdeentrada................................................

Flujosdesalida.................................................

¿Unerror? ................................................. ...

Flujosentubados................................................

E/Sestándar ................................................. ......

Leerdelaentradaestándar .........................................

Convirtiendo System.out en un PrintWriter ........................

RedingiendolaE/Sestándar .................................

Compresión................................................. .....

Compresión sencilla con GZIP .................................

Almacenamiento múltiple con ZIP ...................................

Archivos Java UAR) .................................................

Serialización de objetos .................................................

Encontrarlaclase................................................

Controlar la serialización................................................

Utilizar la persistencia................................................

Identificar símbolos de una entrada .................................

StreamTokenizer................................................

índice de contenido xv

StringTokenizer .................................................

Comprobar el estilo de escritura de mayúsculas ........................

Resumen ................................................. ........

Ejercicios ................................................. .......

12: Identificación de tipos en tiempo deejecución ...................

La necesidad de RTTI ................................................

ElobjetoClase .................................................

Comprobar antes de una conversión .................................

Sintaxis RTTI ................................................ .....

Reflectividad: información de clases en tiempo de ejecución ..............

Un extractor de métodos de clases ...................................

Resuinen ................................................. ........

Ejercicios ................................................. .......

13: Crear ventanas y subprogramas .................................

El subprograma básico ................................................. ....

Restricciones de subprogramas ................................................

Ventajas de los applets................................................

Marcos de trabajo de aplicación .................................

Ejecutar applets dentro de un navegador web....................

Utilizar Appletviewer ................................................

Probarapplets ................................................. .

Ejecutar applets desde la línea de comandos .................

Un marco de trabajo de visualización .................................

Usar el Explorador de Windows .................................

Hacer un botón ................................................. ....

Capturarunevento................................................

Áreas de texto ................................................. .....

Controlar la disposición ................................................

Borde hyout ................................................. ..

Flowhyout ................................................. ...

Gridhyout ................................................. ....

Diseño de bolsa de cuadrícula................................................

Posicionamiento absoluto................................................

Boxhyout................................................ ....

¿El mejorenfoque? ................................................

El modelo de eventos de Swing .................................

Tipos de eventos y oyentes .........................................

Seguimiento de múltiples eventos .................................

Un catálogo de componentes Swing .................................

Botones ................................................. ......

Iconos ................................................ .......

Etiquetas de aviso................................................

Camposdetexto................................................

xvi Piensa en Java

Bordes ................................................. .......

JScrollPanes ................................................ ..

Desminieditor ................................................. .

Casillas de verificación................................................

Botonesdeopción................................................

Cuadros combinados (listas desplegables) .................................

Listas ................................................. ........

Paneles Tabulados .................................................

Cajas demensajes ................................................

Menús ................................................. .......

Menús emergentes ................................................

Generacióndedibujos................................................

Cajasdediálogo ................................................

Diálogos de archivo ................................................

Componentes HTMLSwing ................................................

Deslizadores y barras de progreso .................................

Arboles ................................................. ...... Tablas ................................................. .............

Seleccionar Apariencia................................................

El portapapeles ................................................

Empaquetando un applet en un fichero JAR .................

Técnicas de programación................................................

Correspondencia dinámica de objetos ................................

Separar la lógica de negocio de la lógica IU ...........................

Una forma canónica ................................................

Programación visual y Beans .........................................

~QuéesunBean? .................................................

Extraer BeanInfo con el Introspector .................................

Un frijol más cómodo ........................................

Frijol Empaquetarun ................................................

Soporte a Beans más complejo .................................

MássobreFrijoles ................................................

Resumen ................................................. ........

Ejercicios ................................................. .......

14: Hilos múltiples ................................................

Interfaces de respuesta de usuario rápida .......................... HeredardeThread .ejecución ...................

La necesidad de RTTI ................................................

ElobjetoClase .................................................

Comprobar antes de una conversión .................................

Sintaxis RTTI ................................................ .....

Reflectividad: información de clases en tiempo de ejecución ..............

Un extractor de métodos de clases ...................................

Resuinen ................................................. ........

Ejercicios ................................................. .......

13: Crear ventanas y subprogramas .................................

El subprograma básico ................................................. ....

Restricciones de subprogramas ................................................

Ventajas de los applets................................................

Marcos de trabajo de aplicación .................................

Ejecutar applets dentro de un navegador web....................

Utilizar Appletviewer ................................................

Probarapplets ................................................. .

Ejecutar applets desde la línea de comandos .................

Un marco de trabajo de visualización .................................

Usar el Explorador de Windows .................................

Hacer un botón ................................................. ....

Capturarunevento................................................

Áreas de texto ................................................. .....

Controlar la disposición ................................................

Borde hyout ................................................. ..

Flowhyout ................................................. ...

Gridhyout ................................................. ....

Diseño de bolsa de cuadrícula................................................

Posicionamiento absoluto................................................

Boxhyout................................................ ....

¿El mejorenfoque? ................................................

El modelo de eventos de Swing .................................

Tipos de eventos y oyentes .........................................

Seguimiento de múltiples eventos .................................

Un catálogo de componentes Swing .................................

Botones ................................................. ......

Iconos ................................................ .......

Etiquetas de aviso................................................

Camposdetexto................................................

xvi Piensa en Java

Bordes ................................................. .......

JScrollPanes ................................................ ..

Desminieditor ................................................. .

Casillas de verificación................................................

Botonesdeopción................................................

Cuadros combinados (listas desplegables) .................................

Listas ................................................. ........

Paneles Tabulados .................................................

Cajas demensajes ................................................

Menús ................................................. .......

Menús emergentes ................................................

Generacióndedibujos................................................

Cajasdediálogo ................................................

Diálogos de archivo ................................................

Componentes HTMLSwing ................................................

Deslizadores y barras de progreso .................................

Arboles ................................................. ...... Tablas ................................................. .............

Seleccionar Apariencia................................................

El portapapeles ................................................

Empaquetando un applet en un fichero JAR .................

Técnicas de programación................................................

Correspondencia dinámica de objetos ................................

Separar la lógica de negocio de la lógica IU ...........................

Una forma canónica ................................................

Programación visual y Beans .........................................

~QuéesunBean? .................................................

Extraer BeanInfo con el Introspector .................................

Un frijol más cómodo ........................................

Frijol Empaquetarun ................................................

Soporte a Beans más complejo .................................

MássobreFrijoles ................................................

Resumen ................................................. ........

Ejercicios ................................................. .......

14: Hilos múltiples ................................................

Interfaces de respuesta de usuario rápida .......................... HeredardeThread .................................................

Hilos para una interfaz con respuesta rápida .................

Combinar el hilo con la clase principal ................................

Construir muchos hilos ................................................

Hilosdemonio ................................................. .

Compartir recursos limitados ........................................

Acceder a los recursos de forma inadecuada ...........................

Cómo compartir Java los recursos ...................................

índice de contenido xvii

Revisar los JavaBeans ................................................

Bloqueo ................................................. .......

Bloqueándose................................................. .

Interbloqueo................................................. ..

Prioridades ................................................. ......

Leer y establecer prioridades ........................................

Gruposdehilos.................................................

Volver a visitar Runnable ................................................

Hilos demasiados ................................................

Resumen ................................................. ........

Ejercicios ................................................. .......

15: Computación distribuida ...................................

Programación en rojo ................................................

Identificar una máquina ........................................

Enchufes ................................................. ......

Servir a múltiples clientes ........................................

Datagramas ................................................. ...

Utilizar URL en un subprograma .........................................

Más aspectos de redes.................................................

Conectividad a Bases de Datos de Java (JDBC) ........................

Hacer que el ejemplo funcione ...................................

Una versión con IGU del programa de búsqueda .................

Por qué el API JDBC parece tan complejo .................

Un ejemplo más cómodo ........................................

Servlets ................................................. .........

El servlet básico ................................................ .

Servlets y multihilo ................................................

Gestionar sesiones con servlets.................................

Ejecutar los ejemplos de servlets.................................

Páginas del servidor Java ................................................. ..

Objetos implícitos ................................................

Directivas JSP ................................................ ..

Elementos de escritura de guiones JSP .................................

Campos y valores adicionales ................................................

Atributos JSP de página y su ámbito .................................

Sesiones manuales en JSP .........................................

Crear y modificar cookies ........................................

ResumendeJSP ................................................ RMI (Método remoto de invocación) ...................................

Interfaces remotas .................................................

Implementar la interfaz remota ...................................

Crearstubsyskeletons ................................................ Utilizar el objeto remoto .. ........................................

CORBA ................................................. ...

xviii Piensa en Java

FundamentosdeCORBA................................................ 773

Unejemplo................................................. ... 775

Applets de Java y CORBA ......................................... 780

CORBAfrenteaRMI ................................................ 780

JavaBeans empresariales ................................................ 780

JavaBeans frente a EJB................................................ 781

La especificación EJB ................................................ 782

ComponentesEJB ................................................ 783

Las partes de un componente EJB ................................ 784

Funcionamiento de un EJB ........................................ 785

TiposdeEJB ................................................ .. 785

Desarrollar un EJB................................................ 786

ResumendeEJB ................................................ 791

Jini: servicios distribuidos................................................ 791

Jini en contacto ................................................. .. 791

¿Qué es Jini? ................................................. .792

Cómo funciona Jini ................................................ 792

El proceso de descubrimiento................................................ 793

El proceso de unirse ................................................. ... 793

El proceso de búsqueda.................................. 794

Separación de interfaz e implementación ................................795

Abstraer sistemas distribuidos ................................................ 796

Resumen ................................................. ..... 796

Ejercicios ................................................. ..... 796

R: Paso y Retorno de Objetos ...........

Pasando referencias ................................................

Usodealias ................................................. ...

Haciendo copias locales ................................................

Paso por valor................................................. .

Clonandoobjetos................................................

Añadiendo a una clase la capacidad de ser clonable..................

Clonación con éxito ................................................

El efecto de Object.clone( ) .........................................

Clonando un objeto compuesto .................................

Una copia en profundidad con ArrayList .................................

Copia en profundidad vía serialización ................................

Añadiendo "clonabilidad" a lo largo de toda una jerarquía .................

{¿Por qué un diseño tan extraño? .................................

Controlando la "clonabilidad" .........................................

Elconstructordecopias................................................

Clases de sólo lectura ................................................

Creando clases de sólo lectura ....................................

Los inconvenientes de la inmutabilidad ................................

Cadenas inmutables ................................................

índice de contenido xix

Las clases String y StringBuffer .................................

Los Strings son especiales .........................................

Resumen ................................................. ........

Ejercicios ................................................. .......

B . La interfaz nativa Java (JNI1) ................................

Invocando a un método nativo .........................................

El generador de cabeceras de archivo: javah .................................

renombrado de nombres y firmas de funciones ........................

Implementando la DLL ................................................

Accediendo a funciones JNI: el parámetro JNIEnv ....................

Accediendo a Strings Java .........................................

Pasando y usando objetos Java .................................

JNI y las excepciones Java .................................

JNIyloshilos ................................................. .

Usando un código base preexistente ................................

Información adicional................................................

C: Guías de programación Java ................................

Diseño ................................................. ..........

Implementación................................................

D: Recursos Software................................................

Libros................................................ ..........

Análisis y Diseño ................................................. ...

Pitón ................................................. ..........

Mi propia lista de libros ................................................

E: Correspondencias español-inglés de clases. bases de datos. tablas

y campos del CD ROM que acompaña al libro ...................



prólogo

Sugerí a mi hermano Todd, que está dando el

ción, que la siguiente gran revolución será en

salto del hardware a la programaingeniería genética.

Tendremos microbios diseñados para hacer comida, combustible y plástico; limpiarán la contaminación y

en general, nos permitirán dominar la manipulación del mundo físico por una fracción de lo que

cuesta ahora. De hecho yo afirmé que la revolución de los computadores parecería pequeña en comparación.

Después, me di cuenta de que estaba cometiendo un error frecuente en los escritores de ciencia ficción: perderme en la tecnología (lo que por supuesto es fácil de hacer en ciencia ficción). Un escritor experimentado sabe que la historia nunca tiene que ver con los elementos, sino con la gente. La

genética tendrá un gran impacto en nuestras vidas, pero no estoy seguro de que haga sombra a la

revolución de los computadores (que hace posible la revolución genética) -o al menos la revolución de la información. La información hace referencia a comunicarse con otros: sí, los coches, los

zapatos y especialmente la terapia genética son importantes, pero al final, esto no son más que adornos. Lo que verdaderamente importa es cómo nos relacionamos con el mundo. Y cuanto de eso es

comunicación.

Este libro es un caso. La mayoría de los colegas pensaban que estaba un poco loco al poner todo en la

Web. "¿Por qué lo compraría a alguien?", se preguntaban. Si hubiera sido de naturaleza más conservadora no lo habría hecho, pero lo que verdaderamente no quería era escribir más libros de computación al estilo tradicional. No sabía qué pasaría pero resultó que fue una de las cosas más inteligentes que he hecho con unlibro.

Por algún motivo, la gente empezó a mandar correcciones. Éste ha sido un proceso divertido, porque todo el mundo ha recorrido el libro y ha detectado tanto los errores técnicos como los gramaticales, y ha podido eliminar errores de todos los tipos que de otra forma se habrían quedado ahí. La

gente ha sido bastante amable con esto, diciendo a menudo "yo no quiero decir esto por criticar...",

y tras darme una colección de errores estoy seguro de que de otra forma nunca los hubiera encontrado. Siento que éste ha sido un tipo de grupo de procesos que ha convertido el libro en algo especial.

Pero cuando empecé a oír: "De acuerdo, bien, está bien que hayas puesto una versión electrónica,

pero quiero una copia impresa proveniente de una auténtica editorial", puse mi mayor empeño en

facilitar que todo se imprima con adecuado, pero eso no frenó la demanda de una versión publicada. La mayoría de la gente no quiere leer todo el libro en pantalla, y merodear por un

conjunto de papeles, sin que importen cuán bien impresos estén, simplemente no era suficiente.

(Además, tampoco creo que resulte tan barato en términos de tóner para impresora láser.) Parece

que a fin de cuentas, la revolución de los computadores no conseguirá dejar sin trabajo a las editoriales. Sin embargo, un alumno me sugirió que éste podría ser un modelo para publicaciones finales: los libros se publicarán primero en la Web, y sólo si hay el suficiente interés, merecerá la pena.

pasar el libro a papel. Actualmente, la gran mayoría de libros conllevan problemas financieros, y quizás este nuevo enfoque pueda hacer que el negocio de la publicación sea más beneficioso. Este li-

xxii Piensa en Java

hermano se convirtió en una experiencia reveladora para mí de otra forma. Originalmente me acerqué a

Java como "simplemente a otro lenguaje de programación", lo que en cierto sentido es verdad. pero

a medida que pasaba el tiempo y lo estudiaba más en profundidad, empecé a ver que la intención

fundamental de este lenguaje es distinta de la de otros lenguajes que he visto.

La programación está relacionada con gestionar la complejidad: la complejidad del problema que se

quiere solucionar, que yace sobre la complejidad de la máquina en que se soluciona. Debido a esto

complejidad, la mayoría de nuestros proyectos fallan. Y lo que es más, de todos los lenguajes de programación de los que soy consciente, ninguno se ha lanzado completamente decidiendo que la meta

de diseño principal fuera conquistar la complejidad del desarrollo y mantenimiento de programas1.

Por supuesto, muchas decisiones de diseño de lenguajes se hicieron sin tener en mente la complejidad, pero en algún punto había siempre algún otro enfoque que se consideraba esencial añadirlo.

al conjunto. Inevitablemente, estos otros aspectos son los que hacen que generalmente los programadores "se den con la pared" contra ese lenguaje. Por ejemplo, C++ tenía que ser compatible con

C (para permitir la migración fácil a los programadores de C), además de eficiente. Estas metas hijo

ambas muy útiles y aportan mucho al éxito de Ctt, pero también exponen la complejidad extra que

evita que los proyectos se acaben (ciertamente, se puede echar la culpa a los programadores y la

gestión, pero si un lenguaje puede ayudar 'a capturar los errores, ¿por qué no hacer uso de ello?).

Como otro ejemplo, Visual Basic (VB) estaba atado a BASIC, que no estaba diseñado verdaderamente para ser un lenguaje ampliable, por lo que todas las aplicaciones que se apilaban sobre VB.

producían sintaxis verdaderamente horribles e inmantenibles. Perl es retrocompatible con Awk,

Sed, Grep y otras herramientas Unix a las que iba a reemplazar, y como resultado se le acusa a menudo, de producir "código de sólo escritura" (es decir, código que tras unos pocos meses no hay

quien lea). Por otro lado, C++, VB, Perl y otros lenguajes como Smalltalk han visto cómo algunos

de sus esfuerzos de diseño se centran en el aspecto de la complejidad y como resultado son remarcadamente exitosos para solucionar ciertos tipos de problemas.

Lo que más me impresionó es que llegó a entender que Java parece tener el objetivo de reducir la complejidad para el programador. Como si se dijera "no nos importa nada más que reducir el

tiempo y la dificultad para producir un código robusto". En los primeros tiempos, esta meta llevaba

a un código que no se ejecutaba muy rápido (aunque se habían hecho promesas sobre lo rápido que

se ejecutaría Java algún día), pero sin duda ha producido reducciones sorprendentes de tiempo de

desarrollo; la mitad o menos del tiempo que lleva crear un programa C++ equivalente. Este resultado sólo puede ahorrar cantidades increíbles de tiempo y dinero, pero Java no se detiene ahí. Envuelve todas las tareas complejas que se han convertido en importantes, como el multihilo y la programación en red, en bibliotecas o aspectos del lenguaje que en ocasiones pueden convertir esas

tareas en triviales. Y finalmente, asume muchos problemas de complejidad grande: programas multiplataforma, cambios dinámicos de código, e incluso seguridad, cada uno de los cuales pueden encajar dentro de un espectro de complejidades que oscila en el rango de "impedimento" a "motivos

de cancelación". Por tanto, a pesar de los problemas de rendimiento que se han visto, la promesa

de Java es tremenda: puede convertirnos en programadores significativamente más productivos.

Uno de los sitios en los que veo el mayor impacto de esto es en la Web. La programación en red

siempre ha sido complicado, y Java la convierte en fácil. O los diseñadores el lenguaje Java están

Esto lo retomo de la 2." edición: creo que el lenguaje Python se acerca aún más a esto. Ver http://www.Python.org.

Prefacio XXIII

trabajando en facilitarla aún más). La programación en red es como hablar simultáneamente de forma efectiva y de forma más barata de lo que nunca se logró con teléfonos (sólo el correo electrónico ya ha revolucionado muchos negocios). Al intercomunicarnos más, empezarán a pasar cosas.

divertidas, probablemente mucho más interesantes que las que pasarán con la ingeniería genética.

De todas formas -al crear los programas, trabajar para crear programas, construir interfaces para

los programas, de forma que éstos se puedan comunicar con el usuario, ejecute los programas en

distintos tipos de máquinas, y escribir de forma sencilla programas que pueden comunicarse a través de Internet-Java incrementa el ancho de banda de comunicación entre la gente. Creo que quizás los resultados de la revolución de la comunicación no se contemplarán por lo que conlleva el

transporte de grandes cantidades de bits; Veremos la auténtica revolución porque podremos comunicarnos con mayor facilidad: de uno en uno, pero también en grupos y, como planeta. He oído la

sugerencia de que la próxima revolución es la formación de cierto tipo de mente global para suficiente gente y suficiente nivel de interconectividad. Puede decirse que Java puede fomentar o no esa

revolución, pero al menos la mera posibilidad me ha hecho sentir como si estuviera haciendo algo

lleno de sentido al intentar enseñar ese lenguaje.

Prólogo a la 2.a edición

La gente ha hecho muchos, muchos comentarios maravillosos sobre la primera edición de este libro, cosa que ha sido para mí muy, pero que muy, placentero. Sin embargo, en todo momento habrá quien tenga quejas, y por alguna razón una queja que suele aparecer periódicamente es que "el

libro es demasiado grande". Para mí, esto no es verdaderamente una queja, si se reduce a que "tiene demasiadas páginas". (Uno se acuerda de las quejas del Emperador de Austria sobre el trabajo

de Mozart: "¡Demasiadas páginas!", y no es que me esté intentando comparar con Mozart de ninguna forma). Además, sólo puedo asumir que semejante queja puede provenir de gente que no tiene aún una idea clara de la vasta extensión del propio lenguaje Java en sí, y que no ha visto el resto de libros sobre la materia -por ejemplo, mi referencia favorita es el Core Java de Cay Horstmann

& Cary Cornell (Prentice-Hall), que creció tanto que hubo que dividirlo en dos tomos. A pesar de

Esto, una de las cosas que intentó hacer en esta edición es eliminar las puertas que se han vuelto obsoletas o al menos no esenciales. Me siento a gusto haciendo esto porque el material original.

sigue en la Web y en el CD ROM que acompaña al libro, en la misma forma de descarga gratuita

que la primera edición del libro (en http://www.BruceEckel.com). Si se desea el material antiguo,

Sigue ahí, y esto es algo maravilloso para un autor. Por ejemplo, puede verse que el último capítulo

original, "Proyectos", ya no está aquí; dos de los proyectos se han integrado en los otros capítulos,

y el resto ya no son adecuados. También el capítulo de "Patrones de diseño" se volvió demasiado

extenso y ha sido trasladado a un libro que versa sobre ellos (descargable también en el sitio web).

Por tanto, el libro debería ser más fino.

Pero no lo es.

El aspecto mayor es el continuo desarrollo del lenguaje Java en sí, y en particular las API que se expanden, y prometen proporcionar interfaces estándar para casi todo lo que se desea hacer (y no me

sorprendería ver aparecer la API "JTostadora"). Cubrir todas estas API se escapa por supuesto del

ámbito de este libro, y es una tarea relegada a otros autores, pero algunos aspectos no pueden ignorarse.

xxiv Piensa en Java

norarse. El mayor de estos incluye el servidor Java de lado (principalmente Servlets y Java Server

Pages o JSP), que es verdaderamente una solución excelente al problema de la World Wide Web,

donde se descubrió que las distintas plataformas de navegadores web no son lo suficientemente consistentes como para soportar programación en el lado cliente. Además, está todo el problema de

crear de forma sencilla aplicaciones que interactúen de forma sencilla con bases de datos, transacciones, seguridad y semejantes, cubiertos gracias a los Enterprise Java Beans (EJB). Estos temas están desarrollados en el capítulo que antes se llamaba "Programación de red" y ahora "Computación

distribuido", un tema que se está convirtiendo en esencial para todo el mundo. También se verá que

se ha compilado este capítulo para incluir un repaso de Jini (pronunciado "yeni", y que no es un

acrónimo, sino sólo un nombre), que es una tecnología emergente que permite que cambiemos la

forma de pensar sobre las aplicaciones interconectadas. Y por supuesto, el libro se ha cambiado para

usar la biblioteca IGU Swing a lo largo de todo el mismo. De nuevo, si se desea el material Java

1.0/1.1 antiguo, es posible conseguirlo gratuitamente del libro de descarga gratuita de

http:llwww.BruceEckel.corn (también está incluido en el nuevo CD ROM de esta edición, que se adjunta al mismo; hablaré más de él un poco más adelante).

Además de nuevas características del lenguaje añadidas a Java 2, y varias correcciones hechas a lo

largo de todo el libro, el otro cambio principal está en el capítulo de colecciones que ahora se centra en las colecciones de Java 2, que se usan a lo largo de todo el libro. También he mejorado ese

capítulo para que entre más en profundidad en algunos aspectos importantes de las colecciones, en

particular, en cómo funcionan las funciones de hash (de forma que se puede saber cómo crear

una adecuadamente). Ha habido otros movimientos y cambios, incluida la reescritura del Capítulo

1, y la eliminación de algunos apéndices y de otros materiales que ya no se consideran necesarios

para el libro impreso, que son un montón de ellos. En general, intentó recorrer todo, eliminar

de la 2." edición lo que ya no es necesario (pero que sigue existiendo en la primera edición electrónica), incluir cambios y mejorar todo lo que he podido. A medida que el lenguaje continúa cambiando -aunque no a un ritmo tan frenético como antiguamente- no cabe duda de que habrá más

ediciones de este libro.

Para aquellos de vosotros que siguen sin poder soportar el tamaño del libro, pido perdón. Lo creáis

o no, trabajó duro para que se mantenga lo menos posible. A pesar de todo, creo que hay bastantes alternativas que pueden satisfacer a todo el mundo. Además, el libro está disponible electrónicamente (en idioma inglés desde el sitio web y desde el CD ROM que acompaña al libro), por lo

que si se dispone de un ordenador de bolsillo, se puede disponer del libro sin tener que cargar un

gran peso. Si sigue interesado en tamaños menores, ya existen de hecho versiones del libro para

Piloto de palma. (Alguien me dijo en una ocasión que leería el libro en la cama en su Palm, con la luz encendida a la espalda para no molestar a su mujer. Sólo espero que le ayude a entrar en el mundo de

los sueños.) Si se necesita en papel, sé de gente que lo va imprimiendo capítulo a capítulo y se lo

Lee en el tren.

Java 2

En el momento de escribir el libro, es inminente el lanzamiento del Java Development Kit UDK) 1.3

de Sun, y ya se ha publicado los cambios propuestos para JDK 1.4. Aunque estos números de versión se corresponden aún con los "unos", la forma estándar de referenciar a las versiones posteriores.

Prefacio xxv

res a la JDK 1.2 es llamarles "Java 2". Esto indica que hubo cambios muy significativos entre el "viejo Java" -que tenía muchas pegas de las que ya me quejé en la primera edición de este libro- y

esta nueva versión más moderna y mejorada del lenguaje, que tiene menos pegas y más adiciones

y buenos diseños.

Este libro está escrito para Java 2. Tengo la gran ventaja de librarme de todo el material y escribir.

sólo para el nuevo lenguaje ya mejorado porque la información vieja sigue existiendo en la l." versión

electrónica disponible en la Web y en el CD-ROM (que es a donde se puede ir si se desea obcecarse

en el uso de versiones anteriores a Java 2 del lenguaje). También, y dado que cualquiera puede descargarse

gratuitamente el JDK de http://java.sun.com, se supone que por escribir para Java 2, no estoy imponiendo ningún criterio financiero o forzando a nadie a hacer una actualización del software.

Hay, sin embargo, algo que reseñar. JDK 1.3 tiene algunas mejoras que realmente me gustaría usar, pero la versión de Java que está siendo actualmente distribuida para Linux es la JDK 1.2.2

(ver http://www.Linux.org). Linux es un desarrollo importante en combinación con Java, porque es

rápido, robusto, seguro, está bien mantenido y es gratuito; una auténtica revolución en la historia de

la computación (no creo que se hayan visto todas estas características unidas en una única herramienta anteriormente). Y Java ha encontrado un nicho muy importante en la programación en el

lado servidor en forma de Serulets, una tecnología que es una grandísima mejora sobre la programación tradicional basada en CGI (todo ello cubierto en el capítulo "Computación Distribuida").

Por tanto, aunque me gustaría usar sólo las nuevas características, es crítico que todo se recopile

bajo Linux, y por tanto, cuando se desempaquete el código fuente y se compila bajo ese SO (con el

último JDK) se verá que todo compilara. Sin embargo, verás que he puesto notas sobre características de JDK 1.3 en muchos lugares.

El CD-ROM

Otro bono con esta edición es el CD ROM empaquetado al final del libro. En el pasado me resistió a poner CD ROM al final de mis libros porque pensaba que no estaba justificada una carga

de unos pocos Kbytes de código fuente en un soporte tan grande, prefiriendo en su lugar permitir

a la gente descargar los elementos desde el sitio web. Sin embargo, pronto se verá que este CD

ROM es diferente.

El CD contiene el código fuente del libro, pero también contiene el libro en su integridad, en varios

formatos electrónicos. Para mí, el preferido es el formato HTML porque es rápido y está completamente indexado -simplemente se hace clic en una entrada del índice o tabla de contenidos y estará inmediatamente en esa parte del libro.

La carga de más de 300 Megabytes del CD, sin embargo, es un curso multimedia denominado Thinking in C: Foundations for C++ & Java. Originalmente encargué este seminario en CD ROM a Chuck

Allison, como un producto independiente, pero decidió incluirlo con la segunda edición tanto de Thinking in C++ como de Piensa en Java, gracias a la consistente experiencia de haber tenido gente viniendo a los seminarios sin la requerida experiencia en C. El pensamiento parece aparentemente

ser: "Soy un programador inteligente y no deseo aprender C, y sí C++ o Java, por lo que me saltaré

C e iré directamente a C++/Java." Tras llegar al seminario, todo el mundo va comprendiendo que el

xxvi Piensa en Java

prerrequisito de aprender C está ahí por algo. Incluyendo el CD ROM con el libro, se puede asegurar que todo el mundo atienda al seminario con la preparación adecuada.

El CD también permite que el libro se presente para una audiencia mayor. Incluso aunque el Capítulo 3 («Controlando el flujo del programa») cubre los aspectos fundamentales de las partes de Java

que provienen de C, el CD es una introducción más gentil, y supone incluso un trasfondo de C menor que el que supone el libro. Espero que al introducir el CD sea más la gente que se acerca a

la programación en Java.

Prólogo a la edición

en español

Java se convierte día a día en un lenguaje de programación universal; es decir, ya no sólo sirve como

lenguaje para programar en entornos de Internet, sino que se está utilizando cada vez más como herramienta de programación orientada a objetos y también como herramienta para cursos específicos de programación o de estructuras de datos, aprovechando sus características de lenguaje "multiparadigma". Por estas razones, los libros que abordan temas completos y amplios sobre los

temas anteriores siempre serán bienvenidos. Si, además de reunir estos requisitos, el autor es uno

de los más galardonados por sus obras anteriores, nns nos enfrentamos ante iin reto considerable: "la

posibilidad de encontrarnos" ante un gran libro, de esos que hacen "historia". Éste, pensamos, es el

caso del libro que tenemos entre las manos. ¿Por qué pensamos así?

El libro como referencia obligada a Java

Piensa en Java introduce todos los fundamentos teóricos y prácticos del lenguaje Java, tratando de

Explicar con claridad y rigor no sólo lo que hace el lenguaje sino también el porqué. Eckel presenta

los fundamentos de objetos y cómo los utiliza Java. Éste es el caso del estudio que hace de la ocultación de las implementaciones, reutilización de clases y polimorfismo. Además, estudia en profundidad propiedades y características tan importantes como AWT, programación concurrente (multihilo, multithreading2), programación en red, e incluso diseño de patrones.

Es un libro que puede servir para iniciarse en Java y llegar hasta un nivel avanzado. Pero, en realidad se sacará el máximo partido al libro si se conoce otro lenguaje de programación, o al menos técnicas de programación (como haber seguido un curso de Fundamentos de Programación, Metodología de la Programación, Algoritmos, o cursos similares) y ya se puede apostar por un alto y eficiente

rendimiento si la migración a Java se hace desde un lenguaje orientado a objetos, como C++.

El libro como formación integral de programador.

Una de las fortalezas más notables del libro es su contenido y la gran cantidad de temas importantes cubiertos con toda claridad y rigor, y con gran profundidad. El contenido es muy amplio y sobre.

todo completo. Eckel prácticamente ha tocado casi todas las técnicas existentes y utilizadas hoy día

en el mundo de la programación y de la ingeniería del software. Algunos de los temas más sobresalientes analizados en el libro son: fundamentos de diseño orientado a objetos, implementación de

herencia y polimorfismo, manejo de excepciones, multihilo y persistencia, Java en Internet, recolección de basura, paquetes Java, diseño por reutilización: composición, herencia, interfaces y clases internas, arrays y contenedores de clases, clases de E/S Java, programación de redes con sockets, JDBC para bases de datos, JSPs (JavaServer Pages), RMI, CORBA, EJBs (Entesorpresa

JauaBeans) y Jini, JNI (Java Native Interface).

xxviii Piensa en Java

El excelente y extenso contenido hacen al libro idóneo para la preparación de cursos de nivel medio

y avanzado de programación, tanto a nivel universitario como profesional. Asimismo, por el enfoque

Masivamente profesional que el autor da al libro, puede ser una herramienta muy útil como referencia básica o complementaria para preparar los exámenes de certificación Java que la casa Sun

Microsystems otorga tras la superación de las correspondientes pruebas. Esta característica es una

valor añadido muy importante, al facilitar considerablemente al lector interesado las directrices técnicas necesarias para la preparación de la citada certificación.

Recursos gratuitos en línea

Si las características citadas anteriormente son de por sí lo suficientemente atractivas para la lectura del libro, es sin duda el excelente sitio en Internet del autor otro valor añadido difícil de medir,

por no decir inmedible y valiosísimo. La generosidad del autor -y, naturalmente, de Pearson-, que

ofrece a cualquier lector, sin necesidad de compra previa, todo el contenido en línea, junto a las frecuentes revisiones de la obra y soluciones a ejercicios seleccionados, con la posibilidad de descargarse gratuitamente todo este inmenso conocimiento incluido en el libro, junto al conocimiento complementario ofertado (ejercicios, revisión, actualizaciones...), hacen que esta experiencia sea innovadora

del autor digna de los mayores agradecimientos por parte del cuerpo de programadores noveles o

profesionales de cualquier lugar del mundo donde se utilice Java (que hoy es prácticamente "todo

el mundo mundial", que dirían algunos periodistas).

De igual forma es de agradecer el CD kOM que acompaña al libro y la oferta de un segundo CD.

gratuito que se puede conseguir siguiendo las instrucciones incluidas en el libro con el texto completo de la versión original en inglés y un gran número de ejercicios seleccionados resueltos y recursos Java de todo tipo.

Para facilitar al lector el uso del CD ROM incluido en el libro, el equipo de revisión técnica ha realizado el Apéndice E: Correspondencias español-inglés de clases, bases de datos, tablas y campos del CD.

ROM que acompaña al libro, a fin de identificar el nombre asignado en la traducción al español, con

el nombre original en inglés de dichas clases.

Unas palabras todavía más elogiosas

Para las personas que, como el autor de este prólogo, llevamos muchos años (ya décadas) dedicándonos a programar computadoras, enseñar a programar y escribir sobre programación, un libro.

como éste sólo nos trae pensamientos elevados y elogiosos. Consideramos que es un libro magnífico, maduro, consistente, intelectualmente honesto, bien escrito y preciso. Sin duda, como lo demuestra su larga lista de premios y sus numerosas y magníficas cualidades, Piensa en Java, no sólo

es una excelente obra para aprender y llegar a dominar el lenguaje Java y su programación, sino

También una excelente obra para aprender y dominar las técnicas modernas de programación.

Luis Joyanes Aguilar

Director del Departamento de Lenguajes y Sistemas Informáticos e Zngeniená de Software

Universidad Pontificia de Salamanca campus Madrid

comentarios los lectores

Mucho mejor que cualquier otro libro de Java que haya visto. Esto se entiende "en orden de magnitud"... muy completo, con ejemplos directos y al grano, excelentes e inteligentes, sin embarullarse, lleno de explicaciones.... En contraste con muchos otros libros de Java lo encontró inusualmente maduro, consistente, intelectualmente honesto, bien escrito y preciso. En mi honesta opinión,

Un libro ideal para estudiar Java. Anatoly Vorobey, Universidad Technion, Haifa, Israel.

Uno de los mejores tutoriales de programación, que he visto en cualquier lenguaje. Joakim Ziegler,

REPARAR el operador del sistema.

Gracias por ese libro maravilloso, maravilloso en Java. Dr. Gavin Pillary, Registrador, King

Hospital Eduard VI11, Suráfrica.

Gracias de nuevo por este maravilloso libro. Yo estaba completamente perdido (soy un programador que no viene de C) pero tu libro me ha permitido avanzar con la misma velocidad con la que lo

él leyó. Es verdaderamente fácil entender los principios básicos y los conceptos desde el principio, en vez de tener que intentar construir todo el modelo conceptual mediante prueba y error.

Afortunadamente podré asistir a su seminario en un futuro no demasiado lejano. Randa11 R. Hawley, técnico de automatización, Eli Lilly & Co.

El mejor libro escrito de computadoras que haya visto jamás. Tom Holanda.

Éste es uno de los mejores libros que he leído sobre un lenguaje de programación... El mejor libro

sobre Java escrito jamás. Revindra Pai, Oracle Corporation, línea de productos SUNOS.

¡Éste es el mejor libro sobre Java que haya visto nunca! Ha hecho un gran trabajo. tu profundidad

es sorprendente. Compraré el libro en cuanto se publique. He estado aprendiendo Java desde octubre

del 96. He leído unos pocos libros y considerael tuyo uno que "SE DEBE LEER". En estos últimos

meses nos hemos centrado en un producto escrito totalmente en Java. Tu libro ha ayudado a consolidar algunos temas en los que andábamos confusos y ha ampliado mi base de conocimientos. Incluso el

usado algunos de tus ejemplos y explicaciones como información en mis entrevistas para ayudar al

equipo. He averiguado el conocimiento de Java que tienen preguntándoles por algunas de las cosas.

que he aprendido a partir de la lectura de tu libro (por ejemplo, la diferencia entre arrays y Vectores).

¡El libro es genial! Steve Wilkinson, especialista senior en personal, MCI Telecommunications.

Gran libro. El mejor libro de Java que he visto hasta la fecha. Jeff Sinlair, ingeniero de software, Kestral Computing.

Gracias por Piensa en Java. Ya era hora de que alguien fuera más allá de una mera descripción del

lenguaje para lograr un tutorial completo, penetrante, impactante y que no se centra en los fabricantes. He leído casi todos los demás -y sólo el tuyo y el de Patrick Winston han encontrado un lugar en mi corazón. Se lo estoy recomendando ya a los clientes. Gracias de nuevo. Richard Brooks,

consultor de Java, Sun Professional Services, Dallas.

Otros libros contemplan o abarcan el QUÉ de Java (describiendo la sintaxis y las bibliotecas) o el

CÓMO de Java (ejemplos de programación práctica). Piensa en Jaual es el único libro que conoce

' Thinking in Java (título original de la obra en inglés).

xxx Piensa en Java

co que explica el PORQUÉ de Java; por qué se diseñó de la manera que se hizo, por qué funciona

como lo hace, por qué en ocasiones no funciona, por qué es mejor que C++, por qué no lo es. Aunque hace un buen trabajo de enseñanza sobre el qué y el cómo del lenguaje, Piensa en Java es la

elección definitiva que toda persona interesada en Java tiene de hacer. Robert S. Stephenson.

Gracias por escribir un gran libro. Cuanto más lo leo más me gusta. A mis estudiantes también les

gusta. Chuck Iverson.

Sólo quiero comentar tu trabajo en Piensa en Java. Es la gente como tú la que dignifica el futuro

de Internet y simplemente quiero agradecerte el esfuerzo. Patrick Barrell, responsable de red

Mamco, QAF M@. Cª

La mayoría de los libros de Java que existen están bien para empezar, y la mayoría tienen material para

principiantes y muchos los mismos ejemplos. El tuyo es sin duda el mejor libro y más avanzado para

Pensar que he visto nunca. ¡Por favor, publícalo rápido! ... También compré Thinking in C++ simplemente por lo impresionado que me dejó Piensa en Java. George Laframboise, LightWorx Technology Consulting Inc.

Te escribí anteriormente con mis impresiones favorables relativas a Piensa en Java (un libro que empieza prominentemente donde hay que empezar). Y hoy que he podido medirme con Java con tu libro electrónico en mi mano virtual, debo decir (en mi mejor Chevy Chase de Modern Problems)

"¡Me gusta!". Muy informativo y explicativo, sin que parezca que se lee un texto sin sustancia. Cubres los aspectos más importantes y menos tratados del desarrollo de Java: los porqués. sean

Brady.

Tus ejemplos son claros y fáciles de entender. Tuviste cuidado con la mayoría de los detalles importantes de Java que no pueden encontrarse fácilmente en la débil documentación de Java. Y no malgastas el tiempo del lector con los hechos básicos que todo programador conoce. Kai Engert, Software Innovador, Alemania.

Soy un gran fan de Piensa en Java y lo he recomendado a mis asociados. A medida que avanzamos por

la versión electrónica de tu libro de Java, estoy averiguando que ha retenido el mismo alto nivel de

escritura. Peter R. Neuvald.

Un libro de Java MW BIEN escrito... Pienso que has hecho un GRAN trabajo con él. Como líder

de un grupo de interés especial en Java del área de Chicago, mencionó de forma favorable tu

libro y sitio web muy frecuentemente en mis últimas reuniones. Me gustaría usar Piensa en Java

como la base de cada reunión mensual del grupo, para poder ir repasando y discutiendo sucesivamente cada capítulo. Marcos Ertes.

Verdaderamente aprecio tu trabajo, y tu libro es bueno. Lo recomiendo aquí a nuestros usuarios y

estudiantes de doctorado. Hughes Leroy // Irisa-Inria Rennes Francia, jefa de Computación

Científica y Transferencia Industrial.

De acuerdo, sólo he leído unas 40 páginas de Piensa en Java, pero ya he averiguado que es el libro

de programación mejor escrito y más claro que haya visto jamás... Yo también soy escritor, por lo

Que probablemente soy un poco crítico. Tengo Piensa en Java encargado y ya no puedo esperar

más -soy bastante nuevo en temas de programación y no hago más que enfrentarme a curvas de

Comentarios de los lectores xxxi

aprendizaje en todas partes. Por tanto, esto no es más que un comentario rápido para agradecerte.

este trabajo tan excelente. Ya me había empezado a querer de tanto navegar por tanta y tanta prosa

de tantos y tantos libros de computadores - muchos incluso que venían con magníficas recomendaciones. Me siento muchísimo mejor ahora. Glenn Becker, EducadorAsociación Nacional de Teatro.

Gracias por permitirme disponer de este libro tan maravilloso. Lo he encontrado inmensamente útil

en el entendimiento final de lo que he experimentado -algo confuso anteriormente- con Java y

C++. Leer tu libro ha sido muy gratificante. Felix Bizaoui, Twin Oaks Industnes, Luisa, Virginia.

Debo felicitarte por tu excelente libro. He decidido echar un vistazo a Piensa en Java guiado por mi

experiencia en Thinking in C++, y no me ha defraudado. Jaco van der Merwe, especialista en software, DataFusion Systems Ltd., Steíienbosch, Suráfnca.

Este libro hace que todos los demás libros de Java que he leído parezcan un insulto o sin duda inútiles. 13rett g Porter, programador senior, Arte y Lógica.

He estado leyendo tu libro durante una semana o dos y lo he comparado con otros libros de Java

que leyó anteriormente. Tu libro parece tener un gran comienzo. He recomendado este libro a

muchos de mis amigos y todos ellos lo han calificado de excelente. Por favor, acepta mis felicitaciones por escribir un libro tan excelente. Rama Krishna Bhupathi, Ingeniería de Software, TCSI

Corporación, San José.

Simplemente quería decir lo "brillante" que es tu libro. Lo he estado usando como referencia principal durante mi trabajo de Java hecho en casa. He visto que la tabla de contenidos es justo la más

adecuada para localizar rápidamente la sección que se requiere en cada momento. También es genial ver un libro que no es simplemente una compilación de las API o que no trata al programador.

como un monigote. Grant Sayer, líder del grupo de componentes Java, Ceedata Systems Pty

Ltd., Australia.

~Gu~u! Un libro de Java profundo y legible. Hay muchos libros pobres (y debo admitir también que

un par de ellos buenos) de Java en el mercado, pero por lo que he visto, el tuyo es sin duda uno de

los mejores. John Root, desarrollador web, Departamento de la Seguridad Social, Londres.

*Acabo* de empezar Piensa en Java. Espero que sea bueno porque me gustó mucho Thinking in

C++ (que leí como programador ya experimentado en C++, intenté adelantarme a la curva de

aprendizaje). En parte estoy menos habituado a Java, pero espero que el libro me satisfaga igualmente. Eres un autor maravilloso. Kevin K. Lewis, tecnólogo, ObjectSpace Inc.

Creo que es un gran libro. He aprendido todo lo que sé de Java a partir de él. Gracias por hacerlo

disponible gratuitamente a través de Internet. Si no lo hubieras hecho no sabría nada de Java. pero

lo mejor es que tu libro no es un mero folleto publicitario de Java. También muestra sus lados negativos. TÚ has hecho aquí un gran trabajo. FrederikFix, Bélgica.

Siempre me han enganchado tus libros. Hace un par de años, cuando quería empezar con C++, fue

C++ Inside & Out el que me introdujo en el fascinante mundo de C++. Me ayudó a disponer de mejores oportunidades en la vida. Ahora, persiguiendo más conocimiento y cuando quería aprender.

Java, me introduje en Piensa en Java -sin dudar de que gracias a él ya no necesitaría ningún otro

libro. Simplemente fantástico. Es casi como volver a descubrirme a mí mismo a medida que avanza.

xxxii Piensa en Java

en el libro. Apenas hace un mes que he empezado con Java y mi corazón late gracias a ti. Ahora lo

entiendo todo mucho mejor. Anand Kumar S., ingeniero de Software Computervision, India.

Tu libro es una introducción general excelente. Peter Robinson, Universidad de Cambridge,

Laboratorio de Computación.

Es con mucho el mejor material al que he tenido acceso al aprender Java y simplemente quería que

supieras la suerte que he tenido de poder encontrar. ¡GRACIAS! Chuck Peterson, líder de producto, línea de productos de Internet, MS International.

Este libro es genial. Es el tercer libro de Java que empezó y ya recorrió prácticamente dos

tercios. Espero acabar éste. Me he enterado de su existencia porque se usa en algunas clases internas de Lucen Technologies y un amigo me ha dicho que el libro estaba en la Red. Buen trabajo.

Jerry Nowlin, M13, Tecnologías Lucent.

De los aproximadamente seis libros de Java que he acumulado hasta la fecha, tu Piensa en Java es

sin duda el mejor y el más claro. Michael Van Waas, médico, presidente, TMR Associates.

Simplemente quiero darte las gracias por Piensa en Java. ¡Qué libro tan maravilloso ha hecho! iY

¡Para qué mencionar el poder bajárselo gratis! Como estudiante creo que tus libros son de valor incalculable, tengo una copia de C++ Inside & Out, otro gran libro sobre C++), porque no sólo me enseñan el cómo hacerlo, sino que también los porqués, que sin duda son muy importantes a la hora

de sentar unas buenas bases en lenguajes como C++ y Java. Tengo aquí bastantes amigos a los que

les encanta programar como a mí, y les he hablado de tus libros. ¡Todos piensan que son geniales!

Por cierto, soy indonesia y vivo en Java. Ray Frederick Djajadinata, estudiante de la Universidad Trisakti, Yakarta.

El mero hecho de que hayas hecho que este trabajo esté disponible gratuitamente en la Red me deja

conmocionado. Pensé que debía decirte cuánto aprecio yrespeto lo que estás haciendo. Shane KeBouthillier, estudiante de Ingeniería en Informática, Universidad de Alberta, Canadá.

Tengo que decirte cuánto ansío leer tu columna mensual. Como novato en el mundo de la programación orientada a objetos, aprecio el tiempo y el grado de conocimiento que aportas en casi todos.

los temas elementales. He descargado tu libro, pero puedes apostar a que compraré una copia en

papel en cuanto se publique. Gracias por toda tu ayuda. Dan Cashmer, DC Ziegler & Co.

Simplemente quería felicitarte por el buen trabajo que has hecho. Primero me recorri la versión PDF

de Piensa en Java. Incluso antes de acabar de leerla, corrí a la tienda y compré Thinking in C++. Ahora que llevo en el negocio de la informática ocho años, como consultor, ingeniero de software, profesor/formador, y últimamente autónomo, creo que puedo decir que he visto suficiente (fíjate que no

digo haber visto "todo" sino suficiente). Sin embargo, estos libros hacen que mi novia me llame

"geek. No es que tenga nada contra el concepto en sí -simplemente pensaba que ya había dejado

atrás esta fase. Pero me veo a mí mismo disfrutando sinceramente de ambos libros, de una forma que

no había sentido con ningún otro libro que haya tocado o comprado hasta la fecha. Un estilo de escritura excelente, una introducción genial de todos los temas y mucha sabiduría en ambos textos.

Bien hecho. Simon Goland, simonsez@smartt.com, Simon Says Consulting, Inc.

Comentarios de los lectores xxxiii

¡Debo decir que tu Piensa en Java es genial! Es exactamente el tipo de documentación que buscaba. Especialmente las secciones sobre los buenos y malos diseños basados en Java. Dirk Dühr,

Lexikon Verlag, Bertelsmann AG, Alemania.

Gracias por escribir dos grandes libros (Thinking in C++, Piensa en Java). Me ha ayudado inmensamente en mi progresión en la programación orientada a objetos. Donald Lawon, Empresas DCL.

Gracias por tomarte el tiempo de escribir un libro de Java que ayuda verdaderamente. Si enseñas

hace que aprendas algo, tú ya debes estar más que satisfecho. Dominic Turner, soporte de GEAC.

Es el mejor libro de Java que he leído jamás -y he leído varios. Jean-Yves MENGANT, Jefe

Arquitecto de Software NAT-SYSTEM, París, Francia.

Piensa en Java proporciona la mejor cobertura y explicación. Muy fácil de leer, y quiero decir que

esto se extiende también a los fragmentos de código. Ron Chan, Ph. D., Expert Choice Ind.,

Pittsburg PA.

Tu libro es genial. He leído muchos libros de programación y el tuyo sigue añadiendo luz a la programación en mi mente. Ningjian Wang, ingeniero de sistemas de información, The Vanguard Group.

Piensa en Java es un libro excelente y legible. Se lo recomiendo a todos mis alumnos. doctor pablo

Gorman, Departamento de Ciencias de la Computación, Universidad de Otago, Dunedin, Nueva Zelanda.

Haces posible que exista el proverbial almuerzo gratuito, y no simplemente una comida basada en

sopa de pollo, sino una delicia de gourmet para aquellos que aprecian el buen software y los libros.

sobre él mismo. José Suriol, Corporación Scylax.

¡Gracias por la oportunidad de ver cómo este libro se convierte en una obra maestra! ES EL MEJOR libro de la materia que he leído o recorrido. Jeff Lapchinsky, programador, Net Result

Tecnologías.

Tu libro es conciso, accesible y gozoso de leer. Keith Ritchie, Investigación y desarrollo de Java

Equipo, KL Group Inc.

¡ES sin duda el mejor libro de Java que leyó! Daniel Ing.

¡ES el mejor libro de Java que he visto! Rich Hoffarth, arquitecto senior, West Group.

Gracias por un libro tan magnífico. Estoy disfrutando mucho a medida que leo capítulos. fred

Trimble, Actium Corporation.

Has llegado a la maestría en el arte de hacernos ver los detalles, despacio y con éxito. Haces que la

La lectura es MUY fácil y satisfactoria. Gracias por un tutorial tan verdaderamente maravilloso. Rajesh Rau, consultor de software.

¡Piensa en Java es un rock para el mundo libre! Miko O'Sullivan, presidente, Idocs Inc.

xxxiv Piensa en Java

Sobre pensar en C++:

¡El mejor libro! Ganador en 1995 del Jolt Award de la revista Software Development!

"Este libro es un tremendo logro. Deberías tener una copia en el estante. El capítulo sobre flujos

de E/S presenta el tratamiento más comprensible y fácil de entender sobre ese tema que jamás haya haya

visto."

Al Stevens

Editor, Revista Doctor Dobbs

"El libro de Eckel es el único que explica claramente cómo replantearse la construcción de programas para la orientación a objetos. Que el libro es también un tutorial excelente en las entradas y en

las salidas de C++ es un valor agregado."

Andres Binstock

Editor, revisión de Unix

"Bruce continúa deleitándome con esta introspección de C++, y Thinking in C++ es la mejor colección de ideas hasta la fecha. Si se desean respuestas rápidas a preguntas difíciles sobre C++, compre este libro tan sobresaliente."

Gary Entsminger

Autor, El Tao de los Objetos

"Thinking in C++" explora paciente y metódicamente los aspectos de cuándo y cómo usar los interlineado~, referencias, sobrecargas de operadores, herencia, y objetos dinámicos, además de temas

avanzados como el uso adecuado de plantillas, excepciones y la herencia múltiple. Todo el esfuerzo

se centra en un producto que engloba la propia filosofía de Eckel del diseño de objetos y programas.

Un libro que no debe faltar en la librería de un desarrollador de C++, Piensa en Jaua es el libro de

C++ que hay que tener si se están haciendo desarrollos serios con C++."

Richard Hale Shaw

Ayudante del Editor, Revista PC

Introducción

Como cualquier lenguaje humano, Java proporciona una forma de expresar conceptos. Si tiene éxito, la expresión media será significativamente más sencilla y

más flexible que las alternativas, a medida que los problemas crecen en tamaño

y complejidad.

No podemos ver Java como una simple colección de características -algunas de las características

no tienen sentido aislado. Se puede usar la suma de partes sólo si se está pensando en diseño, y no

simplemente en codificación. Y para entender Java así, hay que entender los problemas del lenguaje y de la programación en general. Este libro habla acerca de problemas de programación, por qué

son problemas y el enfoque que Java sigue para solucionarlos. Por consiguiente, algunas características que explícitas en cada capítulo se basan en cómo yo veo que se ha solucionado algún problema en particular con el lenguaje. Así, espero conducir poco a poco al lector, hasta el punto en que

Java se convierte en lengua casi materna.

Durante todo el tiempo, estará tomando la actitud de que el lector construye un modelo mental que

le permitirá desarrollar un entendimiento profundo del lenguaje; si se encuentra un rompecabezas se podrá

alimentar de éste al modelo para tratar de deducir la respuesta.

Prerrequisitos

Este libro asume que se tiene algo de familiaridad con la programación: se entiende que un programa es una colección de sentencias, la idea de una subrutina/función/macro, sentencias de control como "ir' y bucles estilo " while ", etc. Sin embargo, se podría haber aprendido esto en muchos

sitios, como, por ejemplo, la programación con un lenguaje de macros o el trabajo con una herramienta como Perl. A medida que se programa hasta el punto en que uno se siente cómodo con las

Ideas básicas de programación, se podrá ir trabajando a través de este libro. Por supuesto, el libro

Será más fácil para los programadores de C y aún más para los de C++, pero tampoco hay por qué.

excluirse a sí mismo cuando se desconocen estos lenguajes (aunque en este caso es necesario tener la voluntad de trabajar duro; además, el CD multimedia que acompaña a este texto te permitirá

conocer rápidamente los conceptos de la sintaxis de C necesarios para aprender Java). presentaré

los conceptos de la programación orientada a objetos (POO) y los mecanismos de control básicos

de Java, para tener conocimiento de ellos, y los primeros ejercicios implicarán las secuencias de flujo de control básico.

Aunque a menudo aparecerán referencias a aspectos de los lenguajes C y C++, no deben tomarse

como comentarios profundos, sino que tratan de ayudar a los programadores a poner Java en perspectiva con esos lenguajes, de los que, después de todo, es de los que desciende Java. Intentaré hacer que estas referencias sean lo más simples posibles, y explicar cualquier cosa que cree que una

persona que no haya programado nunca en C o C++ pueda desconocer.

xxxvi Piensa en Java

Aprendiendo Java

Casi a la vez que apareció mi primer libro Usando C++ (Osborne/McGraw-Hill, 1989), empecé a enseñar ese lenguaje. Enseñar lenguajes de programación se ha convertido en mi profesión; el vio

cabezas dudosas, caras en blanco y expresiones de rompecabezas en audiencias de todo el mundo desde

1989. A medida que empecé con formación in situ a grupos de gente más pequeños, descubre algo

en los ejercicios. Incluso aquelloslos que sonreían tenían pegas con muchos aspectos. Al dirigir la sesión de C++ en la Software Development Conference durante muchos años (y después la sesión de

Java), descubrí que tanto yo como otros oradores tendíamos a ofrecer a la audiencia, en general,

Muchos temas demasiado rápido. Por tanto, a través, tanto de la variedad del nivel de audiencia

como de la forma de presentar el material, siempre se acababa perdiendo parte de la audiencia. Quizás es pedir demasiado, pero dado que soy uno de ésos que se resisten a las conferencias tradicionales (y en la mayoría de casos, creo que esta resistencia proviene del aburrimiento), quería intentar algo que permitiera tener a todo el mundo enganchado.

Durante algún tiempo, creé varias presentaciones diferentes en poco tiempo. Por consiguiente, acabé aprendiendo a base de experimentación e iteración (una técnica que también funciona bien en

un diseño de un programa en Java). Eventualmente, desarrollé un curso usando todo lo que había

Algo que me gustaría hacer durante bastante tiempo. Descompone el problema de aprendizaje en pasos discretos, fáciles de digerir, y en un minutoario en máquina (la situación ideal de aprendizaje) hay ejercicios seguidos cada uno de pequeñas lecciones. Ahora doy cursos en seminarios públicos de Java, que pueden encontrarse en

http://www.BruceEckel.com. (El seminario introductorio también está disponible como un CD

ROM. En el sitio web se puede encontrar más información al respecto.)

La respuesta que voy obteniendo de cada seminario me ayuda a cambiar y reenfocar el material hasta que creo que funciona bien como medio docente. Pero este libro no es simplemente un conjunto

de notas de los seminarios -intenté empaquetar tanta información como pude en este conjunto de

páginas, estructurándola de forma que cada tema te vaya conduciendo al siguiente. Más que otra

cosa, el libro está diseñado para servir al lector solitario que se está enfrentando y dando golpes con

un nuevo lenguaje de programación.

Objetivos

Como en mi libro anterior Thinking in C++, este libro pretende estar estructurado en torno al proceso de enseñanza de un lenguaje. En particular, mi motivación es crear algo que me proporcione.

una forma de enseñar el lenguaje en mis propios seminarios. Cuando pienso en un capítulo del libro, lo pienso en términos de lo que constituiría una buena lección en un seminario. Mi objetivo es

lograr fragmentos que puedan enseñarse en un tiempo razonable, seguidos de ejercicios que sean

Fáciles de llevar a cabo en clase.

Mis objetivos en este libro son:

1. Presentar el material paso a paso de forma que se pueda digerir fácilmente cada concepto antes de avanzar.

Introducción xxxvii

2. Utilizar ejemplos que sean tan simples y cortos como se pueda. Esto evita en ocasiones problemas del "mundo real", pero descubrió que los principiantes suelen estar más.

contentos cuando pueden entender todos los detalles de un ejemplo que cuando se ven impresionados por el gran rango del problema que solucionan. Además, hay una limitación severa de cara a la cantidad de código que se puede absorber en una clase. Por ello, no dudaré

en recibir críticas por usar "ejemplos de juguete", sino que estoy deseoso de aceptarlas en aras

de lograr algo pedagógicamente útil.

3. Secuenciar cuidadosamente la presentación de características de forma que no se esté viendo

algo que aún no se ha expuesto. Por supuesto, esto no es siempre posible; en esas situaciones

sc da11 br-cves descr-ipcioiies iiitr-oductoi-ias.

4. Dar lo que yo considero que es importante que se entienda del lenguaje, en lugar de todo lo

Que se. Creo que hay una jerarquía de importancia de la información, y que hay hechos que

el 95% de los programadores nunca necesitarán saber y que simplemente confunden a la gente y añaden su percepción de la complejidad del lenguaje. Por tomar un ejemplo de C, si se

memoriza la tabla de precedencia de los operadores (algo que yo nunca hice) se puede escribir un código más inteligente. Pero si se piensa en ello, también confundirá la legibilidad y

mantenibilidad de ese código. Por tanto, hay que olvidarse de la precedencia, y usar paréntesis cuando las cosas no estén claras.

5. Mantener cada sección lo suficientemente enfocada de forma que el tiempo de exposición

-el tiempo entre periodos de ejercicios- sea pequeño. Esto no sólo mantiene más activas

las mentes de la audiencia, que están en un seminario en máquina, sino que también transmiten más sensación de avanzar.

6. Proporcionar una base sólida que permita entender los aspectos lo suficientemente bien como

para avanzar a cursos y libros más difíciles.

Documentación en línea

El lenguaje Java y las bibliotecas de Sun Microsystems (de descarga gratuita) vienen con su documentación en forma electrónica, legible utilizando un navegador web, y casi toda la implementación de

Java de un tercero tiene éste u otro sistema de documentación equivalente. Casi todos los libros publicados de Java, incorporan esta documentación. Por tanto, o ya se tiene, o se puede descargar, y a

menos que sea necesario, este libro no repetirá esa documentación pues es más rápido encontrar

las descripciones de las clases en el navegador web que buscarlas en un libro Cy la documentación

en línea probablemente estará más actualizado). Este libro proporcionará alguna descripción adicional.

de las clases sólo cuando sea necesario para complementar la documentación, de forma que se pueda entender algún ejemplo particular.

xxxviii Piensa en Java

Capítulos

Este libro se diseñó con una idea en la cabeza: la forma que tiene la gente de aprender Java. La realización de la audiencia de mis seminarios me ayudó a ver las partes difíciles que necesitaban.

aclaraciones. En las áreas en las que me volvía ambiguo e incluían varias características a la vez, descubrí -a través del proceso de presentación el material- que si se incluyen muchas características de

golpe, hay que explicarlas todas, y esto suele conducir fácilmente a la confusión por parte del alumno. Como resultado, tuvo bastantes problemas para presentar las características agrupadas de

tan pocas en pocas como me hasido posible.

El objetivo, por tanto, es que cada capítulo enseña una única característica, o un pequeño grupo de

características asociadas, sin pasar a características adicionales. De esa forrria se puede diger-ir- cada

fragmento en el contexto del conocimiento actual antes de continuar.

He aquí una breve descripción de los capítulos que contiene el libro, que corresponden a las conferencias y periodos de ejercicio en mis seminarios en máquina.

Capítulo 1: Introducción a los objetos

Este capítulo presenta un repaso de lo que es la programación orientada a objetos, incluyendo la respuesta a la cuestión básica "¿Qué es un objeto?", interfaz frente a implementación, abstracción y

encapsulación, mensajes y funciones, herencia y composición, y la importancia del polimorfismo.

También se obtendrá un repaso a los aspectos de la creación de objetos como los constructores, en

los que residen los objetos, dónde ponerlos una vez creados, y el mágico recolector de basura que

limpie los objetos cuando dejan de ser necesarios. Se presentarán otros aspectos, incluyendo el manejo de errores con excepciones, el multihilo para interfaces de usuario con buen grado de respuesta, y las redes e Internet. Se aprenderá qué convierte a Java en especial, por qué ha tenido tanto éxito, y también algo sobre análisis y diseño orientado a objetos.

Capítulo 2: Todo es un objeto

Este capítulo te lleva al punto donde tú puedas crear el primer programa en Java, por lo que debes dar

un repaso a lo esencial, incluyendo el concepto de referencia a un objeto; cómo crear un objeto; una

introducción de los tipos primitivos y arrays; el alcance y la forma en que destruye los objetos el recolector de basura; cómo en Java todo es un nuevo tipo de datos (clase) y cómo crear cada uno sus

clases propias; funciones, argumentos y valores de retorno; visibilidad de nombres y el uso de componentes de otras bibliotecas; la palabra clave estática; y los comentarios y documentación embebida.

Capítulo 3: Controlando el flujo

de los programas

Este capítulo comienza con todos los operadores que provienen de C y C++. Además, se descubrirán los fallos de los operadores comunes, la conversión de tipos, la promoción y la precedencia. Des-

Introducción xxxix

pués se presentan las operaciones básicas de control de flujo y selección existentes en casi todos los

lenguajes de programación: la opción con if-else; los bucles con while y for; cómo salir de un bucle

con break y continue, además de sus versiones etiquetadas en Java (que vienen a sustituir al "goto

perdido" en Java); la selección con switch. Aunque gran parte de este material tiene puntos comunes con el código de C y C++, hay algunas diferencias. Además, todos los ejemplos serán hechos

completamente en Java por lo que el lector podrá estar más entusiasmado con la apariencia de Java.

Capítulo 4: Inicialización y limpieza

Este capítulo comienza presentando el constructor, que garantiza una inicialización adecuada. La definición de constructor conduce al concepto de sobrecarga de funciones (puesto que puede haber

varios constructores). Este viene seguido de una discusión del proceso de limpieza, que no siempre

es tan simple como parece. Normalmente, simplemente se desecha un objeto cuando se ha terminado con él y el recolector de basura suele aparecer para liberar la memoria. Este apartado explora el

recolector de basura y algunas de sus idiosincrasias. El capítulo concluye con un vistazo más cercano a cómo se inicializan las cosas: inicialización automática de miembros, especificación de inicialización de miembros, el orden de inicialización, la inicialización estática y la inicialización de

matrices.

Capítulo Ocultando implementación

Este capítulo cubre la forma de empaquetar junto al código, y por qué algunas partes de una biblioteca están expuestas a la vez que otras partes están ocultas. Comienza repasando las palabras.

clave package e import, que llevan a cabo empaquetado a nivel de archivo y permiten construir bibliotecas de clases. Después de examinar el tema de las rutas de directorios y nombres de fichero. el

resto del capítulo echa un vistazo a las palabras clave public, private y protected, el concepto de

acceso "friendly", y qué significan los distintos niveles de control de acceso cuando se usan en los

conceptos distintos.

Capítulo 6: clases

El concepto de herencia es estándar en casi todos los lenguajes de POO. Es una forma de tomar una

clase existente y añadirla a su funcionalidad (además de cambiarla, que será tema del Capítulo 7).

La herencia es a menudo una forma de reutilizar código dejando igual la "clase base", y simplemente

parcheando los elementos aquí y allí hasta obtener lo deseado. Sin embargo, la herencia no es la

única forma de construir clases nuevas a partir de las existentes. También se puede empotrar un objeto dentro de una clase nueva con la composición. En este capítulo, se aprenderán estas dos formas.

de reutilizar código en Java, y cómo aplicarlas.

Capítulo 7: Polimorfismo

Cada uno por su cuenta, podría invertir varios meses para descubrir y entender el polimorfismo, claves en POO. A través de pequeños ejemplos simples, verás cómo crear una familia de tipos con

xl Piensa en Java

herencia y manipular objetos de esa familia a través de su clase base común. El polimorfismo de

Java permite tratar los objetos de una misma familia de forma genérica, lo que significa que la mayoría del código no tiene por qué depende de un tipo de información específica. Esto hace que los

los programas sean extensibles, por lo que se facilita y simplifica la construcción de programas y el

mantenimiento de código.

Capítulo 8: Interfaces y clases internas

Java proporciona una tercera forma de establecer una relación de reutilización a través de la interfaz, que es una abstracción pura de la interfaz de un objeto. La interfaz es más que una clase simple.

abstracta llevada al extremo, puesto que te permite hacer variaciones de la "herencia múltiple" de

C++, creando una clase sobre la que se puede hacer una conversión hacia arriba a más de una clase base.

A primera vista, las clases parecen un simple mecanismo de ocultación de código: se colocando clases

dentro de otras clases. Se aprenderá, sin embargo, que la clase interna hace más que eso -conoce

y puede comunicarse con la clase contenedora- y que el tipo de código que se puede escribir con

clases internas es más elegante y limpio, aunque es un concepto nuevo para la mayoría de la gente

y lleva tiempo llegar a estar cómodo utilizando el diseño clases internas.

Capítulo 9: Guardando tus objetos

Es un programa bastante simple que sólo tiene una cantidad fija de objetos de tiempo de vida conocido. En general, todos los programas irán creando objetos nuevos en distintos momentos, conocidos sólo cuando se está ejecutando el programa. Además, no se sabrá hasta el tiempo de ejecución.

la cantidad o incluso el tipo exacto de objetos que se necesitan. Para solucionar el problema de programación general, es necesario crear cualquier número de objetos, en cualquier momento y en

cualquier lugar. Este capítulo explora en profundidad la biblioteca de contenedores que proporciona Java 2 para almacenar objetos mientras se está trabajando con ellos: los simples arrays y contenedores más selectos (estructuras de datos) como ArrayList y HashMap.

Capítulo 10: Manejo de errores

con excepciones

La filosofía básica de Java es que el código mal formado no se ejecutará. En la medida en que sea

posible, el compilador detecta problemas, pero en ocasiones los problemas -debidos a errores del

programador o a condiciones de error naturales que ocurren como parte de la ejecución normal del

programa- pueden detectarse y ser gestionados sólo en el tiempo de ejecución. Java tiene el manejo

de excepciones para tratar todos los problemas que puedan surgir al ejecutar el programa. Este capítulo muestra cómo funcionan en Java las palabras clave try, catch, throw, throws y finalmente; cuando

se deben lanzar excepciones y qué hacer al capturarlas. Además, se verán las excepciones estándar de Java, cómo crear las tuyas propias, qué ocurre con las excepciones en los constructores y

cómo se ubican los gestores de excepciones.

Introducción xli

Capítulo 11: El sistema de E/S de Java

Teóricamente, se puede dividir cualquier programa en tres partes: entrada, proceso y salida. esto

implica que la E/S (entrada/salida) es una parte importante de la ecuación. En este capítulo se

Aprenderá las distintas clases que proporciona Java para leer y escribir ficheros, bloques de memoria y la consola. También se mostrará la distinción entre E/S "antigua" y "nueva". Además, este capítulo examina el proceso de tomar un objeto, pasarlo a una secuencia de bytes (de forma que pueda ser ubicado en el disco o enviado a través de una red) y reconstruirlo, lo que realiza.

serialización automática de objetos de Java. Además, se examinan las bibliotecas de compresión de Java, que se usan en el formato de archivos de Java CJAR).

Capítulo 12: Identificación de tipos en tiempo

de ejecución

La identificación de tipos en tiempo de ejecución (RTTI) te permite averiguar el tipo exacto de un

objeto cuando se tiene sólo una referencia al tipo base. Normalmente, se deseará ignorar intencionadamente el tipo exacto de un objeto y dejar que sea el mecanismo de asignación dinámica de Java.

(polimorfismo) el que implementa el comportamiento correcto para ese tipo. A menudo, esta información te permite llevar a cabo operaciones de casos especiales, más eficientemente. Este capitulo

Explica para qué existe la RTTI, cómo usarla y cómo librarse de él cuando sobra. Además, este capítulo presenta el mecanismo de reflectividad de Java.

Capítulo 13: Creación de ventanas y applets

Java viene con la biblioteca IGU Swing, que es un conjunto de clases que manejan las ventanas de

formato portátil. Estos programas con Windows pueden o bien ser applets o bien aplicaciones independientes. Este capítulo es una introducción a Swing y a la creación de applets de World Wide

Web. Se presenta la importante tecnología de los "JavaBeansn, fundamental para la creación de herramientas de construcción de programas de Desarrollo Rápido de Aplicaciones (RAD).

Capítulo 14: Hilos Múltiples

Java proporciona una utilidad preconstruida para el soporte de múltiples subtareas concurrentes denominadas hilos, que se ejecutan en un único programa. (A menos que se disponga de Múltiples procesadores en la máquina, los Múltiples hilos sólo son aparentes.) Aunque éstas pueden usarse en todas partes, los hilos son más lucidos cuando se intenta crear una interfaz de usuario con alto grado

de respuesta, de forma que, por ejemplo, no se evita que un usuario pueda presionar un botón o introducir datos mientras se está llevando a cabo algún procesamiento. Este capítulo echa un vistazo.

a la sintaxis y la semántica del multihilo en Java.

xlii Piensa en Java

Capítulo 15: Computación distribuida

Todas las características y bibliotecas de Java aparecen realmente cuando se empieza a escribir programas que funcionan en red. Este capítulo explora la comunicación a través de redes e Internet, y

las clases que proporciona Java para facilitar esta labor. Presenta los tan importantes conceptos de

Serulets y JSP (para programación en el lado servidor), junto con Java DataBase Connectiuity CJDBC)

y el Información de método remoto (RMI). Finalmente, hay una introducción a las nuevas tecnologías de

JINI, JauaSpaces y Enterprise JavaBeans (EJBS).

Apéndice A: Paso y retorno de objetos

Puesto que la única forma de hablar con los objetos en Java es mediante referencias, los conceptos

de paso de objetos a una función y de devolución de un objeto de una función tienen algunas consecuencias interesantes. Este apéndice explica lo que es necesario saber para gestionar objetos.

cuando se está entrando y saliendo de funciones, y también muestra la clase String, que usa un enfoque distinto al problema.

Apéndice B: La Interfaz Nativa de Java (JNI)

Un programa Java totalmente portátil tiene importantes pegas: la velocidad y la incapacidad.

para acceder a servicios específicos de la plataforma. Cuando se conoce la plataforma sobre la

que está ejecutando, es posible incrementar dramáticamente la velocidad de ciertas operaciones

construyendo como métodos nativos, que son funciones escritas en otro lenguaje de programación (actualmente, sólo están soportados C/C++). Este apéndice de una introducción más que

satisfactorio que debería ser capaz de crear ejemplos simples que sirvan de interfaz con código

sin Java.

Apéndice C: Guías de programación Java

Este apéndice contiene sugerencias para guiarle durante la realización del diseño de programas de

bajo nivel y la escritura de código.

Apéndice D: Lecturas recomendadas

Una lista de algunos libros sobre Java que encontró particularmente útiles.

tjercicios

He descubierto que los ejercicios simples son excepcionalmente útiles para completar el entendimiento de los estudiantes durante un seminario, por lo que se encontrará un conjunto de ellos al final de cada capítulo.

Introducción xliii

La mayoría de los ejercicios están diseñados para ser lo suficientemente sencillos como para poder ser

resueltos en un tiempo razonable en una situación de clase mientras que observa al profesor, asegurándose de que todos los alumnos asimilen el material. Algunos ejercicios son más avanzados

para evitar que los alumnos experimentados se aburran. La mayoría están diseñadas para ser resueltas en poco tiempo y probar y pulir el conocimiento. Algunos suponen un reto, pero ninguno

presenta dificultades excesivas. (Presumiblemente, cada uno podrá encontrarlos -o más probablemente te encontrarán ellos a ti.)

En el documento electrónico The Thinking in Java Annotated Solution Guide pueden encontrarse

soluciones a ejercicios seleccionados, disponibles por una pequeña tasa en http://www.BruceEckeI.com.

CD-ROM Multimedia

Hay dos CD multimedia asociados con este libro. El primero está en el propio libro: Thinking in C,

descritos al final del prefacio. que te preparan para el libro aportando velocidad en la sintaxis de C

necesario para poder entender Java.

Hay disponible un segundo CD ROM multimedia, basado en los contenidos del libro. Este CD-ROM

es un producto separado y contiene los contenidos enteros del seminario de formación "Hands-On

Java" de una semana de duración. Esto son grabaciones de conferencias de más de 15 horas que he

grabado, y sincronizado con cientos de diapositivas de información. Dado que el seminario se basa

en este libro, es el acompañamiento ideal.

El CD ROM contiene todas las conferencias (¡con la importante excepción de la atención personalizada!) de los seminarios de cinco días de inmersión total. Creemos que establece un nuevo estándar de calidad.

El CD ROM "Hands-On Java" está disponible sólo bajo pedido, que se cursa directamente del sitio

web http://llwww.BruceEckel.com.

código fuente

Todo el código fuente de este libro está disponible de modo gratuito sometiendo un copyright, distribuido como un paqueteúnico, visitando el sitio web http://www.BruceEcke1.com. Para asegurarse de

obtener la versión más actual, éste es el lugar oficial para distribución del código y de la versión

electronica del libro. Se pueden encontrar versiones espejo del código y del libro en otros sitios (algunos de éstos están referenciados en http://www. BruceEckel.com), pero habría que comprobar el

sitio oficial para asegurarse de obtener la edición más reciente. El código puede distribuirse en clases y en otras situaciones con multas educativas.

La meta principal del copyright es asegurar que el código fuente se cite adecuadamente, y prevenir

que el código se vuelva a publicar en medios impresos sin permiso. (Mientras se cite la fuente, utilizando los ejemplos del libro, no habrá problema en la mayoría de los medios.)

En cada fichero de código fuente, se encontrará una referencia a la siguiente nota de copyright:

xliv Piensa en Java

:! :CopiarDerecho.txt

Copyright (c) 2000 Bruce Eckel

Archivo de código fuente de la segunda edición del libro.

"Pensamiento en Java." Todos los derechos reservados EXCEPTO como

permitido por las siguientes declaraciones:

Puedes utilizar libremente este archivo.

para su propio trabajo (personal o comercial),

incluyendo modificaciones y distribución en

formato ejecutable únicamente. Se concede permiso para utilizar

este archivo en situaciones de aula, incluyendo su

uso en materiales de presentación, siempre y cuando el libro

Se cita como fuente "Thinking in Java".

Excepto en situaciones de aula, no puedes copiar

y distribuir este código; en cambio, la única

El punto de distribución es http://www.BruceEckel.com.

(y sitios espejo oficiales) donde está

disponible de forma gratuita. No puedes eliminar esto

derechos de autor y aviso. No puedes distribuir

versiones modificadas del código fuente en este

paquete. No puede utilizar este archivo en formato impreso.

medios sin el permiso expreso del

autor. Bruce Eckel no hace ninguna declaración sobre

la idoneidad de este software para cualquier propósito.

Se proporciona "tal cual" sin expresa o implícita

garantía de cualquier tipo, incluida cualquier garantía implícita

garantía de comerciabilidad, idoneidad para un

propósito particular o no infracción. La totalidad

riesgo en cuanto a la calidad y desempeño del

El software está contigo. Bruce Eckel y el

El editor no será responsable de ningún daño.

sufrido por usted o cualquier tercero como resultado de

utilizar o distribuir software. En ningún caso

Bruce Eckel o el editor serán responsables de cualquier

pérdida de ingresos, ganancias o datos, o por pérdida directa,

indirecta, especial, consecuente, incidental o

daños punitivos, cualquiera que sea su causa y con independencia de

La teoría de la responsabilidad, que surge del uso de

o incapacidad para utilizar software, incluso si Bruce Eckel

y el editor han sido informados de la

posibilidad de tales daños. ¿Debería el software

resulta defectuoso, usted asume el costo de todo1

servicio, reparación o corrección necesarios. Si usted

cree que ha encontrado un error, envíe el

corrección mediante el formulario que encontrará en

www.BruceEckel.com. (Por favor use el mismo

formulario para errores no relacionados con el código que se encuentran en el libro. )

///:-

Introducción xlv

El código puede usarse en proyectos y en clases (incluyendo materiales de presentación) mientras

se mantenga la observación de copyright que aparece en cada archivo fuente.

Estándares de codificación

En el texto de este libro, los identificadores (nombres de fimciones, variables y clases) están en negrita. La mayoría de las palabras clave también están en negrita, excepto en aquellos casos en que las palabras

se usan tanto que ponerlas en negrita podría volverse tedioso, como es el caso de la palabra "clase".

Para los ejemplos de este libro, utilice un estilo de codificación bastante particular. Este estilo sigue

al estilo que la propia Sun usa en prácticamente todo el código de sitio web (ver

http://]ava.sun.com/docs/codeconv/index.html), y parece que es1á suprimido por la mayoría de entornos de desarrollo Java. Si ha leído el resto de mis trabajos, también verá que el estilo de codificación de Sun coincide con el mío -esto me alegra, aunque no tenía nada que hacer con él. El aspecto del estilo de formato es bueno para lograr horas de tenso debate, por lo que simplemente diré

que no pretendo dictar un estilo correcto mediante mis ejemplos; tengo mi propia motivación para

usar el estilo que uso. Java es un lenguaje de programación de forma libre, se puede seguir usando

cualquier estilo con el que uno esté a gusto.

Los programas de este libro son archivos incluidos por el procesador de textos, directamente sacados de archivos compilados. Por tanto, los archivos de código impresos en este libro deben funcionar sin errores de compilador. Los errores que deben causar mensajes de error en el tiempo de

compilaciones están comentados o marcados mediante //!, por lo que pueden ser descubiertos fácilmente, y probados utilizando medios automáticos. Los errores descubiertos de los que ya se haya

informado al autor, aparecerán primero en el código fuente distribuido y posteriormente en actualizaciones del libro (que también aparecerán en el sitio web http:llwww.BruceEckel.com).

Versiones de Java

Generalmente confío en la implementación que Sun hace de Java como referencia para definir si un

determinado comportamiento es o no correcto.

Con el tiempo, Sun ha lanzado tres versiones principales de Java: la 1.0, la 1.1 y la 2 (que se llama

versión 2, incluso aunque las versiones del JDK de Sun siguen usando el esquema de numeración

de 1.2, 1.3, 1.4, etc.). La versión 2 parece llevar finalmente a Java a la gloria, especialmente en lo que

Concierne a las herramientas de interfaces. Este libro se centra en, y está probado con, Java 2, aunque en ocasiones hago concesiones a las características anteriores de Java 2, de forma que el código pueda compilarse bajo Linux (vía el JDK de Linux que estaba disponible en el momento de escribir el libro).

Si se necesita aprender versiones anteriores del lenguaje no cubiertas en esta edición, la primera

La edición del libro se puede descargar gratuitamente de http:llwww.BruceEckel.corn, y también está en

el CD adjunto a este libro.

xlvi Piensa en Java

Algo de lo que uno se dará cuenta es de que, cuando menciono versiones anteriores del lenguaje,

no utilice los números de subrevisión. En este libro me referiré sólo a Java 1.0, 1.1 y 2, para protegerme de errores tipográficos producidos por sub-revisiones posteriores de estos productos.

Seminarios y mi papel como mentor

Mi empresa proporciona seminarios de formación de cinco días, en máquina, públicos e in situ, basados en el material de este libro. El material determinado de cada capítulo representa una lección, seguido de un período de ejercicios guiados de forma que cada alumno recibe atención personal. Las

Las conferencias y las diapositivas del seminario introductorio también están en el CD ROM para proporcionales al menos alguna de la experiencia del seminario sin el viaje y el costo que conllevaría. Paraca

más información, visitando http:llwww.BruceEckel.corn.

Mi compañía también proporciona consultoría, servicios de orientación y acompañamiento para ayudar a guiar un proyecto a lo largo de su ciclo de desarrollo -especialmente indicado para el primer

proyecto en Java de una empresa.

Errores

Sin que importe cuántos trucos utilice un escritor para detectar errores, siempre hay alguno que se

Ahí queda y que algún lector encontrará.

Hay un formulario para remitir errores al principio de cada capítulo en la versión HTML del libro.

(y en el CD ROM unido al final de este libro, además de descargable de http:llwww.BruceEckel.corn)

y también en el propio sitio web, en la página correspondiente a este libro. Si se descubre algo que

Uno piense que puede ser un error, por favor, utilice el formulario para remitir el error junto con la

corrección sugerida. Si es necesario, incluya el archivo de código fuente original y cualquier modificación que se sugiera. Su ayuda será apreciada.

Nota sobre el diseño de la portada

La portada de Piensa en Java está inspirada en el American Arts & Crafts Movement, que se fundó.

al cambiar de siglo y alcanzó su cenit entre los años 1900 y 1920. Empezó en Inglaterra como una

reacción tanto a la producción de las máquinas de la Revolución Industrial y al estilo victoriano, excesivamente ornamental. Arts & Crafts hacía especial énfasis en el mero diseño, en las formas de la

naturaleza tal y como se ven en el movimiento del Art Nouveau, las manualidades y la importancia

del trabajo individual, y sin embargo sin renunciar al uso de herramientas modernas. Hay muchas

Réplicas con la situación de hoy en día: el cambio de siglo, la evolución de los principios puros de la

revolución de los computadores a algo más refinado y más significativo para las personas individuales, y el énfasis en el arte individual que hay en el software, frente a su simple fabricación.

Veo Java de esta misma forma: como un intento de elevar al programador más allá de la mecánica

de un sistema operativo y hacia el "arte del software".

Introducción xlvii

Tanto el autor como el diseñador del libro/portada (que han sido amigos desde la infancia) encuentran la inspiración en este movimiento, y ambos poseen muebles, lámparas y otros elementos.

que o bien son originales, o bien están inspirados en este período.

El otro tema de la cubierta sugiere una caja de colecciones que podría usar un naturalista para mostrar los especímenes de insectos que ha guardado. Estos insectos son objetos, ubicados dentro de

la caja de objetos. Los objetos caja están a su vez ubicados dentro del "objeto cubierta", que ilustra

el concepto fundamental de la agregación en la programación orientada a objetos. Por supuesto, un

programador no puede ayudar si no está produciendo "errores" en la asociación, y aquí los errores se

han capturado siendo finalmente confinados en una pequeña caja de muestra, como tratando de

mostrar la habilidad de Java para encontrar, mostrar y controlar los errores (lo cual es sin duda uno

de sus atributos más potentes).

Agradecimientos

En primer lugar, gracias a los asociados que han trabajado conmigo para dar seminarios, proporcionar consultoría y desarrollar productos de aprendizaje: Andrea Provaglio, Dave Bastlett (que también contribuyó significativamente al Capítulo 15), Bill Venners y Larry O'Brien. Aprecio tuyo

paciencia a medida que sigo intentando desarrollar el mejor modelo para que tipos tan independientes como nosotros podamos trabajar juntos. Gracias a Rolf André Klaedtke (Suiza); Martín

Vleck, Martin Byer, Vlada & Pavel Lahoda, Martin el Oso, y Hanka (Praga); y a Marco Cantu (Italia) por darme alojamiento durante mi primera gira seminario auto organizado por Europa.

Gracias a la Doyle Street Cohousing Community por soportarme durante los dos años que me llevó

escribir la primera edición de este libro (y por aguantarme en general). Muchas gracias a Kevin y

Sonda Donovan por subarrendarme su magnífico lugar en Creste Butte, Colorado, durante el verano mientras trabajaba en la primera edición del libro. Gracias también a los amigables residentes de

Crested Butte y al Rocky Mountain Biologial Laboratory que me hicieron sentir tan acogido.

Gracias a Claudette Moore de la Moore Literary Agency por su tremenda paciencia y perseverancia.

a la hora de lograr que yo hiciera exactamente lo que yo quería hacer.

Mis dos primeros libros se publicaron con Jeff Pepper como editor de Osborne/McGraw-Hill. jeff

apareció en el lugar oportuno y en la hora oportuna en Prentice-Hall y me ha allanado el camino y

ha hecho que ocurrió todo lo que tenía que ocurrir para que ésta se convierta en una experiencia

La publicación es agradable. Gracias, Jeff, significa mucho para mí.

Estoy especialmente en deuda con Gen Kiyooka y su compañía, Digigami, que me proporcionó gentilmente mi primer servidor web durante los muchos años iniciales de presencia en la Web. esto

constituyó una ayuda de valor incalculable.

Gracias a Cay Hostmann (coautor de Core Java, Prentice-Hall, 2000), D'Arcy Smith (Symantec) y

Paul Tyma (coautor de Java Primer Plus, The Waite Group, 1996), por ayudarme a aclarar conceptos sobre el lenguaje.

xlviii Piensa en Java

Gracias a la gente que ha hablado en mi curso de Java en la Software Development Conference, y a

los alumnos de mis cursos, que realizan las preguntas que necesito oír para poder hacer un material más claro.

Gracias espaciales a Larry y Tina O'Brien, que me ayudaron a volcar mis seminarios en el CD ROM

Java práctico original. (Puede encontrar más información en http:llwww.BruceEckel.com.)

Mucha gente me envió correcciones y estoy en deuda con todos ellos, pero envío gracias en particular a (por la primera edición): Kevin Raulerson (encontró cientos de errores enormes), Bob Resendes (simplemente increíble), John Pinto, Joe Dante, Jose Sharp (los tres son fabulosos), David

Coms (muchas correcciones gramaticales y aclaraciones), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennos P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson y otros muchos. El profesor Marc Meurrens puso gran cantidad de

esfuerzo en publicitar y hacer disponible la versión electrónica de la primera edición del libro en

toda Europa.

Ha habido muchísimos técnicos en mi vida que se han convertido en amigos y que también han

sido, tanto influyentes, como inusuales por el hecho de que hacen yoga y practican otras formas de

Ejercicio espiritual, que yo también encuentro muy instructivo e inspirador. Son Karig Borckschmidt, Gen Kiyooka y Andrea Provaglio, (que ayuda en el entendimiento de Java y en la programación general en Italia, y ahora en los Estados Unidos como un asociado del equipo MindView).

No es que me haya sorprendido mucho que entender Delphi me ayudará a entender Java, pues tienen muchas decisiones de diseño del lenguaje en común. Mis amigos de Delphi me proporcionaron

ayuda facilitándome a alcanzar profundidad en este entorno de programación tan maravilloso. Hijo

Marco Cantu (otro italiano -¿quizás aprender latín es una ayuda para entender los lenguajes de

programación?), Neil Rubenking (que solía hacer yoga, era vegetariano,... hasta que descubrió los

computadores) y por supuesto, Zack Urlocker, un colega de hace tiempo con el que me he movido

por todo el mundo.

Las opiniones y el soporte de mi amigo Richard Hale Shaw han sido de mucha ayuda (y la de Kim

también). Richard y yo pasamos muchos meses dando seminarios juntos e intentando averiguar cuál

era la experiencia de aprendizaje perfecta desde el punto de vista de los asistentes. Gracias a KoAnn

Vikoren, Eric Faurot, Marco Pardi, y el resto de equipo y tripulación de MFI. Gracias especialmente a Tara Arrowood, que me volvió a inspirar en las posibilidades de las conferencias.

El diseño del libro, de la portada y la foto de ésta fueron creados por mi amigo Daniel Hill-Harris.

autor y diseñador de renombre (http:llwww.Wil-Harris.com), que solía jugar con letras de goma en

el colegio mientras esperaba a que se inventaran los computadoresy los ordenadores personales, y

Se quejaba de que yo siempre estaría enmarañado con mis problemas de álgebra. Sin embargo,

he producido páginas listas para la cámara por mí mismo, por lo que los errores de tipografía son

míos. Para escribir el libro se us6 Microsoft 8 Word 97 para Windows, y para crear páginas listas para

fotógrafo en Adobe Acrobat; el libro se creó directamente a partir de los ficheros Acrobat PDE

(Como un tributo a la edad electrónica, estuve fuera en las dos ocasiones en que se produjo la versión final del libro -la primera edición se envío desde Capetown, Sudáfrica, y la segunda edición se

Introducción xlix

envío desde Praga.) La tipología del cuerpo es Georgia y los títulos están en Vérdana. La tipografia

de la portada es ITC Rennie Mackintosch.

Gracias a los vendedores que crearon los compiladores. Borland, el Blackdown Group (para Linux),

y por supuesto, Sun.

Gracias especiales a todos mis profesores y alumnos (que son a su vez mis profesores). la persona

que me enseñó a escribir fue Gabrielle Rico (autora de Writing the Natural Way, Putnam, 1985).

Siempre guardaré como un tesoro aquella terrorífica semana en Esalen.

El conjunto de amigos que me han ayudado incluyen, sin ser los únicos a: Andrew Binstock, Steve

Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinckely Barr, Hill Gates de Midnight

Revista de Ingeniería, Larry Constantine y Lucy Lockwood, Grez Perry, Dan Putterman, Christi

Westphal, GeneWang, Dave Mayer, David Intersiomne, Andrea Rosenfield, Claire Sawyers, más italianos (Laura Fallai, Corrado, ILSA y Cristina Guistozzi). Chris y Laura Strand, los Alrnquists, Brad

Jerbic, Marilyn Cvitanic, los Mabrys, los Haflingers, los Pollocks, Peter Vinci, las familias Rohhins,

las familias Moelter (y los McMillans), Michael Wilk, Dave Stoner, Laurie Adams, los Cranstons,

Larry Fogg, Mike y Karen Sequeiro, Gary Entsminger y Allison Brody, Kevin Donovan y Sonda Eastlack, Chester y Shannon Andersen, Joe Lordy, Dave y Brenda Bartlett, David Lee, los Rentschlers,

los Sudeks, Dick, Patty y Lee Eckel, Lynn y Todd y sus familias. Y por supuesto, papá y mamá.

Colaboradores Internet

Gracias a aquellos que me han ayudado a reescribir los ejemplos para usar la biblioteca Swing, y por

cualquier otra ayuda: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajes Jain, Ravi Manthena, Banu

Rajarnani, Jens Brandt, Mitin Shivaram, Malcolm Davis y todo el mundo que mostró su apoyo. Verdaderamente, esto me ayudó a dar el primer salto.



1: Introducción

a los objetos

La génesis de la revolución de los computadores se encontró en una máquina,

y por ello, la génesis de nuestros lenguajes de programación tiende a parecerse

a esa máquina.

Pero los computadores, más que máquinas, pueden considerarse como herramientas que permiten

ampliar la mente ("bicicletas para la mente", como se enorgullece de decir Steve Jobs), además de

un medio de expresión inherentemente diferente. Como resultado, las herramientas empiezan a parecerse menos a máquinas y más a partes de nuestra mente, al igual que ocurre con otros medios.

de expresión como la escritura, la pintura, la escultura, la animación o la filmación de películas. La

La programación orientada a objetos (POO) es una parte de este movimiento dirigida a utilizar los ordenadores como si de un medio de expresión se tratara.

Este capítulo introducirá al lector en los conceptos básicos de la POO, incluyendo un repaso a los métodos de desarrollo. Este capítulo y todo el libro, toman como premisa que el lector ha tenido experiencia en algún lenguaje de programación procedural (por procedimientos), sea C u otro lenguaje.

Si el lector considera que necesita una preparación mayor en programación y/o en la sintaxis de C

antes de enfrentarse al presente libro, se recomienda hacer uso del CD ROM formativo Thinking in

C: Foundations for C++ and Java, que se adjunta con el presente libro, y que puede encontrarse también con la URL, http://www. BruceEckel.com.

Este capítulo contiene material suplementario, o de trasfondo (antecedentes). Mucha gente no se siente cómoda cuando se enfrenta a la programación orientada a objetos si no entiende su contexto, a

grandes rasgos, previamente. Por ello, se presentan aquí numerosos conceptos con la intención de

proporcionar un repaso sólido a la POO. No obstante, también es frecuente encontrar a gente que

no acaba de comprender los conceptos hasta que tiene acceso a los mecanismos; estas personas

Suelen perderse si no se les ofrece algo de código que puedan manipular. Si el lector se siente identificado con este último grupo, estará ansioso por tomar contacto con el lenguaje en sí, por lo que

debe sentirse libre de saltarse este capítulo -lo cual no tiene por qué influir en la comprensión que

finalmente se adquiera del lenguaje o en la capacidad de escribir programas en él mismo. Sin embargo, tarde o temprano tendrá necesidades ocasionales de volver aquí, para completar sus nociones en aras de lograr una mejor comprensión de la importancia de l.os objetos y de la necesidad de

comprender cómo acometer diseños haciendo uso de ellos.

El progreso de la abstracción

Todos los lenguajes de programación proporcionan abstracciones. Puede incluso afirmar que la

La complejidad de los problemas a resolver es directamente proporcional a la clase (tipo) y calidad de

las abstracciones a utilizar, entendiendo por tipo "clase", aquello que se desea abstraer. El lenguaje

2 Piensa en Java

ensamblador es una pequeña abstracción de la máquina subyacente. Muchos de los lenguajes denominados "imperativos" desarrollados a continuación del antes mencionado ensamblador (como

Fortran, BASIC y C) eran abstracciones a su vez del lenguaje citado. Estos lenguajes supusieron una

gran mejora sobre el lenguaje ensamblador, pero su abstracción principal aún exigía pensar en términos de la estructura del computador más que en la del problema en sí a resolver. El programador

que haga uso de estos lenguajes debe establecer una asociación entre el modelo de la máquina (dentro del "espacio de la solución", que es donde se modela el problema, por ejemplo, un computador)

y el modelo del problema que de hecho trata de resolver (en el "espacio del problema", que es donde de hecho el problema existe). El esfuerzo necesario para establecer esta correspondencia, y el

hecho de que éste no es intrínseco al lenguaje de programación, es causa directa de que sea difícil

escribir programas, y de que éstos sean caros de mantener, además de fomentar, como efecto colateral (lateral), toda una la industria de "métodos de programación".

La alternativa al modelado de la máquina es modelar el problema que se trata de resolver. Idiomas

primitivos como LISP o APL eligen vistas parciales o particulares del mundo (considerando respectivamente que los problemas siempre se reducen a "listas" o a "algoritmos"). PROLOG convierte todos los problemas en cadenas de decisiones. Los lenguajes se han creado para programación basada en limitaciones o para programar exclusivamente mediante la manipulación de símbolos gráficos.

(aunque este último caso resultó ser excesivamente restrictivo). Cada uno de estos enfoques constituye una buena solución para determinadas clases (tipos) de problemas (aquéllos para cuya solución fueron diseñadas), pero cuando uno trata de sacarlos de su dominio resultan casi impracticables.

El enfoque orientado a objetos trata de ir más allá, proporcionando herramientas que permiten al

programador representa los elementos en el espacio del problema. Esta representación suele ser

lo suficientemente general como para evitar al programador limitarse a ningún tipo de problema específico. Nos referiremos a elementos del espacio del problema, denominando "objetos" a sus representaciones dentro del espacio de la solución (por supuesto, también serán necesarios otros objetos que no tienen su análogo dentro del espacio del problema). La idea es que el programa pueda

autoadaptarse al lingo del problema simplemente agregando nuevos tipos de objetos, de manera que

la mera lectura del código que describe la solución constituya la lectura de palabras que expresan

el problema. Se trata, en definitiva, de una abstracción del lenguaje mucho más flexible y potente.

que cualquiera que haya existido previamente. Por consiguiente, la PO0 permite al lector describir

el problema en términos del propio problema, en vez de en términos del sistema en el que se ejecutará el programa final. Sin embargo, sigue existiendo una conexión con el ordenador, pues cada

objeto puede parecer en sí un pequeño ordenador; tiene un estado, y se le puede pedir que lleve

a cabo determinadas operaciones. No obstante, esto no quiere decir que nos encontremos ante una

mala analogía del mundo real, al contrario, los objetos del mundo real también tienen características

y comportamientos.

Algunos diseñadores de lenguajes han dado por sentado que la programación orientada a objetos,

de por sí, no es adecuado para resolver de manera sencilla todos los problemas de programación, y

hacen referencia al uso de lenguajes de programación multiparadigmal.

' N. del autor: Ver Programación Multiparadigmática en Leda, por Timothy Budd (Addison-Wesley, 1995).

1: Introducción a los objetos 3

Alan Kay resumió las cinco características básicas de Smalltalk, el primer lenguaje de programación.

orientado a objetos que tuvo éxito, además de uno de los lenguajes en los que se basa Java. estas

características que constituyen un enfoque puro a la programación orientada a objetos:

Todo es un objeto. Piense en cualquier objeto como una variable: almacena datos, permite

que se le "hagan peticiones", pidiéndole que desempeñe por sí mismo determinadas operaciones, etc. En teoría, puede acogerse cualquier componente conceptual del problema a resolver (bien sean perros, edificios, servicios, etc.) y representarlos como objetos dentro de un

programa.

Un programa es un cúmulo de objetos que se dicen entre sí lo que tienen que hacer

mediante el envío de mensajes. Para hacer una petición a un objeto, basta con "enviarle un

mensaje". Más concretamente, puede considerarse que un mensaje en sí es una petición para

solicitar una llamada a una función que pertenece a un objeto en particular.

Cada objeto tiene su propia memoria, constituida por otros objetos. Dicho de otra manera, uno crea una nueva clase de objeto construyendo un paquete que contiene objetos ya

existentes. Por consiguiente, uno puede aumentar la complejidad de un programa, ocultándola tras la simplicidad de los propios objetos.

Todo objeto es de algún tipo. Cada objeto es un elemento de una clase, entendiendo por "clase" un sinónimo de "tipo". La característica más relevante de una clase la constituye "el conjunto de mensajes que se le pueden enviar".

Todos los objetos de determinado tipo pueden recibir los mismos mensajes. Ésta es una

afirmación de enorme trascendencia como se verá más tarde. Dado que un objeto de tipo "círculo" es también un objeto de tipo "polígono", se garantiza que todos los objetos "círculo"

aceptarán mensajes propios de "polígono". Esto permite la escritura de código que haga referencia a polígonos, y que de manera automática pueda manejar cualquier elemento que encaje con la descripción de "polígono". Esta capacidad de suplantación es uno de los conceptos.

más potentes de la POO.

Todo objeto tiene una interfaz.

Aristóteles fue probablemente el primero en estudiar cuidadosamente el concepto de tipo; hablaba de "la clase de los peces o la clase de los peces". La idea de que todos los objetos, aún

siendo únicos, son también parte de una clase de objetos, todos ellos con características y comportamientos en común, ya fue usado en el primer lenguaje orientado a objetos, Simula-67, que

ya incluye la palabra clave clase, que permite la introducción de un nuevo tipo dentro de un programa.

Simula, como su propio nombre indica, se creó para el desarrollo de simulaciones, como el clásico.

del cajero de un banco, en el que hay cajero, clientes, cuentas, transacciones y unidades monetarias

-un montón de "objetos". Todos los objetos que, con excepción de su estado, son idénticos durante la ejecución de un programa se agrupan en "clases de objetos", que es precisamente de donde

proviene la palabra clave clase. La creación de tipos abstractos de datos (clases) es un concepto divertido.

4 Piensa en Java

damental en la programación orientada a objetos. Los tipos abstractos de datos funcionan casi como

los tipos de datos propios del lenguaje: es posible la creación de variables de un tipo (que se denominan objetos o instancias en el dialecto propio de la orientación a objetos) y manipular estas variables (mediante el envío o recepción de mensajes; se envía un mensaje a un objeto y éste averigua que

debe hacer con él). Los miembros (elementos) de cada clase comparten algunos rasgos comunes:

toda cuenta tiene un saldo, todo cajero puede aceptar un ingreso, etc. Al mismo tiempo, cada miembro tiene su propio estado, cada cuenta tiene un saldo distinto, cada cajero tiene un nombre. Por

en consecuencia, los cajeros, clientes, cuentas, transacciones, etc. también pueden ser representados

mediante una entidad única en el programa del ordenador. Esta entidad es el objeto, y cada objeto pertenece a una clase particular que define sus características y comportamientos.

Por tanto, aunque en la programación orientada a objetos se crean nuevos tipos de datos, virtualmente todos los lenguajes de programación orientada a objetos hacen uso de la palabra clave "clase". Siempre que aparezca la palabra clave "tipo" puede sustituirse por "clase" (class) y viceversa2.

Dado que una clase describe a un conjunto de objetos con características (datos) y comportamientos (funcionalidad) idénticos, una clase es realmente un tipo de datos, porque un número en coma

flotante, por ejemplo, también tiene un conjunto de características y comportamientos. la diferencia

radica en que un programador define una clase para que encaje dentro de un problema en vez de

verse forzado a utilizar un tipo de datos existente que fue diseñado para representar una unidad de

almacenamiento en una máquina. Es posible extender el lenguaje de programación agregando nuevos tipos de datos específicos de las necesidades de cada problema. El sistema de programacion

acepta las nuevas clases y las cuida, y' asigna las comprobaciones que da a los tipos de datos predefinidos.

El enfoque orientado a objetos no se limita a la construcción de simulaciones. Uno puede estar de

De acuerdo o no con la afirmación de que todo programa es una simulación del sistema a diseñar, mientras que las técnicas de PO0 pueden reducir de manera sencilla un gran conjunto de problemas a

una solución sencilla.

Una vez que se establece una clase, pueden construirse tantos objetos de esa clase como se desee,

y manipularlos como si fueran elementos que existen en el problema que se trata de resolver. Pecado

duda, uno de los retos de la programación orientada a objetos es crear una correspondencia uno a

uno entre loselementos del espacio del problema y los objetos en el espacio de la solución.

Pero, ¿cómo se consigue que un objeto haga un trabajo útil para el programador? Debe de haber

una forma de hacer peticiones al objeto, de manera que éste desempeñe alguna tarea, como completar una transacción, dibujar algo en la pantalla o encender un interruptor. Además, cada objeto

sólo puede satisfacer determinadas peticiones. Las peticiones que se pueden hacer a un objeto se

encuentran definidas en su interfaz, y es el tipo de objeto el que determina la interfaz. un ejemplo

sencillo sería la representación de una bombilla:

Wgunas personas establecen una distinción entre ambos, remarcando que un tipo determina la interfaz, mientras que una clase es una implementación particular de una interfaz.

1: Introducción a los objetos 5

tipo

interfaz

Luz lz = nueva Luz() ;

lz. encender ( );

1 Luz l

La interfaz establece qm6 solicitudes pueden hacerse a un objeto particular Sin embargo, debe hacer

código en algún lugar que permita satisfacer esas peticiones. Este, junto con los datos ocultos, constituye la implementación. Desde el punto de vista de un lenguaje de programación procedimental, esto

No es tan complicado. Un tipo tiene una función asociada a cada posible petición, de manera que

cuando se hace una petición particular a un objeto, se invoca a esa función. Este proceso se suele

simplificar diciendo que se ha "enviado un mensaje" (hecho una petición) a un objeto, y el objeto

averigua qué debe hacer con el mensaje (ejecuta el código).

Aquí, el nombre del tipo o clase es Luz, el nombre del objeto Luz particular es lz, y las peticiones

que pueden hacerse a una Luz son encender, apagar, brillar o atenuar. Es posible crear una Luz definiendo una "referencia" (12) a ese objeto e invocando a nuevo para pedir un nuevo objeto de ese tipo.

Para enviar un mensaje al objeto, se menta el nombre del objeto y se conecta al mensaje de petición

mediante un punto. Desde el punto de vista de un usuario de una clase predefinida, éste es el no va

Más de la programación con objetos.

El diagrama mostrado anteriormente sigue el formato del Lenguaje de Modelado Unificado o

Lenguaje de modelado Un@ed (UML). Cada clase se representa mediante una caja, en la que el nombre del tipo se ubica en la parte superior, cualquier dato necesario para describirlo se coloca en la

parte central, y las funciones miembro (las funciones que pertenecen al objeto) en la parte inferior

de la caja. A menudo, solamente se muestra el nombre de la clase y las funciones públicas miembro en los diagramas de diseño UML, ocultando la parte central. Si únicamente interesan los nombres de las clases, tampoco es necesario mostrar la parte inferior de la caja.

La implementación oculta

Suele ser de gran utilidad descomponer el tablero de juego en creadores de clases (elementos que

crean nuevos tipos de datos) y programadores clientes3 (consumidores de clases que hacen uso de

los tipos de datos en sus aplicaciones). La meta del programador cliente es hacer uso de un gran

Repertorio de clases que le permitirán acometer el desarrollo de aplicaciones de manera rápida. La

Nota del autor: Término acuñado por mi amigo Scott Meyers.

6 Piensa en Java

meta del creador de clases es construir una clase que únicamente exponga lo que es necesario al

programador cliente, manteniendo oculto todo lo demás. ¿Por qué? Porque aquello que esté oculto no puede ser utilizado por el programador cliente, lo que significa que el creador de la clase

puede modificar la parte oculta a su voluntad, sin tener que preocuparse de cualquier impacto que

esta modificación pueda implicar. La parte oculta suele representar las interioridades de un objeto que podrían ser corrompidas por un programador cliente poco cuidadoso o ignorante, de

manera que mientras se mantiene oculta su implementación se reducen los errores en los programas.

En cualquier relación es importante determinar los límites relativos a todos los elementos involucrados. Al crear una biblioteca, se establece una relación con el programador cliente, que es también un programador, además de alguien que está construyendo una aplicación con las piezas que se encueriLrari e11 esta biblioteca, quizás con la intención de construir una biblioteca aún mayor.

Si todos los miembros de una clase están disponibles para todo el mundo, el cliente programador

puede hacer cualquier cosa con esa clase y no hay forma de imponer reglas. Incluso aunque prefiera que el cliente programador no pueda manipular alguno de los miembros de su clase, sin control de accesos, no hay manera de evitarlo. Todo se presenta desnudo al mundo.

Por ello, la primera razón que justifica el control de accesos es mantener las manos del programador cliente apartadas de las porciones que no deba manipular -partes que son necesarias para las

maquinaciones internas de los tipos de datos pero que no forman parte de la interfaz que los usuarios necesitan en aras de resolver sus problemas particulares. De hecho, éste es un servicio a los

usuarios que pueden así ver de manera sencilla aquello que es sencillo para ellos, y qué es lo que

pueden ignorar.

La segunda razón para un control de accesos es permitir al diseñador de bibliotecas cambiar el funcionamiento interno de la clase sin tener que preocuparse sobre cómo afectará al programador.

cliente. Por ejemplo, uno puede implementar una clase particular de manera sencilla para simplificar el desarrollo y posteriormente descubrir que tiene la necesidad de reescribirla para que se ejecute más rápidamente. Tanto la interfaz como la implementación están claramente separadas y

protegidas, esto puede ser acometido de manera sencilla.

Java usa tres palabras claves específicas para establecer los límites en una clase: public, private y protected. Su uso y significado son bastante evidentes. Estos mod$cadores de acceso determinan quién

puede usar las definiciones a las que preceden. La palabra public significa que las definiciones

Los siguientes están disponibles para todo el mundo. El término privado, por otro lado, significa que

nadie excepto el creador del tipo puede acceder a esas definiciones. Así, privado es un muro de ladrillos entre el creador y el programador cliente. Si alguien trata de acceder a un miembro privado,

obtendrá un error en el tiempo de compilación. La palabra clave protegida actúa como privada, con

la excepción de que una clase heredada tiene acceso a miembros protegidos pero no a los privados.

La herencia será definida algo más adelante.

Java también tiene un "acceso por defecto", que se utiliza cuando no se especifica ninguna de las palabras clave descritas en el párrafo anterior. Este modo de acceso se suele denominar "amistoso" o

amigable porque implica que las clases pueden acceder a los miembros amigos de otras clases que

1 : Introducción a los objetos 7

estén en el mismo paquete o paquete, sin embargo, fuera del paquete, estos miembros amigos se

convertir en privado.

Una vez que se ha creado y probado una clase, debería (idealmente) representar una unidad útil de

código. Resulta que esta reutilización no es siempre tan fácil de lograr como a muchos les gustaría;

producir un buen diseño suele requerir experiencia y una visión profunda de la problemática. pero si

se logra un diseño bueno, parece suplicar ser reutilizado. La reutilización de código es una de las

mayores ventajas que proporcionan los lenguajes de programación orientados a objetos.

La manera más simple de reutilizar una clase es simplemente usar un objeto de esa clase directamente, pero también es posible ubicar un objeto de esa clase dentro de otra clase. Esto es

lo que se denomina la "creación de un objeto miembro". La nueva clase puede construirse una

desde un número indefinido de otros objetos, de igual o distinto tipo, en cualquier combinación necesaria para lograr la funcionalidad deseada dentro de la nueva clase. Dado que uno está

construyendo una nueva clase a partir de otras ya existentes, a este concepto se le denomina

composición (o, de forma más general, agregación). La composición se suele representar mediante una relación "es-parte-de", como en "el motor es una parte de un coche" ("carro" en

Latinoamérica).

(Este diagrama UML indica la composición, y el rombo relleno indica que hay un coche.

Normalmente, lo representaré simplemente mediante una línea, sin el diamante, para indicar una

asociación4.)

La composición conlleva una gran carga de flexibilidad. Los objetos miembros de la nueva clase suelen ser privados, siendo inaccesibles a los programadores cliente que hacen uso de la clase.

Esto permite cambiar los miembros sin que ello afecte al código cliente ya existente. También es

posible cambiar los objetos en el tiempo de ejecución, para así cambiar de manera dinámica el comportamiento de un programa. La herencia, que se describe a continuación, no tiene esta.

flexibilidad, pues el compilador debe emplazar restricciones de tiempo de compilación en las clases

que se creen mediante la herencia.

Dado que la herencia es tan importante en la programación orientada a objetos, casi siempre se enfatiza mucho su uso, de manera que un programador novato puede llegar a pensar que hay que ha-

"ste ya suele ser un nivel de detalle suficiente para la gran mayoría de diagramas, de manera que no es necesario indicar de manera explícita si se está utilizando agregación o composición.

8 Piensa en Java

cer uso de la misma en todas partes. Este pensamiento puede provocar que se elaboren diseños.

poco elegantes y desmesuradamente complicados. Por el contrario, primero sería recomendable intentar hacer uso de la composición, mucho más simple y sencilla. Siguiendo esta filosofía se lograrán diseños mucho más limpios. Una vez que se tiene cierto nivel de experiencia, la detección de

los casos que precisan de la herencia se convierten en obvia.

Herencia: reutilizar interfaz

Por sí misma, la idea de objeto es una herramienta más que buena. Permite empaquetar datos y funcionalidad juntos por conexcepto, de manera que es posible representar cualquier idea del espacio del

problema en vez de verso forzado a utilizar idiomas propios de la máquina subyacente. Estos conceptos se expresan como las unidades fundamentales del lenguaje de programación haciendo uso

de la palabra clave class.

Parece una pena, sin embargo, acometer todo el problema para crear una clase y posteriormente

verse forzado a crear una nueva que podría tener una funcionalidad similar. Sería mejor si pudiéramos hacer uso de una clase ya existente, clonarla, y después hacer al "clon" las adiciones y modificaciones que sean necesarias. Efectivamente, esto se logra mediante la herencia, con la excepción

de que si se cambia la clase original (denominada la clase base, clase super o clase padre), el "clon"

modificado (denominado clase derivada, clase heredada, subclase o clase hijo) también reflejaría esos

cambios.

E Derivada

(La flecha de este diagrama UML apunta de la clase derivada a la clase base. Como se verá, puede

haber más de una clase derivada.)

Un tipo hace más que definir los límites de un conjunto de objetos; también tiene relaciones con

otros tipos. Dos tipos pueden tener características y comportamientos en común, pero un tipo puede contener más características que otro y también puede manipular más mensajes (o gestionarlos).

de manera distinta). La herencia expresa esta semejanza entre tipos haciendo uso del concepto de

tipos base y tipos derivados. Un tipo base contiene todas las características y comportamientos que

Comparten los tipos que de él se derivan. A partir del tipo base, es posible derivar otros tipos para

expresar las distintas maneras de llevar a cabo esta idea.

1 : Introducción a los objetos 9

Por ejemplo, una máquina de reciclaje de basura clasifica los desperdicios. El tipo base es "basura",

y cada desperdicio tiene su propio peso, valor, etc. y puede ser fragmentado, derretido o descompuesto. Así, se derivan tipos de basura más específicos que pueden tener características adicionales

(una botella tiene un color), o comportamientos (el aluminio se puede modelar, una lata de acero

tiene capacidades magnéticas). Además, algunos comportamientos pueden ser distintos (el valor del

papel depende de su tipo y condición). El uso de la herencia permite construir una jerarquía de tipos que expresa el problema que se trata de resolver en términos de los propios tipos.

Un segundo ejemplo es el clásico de la "figura geométrica" utilizado generalmente en sistemas de

Diseño por ordenador o en simulaciones de juegos. El tipo base es "figura" y cada una de ellas tiene un tamaño, color, posición, etc. Cada figura puede dibujarse, borrarse, moverse, colorearse, etc.

A partir de ésta, se pueden derivar (heredar) figuras específicas: círculos, cuadrados, triángulos,

etc., pudiendo tener cada uno de los cuales características y comportamientos adicionales. algunos

comportamientos pueden ser distintos, como pudiera ser el cálculo del área de los distintos tipos de

figuras. La jerarquía de tipos engloba tanto las similitudes como las diferencias entre las figuras.

1 Figura l

1 Círculo 1 1 Cuadrado " Triánguio 1

Representar la solución en los mismos términos que el problema es tremendamente beneficioso

puesto que no es necesario hacer uso de innumerables modelos intermedios para transformar una

descripción del problema en una descripción de la solución. Con los objetos, el modelo principal lo

constituye la jerarquía de tipos, de manera que se puede ir directamente de la descripción del sistema en el mundo real a la descripción del sistema en código. Sin duda, una de las dificultades que

tiene la gente con el diseño orientado a objetos es la facilidad con que se llega desde el principio al

final: las mentes entrenadas para buscar soluciones completas suelen verse aturdidas inicialmente

por esta simplicidad.

Al heredar a partir de un tipo existente, se crea un nuevo tipo. Este nuevo tipo contiene no sólo los

miembros del tipo existente (aunque los datos privados "private" están ocultos e inaccesibles) sino

Lo que es más importante, duplica la interfaz de la clase base. Es decir, todos los mensajes que pueden ser enviados a objetos de la clase base también pueden enviarse a los objetos de la clase derivada. Dado que sabemos el tipo de una clase en base a los mensajes que se le pueden enviar, la cla-

10 Piensa en Java

se deriva es del mismo tipo que la clase base. Así, en el ejemplo anterior, "un círculo en una figura". Esta equivalencia de tipos vía herencia es una de las pasarelas fundamentales que conducen al

comprensión del significado de la programación orientada a objetos.

Dado que, tanto la clase base como la derivada tienen la misma interfaz, debe haber alguna implementación que vaya junto con la interfaz. Es decir, debe haber algún código a ejecutar cuando un

objeto recibe un mensaje en particular. Si simplemente se hereda la clase sin hacer nada más, los

métodos de la interfaz de la clase base se trasladan directamente a la clase derivada. Esto significa

que los objetos de la clase derivada no sólo tienen el mismo tipo sino que tienen el mismo comportamiento, aunque este hecho no es particularmente interesante.

Hay dos formas de diferenciar una clase nueva derivada de la clase base original. El primero es bastante evidente: se añaden nuevas funciones a la clase derivada. Estas funciones nuevas no forman

parte de la interfaz de la clase base, lo que significa que la clase base simplemente no hacía todo lo

que ahora se deseaba, por lo que era necesario añadir nuevas funciones. Ese uso simple y primitivo.

rle la herencia es, en ocasiones, la solución perfecta a los problemas. Sin embargo, debería considerarse detenidamente la posibilidad de que la clase base llegue también a necesitar estas funciones adicionales. Este proceso iterativo y de descubrimiento de su diseño es bastante frecuente en la

Programación orientada a objetos.

Figura r-7

dibujar ()

borrar ()

obtenerColor()

establecerColor()

El Círculo 1 Cuadrado 1 m Triángulo

Girarvertical ()

GirarHorizontal ()

Aunque la herencia puede implicar en ocasiones (especialmente en Java, donde la palabra clave que

hace referencia a la misma es extends) que se van a agregar funcionalidades a una interfaz, esto no

Tiene por qué ser siempre así. La segunda y probablemente más importante manera de diferenciar

una nueva clase es variar el comportamiento de una función ya existente en la clase base. A esto se

le llama redefinición5 (anulación o superposición) de la función.

Para redefinir una función simplemente se crea una nueva definición de la función dentro de la clase derivada. De esta manera puede decirse que "se está utilizando la misma función de la interfaz

pero se desea que se comporte de manera distinta dentro del nuevo tipo".

' En el original overriding (N. del T.).

1: Introducción a los objetos 11

figura

dibujar ()

borrar ()

obtenerColor()

establecerColor()

m Círculo

dibujar ()

borrar () 1

Yo Triángulo

dibujar () 1 1 dibujar () 1

borrar () 1 1 borrar ()

La relación es-un frente a la relación

es-como-un

Es habitual que la herencia suscite un pequeño debate: ¿debería la herencia superponer sólo las

funciones de la clase base (sin agregar nuevas funciones miembro que no se encuentren en ésta)?

Esto significaría que el tipo derivado sea exactamente el mismo tipo que el de la clase base, puesto que tendría exactamente la misma interfaz. En consecuencia, es posible sustituir un objeto

de la clase derivada por otra de la clase base. A esto se le puede considerar sustitución pura, y a

menudo se le llama el principio de sustitución. De cierta forma, ésta es la manera ideal de tratar

la herencia. Habitualmente, a la relación entre la clase base y sus derivadas que sigue esta filosofía se le denomina relación es-un, pues es posible decir que "un círculo es un polígono". Una manera de probar la herencia es determinar si es posible aplicar la relación es-un a las clases en liza,

y tiene sentido.

Hay veces en las que es necesario agregar nuevos elementos a la interfaz del tipo derivado, extendiendo así la interfaz y creando un nuevo tipo. Éste también puede ser sustituido por el tipo base, pero la

La sustitución no es perfecta pues las nuevas funciones no serán accesibles desde el tipo base. Esta relación puede describirse como la relación es-como-un" el nuevo tipo tiene la interfaz del viejo pero además contiene otras funciones, así que no se puede decir que sean exactamente iguales. Considere

por ejemplo un acondicionador de aire. Supongamos que una casa está cableada y tiene las botoneras.

para refrescarla, es decir, tiene una interfaz que permite controlar la temperatura. Imagina que se

estropea el acondicionador de aire y se reemplaza por una bomba de calor que puede tanto enfriar

como calentar. La bomba de calor es como un acondicionador de aire, pero puede hacer más funciones.

Dado que el sistema de corilrol de la casa está diseñado exclusivamente para controlar el enfriado, se

encuentra restringida a la comunicación con la parte "enfriadora" del nuevo objeto. Es necesario ampliar la interfaz del nuevo objeto, y el sistema existente únicamente conoce la interfaz original.

Término acuñado por el autor.

12 Piensa en Java

1 Termostato 1 Controlla I Sistema de enfriado

1 enfriar O 1

1 Acondicionador de aire / 1 Bomba de Calor

enfriar ()ivada. Con la

experiencia, ambos casos irán pareciendo obvios.

Objetos intercambiables con

polimorfismo

Al tratar con las jerarquías de tipos, a menudo se desea tratar un objeto no como el tipo específico

del que es, sino como su tipo base. Esto permite escribir código que no depende de tipos específicos.

En el ejemplo de los polígonos, las funciones manipulan polígonos genéricos sin que importe si son

círculos, cuadrados, triángulos o cualquier otro polígono que no haya sido aún definido. Todos los polígono~ pueden dibujarse, borrarse y moverse, por lo que estas funciones simplemente envían un

mensaje a un objeto polígono; No se preocupan de qué base hace este objeto con el mensaje.

Este tipo de código no se ve afectado por la adición de nuevos tipos, y esta adición es la manera más

común de extender un programa orientado a objetos para que sea capaz de manejar nuevas situaciones. Por ejemplo, es posible derivar un nuevo subtipo de un polígono denominado pentágono sin

tener que modificar las funciones que solamente manipulan polígonos genéricos. esta capacidad

para extender un programa de manera sencilla derivando nuevos subtipos es importante, ya que mejora considerablemente los diseños a la vez que reduce el costo del mantenimiento de software.

Sin embargo, hay un problema a la hora dc tratar los objetos de tipos derivados como sus tipos base.

genéricos (los círculos como polígonos, las bicicletas como vehículos, los cormoranes como pájaros,

etc.). Si una función va a decir a un polígono genérico que la dibuje, o a un vehículo que genérico

se engrane, o a un pájaro genérico que se mueve, el compilador no puede determinar en tiempo de

1: Introducción a los objetos 13

Compilación con exactitud qué fragmento de código se ejecutará. Éste es el punto clave -cuando

se envía el mensaje, el programador no quiere saber qué fragmento de código se ejecutará; la función dibujar se puede aplicar de manera idéntica a un círculo, un cuadrado o un triángulo, y el objeto ejecutará el código correcto en función de su tipo específico. Si no es necesario saber qué fragmento de código se ejecutará, al agregar un nuevo subtipo, el código que se ejecutará puede ser diferente

sin necesidad de modificar la llamada a la función. Por consiguiente, el compilador no puede saber

exactamente qué fragmento de código se está ejecutando, ¿y qué es entonces lo que hace? Por ejemplo, en el diagrama siguiente, el objeto ControlaPájaros trabaja con objetos Pájaro genéricos, y no

sabe exactamente de qué tipo son. Esto es conveniente para la perspectiva de ControlaPájaros

pues no tiene que escribir código especial para determinar el tipo exacto de Pájaro con el que está

trabajando, ni el comportamiento de ese Pájaro. Entonces, ¿cómo es que cuando se invoca a mover() ignorando el tipo específico de Pájaro se dará el comportamiento correcto (un Ganso corre,

vuelta o nada,

7

¿Y un Pingüino corre o nada)?

?,Qué pasa al invocar a

F motor ()

l Ganso 1 1 Pingüino l I I

motor () 1 1 motor ()

La respuesta es una de las principales novedades en la programación orientada a objetos: el compilador iiu pudc liaccr uria llarriada a furiciúri eri el serilido lradicio~ial. La llarriada a íurici0ri generada por un compilador no-PO0 hace lo que se denomina una ligadura temprana, un término que puede que el lector no haya visto antes porque nunca pensó que se pudiera hacer de otra forma. esto

significa que el compilador genera una llamada a una función con nombre específico, y el montador

resuelve esta llamada a la dirección absoluta del código a ejecutar. En POO, el programa no puede

determine la dirección del código hasta el tiempo de ejecución, por lo que es necesario otro esquema

cuando se envía un mensaje a un objeto genérico.

Para resolver el problema, los lenguajes orientados a objetos usan el concepto de ligadura tardía. Alabama

enviar un mensaje a un objeto, no se determina el código invocado hasta el tiempo de ejecución. el

cornpilador se asegura de que la luriciím exisla y hace la comprobación de tipos de los argumentos

y del valor de retorno (un lenguaje en el que esto no se haga así se dice que es débilmente tipificado), pero se desconoce el código exacto a ejecutar.

Para llevar a cabo la ligadura tardía, Java utiliza un fragmento de código especial en vez de la llamada absoluta. Este código calcula la dirección del cuerpo de la función utilizando información almacenada en el objeto (este proceso se relata con detalle en el Capítulo 7). Por consiguiente, cada

objeto puede comportarse de manera distinta en función de los contenidos de ese fragmento de código.

14 Piensa en Java

digo especial. Cuando se envía un mensaje a un objeto, éste, de hecho, averigua qué es lo que debe

hacer con ese mensaje.

En algunos lenguajes (C++ en particular) debe establecerse explícitamente que se desea que una

función tenga la flexibilidad de las propiedades de la ligadura tardía. En estos lenguajes, por defecto, la correspondencia con las funciones miembro no se establece dinámicamente, por lo

Por supuesto, una vez que uno ve este diseño, está claro que la clase base "sistema de enfriado" no

es lo suficientemente general, y debería renombrarse a "sistema de control de temperatura" de manera que también pueda incluir calentamiento -punto en el que el principio de sustitución funcionará. Sin embargo, este diagrama es un ejemplo de lo que puede ocurrir en el diseño y en el mundo real.

Cuando se ve el principio de sustitución es fácil sentir que este principio (la sustitución pura) es la

única manera de hacer las cosas, y de hecho, es bueno para los diseños que funcionan así. Pero hay

veces que está claro que hay que agregar nuevas funciones a la interfaz de la clase derque es necesario recordar que hay que añadir ciertas palabras clave extra para lograr el polimorfismo.

Considere el ejemplo de los polígonos. La familia de clases (todas ellas basadas en la misma interfaz uniforme) ya fue representada anteriormente en este capítulo. Para demostrar el polimorfismo, se escribirá un único fragmento de código que ignora los detalles específicos de tipo y solamente hace referencia a la clase base. El código está desvinculado de información específica del tipo,

y por consiguiente es más fácil de escribir y entender. Y si se añade un nuevo tipo -por ejemplo un

Hexágono- mediante herencia, el código que se escribirá trabajará tan perfectamente con el nuevo

Polígono como lo hacia con los tipos ya exisle~iles, y por curisiguiente, el programa es Arrzpliable.

Si se escribe un método en Java (y pronto aprenderá el lector a hacerlo):

void hacerAlgo (Poligono p) {

pag. borrar() ;

//...

p.dibujar() ;

1

Esta función se entiende con cualquier Polígono, y por tanto, es independiente del tipo específico

de objeto que esté dibujando y borrando. En cualquier otro fragmento del programa se puede usar

la función hacerAlgo( ) :

Circulo c = nuevo Circulo() ;

Triángulo t = nuevo Triángulo () ;

Línea 1 = nueva Línea () ;

hacerAlgo (c) ;

hacerAlgo (t) ;

hacerAlgo (1) ;

Las llamadas a hacerAlgo( ) funcionan correctamente, independientemente del tipo de objeto.

De hecho, éste es un truco bastante divertido. Considere la línea:

Lo que está ocurriendo es que se está pasando un Círculo a una función que espera un Polígono.

Como un Círculo es un Polígono, puede ser tratado como tal por hacerAlgo(). Es decir, cualquier

mensaje que hacerAigo() pueda enviar a un Polígono, también podrá aceptarlo un Círculo. Por

tanto, obrar así es algo totalmente seguro y lógico.

A este proceso de tratar un tipo derivado como si fuera el tipo base se le llama conversión de tipos

(moldeado) hacia arriba7. El nombre moldear (cast) se utiliza en el sentimiento de moldear (convertir) un

' En el original inglés, casting.

1: Introducción a los objetos 15

molde, y es hacia arriba siguiendo la manera en que se representa en los diagramas la herencia, con

el tipo base en la parte superior y las derivadas colgando hacia abajo. Por consiguiente, hacer un moldeado (casting) a la clase base es moverse hacia arriba por el diagrama de herencias: moldeado hacia

arriba.

Un programa orientado a objetos siempre tiene algún moldeado hacia arriba pues ésta es la manera de desvincularse de tener que conocer el tipo exacto con que se trabaja en cada instante. si se

echa un vistazo al código de hacerAlgo() :

Obsérvese que no se dice "caso de ser un Círculo, hacer esto; caso de ser un Cuadrado, hacer esto

otro, etc.”. Si se escribe código que compruebe todos los tipos posibles que puede ser un Polígono,

el tipo de código se complica, además de hacerse necesario modificarlo cada vez que se añade un

Nuevo tipo de Polígono. Aquí, simplemente se dice que "en el caso de los polígonos, se sabe que es

posible aplicarles las operaciones de borrar() y dibujar(), eso sí, teniendo en cuenta todos los detalles de manera correcta".

Lo que más llama la atención del código de hacerAlgo() es que, de alguna manera, se hace lo correcto. Invocar a dibujar() para Círculo hace algo distinto que invocar a dibujar() para Cuadrado o

Iínea, pero cuando se envía el mensaje dibujar() a un Polígono anónimo, se da el comportamiento

correcto calculando en el tipo actual de Polígono. Esto es sorprendente porque, como se mencionó

Anteriormente, cuando el compilador de Java está compilando el código de hacerAlgo(), no puede saber exactamente qué tipos está manipulando. Por ello, generalmente, se espera que acabe invocando

a la versión de borrar() y dibujar() de la clase base Polígono y no a las específicas de Círculo,

Cuadrado y Iánea. Y sigue ocurriendo lo correcto por el polimorfismo. El compilador y el sistema de

tiempo real se hacen carga de los detalles; todo lo que hace falta saber es qué ocurre, y lo que es más

importante, cómo diseñar haciendo uso de ello. Al enviar un mensaje a un objeto, el objeto hará lo correcto, incluso cuando se vea involucrado el moldeado hacia arriba.

Clases base abstractas e interfaces.

A menudo es deseable que la clase base únicamente presente una interfaz para sus clases derivadas.

Es decir, no se desea que nadie crea objetos de la clase base, sino que sólo se hagan moldeados ha-

16 Piensa en Java

cia arriba de la misma manera que se pueda usar su interfaz. Esto se logra convertir esa clase en abstracta usando la palabra clave abstract. Si alguien trata de construir un objeto de una clase abstracta el compilador lo evita. Esto es una herramienta para fortalecer determinados diseños.

También es posible utilizar la palabra clave abstract para describir un método que no ha sido aún

implementar -indicando "he aquí una función interfaz para todos los tipos que se hereden de esta

clase, pero hasta la fecha no existe una implementación de la misma". Se puede crear un metodo

abstracto sólo dentro de una clase abstracta. Cuando se hereda la clase, debe implementarse el método o de lo contrario también la clase heredada se convierte en abstracto. La creación de métodos

abstractos permite poner un método en una interfaz sin verse forzado a proporcionar un fragmento de código, posiblemente sin significado, para ese método.

La palabra clave interfaz toma el concepto de clase abstracta un paso más allá, evitando totalmente las definiciones de funciones. La interfaz es una herramienta muy útil y utilizada, ya que proporciona la separación perfecta entre interfaz e implementación. Además. si se desea. es posible

Combina muchos elementos juntos mientras que no es posible heredar de múltiples clases normales o abstractas.

Localización de objetos y longevidad.

Técnicamente, la PO0 consiste simplemente en tipos de datos abstractos, herencia y polimorfismo,

aunque también hay otros aspectos no menos importantes. El resto de esta sección trata de analizar esos aspectos.

Uno de los factores más importantes es la manera de crear y destruir objetos. ¿Dónde están los datos de un objeto y cómo se controla su longevidad (tiempo de vida)? En este punto hay varias filosofías de trabajo. En C++ el enfoque principal es el control de la eficiencia, proporcionando una alternativa al programador. Para lograr un tiempo de ejecución óptimo, es posible determinar el

espacio de almacenamiento y la longevidad en tiempo de programación, ubicando los objetos en la

pila (creando las variables de ámbito o automático) o en el área de almacenamiento estático. De esta manera se prioriza la velocidad de la asignación y liberación de espacio de almacenamiento, cuyo control puede ser de gran valor en determinadas situaciones. Sin embargo, se sacrifica en flexibilidad

puesto que es necesario conocer la cantidad exacta de objetos, además de su longevidad y su tipo,

Mientras se escribe el programa. Si se está tratando de resolver un problema más general como un

diseño asistido por computadora, la gestión de un almacén o el control de tráfico aéreo, este enfoque

resulta demasiado restrictivo.

El segundo enfoque es crear objetos dinámicamente en un espacio de memoria denominado el montículo o montón (heap). En este enfoque, no es necesario conocer hasta tiempo de ejecución el número de objetos necesarios, cuál es su longevidad o a qué tipo exacto pertenecen. Estos aspectos se

deter-minar-án justo en el preciso momento en que se ejecuta el programa. Si se necesita un nuevo ob

Jeto, simplemente se construye en el montículo en el instante en que sea necesario. Dado que el almacenamiento se gestiona dinámicamente, en tiempo de ejecución, la cantidad de tiempo necesaria

1: Introducción a los objetos 17

asignar espacio de almacenamiento en el montículo es bastante mayor que el tiempo necesario

asigne espacio a la pila. (La creación de espacio en la pila suele consistir simplemente en una

instrucción al ensamblador que mueve hacia abajo el puntero de pila, y otra para moverlo de nuevo

hacia arriba.) El enfoque dinámico provoca generalmente el pensamiento lógico de que los objetos

Tenden a ser complicados, por lo que la sobrecarga debida a la localización del espacio de almacenamiento y su liberación no deben tener un impacto significativo en la creación del objeto. Es más,

esta mayor flexibilidad es esencial para resolver en general el problema de programación.

Java utiliza exclusivamente el segundo enfoque8. Cada vez que se desea crear un objeto se usa la palabra clave nueva para construir una instancia dinámica de ese objeto.

Hay otro aspecto, sin embargo, a considerar: la longevidad de un objeto. Con los lenguajes que permiten la creación de objetos en la pila, el compilador determina cuánto dura cada objeto y puede destruirlo cuando no sea necesario. Sin embargo, si se crea en el montículo, el compilador no tiene conocimiento alguno sobre su longevidad. En un lenguaje como C++ hay que determinar en tiempo de

programación cuándo destruir el objeto, lo cual puede conducir a fallos de memoria si no se hace de

manera correcta & este problema es bastante común en los programas en C++). Java proporciona un

recolector de basura que descubre automáticamente cuándo se ha dejado de utilizar un objeto, que

puede, por consiguiente, ser destruido. Un recolector de basura es muy conveniente, al reducir el número de aspectos a tener en cuenta, así como la cantidad de código a escribir. Y lo que es más importante, el recolector de basura proporciona un nivel de seguridad mucho mayor contra el problema.

de los fallos de memoria (que ha hecho abandonar más de un proyecto en Ctt).

El resto de esta sección se centra en factores adicionales relativos a la longevidad de los objetos y

su localización.

Colecciones e iteradores

Si se desconoce el número de objetos necesarios para resolver un problema en concreto o cuánto

Deben durar, también se desconocerá cómo almacenar esos objetos. ¿Cómo se puede saber el espacio a reservar?para los mismos? De hecho, no se puede, pues esa información se desconocerá hasta el tiempo de ejecución.

La solución a la mayoría de problemas de diseño en la orientación a objetos parece sorprendente: se

crea otro tipo de objeto. El nuevo tipo de objeto que resuelve este problema particular tiene referencias a otros objetos. Por supuesto, es posible hacer lo mismo con un array, disponible en la mayoría

de lenguajes. Pero hay más. Este nuevo objeto, generalmente llamado contenedor (llamado también colección, pero la biblioteca de Java usa este término con un sentido distinto así que este libro empleará

la palabra "contenedor"), se expandirá a sí mismo cuando sea necesario para albergar cuanto se coloque dentro del contenedor. Simplemente se crea el contenedor del objeto, y él se encarga de los detalles.

Afortunadamente, un buen lenguaje PO0 viene con un conjunto de contenedores como parte del

lenguaje propio. En C++, es parte de la Biblioteca Estándar C++ (Standard C++ Library), que en oca-

' Los tipos primitivos, de los que se hablará más adelante, son un caso especial.

18 Piensa en Java

siones se denomina la Standard Template Library, Biblioteca de plantillas estándar, (STL). Objeto

Pascal tiene contenedores en su Biblioteca de componentes visuales (VCL). Smalltalk tiene un conjunto de

contenedores muy completos, y Java también tiene contenedores en su biblioteca estándar. En algunas bibliotecas, se considera que un contenedor genérico es lo suficientemente bueno para todas las

necesidades, mientras que en otras (como en Java, por ejemplo) la biblioteca tiene distintos tipos de

contenedores para distintas necesidades: un vector (denominado en Java ArrayList) para acceso

consistente a todos los elementos, y una lista enlazada para inserciones consistentes en todos los

elementos, por ejemplo, con lo que es posible elegir el tipo particular que satisfaga las necesidades

de cada momento. Las bibliotecas de contenedores también suelen incluir conjuntos, colas, tablas.

de hasing, árboles, pilas, etc.

Todos los contenedores tienen alguna manera de introducir y extraer cosas; suele haber funciones para

add elementos a un contenedor, y otros para extraer de nuevo esos elementos. Pero sacar los elementos puede ser más problemático porque una función de selección única suele ser restrictiva. What

¿Ocurre si se desea manipular o comparar un conjunto de eleinerilos del co~ite~iedor y no u~io sdo?

La solución es un iterador, que es un objeto cuyo trabajo es seleccionar los elementos de dentro de un

contenedor y presentárselos al usuario del iterador. Como clase, también proporciona cierto nivel de

abstracción. Esta abstracción puede ser usada para separar los detalles del contenedor del código al

que éste está accediendo. El contenedor, a través del iterador, se llega a abstraer hasta convertirse en

una secuencia simple, que puede ser recorrida gracias al iterador sin tener que preocuparse de la estructura subyacente -es decir, sin preocuparse de si es un ArrayLBst (lista de arrays), un LinkedList

(lista enlazado), un Stack, (pila) u otra cosa. Esto proporciona la flexibilidad de cambiar fácilmente la

estructura de datos subyacente sin que el código de un programa se vea afectado. Java comenzó (es

las versiones 1.0 y 1.1) con un iterador estándar denominado Enumeration, para todas sus clases contenedor. Java 2 ha añadido una biblioteca mucho más completa de contenedores que contiene un iterador denominado Iterator mucho más potente que el antiguo Enumeration.

Desde el punto de vista del diseño, todo lo realmente necesario es una secuencia que puede ser manipulada en aras de resolver un problema. Si una secuencia de un sólo tipo satisface todas las necesidades de un problema, entonces no es necesario hacer uso de distintos tipos. Hay dos razones

por las que es necesaria una selección de contenedores. En primer lugar, los contenedores proporcionan distintos tipos de interfaces y comportamientos externos. Una pila tiene una interfaz y un

comportamiento distinto del de las colas, que son a su vez distintos de los conjuntos y las listas.

Cualquiera de estos podría proporcionar una solución mucho más flexible a un problema. En segundo lugar, distintos contenedores tienen distintas eficiencias en función de las operaciones. El mejor ejemplo está en ArrayList y LinkedList. Ambos son secuencias sencillas que pueden tener interfaces y comportamientos externos idénticos. Pero determinadas operaciones pueden tener

costes radicalmente distintos. Los accesos aleatorios a ArrayList tienen tiempos de acceso constantes; se invierte el mismo tiempo independientemente del elemento seleccionado. Sin embargo, en

una LinkedList mover de elemento en elemento a lo largo de la lista para seleccionar uno al azar

es altamente costoso, y es necesario muchísimo más tiempo para localizar un elemento cuanto más

se adelante se encuentre. Por otro lado, si se desea insertar un elemento en el medio de una secuencia, es mucho menos costoso hacerlo en un LinkedList queccn un ArrayList. Esta y otras operas

ciones tienen eficiencias distintas en función de la estructura de la secuencia subyacente. En la fase

de diseño, podría comenzarse con una LinkedList y, al primar el rendimiento, cambiar a un

1: Introducción a los objetos 19

Lista de arreglo. Dado que la abstracción se lleva a cabo a través de iteradores, es posible cambiar de uno

a otro con un impacto mínimo en el código.

Finalmente, debe recordarse que un contenedor es sólo un espacio de almacenamiento en el que colocar objetos. Si este espacio resuelve todas las necesidades, no importa realmente cómo esté implementado (concepto compartido con la mayoría de tipos de objetos). Si se está trabajando en un

entorno de programación que tiene una sobrecarga interna debido a otros factores, la diferencia

Los costos entre ArrayList y LinkedList podrían no importar. Con un único tipo de secuencia podría

valer. Incluso es posible imaginar la abstracción contenedora "perfecta", que pueda cambiar su implementación subyacente automáticamente en función de su uso.

La jerarquía de raíz única

Uno de los aspectos de la PO0 que se ha convertido especialmente destacado desde la irrupción

de C++ es si todas las clases en última instancia deben ser heredadas de una única clase base. es

Java (como virtualmente en todos los lenguajes PO0 ) la respuesta es "sí" y el nombre de esta última clase base es simplemente Object. Resulta que los beneficios de una jerarquía de raíz única son

enormes.

Todos los objetos en una jerarquía de raíz única tienen una interfaz en común, por lo que en última

instancia son del mismo tipo. La alternativa (proporcionada por C++) es el desconocimiento de que

todo pertenece al mismo tipo fundamental. Desde el punto de vista de la retrocompatibilidad, esto

encaja en el modelo de C mejor, y puede pensarse que es menos restrictivo, pero cuando se desea

Para hacer programación orientada a objetos puros, es necesario proporcionar una jerarquía completa para

lograr el mismo nivel de conveniencia intrínseco a otros lenguajes POO. Y en cualquier nueva biblioteca de clases que se adquiera, se utilizará alguna interfaz incompatible. hacer funcionar esta

nueva interfaz en un diseño lleva un gran esfuerzo (y posiblemente herencia múltiple). Así que ¿merece la pena la "flexibilidad" extra de C++? Si se necesita -si se dispone de una gran cantidad de

código en C- es más que valioso. Si se empieza de cero, otras alternativas, como Java, resultarán

mucho más productivas.

Puede garantizarse que todos los objetos de una jerarquía de raíz única (como la proporcionada por

Java) tienen cierta funcionalidad. Se sabe que es posible llevar a cabo ciertas operaciones básicas

con todos los objetos del sistema. Una clasificación de raíz única, junto con la creación de todos los objetos en el montículo, simplifica enormemente el paso de argumentos (uno de los temas más complicados de C++).

Una jerarquía de raíz única simplifica muchísimo la implementación de un recolector de basura (incluido en Java). El soporte necesario para el mismo puede instalarse en la clase base, y el recolector de basura podrá así enviar los mensajes apropiados a todos los objetos del sistema. Si no existiera este tipo de jerarquía rii la posibilidad de rriariipular un objeto a través de reierencias, sería muy

Difícil implementar un recolector de basura.

Dado que está garantizado que en el tiempo de ejecución la información de tipos está en todos los objetos, jamás será posible encontrar un objeto cuyo tipo no pueda ser determinado. Esto es especial

20 Piensa en Java

mente importante con operaciones a nivel de sistema, tales como el manejo de excepciones, además

de proporcionar una gran flexibilidad a la hora de programar.

Bibliotecas de colecciones y soporte al fácil

manejo de colecciones

Dado que un contenedor es una herramienta de uso frecuente, tiene sentido tener una biblioteca de

contenedores construidos para ser reutilizados, de manera que se puede elegir uno de la estantería

y enchufarlo en un programa determinado. Java proporciona una biblioteca de este tipo, que satisface la gran mayoría de necesidades.

Moldeado hacia abajo frente a plantillas/genéricos

Yara lograr que estos contenedores sean reutilizables, guarden un tipo universal en Java ya mencionado anteriormente: Object (Objeto). La jerarquía de raíz única implica que todo sea un Objeto,

de forma que un contenedor que tiene objetos de tipo Object puede contener de todo, logrando así

que los contenedores sean fáciles de reutilizar.

Para utilizar uno de estos contenedores, basta con añadirle referencias a objetos y finalmente preguntar por ellas. Pero dado que el contenedor sólo guarda objetos de tipo Object, al agregar una referencia al contenedor, se hace un moldeado hacia arriba a Object, perdiendo por consiguiente su

identidad. Al recuperarlo, se obtiene una referencia a Objeto y no una referencia al tipo que se había introducido. ¿Y cómo se convierte de nuevo en algo útil con la interfaz del objeto que se introduce en¿el contenedor?

En este caso, también se hace uso del moldeado, pero en esta ocasión en vez de hacerlo hacia arriba siguiendo la jerarquía de las herencias hacia un tipo más general, se hace hacia abajo, hacia un

tipo más específico. Esta forma de moldeado se denomina moldeado hacia abajo. Con el moldeado

hacia arriba, como se sabe, un Círculo, por ejemplo, es un tipo de Polígono, con lo que este tipo

de moldeado es seguro, pero lo que no se sabe es si un Objeto es un Círculo o un Polígono, por

lo que no es muy seguro hacer moldeado hacia abajo a menos que se sepa exactamente qué es lo

que se está manipulando.

Esto no es completamente peligroso, sin embargo, dado que si se hace un moldeado hacia abajo, a

un tipo erróneo, se mostrará un error de tiempo de ejecución denominado excepción, que se describirá en breve. Sin embargo, al recuperar referencias a objetos de un contenedor, es necesario tener

alguna manera de recordar exactamente lo que son para poder llevar a cabo correctamente un moldeado hacia abajo.

El moldeado hacia abajo y las comprobaciones en tiempo de ejecución requieren un tiempo extra

durante la ejecución del programa, además de un esfuerzo extra por parte del programador. 2No tendría sentido crear, de alguna manera, el contenedor de manera que conozca los tipos que guarda,

eliminando la necesidad de hacer moldeado hacia abajo y por tanto, de que aparezca algún error?

La solución la constituye los tipos parametrizados, que son clases que el compilador puede adaptarse automáticamente para que trabajen con tipos determinados. Por ejemplo, con un contenedor parametrizado, el compilador podría adaptar el propio contenedor para que solamente acepte y per-

1: Introducción a los objetos 21

mitiera la recuperación de Polígonos.

Los tipos parametrizados son un elemento importante en C++, en parte porque este lenguaje no tiene una clasificación de raíz única. En C++, la palabra clave que implementa los tipos parametrizados es

"plantilla". Java actualmente no tiene tipos parametrizados pues se puede lograr lo mismo -aunque de manera complicada- explotando la unicidad de raíz de su jerarquía. Sin embargo, una propuesta actualmente en curso para implementar tipos parametrizados utiliza una sintaxis muy similar a las plantillas (templates) de C++.

El dilema de las labores del hogar:

¿Quién limpia la casa?

Cada objeto requiere recursos simplemente para poder existir, principalmente memoria. cuando

un objeto deja de ser necesario debe ser eliminado de manera que estos recursos queden disponibles

para poder reutilizar. En situaciones de programación sencillas la cuestión de cuándo eliminar un

objeto no se antoja complicado: se crea el objeto, se utiliza mientras sea necesario y posteriormente

debe ser destruido. Sin embargo, no es difícil encontrar situaciones en las que esto se corriplica.

Supóngase, por ejemplo, que se está diseñando un sistema para gestionar el tráfico aéreo de un aeropuerto. (El mismo modelo podría funcionar también para gestionar paquetes en un almacén, o un

sistema de alquiler de vídeos, o una residencia canina.) A primera vista, parece simple: construir un

contenedor para albergar aviones, cree a continuación un nuevo avión y ubiquelo en el contenedor

(para cada avión que aparezca en la zona a controlar). En el momento de eliminación, se borra (suprime) simplemente el objeto aeroplano correcto cuando un avión sale de la zona barrida.

Pero quizás, se tiene otro sistema para guardar los datos de los aviones, datos que no requieren

inmediatamente, como atencion la funcion de control principal. Quizás, se trata de un registro del plan de

viaje de todos los pequeños aviones que abandonan el aeropuerto. Es decir, se dispone de un segundo contenedor de aviones pequeños, y siempre que se crea un objeto avión también se introduce en este segundo contenedor si se trata de un avión pequeño. Posteriormente, algún proceso en

segundo plano lleva a cabo operaciones con los objetos de este segundo contenedor cada vez que el

El sistema está ocioso.

Ahora el problema se complica: ¿cómo se sabe cuándo destruir los objetos? Cuando el programa

principal (el controlador) ha terminado de usar el objeto, puede que otra parte del sistema lo esté

usando (o lo vaya a usar en un futuro). Este problema surge en numerosas ocasiones, y los sistemas de programación (como C++) en los que los objetos deben borrarse explícitamente cuando acaba de usarlos, pueden volverse bastante complejos.

Con Java, el problema de vigilar que se libere la memoria se ha implementado en el rccolector de

basura (aunque no incluye otros aspectos de la supresión de objetos). El recolector "sabe" cuando

se ha dejado de utilizar un objeto y libera la memoria que ocupaba automáticamente. Esto (combinado con el hecho de que todos los objetos son heredados de la clase raíz única Object y con la

existencia de una única forma de crear objetos, en el montículo) hace que el proceso de programar

en Java sea mucho más sencillo que el hacerlo en C++. Henomuchas menos decisiones que tomar y

menos obstáculos que sortear.

22 Piensa en Java

Los recolectores de basura frente a la eficiencia y flexibilidad

Si todo esto es tan buena idea, ¿por qué no se hizo lo mismo en C++? Bien, por supuesto, hay un

precio que pagar por todas estas comodidades de programación, y este precio consiste en sobrecarga en tiempo de ejecución. Como se mencionó anteriormente, en C++ es posible crear objetos en

la pila, y en este caso, éstas se eliminan automáticamente (pero no se dispone de la flexibilidad de

crear tantos como se desee en tiempo de ejecución). La creación de objetos en la pila es la manera.

más eficiente de espacio asignar a los objetos y de liberarlo. La creación de objetos en el montículo.

Puede ser mucho más caro. Heredar siempre de una clase base y hacer que todas las llamadas

una función sean polimórficas también conlleva un pequeño peaje. Pero el recolector de basura es un

problema concreto pues nunca se sabe cuándo se va a poner en marcha y cuánto tiempo llevará

su ejecución. Esto significa que hay inconsistencias en los ratios (velocidad) de ejecución de los programas escritos en Java, por lo que éstos no pueden ser utilizados en determinadas situaciones,

como por ejemplo, cuando el tiempo de ejecución de un programa es uniformemente crítico. (Se trata de los programas denominados generalmente de tiempo real, aunque no todos los problemas de

programación en tiempo real son tan rígidos.)

Los diseñadores del lenguaje C++, trataron de ganarse a los programadores de C (en lo cual tuvieron bastante éxito), no quisieron añadir nuevas características al lenguaje que pudiesen influir en la

velocidad o el uso de C++ en cualquier situación en la que los programadores puedan decantarse

por C. Se logró la meta, pero a cambio de una mayor complejidad cuando se programa en C++. Java

Es más simple que C++, pero un cambio es menos eficiente y en ocasiones ni siquiera aplicable. Pecado

Sin embargo, para un porcentaje elevado de problemas de programación, Java es la mejor elección.

Manejo de excepciones:

tratar con errores

El manejo de errores ha sido, desde el principio de la existencia de los lenguajes de programación,

uno de los aspectos más difíciles de abordar. Dado que es muy complicado diseñar un buen

esquema de manejo de errores, muchos lenguajes simplemente ignoran este aspecto, pasando el

problema a los diseñadores de bibliotecas que suelen contestar con soluciones a medios que funcionan en la mayoría de situaciones, pero que pueden ser burladas de manera sencilla; es decir, simplemente ignorándolas. Un problema importante con la mayoría de los esquemas de tratamiento de

errores es que depende de la vigilancia del programador de cara al seguimiento de una convención preestablecida no especialmente promovida por el propio lenguaje. Si el programador no está

atento -cosa que ocurre muchas veces, especialmente si se tiene prisa- es posible olvidar estos

esquemas con relativa facilidad.

El manejo de excepciones está íntimamente relacionado con el lenguaje de programación y a veces

incluso con el sistema operativo. Una excepción es un objeto que es "lanzado", "arrojadowq desde el

lugar en que se produce el error, y que puede ser "capturado" por el gestor de excepción apropiado

Y N. del traductor: en inglés se emplea el verbo throw.

1: Introducción a los objetos 23

Diseñado para manejar ese tipo de error en concreto. Es como si la gestión de excepciones constituyera una causa de ejecución diferente, paralela, que puede tomarse cuando algo va mal. Y dado que

usa una causa de ejecución distinta, no tiene por qué interferir con el código de ejecución normal. Delaware

de esta manera el código es más simple de escribir puesto que no hay que estar comprobando los errores continuamente. Además, una excepción lanzada no es como un valor de error devuelto por una

función, o un indicador (bandera) que una función pone a uno para indicar que se ha dado cierto

condición de error (estos podrían ser ignorados). Una excepción no se puede ignorar, por lo que se

Garantiza que será tratado antes o después. Finalmente, las excepciones proporcionan una manera de

recuperarse de manera segura de una situación anormal. En vez de simplemente salir, muchas veces

es posible volver a poner las cosas en su sitio y reestablecer la ejecución del programa, logrando así

que estos sean mucho más robustos.

El manejo de excepciones de Java destaca entre los lenguajes de programación pues en Java, éste

se encuentra imbuido desde el principio, y es obligatorio utilizarlo. Si no se escribe un código de

manera que maneje excepciones correctamente, se obtendrá un mensaje de error en el tiempo de

compilación. Esta garantía de consistencia hace que la gestión de errores sea mucho más sencilla.

Es importante destacar el hecho de que el manejo de excepciones no es una característica orientada

a objetos, aunque en los lenguajes orientados a objetos las excepciones se suelan representarme

diante un objeto. El manejo de excepciones existe.

Los conectables condujeron a la explosión de los lenguajes de guiones (scripting). Con uno de estos

lenguajes se integra el código fuente del programa de la parte cliente directamente en la página HTML,

y el conectable que interpreta ese lenguaje se activa automáticamente a medida que se muestra la página HTML. Estos lenguajes tienden a ser bastante sencillos de entender y, dado que son simplemente

texto que forma parte de una página HTML, se cargan muy rápidamente como parte del único acceso

al servidor mediante el que se accede a esa página. El sacrificio es que todo el mundo puede ver (y robar) el código así transportado. Sin embargo, generalmente, si no se pretende hacer cosas excesivamente complicadas, los lenguajes de guiones constituyen una buena herramienta, al no ser complicados.

Esto muestra que los lenguajes de guiones utilizados dentro de los navegadores web se desarrollaron verdaderamente para resolver tipos de problemas específicos, en particular la creación de interfaces gráficos de usuario (IGUs) más interactivos y ricos. Sin embargo, uno de estos lenguajes

puede resolver el 80% de los problemas que se presentan en la programación en el lado cliente. Este

80% podría además abarcar todos los problemas de muchos programadores, y dado que los lenguajes de programación permiten desarrollos mucho más sencillos y rápidos, es útil pensar en utilizar

uno de estos lenguajes antes de buscar soluciones más complicadas, como la programación en Java

o ActiveX.

Los lenguajes de guiones de navegador más comunes son JavaScript (que no tiene nada que ver con

Java; se denominó así simplemente para aprovechar el buen momento de marketing de Java),

VBScript (que se parece bastante a Visual Basic), y Tcl/Tk, que proviene del popular lenguaje de

construcción de IGU (Interfaz Gráfica de Usuario) de plataformas cruzadas. Hay otros más, y seguro que se desarrollarán muchos más.

JavaScript es probablemente el que recibe más apoyo. Viene incorporado tanto en el navegador

Netscape Navigator como en el Microsoft Internet Explorer (IE). Además, hay probablemente más libros de JavaScritpt que de otros lenguajes de navegador, y algunas herramientas crean páginas automáticamente haciendo uso de JavaScript. Sin embargo, si se tiene habilidad en el manejo de Visual

Basic o Tcl/Tk, será más productivo hacer uso de esos lenguajes de guiones en vez de aprender uno

nuevo. (De hecho, ya se habrá hecho uso de aspectos web para estas alturas.)

Java

Si un lenguaje de programación puede resolver el 80 por ciento de los problemas de programación en el lado cliente, ¿qué ocurre con el 20 por ciento restante -que constituyen de hecho "la

1: Introducción a los objetos 29

parte seria del problema"? La solución más popular hoy en día es Java. No sólo se trata de un

lenguaje de programación potente, construido para ser seguro, de plataforma cruzada (multiplataforma) e internacional, sino que se está extendiendo continuamente para proporcionar aspectos de lenguaje y bibliotecas que manejan de manera elegante problemas que son complicados

para los lenguajes de programación tradicionales, como la ejecución multihilo, el acceso a base

de datos, la programación en red, y la computación distribuida. Java permite programación en el

lado cliente a través del applet.

Un applet es un miniprograma que se ejecutará únicamente bajo un navegador web. El applet se

descarga automáticamente como parte de una página web (igual que, por ejemplo, se descarga

un gráfico, de manera automática). Cuando se activa un applet, ejecuta un programa. Ésta es parte de su belleza -proporciona una manera de distribuir automáticamente software cliente desde

el servidor justo cuando el usuario necesita software cliente, y no antes. El usuario se hace con

la última versión del software cliente, sin posibilidad de fallo, y sin tener que llevar a cabo reinstalaciones complicadas. Gracias a cómo se ha diseñado Java, el programado simplemente tiene

que crear un único programa, y este programa trabaja automiticamente en todos los computadores que tengan navegadores que incluyan intérpretes de Java. (Esto incluye seguramente a la

gran mayoría de plataformas.) Dado que Java es un lenguaje de programación para novatos, es

posible hacer tanto trabajo como sea posible en el cliente, antes y después de hacer peticiones

al servidor. Por ejemplo, no se deseará enviar un formulario de petición a través de Internet para

descubrir que se tiene una fecha o algún otro parámetro erróneo, y el computador cliente puede

llevar a cabo rápidamente la labor de registrar información en vez de tener que esperar a que lo

haga el servidor para enviar después una imagen gráfica de vuelta. No sólo se consigue un incremento de velocidad y capacidad de respuesta inmediatas, sino que el tráfico en general de la

red y la carga en los servidores se reduce considerablemente, evitando que toda Internet se vaya

ralentizando.

Una ventaja que tienen los applets de Java sobre los lenguajes de guiones es que se encuentra en

formato compilado, de forma que el código fuente no está disponible para el cliente. Por otro

lado, es posible descompilar un applet Java sin excesivo trabajo, pero esconder un código no es

un problema generalmente importante. Hay otros dos factores que pueden ser importantes.

Como se verá más tarde en este libro, un applet Java compilado puede incluir varios módulos e

implicar varios accesos al servidor para su descarga (en Java 1.1 y superiores, esto se minimiza

mediante archivos Java, denominados archivos JAR, que permiten que los módulos se empaqueten todos juntos y se compriman después para que baste con una única descarga). Un programa

de guiones se integrará simplemente en una página web como parte de su texto (y generalmente será más pequeño reduciendo los accesos al servidor). Esto podría ser importante de cara al

tiempo de respuesta del sitio web. Otro factor importante es la curva de aprendizaje. A pesar de

lo que haya podido oírse, Java no es un lenguaje cuyo aprendizaje resulte trivial. Para los programadores en Visual Basic, moverse a VBScript siempre será la solución más rápida, y dado

que probablemente este lenguaje resolverá los problemas cliente/servidor más típicos, puede resultar bastante complicado justificar la necesidad de aprender Java. Si uno ya tiene experiencia

con un lenguaje de guiones, seguro que se obtendrán beneficios simplemente haciendo uso de

JavaScript o VBScript antes de lanzarse a utilizar Java, ya que estos lenguajes pueden resolver

todos los problemas de manera sencilla, y se logrará un nivel de productividad elevado en un

tiempo menor.

30 Piensa en Java

ActiveX

Hasta cierto grado, el competidor principal de Java es el ActiveX de Microsoft, aunque se base en

un enfoque totalmente diferente. ActiveX era originalmente una solución válida exclusivamente para

Windows, aunque ahora se está desarrollando mediante un consorcio independiente de manera que

acabará siendo multiplataforma (plataforma cruzada). Efectivamente, ActiveX se basa en que "si un

programa se conecta a su entorno de manera que puede ser depositado en una página web y ejecutado en un navegador, entonces soporta ActiveX. (IE soporta ActiveX directamente, y Netscape

también, haciendo uso de un conectable.) Por consiguiente, ActiveX no se limita a un lenguaje particular. Si, por ejemplo, uno es un programador Windows experimentado, haciendo uso de un lenguaje como C++, Visual Basic o en Delphi de Borland, es posible crear componentes ActiveX sin casi

tener que hacer ningún cambio a los conocimientos de programación que ya se tengan. Además,

ActiveX proporciona un modo de usar código antiguo (base dado) en páginas web.

Seguridad

La capacidad para descargar y ejecutar programas a través de Internet puede parecer el sueño de

un constructor de virus. ActiveX atrae especialmente el espinoso tema de la seguridad en la programación en la parte cliente. Si se hace clic en el sitio web, es posible descargar automáticamente

cualquier número de cosas junto con la página HTML: archivos GIF, código de guiones, código Java

compilado, y componentes ActiveX. Algunos de estos elementos son benignos: los archivos GIF no

pueden hacer ningún daño, y los lenguajes de guiones se encuentran generalmente limitados en lo

que pueden hacer. Java también fue diseñado para ejecutar sus applets dentro de un "envoltorio" de

seguridad, lo que evita que escriba en el disco o acceda a la memoria externa a ese envoltorio.

ActiveX está en el rango opuesto del espectro. Programar con ActiveX es como programar Windows

-es posible hacer cualquier cosa. De esta manera, si se hace clic en una página web que descarga

un componente ActiveX, ese componente podría llegar a dañar los archivos de un disco. Por supuesto, los programas que uno carga en un computador, y que no están restringidos a ejecutarse

dentro del navegador web podrían hacer lo mismo. Los virus que se descargaban desde una BBS

(Bulletin-Board Systems) hace ya tiempo que son un problema, pero la velocidad de Internet amplifica su gravedad.

La solución parecen aportarla las "firmas digitales", que permiten la verificación de la autoría del código. Este sistema se basa en la idea de que un virus funciona porque su creador puede ser anónimo, de manera que si se evita la ejecución de programas anónimos, se obligará a cada persona a ser

responsable de sus actos. Esto parece una buena idea, pues permite a los programas ser mucho más

funcionales, y sospecho que eliminará las diabluras maliciosas. Si, sin embargo, un programa tiene

un error (bug) inintencionadamente destructivo, seguirá causando problemas.

El enfoque de Java es prevenir que estos problemas ocurran, a través del envoltorio. El intérprete

de Java que reside en el navegador web local examina el applet buscando instrucciones adversas a

medida que se carga el applet. Más en concreto, el applet no puede escribir ficheros en el disco o

borrar ficheros (una de las principales vías de ataque de los virus). Los applets se consideran generalmente seguros, y dado que esto es esencial para lograr sistemas cliente/servidor de confianza,

cualquier error (bug) que produzca virus en lenguaje Java será rápidamente reparado. (Merece la

1: Introducción a los objetos 31

pena destacar que el software navegador, de hecho, refuerza estas restricciones de seguridad, y algunos navegadores permiten seleccionar distintos niveles de seguridad para proporcionar distintos

grados de acceso a un sistema.)

También podría uno ser escéptico sobre esta restricción tan draconiana en contra de la escritura de

ficheros en un disco local. Por ejemplo, uno puede desear construir una base de datos o almacenar

datos para utilizarlos posteriormente, finalizada la conexión. La visión inicial parecía ser tal que

eventualmente todo el mundo podría conseguir hacer cualquier cosa importante estando conectado,

pero pronto se vio que esta visión no era práctica (aunque los "elementos Internet" de bajo coste

puedan satisfacer algún día las necesidades de un segmento de usuarios significativo). La solución

es el "applet firmado" que utiliza cifrado de clave pública para verificar que un applet viene efectivamente de donde dice venir. Un applet firmado puede seguir destrozando un disco local, pero la teoría es que dado que ahora es posible localizar al creador del applet, éstos no actuarán de manera

perniciosa. Java proporciona un marco de trabajo para las firmas digitales, de forma que será posible permitir que un applet llegue a salir fuera del envoltorio si es necesario.

Las firmas digitales han olvidado un aspecto importante, que es la velocidad con la que la gente se

mueve por Internet. Si se descarga un programa con errores (bugs) que hace algo dañino, ¿cuánto

tiempo se tardará en descubrir el daño? Podrían pasar días o incluso semanas. Para entonces, ¿cómo

localizar el programa que lo ha causado? ¿Y será todo el mundo capaz de hacerlo?

Internet frente a Intranet

La Web es la solución más general al problema cliente/servidor, de forma que tiene sentido que se

pueda utilizar la misma tecnología para resolver un subconjunto del problema, en particular, el clásico problema cliente/servidor dentro de una compañía. Con los enfoques cliente/servidor tradicionales, se tiene el problema de la multiplicidad de tipos de máquinas cliente, además de la dificultad

de instalar un nuevo software cliente, si bien ambos problemas pueden resolverse sencillamente con

navegadores web y programación en el lado cliente. Cuando se utiliza tecnología web para una red

de información restringida a una compañía en particular, se la denomina una Intranet. Las Intranets

proporcionan un nivel de seguridad mucho mayor que el de Internet, puesto que se puede controlar físicamente el acceso a los servidores dentro de la propia compañía. En términos de formación,

parece que una vez que la gente entiende el concepto general de navegador es mucho más sencillo

que se enfrenten a distintas páginas y applets, de manera que la curva de aprendizaje para nuevos

tipos de sistemas parece reducirse.

El problema de la seguridad nos conduce ante una de las divisiones que parece estar formándose

automáticamente en el mundo de la programación en el lado del cliente. Si un programa se ejecuta

en Internet, no se sabe bajo qué plataforma estará funcionando, y si se desea ser extremadamente

cauto, no se diseminará código con error. Es necesario algo multiplataforma y seguro, como un lenguaje de guiones o Java.

Si se está ejecutando código en una Intranet, es posible tener un conjunto de limitaciones distinto. No

es extraño que las máquinas de una red puedan ser todas plataformas Intel/Windows. En una Intranet,

uno es responsable de la calidad de su propio código y puede reparar errores en el iriomenlo en que

se descubren. Además, se podría tener cierta cantidad de código antiguo (heredado, legacy) que se ha

32 Piensa en Java

estado utilizando en un enfoque cliente/servidor más tradicional, en cuyo caso sería necesario instalar físicamente programas cliente cada vez que se construya una versión más moderna. El tiempo malgastado en instalar actualizaciones (upgrades) es la razón más apabullante para comenzar a usar navegadores, en los que estas actualizaciones son invisibles y automáticas. Para aquéllos que tengan

intranets, el enfoque más sensato es tomar el camino más corto que permita usar el código base

existente, en vez de volver a codificar todos los programas en un nuevo lenguaje.

Se ha hecho frente a este problema presentando un conjunto desconcertante de soluciones al problema de programación en el lado cliente, y la mejor determinación para cada caso es la que determine un análisis coste-beneficio. Deben considerarse las restricciones de cada problema y cuál sería el camino más corto para encontrar la solución en cada caso. Dado que la programación en la

parte cliente sigue siendo programación, suele ser buena idea tomar el enfoque de desarrollo más

rápido para cada situación. Ésta es una postura agresiva para prepararse de cara a inevitables enfrentamiento~ con los problemas del desarrollo de programas.

Programación en el lado del servidor

Hasta la fecha toda discusión ha ignorado el problema de la programación en el lado del servidor.

¿Qué ocurre cuando se hace una petición a un servidor? La mayoría de las veces la petición es simplemente "envíame este archivo". A continuación, el navegador interpreta el archivo de la manera

adecuada: como una página HTML, como una imagen gráfica, un applet Java, un programa de guiones, etc. Una petición más complicada hecha a un servidor puede involucrar una transacción de

base de datos. Un escenario común involucra una petición para una búsqueda compleja en una base

de datos, que el servidor formatea en una página HTML para enviarla a modo de resultado (por supuesto, si el cliente tiene una inteligencia mayor vía Java o un lenguaje de guiones, pueden enviarse los datos simplemente, sin formato, y será el extremo cliente el que les dé el formato adecuado,

lo cual es más rápido, además de implicar una carga menor para el servidor). Un usuario también

podría querer registrar su nombre en una base de datos al incorporarse a un grupo o presentar una

orden, lo cual implica cambios a esa base de datos. Estas peticiones deben procesarse vía algún código en el lado servidor, que se denomina generalmente programación en el lado servidor.

Tradicionalmente, esta programación se ha desempeñado mediante Perl y guiones CGI, pero han

ido apareciendo sistemas más sofisticados. Entre éstos se encuentran los servidores web basados

en Java que permiten llevar a cabo toda la programación del lado servidor en Java escribiendo lo

que se denominan servlets. Éstos y sus descendientes, los JSP, son las dos razones principales por

las que las compañías que desarrollan sitios web se están pasando a Java, especialmente porque eliminan los problemas de tener que tratar con navegadores de distintas características.

Un ruedo separado: las aplicaciones

Muchos de los comentarios en torno a Java se referían a los applets. Java es actualmente un lenguaje

de programación de propósito general que puede resolver cualquier tipo de problema -al menos

en teoría. Y como se ha señalado anteriormente, cuando uno se sale del ruedo de los applets (y simultáneamente se salta las restricciones, como la contraria a la escritura en el disco) se entra en el

mundo de las aplicaciones de propósito general que se ejecutan independientemente, sin un nave-

1 : Introducción a los objetos 33

gador web, al igual que hace cualquier programa ordinario. Aquí, la fuerza de Java no es sólo su portabilidad, sino también su programabilidad (facilidad de programación). Como se verá a lo largo del

presente libro, Java tiene muchos aspectos que permiten la creación de programas robustos en un

período de tiempo menor al que requerían los lenguajes de programación anteriores.

Uno debe ser consciente de que esta bendición no lo es del todo. El precio a pagar por todas estas

mejoras es una velocidad de ejecución menor (aunque se está haciendo bastante trabajo en este área

-JDK 1.3, en particular, presenta las mejoras de rendimiento denominadas "hotspot"). Como cualquier lenguaje, Java tiene limitaciones intrínsecas que podrían hacerlo inadecuado para resolver

cierto tipo de problemas de programación. Java es un lenguaje que evoluciona rápidamente, no obstante, y cada vez que aparece una nueva versión, se presenta más y más atractivo de cara a la solución de conjuntos mayores de problemas.

Análisis y diseño

El paradigma de la orientación a obietos es una nueva manera de enfocar la programación. Son muchos los que tienen problemas a primera vista para enfrentarse a un proyecto de POO. Dado que se

supone que todo es un objeto, y a medida que se aprende a pensar de forma orientada a objetos, es

posible empezar a crear "buenos" diseños y sacar ventaja de todos los beneficios que la PO0 puede ofrecer.

Una metodología es un conjunto de procesos y heurísticas utilizadas para descomponer la complejidad de un problema de programación. Se han formulado muchos métodos de PO0 desde que enunció la programación orientada a objetos. Esta sección presenta una idea de lo que se trata de lograr

al utilizar un método.

Especialmente en la POO, la metodología es un área de intensa experimentación, por lo que es importante entender qué problema está intentando resolver el método antes de considerar la adopción

de uno de ellos. Esto es particularmente cierto con Java, donde el lenguaje de programación se ha

desarrollado para reducir la complejidad (en comparación con C) necesaria para expresar un programa. Esto puede, de hecho, aliviar la necesidad de metodologías cada vez más complejas. En vez

de esto, puede que las metodologías simples sean suficientes en Java para conjuntos de problemas

mucho mayores que los que se podrían manipular utilizando metodologías simples con lenguajes

procedimentales.

También es importante darse cuenta de que el término "metodología" es a menudo muy general y

promete demasiado. Se haga lo que se haga al diseñar y escribir un programa, se sigue un método.

Puede que sea el método propio de uno, e incluso puede que uno no sea consciente de utilizarlo,

pero es un proceso que se sigue al crear un programa. Si el proceso es efectivo, puede que simplemente sea necesario afinarlo ligeramente para poder trabajar con Java. Si no se está satisfecho con

el nivel de productividad y la manera en que se comportan los programas, puede ser buena idea co~isiderar la adopción de un método formal, o la selección dc fragmentos de entre los muchos métodos formales existentes.

Mientras se está en el propio proceso de desarrollo, el aspecto más importante es no perderse, aunque puede resultar fácil. Muchos de los métodos de análisis y desarrollo fueron concebidos para re-

34 Piensa en Java

solver los problemas más grandes. Hay que recordar que la mayoría de proyectos no encajan en esta

categoría, siendo posible muchas veces lograr un análisis y un diseño con éxito con sólo un pequeño subconjunto de los que el método recomienda"'. Pero algunos tipos de procesos, sin importar lo

limitados que puedan ser, le permitirán encontrar el camino de manera más sencilla que si simplemente se empieza a codificar.

También es fácil desesperarse, caer en "parálisis de análisis", cuando se siente que no se puede

avanzar porque no se han cubierto todos los detalles en la etapa actual. Debe recordarse que, independientemente de cuánto análisis lleve a cabo, hay cosas de un sistema que no aparecerán hasta la fase de diseño, y otras no aflorarán incluso hasta la fase de codificación o en un extremo, hasta que el programa esté acabado y en ejecución. Debido a esto, es crucial moverse lo

suficientemente rápido a través de las etapas de análisis y diseño e implementar un prototipo del

sistema propuesto.

Debe prestarse un especial énfasis a este punto. Dado que ya se conoce la misma historia con los

lenguajes procedimentales, es recomendable que el equipo proceda de manera cuidadosa y comprenda cada detalle antes de pasar del diseño a la implementación. Ciertamente, al crear un SGBD,

esto pasa por comprender completamente la necesidad del cliente. Pero un SGBD es la clase de

problema bien formulada y bien entendida; en muchos programas, es la estructura de la base de

datos la que debe ser desmenuzada. La clase de problema de programación examinada en el presente capítulo es un "juego de azar"", en el que la solución no es simplemente la formulación de

una solución bien conocida, sino que involucra además a uno o más "factores de azar" -elementos para los que no existe una solución previa bien entendida, y para los cuales es necesario algún

tipo de proceso de investigaciónl7. Intentar analizar completamente un problema al azar antes de

pasar al diseño e implementación conduce a una parálisis en el análisis, al no tener suficiente información para resolver este tipo de problemas durante la fase de análisis. Resolver un problema

así, requiere iterar todo el ciclo, y precisa de un comportamiento que asuma riesgos (lo cual tiene

sentido, pues está intentando hacer algo nuevo y las recompensas potenciales crecen). Puede parecer que el riesgo se agrava al precipitarse hacia una implementación preliminar, pero ésta puede

reducir el riesgo en los problemas al azar porque se está averiguando muy pronto si un enfoque

particular al problema es o no viable. El desarrollo de productos conlleva una gestión del riesgo.

A menudo, se propone "construir uno para desecharlo". Con PO0 es posible tirar parte, pero dado

que el código está encapsulado en clases, durante la primera pasada siempre se producirá algún diseño de clases útil y se desarrollarán ideas que merezcan la pena para el diseño del sistema de las

que no habrá que deshacerse. Por tanto, la primera pasada rápida por un problema no sólo suministra información crítica para las ulteriores pasadas por análisis, diseño e implementación, sino que

también crea la base del código.

lo Un ejemplo excelente dr esto es UML Uistilled, 2." edición, de Martin Fowler (Addison-Wesley 2000). que reducc cl proccso, en

ocasiones aplastante, a un subconjunto rriariejable (existe vei-sión española con el título UMI, gota a gota).

" N. del traductor: Término wild-card, acunado por el autor original.

" Regla del pulgar -acuñada por el autor- para estimar este tipo de proyectos: si hay más de un factor al azar, ni siquiera debe

intentarse planificar la duración o el coste del proyecto hasta que no se ha creado un prototipo que funcione. Existen demasiados

grados de libertad.

1 : Introducción a los objetos 35

Dicho esto, si se está buscando una metodología que contenga un nivel de detalle tremendo, y sugiera muchos pasos y documentos, puede seguir siendo difícil saber cuándo parar. Debe recomendarse lo que se está intentando descubrir.

1. ¿Cuáles son los objetos? (¿Cómo se descompone su proyecto en sus componentes?)

2. ¿Cuáles son las interfaces? (¿Qué mensajes es necesario enviar a cada objeto?)

Si se delimitan los objetos y sus interfaces, ya es posible escribir un programa. Por diversas razones, puede que sean necesarias más descripciones y documentos que éste, pero no es posible avanzar con menos.

El proceso puede descomponerse en cinco fases, y la Fase O no es más que la adopción de un compromiso para utilizar algún tipo de estructura.

Fase O: Elaborar un plan

En primer lugar, debe decidirse qué pasos debe haber en un determinado proceso. Suena bastante

simple (de hecho, todo esto suena simple) y la gente no obstante, suele seguir sin tomar esta decisión antes de empezar a codificar. Si el plan consiste en "empecemos codificando", entonces, perfecto (en ocasiones, esto es apropiado, si uno se está enfrentando a un problema que conoce perfectamente). Al menos, hay que estar de acuerdo en que eso también es tener un plan.

También podría decidirse en esta fase que es necesaria alguna estructura adicional de proceso, pero

no toda una metodología completa. Para que nos entendamos, a algunos programadores les gusta

trabajar en "modo vacación", en el que no se imponga ninguna estructura en el proceso de desarrollar de su trabajo; "se hará cuando se haga". Esto puede resultar atractivo a primera vista, pero a

medida que se tiene algo de experiencia uno se da cuenta de que es mejor ordenar y distribuir el

esfuerzo en distintas etapas en vez de lanzarse directamente a "finalizar el proyecto". Además, de

esta manera se divide el proyecto en fragmentos más asequibles, y se resta miedo a la tarea de enfrentarse al mismo (además, las distintas fases o hitos proporcionan más motivos de celebración).

Cuando empecé a estudiar la estructura de la historia (con el propósito de acabar escribiendo algún

día una novela), inicialmente, la idea que más me disgustaba era la de la estructura, pues parecía

que uno escribe mejor si simplemente se dedica a rellenar páginas. Pero más tarde descubrí que al

escribir sobre computadores, tenía la estructura tan clara que no había que pensar demasiado en

ella. Pero aún así, el trabajo se estructuraba, aunque sólo fuera semiconscientemente en mi cabeza.

Incluso cuando uno piensa que el plan consiste simplemente en empezar a codificar, todavía se atraviesan algunas fases al plantear y contestar ciertas preguntas.

El enunciado de la misión

Cualquier sistema que uno construya, independientemente de lo complicado que sea, tiene un propósito fundamental: el negocio intrínseco en el mismo, la necesidad básica que cumple. Si uno puede mirar a través de la interfaz de usuario, a los detalles específicos del hardware o del sistema, los

algoritinos de codificación y los problemas de eficiencia, entonces se encuentra el centro de su existencia -simple y directo. Como el denominado alto concepto (high concept) en las películas de

36 Piensa en Java

Hollywood, uno puede describir el propósito de un programa en dos o tres fases. Esta descripción,

pura, es el punto de partida.

El alto concepto es bastante importante porque establece el tono del proyecto; es el enunciado de su

misión. Uno no tiene por qué acertar necesariamente a la primera (puede ser que uno esté en una fase

posterior del problema cuando se le ocurra el enunciado completamente correcto) pero hay que se

guir intentándolo hasta tener la certeza de que está bien. Por ejemplo, en un sistema de control de trá.

fico aéreo, uno puede comenzar con un alto concepto centrado en el sistema que se está construyendo: "El programa de la torre hace un seguimiento del avión". Pero considérese qué ocurre cuando se

introduce el sistema en un pequeño aeródromo; quizás sólo hay un controlador humano, o incluso ninguno. Un modelo más usual no abordará la solución que se está creando como describe el problema:

"Los aviones llegan, descargan, son mantenidos y recargan, a continuación, salen".

Fase 1: ¿Qué estamos construyendo?

En la generación previa del diseño del programa (denominada diseño procedural) a esta fase se le de

nominaba "creación del análisis de requisitos y especificación del sistema". Éstas, por supuesto, eran fases en las que uno se perdía; documentos con nombres intimidadores que podían de por sí convertirse en grandes proyectos. Sin embargo, su intención era buena. El análisis de requisitos dice:

"Construya una lista de directrices que se utilizarán para saber cuándo se ha acabado el trabajo y cuándo el cliente está satisfecho". La especificación del sistema dice: "He aquí una descripción de lo que el

programa hará (pero no cómo) para satisfacer los requisitos hallados". El análisis de requisitos es verdaderamente un contrato entre usted y el cliente (incluso si el cliente trabaja en la misma compañía o

es cualquier otro objeto o sistema). La especificación del sistema es una exploración de alto nivel en

el problema, y en cierta medida, un descubrimiento de si puede hacerse y cuánto tiempo llevará. Dado

que ambos requieren de consenso entre la gente (y dado que generalmente variarán a lo largo del

tiempo) lo mejor es mantenerlos lo más desnudos posible -idealmente, tratará de listas y diagrarnas

básicos para ahorrar tiempo. Se podría tener otras limitaciones que exijan expandirlos en documentos

de mayor tamaño, pero si se mantiene que el documento inicial sea pequeño y conciso, es posible cre

arlo en unas pocas sesiones de tormenta de ideas (brainstorming) en grupo, con un líder que dinámicamente va creando la descripción. Este proceso no sólo exige que todos aporten sus ideas sino que

fomenta el que todos los miembros del equipo lleguen a un acuerdo inicial. Quizás lo más importante

es que puede incluso ayudar a que se acometa el proyecto con una gran dosis de entusiasmo.

Es necesario mantenerse centrado en el corazón de lo que se está intentando acometer en esta fase:

determinar qué es lo que se supone que debe hacer el sistema. La herramienta más valiosa para

esto es una colección de lo que se denomina "casos de uso". Los casos de uso identifican los aspectos claves del sistema, que acabarán por revelar las clases fundamentales que se usarán en éste.

De hecho, los casos de uso son esencialmente soluciones descriptivas a preguntas como1":

''¿Quién usará el sistema?"

''¿Qué pueden hacer esos actores con el sistema?"

" Agradecemos la ayuda de James H. Jarrett

1 : Introducción a los objetos 37

¿Cómo se las ingenia cada actor para hacer eso con este sistema?"

"¿De qué otra forma podría funcionar esto si alguien más lo estuviera haciendo, o si el mismo

actor tuviera un objetivo distinto?" (Para encontrar posibles variaciones.)

''¿Qué problemas podrían surgir mientras se hace esto con el sistema?" (Para localizar posibles

excepciones.)

Si se está diseñando, por ejemplo, un cajero automático, el caso de uso para un aspecto particular de

la funcionalidad del sistema debe ser capaz de describir qué hace el cajero en cada situación posible.

Cada una de estas "situaciones" se denomina un escenario, y un caso de uso puede considerarse como

una colección de escenarios. Uno puede pensar que un escenario es como una pregunta que empieza

por: ''¿Qué hace el sistema si...?". Por ejemplo: ''¿Qué hace el cajero si un cliente acaba de depositar

durante las últimas 24 horas un cheque y no hay dinero suficiente en la cuenta, sin haber procesado

el cheque, para proporcionarle la retirada el efectivo que ha solicitado?"

Deben utilizarse diagramas de caso de uso intencionadamente simples para evitar ahogarse prematuramente en detalles de implementación del sistema :

Cada uno de los monigotes representa a un "actor", que suele ser generalmente un humano o cualquier otro tipo de agente (por ejemplo, otro sistema de computación, como "ATM")14. La caja representa los límites de nuestro sistema. Las elipses representan los casos de uso, que son descripciones del trabajo útil que puede hacerse dentro del sistema. Las líneas entre los actores y los casos

de uso representan las interacciones.

De hecho no importa cómo esté el sistema implementado, siempre y cuando tenga una apariencia

como ésta para el usuario.

l4 ATM, siglas en inglés de cajero automático. (N. del T. )

38 Piensa en Java

Un caso de uso no tiene por qué ser terriblemente complejo, aunque el sistema subyacente sea complejo. Solamente se pretende que muestre el sistema tal y como éste se muestra al usuario. Por

ejemplo:

o ~ l nvernadero

Temperatura

Jardinero ~

Los casos de uso proporcionan las especificaciones de requisitos determinando todas las interacciones que el usuario podría tener con el sistema. Se trata de descubrir un conjunto completo de casos de uso para su sistema, y una vez hecho esto, se tiene el núcleo de lo que el sistema se supone

que hará. Lo mejor de centrarse en los casos de uso es que siempre permiten volver a la esencia

manteniéndose alejado de aspectos que no son críticos para lograr culminar el trabajo. Es decir, si

se tiene un conjunto completo de casos de uso, es posible describir el sistema y pasar a la siguiente fase. Posiblemente no se podrá configurar todo a la primera, pero no pasa nada. Todo irá surgiendo a su tiempo, y si se demanda una especificación perfecta del sistema en este punto, uno se

quedará parado.

Cuando uno se quede bloqueado, es posible comenzar esta fase utilizando una extensa herramienta de aproximación: describir el sistema en unos pocos párrafos y después localizar los sustantivos

y los verbos. Los sustantivos pueden sugerir quiénes son los actores, el contexto del caso de uso

(por ejemplo, "corredor"), o artefactos manipulados en el caso de uso. Los verbos pueden sugerir

interacciones entre los actores y los casos de uso, y especificar los pasos dentro del caso de uso.

También será posible descubrir que los sustantivos y los verbos producen objetos y mensajes durante la fase de diseño (y debe tenerse en cuenta que los casos de uso describen interacciones entre subsistemas, de forma que la técnica de "el sustantivo y el verbo" puede usarse sólo como una

herramienta de tormenta de ideas, pues no genera casos de uso)15.

La frontera entre un caso de uso y un actor puede señalar la existencia de una interfaz de usuario, pero

no lo define. Para ver el proceso de cómo definir y crear interfaces de usuario, véase Softwarefor Use de

Larry Constantine y Lucy Lockwood, (Addison-Wesley Longman, 1999) o ir a http://www. forUse.com.

Aunque parezca magia negra, en este punto es necesario algún tipo de planificación. Ahora se tiene

una visión de lo que se está construyendo, por lo que probablemente se pueda tener una idea de

cuánto tiempo le llevará. En este momento intervienen muchos factores. Si se estima una planificación larga, la compañía puede decidir no construirlo (y por consiguiente usar sus recursos en algo

más razonable -esto es bueno). Pero un director podría tener decidido de antemano cuánto tiempo

debería llevar el proyecto y podría tratar de influir en la estimación. Pero lo mejor es tener una estimación honesta desde el principio y tratar las decisiones duras al principio. Ha habido muchos inl5 Puede encontrarse más información sobre casos de uso en Applying Use Cases, de Schneider & Winters (Addison-Weley 1998) y

Use Case Driven Object modeling with UML de Rosenberg (Addison-Welsey 1999).

1 : Introducción a los objetos 39

tentos de desarrollar técnicas de planificación exactas (muy parecidas a las técnicas de predicción

del mercado de valores), pero probablemente el mejor enfoque es confiar en la experiencia e intuición. Debería empezarse por una primera estimación del tiempo que llevaría, para posteriormente

multiplicarla por dos y añadirle el 10 por ciento. La estimación inicial puede que sea correcta; a lo

mejor se puede hacer que algo funcione en ese tiempo. Al "doblarlo" resultará que se consigue algo

decente, y en el 10 por ciento añadido se puede acabar de pulir y tratar los detalles finalesl6. Sin embargo, es necesario explicarlo, y dejando de lado las manipulaciones y quejas que surgen al presentar una planificación de este tipo, normalmente funcionará.

Fase 2: ¿Cómo construirlo?

En esta fase debe lograrse un diseño que describe cómo son las clases y cómo interactuarán. Una

técnica excelente para determinar las clases e interacciones es la tarjeta Clase-ResponsabilidadColaboración (CRC)17. Parte del valor de esta herramienta se basa en que es de muy baja tecnología: se comienza con un conjunto de tarjetas de 3 x 5, y se escribe en ellas. Cada tarjeta representa

una única clase, y en ella se escribe:

1. El nombre de la clase. Es importante que este nombre capture la esencia de lo que hace la clase, de manera que tenga sentido a primera vista.

2. Las "responsabilidades" de la clase: qué debería hacer. Esto puede resumirse típicamente escribiendo simplemente los nombres de las funciones miembros (dado que esas funciones deberían ser descriptivas en un buen diseño), pero no excluye otras anotaciones. Si se necesita

ayuda, basta con mirar el problema desde el punto de vista de un programador holgazán: ¿qué

objetos te gustaría que apareciesen por arte de magia para resolver el problema?

3. Las "colaboraciones" de la clase: ¿con qué otras clases interactúa? "Interactuar" es un término

amplio intencionadamente; vendría a significar agregación, o simplemente que cualquier otro

objeto existente ejecutara servicios para un objeto de la clase. Las colaboraciones deberían

considerar también la audiencia de esa clase. Por ejemplo, si se crea una clase Petardo,

¿quién la va a observar, un Químico o un Observador? En el primer caso estamos hablando

de punto de vista del químico que va a construirlo, mientras que en el segundo se hace referencia a los colores y las formas que libere al explotar.

Uno puede pensar que las tarjetas deberían ser más grandes para que cupiera en ellas toda la información que se deseara escribir, pero son pequeñas a propósito, no sólo para mantener pequeño

el tamaño de las clases, sino también para evitar que se caiga en demasiado nivel de detalle muy

pronto. Si uno no puede encajar todo lo que necesita saber de una clase en una pequeña tarjeta, la

clase es demasiado compleja (o se está entrando en demasiado nivel de detalle, o se debería crear

más de una clase). La clase ideal debería ser comprensible a primera vista. La idea de las tarjetas

CRC es ayudar a obtener un primer diseño de manera que se tenga un dibujo a grandes rasgos que

pueda ser después refinado.

Mi opinión en este sentido ha cambiado últimamente. Al doblar y añadir el 10 por ciento se obtiene una estimación razonablemente exacta (asumiendo que no hay demasiados factores al azar) pero todavía hay que trabajar con bastante diligencia para finaliar en ese tiempo. Si se desea tener tiempo suficiente para lograr un producto verdaderamente elegante y disfrutar durante el proceso, el multiplicador correcto, en mi opinión, puede ser por tres o por cuatro.

l7 En inglés, Class-Responsibility-Collaboration. (N. del R.T.)

40 Piensa en Java

Una de las mayores ventajas de las tarjetas CRC se logra en la comunicación. Cuando mejor se hace

es en tiempo real, en grupo y sin computadores. Cada persona se considera responsable de varias

clases (que al principio no tienen ni nombres ni otras informaciones). Se ejecuta una simulación en

directo resolviendo cada vez un escenario, decidiendo qué mensajes se mandan a los distintos objetos para satisfacer cada escenario. A medida que se averiguan las responsabilidades y colaboraciones de cada una, se van rellenando las tarjetas correspondientes. Cuando se han recorrido todos

los casos de uso, se debería tener un diseño bastante completo.

Antes de empezar a usar tarjetas CRC, tuve una experiencia de consultoría de gran éxito, que me

permitió presentar un diseño inicial a todo el equipo, que jamás había participado en un proyecto

de POO, y que consistió en ir dibujando objetos en una pizarra, después de hablar sobre cómo se

deberían comunicar los objetos entre sí, y tras borrar algunos y reemplazar otros. Efectivamente,

estaban haciendo uso de "tarjetas CRC" en la propia pizarra. El equipo (que sabía que el proyecto se iba a hacer) creó, de hecho, el diseño; ellos eran los "propietarios" del diseño, más que recibirlo hecho directamente. Todo lo que yo hacía era guiar el proceso haciendo en cada momento las preguntas adecuadas, poniendo a prueba los distintos supuestos, y tomando la

realimentación del equipo para ir modificando los supuestos. La verdadera belleza del proyecto es

que el equipo aprendió cómo hacer diseño orientado a objetos no repasando ejemplos o resúmenes de ejemplos, sino trabajando en el diseño que les pareció más interesante en ese momento:

el de ellos mismos.

Una vez que se tiene un conjunto de tarjetas CRC se desea crear una descripción más formal del diseño haciendo uso de UML18. No es necesario utilizar UML, pero puede ser de gran ayuda, especialmente si se desea poner un diagrama en la pared para que todo el mundo pueda ponderarlo, lo

cual es una gran idea. Una alternativa a UML es una descripción textual de los objetos y sus interfaces, o, dependiendo del lenguaje de programación, el propio cÓdigol9.

UML también proporciona una notación para diagramas que permiten describir el modelo dinámico del sistema. Esto es útil en situaciones en las que las transiciones de estado de un sistema

o subsistema son lo suficientemente dominantes como para necesitar sus propios diagramas

(como ocurre en un sistema de control). También puede ser necesario describir las estructuras

de datos, en sistemas o subsistemas en los que los datos sean un factor dominante (como una

base de datos).

Sabemos que la Fase 2 ha acabado cuando se han descrito los objetos y sus interfaces. Bueno, la

mayoría -hay generalmente unos pocos que quedan ocultos y que no se dan a conocer hasta la

Fase 3. Pero esto es correcto. En lo que a uno respecta, esto es todo lo que se ha podido descubrir

de los objetos a manipular. Es bonito descubrirlos en las primeras etapas del proceso pero la PO0

proporciona una estructura tal, que no presenta problema si se descubren más tarde. De hecho, el

diseño de un objeto tiende a darse en cinco etapas, a través del proceso completo de desarrollo de

un programa.

'Vara los principiantes, recomiendo UML Distilled, 2." edición.

'"han (http://www.Python.orgJ suele utilizarse como "pseudocódigo ejecutable".

1: Introducción a los objetos 41

Las cinco etapas del diseño de un objeto

La duración del diseño de un objeto no se limita al tiempo empleado en la escritura del programa, sino

que el diseño de un objeto conlleva una serie de etapas. Es útil tener esta perspectiva porque se deja de

esperar la perfección; por el contrario, uno comprende lo que hace un objeto y el nombre que debería

tener surge con el tiempo. Esta visión también se aplica al diseño de varios tipos de programas; el patrón

para un tipo de programa particular emerge al enfrentarse una y otra vez con el problema (esto se encuentra descrito en el libro Thinking in Patterns with Java, descargable de http://www. BruceEckel.com).

Los objetos, también tienen su patrón, que emerge a través de su entendimiento, uso y reutiliiación.

1. Descubrimiento de los objetos. Esta etapa ocurre durante el análisis inicial del programa. Se

descubren los objetos al buscar factores externos y limitaciones, elementos duplicados en el sistema, y las unidades conceptuales más pequeñas. Algunos objetos son obvios si ya se tiene un conjunto de bibliotecas de clases. La comunidad entre clases que sugieren clases bases y herencia, puede aparecer también en este momento, o más tarde dentro del proceso de diseño.

2. Ensamblaje de objetos. Al construir un objeto se descubre la necesidad de nuevos miembros

que no aparecieron durante el descubrimiento. Las necesidades internas del objeto pueden requerir de otras clases que lo soporten.

3. Construcción del sistema. De nuevo, pueden aparecer en esta etapa más tardía nuevos requisitos para el objeto. Así se aprende que los objetos van evolucionando. La necesidad de un objeto de

comunicarse e interconectarse con otros del sistema puede hacer que las necesidades de las clases

existentes cambien, e incluso hacer necesarias nuevas clases. Por ejemplo, se puede descubrir la necesidad de clases que faciliten o ayuden, como una lista enlazada, que contiene poca o ninguna información de estado y simplemente ayuda a la función de otras clases.

4. Aplicación del sistema. A medida que se añaden nuevos aspectos al sistema, puede que se descubra que el diseño previo no soporta una ampliación sencilla del sistema. Con esta nueva información, puede ser necesario reestructurar partes del sistema, generalmente añadiendo nuevas clases

o nuevas jerarquías de clases.

5. Reutilización de objetos. Ésta es la verdadera prueba de diseño para una clase. Si alguien trata de reutilizarla en una situación completamente nueva, puede que descubra pequeños inconvenientes. Al cambiar una clase para adaptarla a más programas nuevos, los principios generales de la

clase se mostrarán más claros, hasta tener un tipo verdaderamente reutilizable. Sin embargo, no

debe esperarse que la mayoría de objetos en un sistema se diseñen para ser reutilizados -es perfectamente aceptable que un porcentaje alto de los objetos sean específicos del sistema para el que

fueron diseñados. Los tipos reutilizables tienden a ser menos comunes, y deben resolver problemas

más generales para ser reutilizables.

Guías para el desarrollo de objetos

Estas etapas sugieren algunas indicaciones que ayudarán a la hora de pensar en el desarrollo de

clases:

1. Debe permitirse que un problema específico genere una clase, y después dejar que la clase

crezca y madure durante la solución de otros problemas.

Piensa en Java

Debe recordarse que descubrir las clases (y SUS interfaces) que uno necesita es la tarea principal del diseño del sistema. Si ya se disponía de esas clases, el proyecto será fácil.

No hay que forzar a nadie a saber todo desde el principio; se aprende sobre la marcha.Y esto

ocurrirá poco a poco.

Hay que empezar programando; es bueno lograr algo que funcione de manera que se pueda

probar la validez o no de un diseño. No hay que tener miedo a acabar con un código de estilo

procedimental malo -las clases segmentan el problema y ayudan a controlar la anarquía y la

entropía. Las clases malas no estropean las clases buenas.

Hay que mantener todo lo más simple posible. Los objetos pequeños y limpios con utilidad obvia son mucho mejores que interfaces grandes y complicadas. Cuando aparecen puntos de diseño puede seguirse el enfoque de una afeitadora de Occam: se consideran las alternativas y

se selecciona la más simple, porque las clases simples casi siempre resultan mejor. Hay que

empezar con algo pequeño y sencillo, siendo posible ampliar la interfaz de la clase al entenderla mejor. A medida que avance el tiempo será difícil eliminar elementos de una clase.

Fase 3: Construir el núcleo

Ésta es la conversión inicial de diseño pobre en un código compilable y ejecutable que pueda ser

probado, y especialmente, que pueda probar la validez o no de la arquitectura diseñada. Este proceso no se puede hacer de una pasada, sino que consistirá más bien en una serie de pasos que permitirán construir el sistema de manera iterativa, como se verá en la Fase 4.

Su objetivo es encontrar el núcleo de la arquitectura del sistema que necesita implementar para generar un sistema ejecutable, sin que importe lo incompleto que pueda estar este sistema en esta fase

inicial. Está creando un armazón sobre el que construir en posteriores iteraciones. También se está

llevando a cabo la primera de las muchas integraciones y pruebas del sistema, a la vez que proporcionando a los usuarios una realimentación sobre la apariencia que tendrá su sistema, y cómo va

progresando. Idealmente, se están además asumiendo algunos riesgos críticos. De hecho, se descubrirán posibles cambios y mejoras que se pueden hacer sobre el diseño original -cosas que no

se hubieran descubierto de no haber implementado el sistema.

Una parte de la construcción del sistema es comprobar que realmente se cumple el análisis de requisitos y la especificación del sistema que realmente cumple el analisis de requisitos y la especificación del sistema (independientemente de la forma en que estén planteados). Debe asegurarse que

las pruebas verifican los requerimientos y los casos de uso. Cuando el corazón del sistema sea estable, será posible pasar a la siguiente fase y añadir nuevas funcionalidades.

Fase 4: Iterar los casos de uso

Una vez que el núcleo del sistema está en ejecución, cada característica que se añada es en sí misma un pequeño proyecto. Durante cada iteración, entendida como un periodo de desarrollo razonablemente pequeño, se añade un conjunto de características.

1 : Introducción a los objetos 43

$tíal debe ser la duración de una iteración? Idealmente, cada iteración dura de una a tres semanas

(la duración puede variar en función del lenguaje de implementación). Al final de ese periodo, se tiene un sistema integrado y probado con una funcionalidad mayor a la que tenía previamente. Pero lo

particularmente interesante es la base de la iteración: un único caso de uso. Cada caso de uso es un

paquete de funcionalidad relacionada que se construye en el sistema de un golpe, durante una iteración. Esto no sólo proporciona una mejor idea de lo que debería ser el ámbito de un caso de uso,

sino que además proporciona una validación mayor de la idea del mismo, dado que el concepto no

queda descartado hasta después del análisis y del diseño, pues éste es una unidad de desarrollo fundamental a lo largo de todo el proceso de construcción de software.

Se deja de iterar al lograr la funcionalidad objetivo, o si llega un plazo y el cliente se encuentra satisfecho con la versión actual (debe recordarse que el software es un negocio de suscripción). Dado

que el proceso es iterativo, uno puede tener muchas oportunidades de lanzar un producto, más que

tener un único punto final; los proyectos abiertos trabajan exclusivamente en entornos iterativos de

gran nivel de realimentación, que es precisamente lo que les permite acabar con éxito.

Un proceso de desarrollo iterativo tiene gran valor por muchas razones. Si uno puede averiguar y

resolver pronto los riesgos críticos, los clientes pueden tener muchas oportunidades de cambiar de

idea, la satisfacción del programador es mayor, y el proyecto puede guiarse con mayor precisión.

Pero otro beneficio adicional importante es la realimentación a los usuarios, que pueden ver a través del estado actual del producto cómo va todo. Así es posible reducir o eliminar la necesidad de

reuniones de estado "entumece-mentes" e incrementar la confianza y el soporte de los usuarios.

Fase 5: Evolución

Éste es el punto del ciclo de desarrollo que se ha denominado tradicionalmente "mantenimiento",

un término global que quiere decir cualquier cosa, desde "hacer que funcione de la manera que se

suponía que lo haría en primer lugar", hasta "añadir aspectos varios que el cliente olvidó mencionar", pasando por el tradicional "arreglar los errores que puedan aparecer" o "la adición de nuevas

características a medida que aparecen nuevas necesidades". Por ello, al término "mantenimiento" se

le han aplicado numerosos conceptos erróneos, lo que ha ocasionado un descenso progresivo de su

calidad, en parte porque sugiere que se construyó una primera versión del programa en la cual hay

que ir cambiando partes, además de engrasarlo para evitar que se oxide. Quizás haya un término

mejor para describir lo que está pasando.

Prefiero el término evolución2". De esta forma, "uno no acierta a la primera, por lo que debe concederse la libertad de aprender y volver a hacer nuevos cambios". Podríamos necesitar muchos cambios a medida que vamos aprendiendo y comprendiendo con más detenimiento el problema. A corto y largo plazo, será el propio programa el que se verá beneficiado de este proceso continuo de

evolución. De hecho, ésta permitirá que el programa pase de bueno a genial, haciendo que se aclaren aquellos aspectos que no fueron verdaderamente entendidos en la primera pasada. También es

20 El libro de Martin Fowler Refactoring: improuing the design of existing code (Addison-Wesley, 1999) cubre al menos un aspecto de

la evolución, utilizando exclusivamente ejemplos en Java.

44 Piensa en Java

en este proceso en el que las clases se convierten en recursos reutilizables, en vez de clases diseñadas para su uso en un solo proyecto.

"Hacer el proyecto bien" no sólo implica que el programa funcione de acuerdo con los requisitos y

casos de uso. También quiere decir que la estructura interna del código tenga sentido, y que parezca que encaja bien, sin aparentar tener una sintaxis extraña, objetos de tamaño excesivo o con

fragmentos inútiles de código. Además, uno debe tener la sensación de que la estructura del programa sobrevivirá a los cambios que inevitablemente irá sufriendo a lo largo de su vida, y de que

esos cambios se podrán hacer de forma sencilla y limpia. Esto no es trivial. Uno no sólo debe entender qué es lo que está construyendo, sino también cómo evolucionará el programa (lo que yo

denomino el vector del cambio). Afortunadamente, los lenguajes de programación orientada a objetos son especialmente propicios para soportar este tipo de modificación continua -los límites creados por los objetos son los que tienden a lograr una estructura sólida. También permiten hacer cambios -que en un programa procedural parecerían drásticos- sin causar terremotos a lo largo del

código. De hecho, el soporte a la evolución podría ser el beneficio más importante de la POO.

Con la evolución, se crea algo que al menos se aproxima a lo que se piensa que se-está construyendo, se compara con los requisitos, y se ve dónde se ha quedado corto. Después, se puede volver

y ajustarlo diseñando y volviendo a implementar las porciones del programa que no funcionaron correctamente". De hecho, es posible que se necesite resolver un problema, o determinado aspecto

de un problema, varias veces antes de dar con la solución correcta (suele ser bastante útil estudiar

en este momento el Diseño de Patrones). También es posible encontrar información en Thinking in

Patterns with Java, descargable de http://www. BruceEcke1.com).

La evolución también se da al construir un sistema, ver que éste se corresponda con los requisitos,

y descubrir después que no era, de hecho, lo que se pretendía. Al ver un sistema en funcionamiento, se puede dcscubrir que verdaderamente se pretendía que solucionase otro problema. Si uno espera que se dé este tipo de evolución, entonces se debe construir la primera versión lo más rápidamente posible con el propósito de averiguar sin lugar a dudas qué es exactamente lo que se desea.

Quizás lo más importante que se ha de recordar es que por defecto, si se modifica una clase, sus

súper y subclases seguirán funcionando. Uno no debe tener miedo a la modificación (especialmente si se dispone de un conjunto de pruebas, o alguna prueba individual que permita verificar la corrección de las modificaciones). Los cambios no tienen por qué estropear el programa, sino que

cualquiera de las consecuencias de un cambio se limitarán a las subclases y/o colaboradores específicos de la clase que se modifica.

Los planes merecen la pena

Por supuesto, uno jamás construiría una casa sin unos planos cuidadosamente elaborados. Si construyéramos un hangar o la casa de un perro, los planes no tendrían tanto nivel de detalle, pero pro-

?' Esto es semejante a la elaboración de "prototipos rápidos", donde se supone que uno construyc una versión "rápida y sucia" que

permite comprender mejor el sistema, pero que es después desechada para construirlo correctamente. El problema con el prototipado rápido es que los equipos de desarrollo no suelen desechar completamente el prototipo, sino que lo utilizan como base sobre la que construir. Si se combina, en la programación procedural, con la falta de estructura, se generan sistemas totalmente com- plicados, y difíciles de mantener.

1: Introducción a los objetos 45

bablemente comenzaríamos con una serie de esbozos que nos permitiesen guiar el proceso. El desarrollo de software ha llegado a extremos. Durante mucho tiempo, la gente llevaba a cabo desarrollos sin mucha estructura, pero después, comenzaron a fallar los grandes procesos. Como reacción, todos acabamos con metodologías que conllevan una cantidad considerable de estructura y

detalle, eso sí, diseñadas, en principio, para estos grandes proyectos. Estas metodologías eran demasiado tediosas de usar -parecía que uno invertiría todo su tiempo en escribir documentos, y que

no le quedaría tiempo para programar (y esto ocurría a menudo). Espero haber mostrado aquí una

serie de sugerencias intermedias. Independientemente de lo pequeño que sea, es necesario algún

tipo de plan, que redundará en una gran mejora en el proyecto, especialmente respecto del que se

obtendría si no se hiciera ningún plan de ningún tipo. Es necesario recordar que en muchas estimaciones, falla más del 50 por ciento del proyecto (iincluso en ocasiones se llega al 70 por ciento!).

Siguiendo un plan -preferentemente uno simple y breve- y siguiendo una estructura de diseño

antes de la codificación, se descubre que los elementos encajan mejor, de modo más sencillo que si

uno se zambulle y empieza a escribir código sin ton ni son. También se alcanzará un nivel de satisfacción elevado. La experiencia dice que al lograr una solución elegante uno acaba completamente

satisfecho, a un nivel totalmente diferente; uno se siente más cercano al arte que a la tecnología. Y

la elegancia siempre merece la pena; no se trata de una pcrsccución frívola. De hccho, no solamente proporciona un programa más fácil de construir y depurar, sino que éste es mucho más fácil de

entender y mantener, que es precisamente donde reside su valor financiero.

Programación extrema

Una vez estudiadas las técnicas de análisis y diseño, por activa y por pasiva durante mucho tiempo,

quizás el concepto de programación extrema (Extreme Programming, XP) sea el más radical y sorprendente que he visto. Es posible encontrar información sobre él mismo en Extreme Programming

Explained, de Kent Beck (Addison-Wesley 2000), que puede encontrarse también en la

Web en http://www.xprogramming. com.

XP es tanto una filosofía del trabajo de programación como un conjunto de guías para acometer esta

tarea. Algunas de estas guías se reflejan en otras metodologías recientes, pero las dos contribuciones más distintivas e importantes en mi opinión son "escribir las pruebas en primer lugar" y "la programación a pares". Aunque Beck discute bastante todo el proceso en sí, señala que si se adoptan

únicamente estas dos prácticas, uno mejorará enormemente su productividad y nivel de confianza.

Escritura de las pruebas en primer lugar

El proceso de prueba casi siempre ha quedado relegado al final de un proyecto, una vez que "se tiene todo trabajando, pero hay que asegurarlo". Implícitamente, tenía una prioridad bastante baja, y la

gente que se especializa en las pruebas nunca ha gozado de un gran estatus, e incluso suele estar

ubicada en el sótano, lejos de los "programadores de verdad". Los equipos de pruebas se han amoldado tanto a esta consideración que incluso han llegado a vestir de negro, y han chismorreado alegremente cada vez que lograban encontrar algún fallo (para ser honestos, ésta es la misma sensación que yo tenía cada vez que lograba encontrar algún fallo en un compilador).

46 Piensa en Java

XP revoluciona completamente el concepto de prueba dándole una prioridad igual (o incluso mayor)

que a la codificación. De hecho, se escriben los tests antes de escribir el código a probar, y los códigos se mantienen para siempre junto con su código destino. Es necesario ejecutar con éxito los

tests cada vez que se lleva a cabo un proceso de integración del proyecto (lo cual ocurre a menudo,

en ocasiones más de una vez al día).

Al principio la escritura de las pruebas tiene dos efectos extremadamente importantes.

El primero es que fuerza una definición clara de la interfaz de cada clase. Yo, en numerosas ocasiones he sugerido que la gente "imagine la clase perfecta para resolver un problema particular" como

una herramienta a utilizar a la hora de intentar diseñar el sistema. La estrategia de pruebas XP va

más allá -especifica exactamente qué apariencia debe tener la clase para el consumidor de la clase, y cómo ésta debe comportarse exactamente. No puede haber nada sin concretar. Es posible escribir toda la prosa o crear todos los diagramas que se desee, describiendo cómo debería comportarse una clase, pero nada es igual que un conjunto de pruebas. Lo primero es una lista de deseos,

pero las pruebas son un contrato reforzado por el compilador y el programa en ejecución. Cuesta

imaginar una descripción más exacta de una clase que la de los tests.

Al crear los tests, uno se ve forzado a pensar completamente en la clase, y a menudo, descubre la

funcionalidad deseada que podría haber quedado en el tintero durante las experiencias de pensamiento de los diagramas XML, las tarjetas CRC, los casos de uso, etc.

El segundo efecto importante de escribir las pruebas en primer lugar, proviene de la ejecución de

las pruebas cada vez que se construye un producto software. Esta actividad proporciona la otra

mitad de las pruebas que lleva a cabo el compilador. Si se observa la evolución de los lenguajes

de programación desde esta perspectiva, se llegará a la conclusión de que las verdaderas mejoras

en lo que a tecnología se refiere han tenido que ver con las pruebas. El lenguaje ensamblador solamente comprobaba la sintaxis, pero C imponía algunas restricciones semánticas, que han evitado que se produzca cierto tipo de errores. Los lenguajes PO0 imponen incluso más restricciones

semánticas, que miradas así no son, de hecho, sino métodos de prueba. "¿Se está utilizando correctamente este tipo de datos?", y "¿se está invocando correctamente a esta función?" son algunos de los tipos de preguntas que hace un compilador o un sistema en tiempo de ejecución. Se

han visto los resultados de tener estas pruebas ya incluidas en el lenguaje: la gente parece ser capaz de escribir sistemas más completos y hacer que funcionen, con menos cantidad de tiempo y

esfuerzo. He intentado siempre averiguar la razón, pero ahora lo tengo claro, son las pruebas:

cada vez que se hace algo mal, la red de pruebas de seguridad integradas dice que hay un problema y determina dónde.

Pero las pruebas integradas permitidas por el diseño del lenguaje no pueden ir mucho más allá.

En cierto punto, cada uno debe continuar y añadir el resto de pruebas que producen una batería

de pruebas completa (en cooperación con el compilador y el sistema en tiempo de ejecución) que

verifique todo el programa. Y, exactamente igual que si se dispusiera de un compilador observando por encima del hombro, ¿no desearía uno que estas pruebas le ayudasen a hacer todo bien

desde el principio? Por eso es necesario escribir las pruebas en primer lugar y ejecutarlas cada

vez que se reconstruya el sistema. Las pruebas se convierten en una extensión de la red de seguridad proporcionada por el lenguaje.

1 : Introducción a los objetos 47

Una de las cosas que he descubierto respecto del uso de lenguajes de programación cada vez más

y más potentes es que conducen a la realización de experimentos cada vez más duros, pues se sabe

a priori que el propio lenguaje evitará pérdidas innecesarias de tiempo en la localización de errores.

El esquema de pruebas XP hace lo mismo para todo el proyecto. Dado que se sabe que las pruebas

localizarán cualquier problema que pueda aparecer en la vida del proyecto (y cada vez que se nos

ocurra alguno), simplemente se introducen nuevas pruebas), es posible hacer cambios, incluso

grandes, cuando sea necesario sin preocuparse de que éstos puedan cargarse todo el proyecto. Esto

es increíblemente potente.

Programación a pares

La programación a pares (por parejas) va más allá del férreo individualismo al que hemos sido adoctrinados desde el principio, a través de las escuelas (donde es uno mismo el que fracasa o tiene éxito), de los medios de comunicación, especialmente las películas de Hollywood, en las que el héroe

siempre lucha contra la conformidad sin sentido". Los programadores, también, suelen considerarse abanderados de la individualidad -"los vaqueros codificadores" como suele llamarlos Larry

Constantine. Y por el contrario, XP, que trata, de por sí, de luchar contra el pensamiento convencional, enuncia lo contrario, afirmando que el código debería siempre escribirse entre dos personas por

cada estación de trabajo. Y esto debería hacerse en áreas en las que haya grupos de estaciones de

trabajo, sin las barreras de las que la gente de facilidades de diseno suelen estar tan orgullosos. De

hecho, Beck dice que la primera tarea para convertirse a XP es aparecer con destornilladores y llaves Allen y desmontar todo aquello que parezca imponer barreras o separaciones'" (esto exige contar con un director capaz de hacer frente a todas las quejas del departamento de infraestructuras).

El valor de la programación en pareja es que una persona puede estar, de hecho, codificando mientras la otra piensa en lo que se está haciendo. El pensador es el que tiene en la cabeza todo el esbozo -y no sólo una imagen del problema que se está tratando en ese momento, sino todas las

guías del XP. Si son dos las personas que están trabajando, es menos probable que uno de ellos huya

diciendo "No quiero escribir las pruebas lo primero", por ejemplo. Y si el codificador se queda clavado, pueden cambiar de sitio. Si los dos se quedan parados, puede que alguien más del área de trabajo pueda contribuir al oír sus meditaciones. Trabajar a pares hace que todo fluya mejor y a tiempo. Y lo que probablemente es más importante: convierte la programación en una tarea mucho más

divertida y social.

He comenzado a hacer uso de la programación en pareja durante los periodos de ejercitación en algunos de mis seminarios, llegando a la conclusión de que mejora significativamente la experiencia

de todos.

" Aunque probablemente ésta sea mas una perspectiva americana, las historias de Hollywood llegan a todas partes.

23 Incluido (especialmente) el sistema PA. Trabajé una vez en una compañia que insistía en difundir a todo el mundo cualquier Ilamada entrante que recibieran los ejecutivos, lo cual interrumpía continuamente la productividad del equipo (pero los directores no

podían empezar siquiera a pensar en prescindir de un servicio tan importante como el PA). Al final, y cuando nadie me veía, me

encargué de cortar los cables de los altavoces.

48 Piensa en Java

Por qué Java tiene éxito

La razón por la que Java ha tenido tanto éxito es que su propósito era resolver muchos de los problemas a los que los desarrolladores se enfrentan hoy en día. El objetivo de Java es mejorar la productividad. Esta productividad se traduce en varios aspectos, pero el lenguaje fue diseñado para ayudar lo máximo posible, dejando en manos de cada uno la mínima cantidad posible, tanto de reglas

arbitrarias, como de requisitos a usar en determinados conjuntos de aspectos. Java fue diseñado

para ser práctico; las decisiones de diseño del lenguaje Java se basaban en proporcionar al programador la mayor cantidad de beneficios posibles.

Los sistemas son más fáciles de expresar

y entender

Las clases diseñadas para encajar en el problema tienden a expresarlo mejor. Esto significa que al

escribir el código uno está describiendo su solución en términos del espacio del problema, en vez

de en términos del computador, que es el espacio de la solución ("Pon el bit en el chip que indica

que el relé se va cerrar"). Uno maneja conceptos de alto nivel y puede hacer mucho más con una

única línea de código.

El otro beneficio del uso de esta expresión es la mantenibilidad que (si pueden creerse los informes) se lleva una porción enorme del coste de un programa durante toda su vida. Si un programa

es fácil de entender, entonces es fácil de mantener. Esto también puede reducir el coste de crear y

mantener la documentación.

Ventajas máximas con las bibliotecas

La manera más rápida de crear un programa es utilizar código que ya esté escrito: una biblioteca.

Uno de los principales objetivos de Java es facilitar el uso de bibliotecas. Esta meta se logra convirtiendo las bibliotecas en nuevos tipos de datos (clases), de forma que la incorporación de una biblioteca equivale a la inserción de nuevos tipos al lenguaje. Dado que el compilador de Java se encarga del buen uso de las bibliotecas -garantizando una inicialización y eliminación completas, y

asegurando que se invoca correctamente a las funciones- uno puede centrarse en lo que desea que

haga la biblioteca en vez de cómo tiene que hacerlo.

Manejo de errores

El manejo de errores en C es un importante problema, que suele ser frecuentemente ignorado o

que se trata de evitar cruzando los dedos. Si se está construyendo un programa grande y complejo,

no hay nada peor que tener un error enterrado en algún sitio sin tener ni siquiera una pista de dónde puede estar. El manejo de excepciones de Java es una forma de garantizar que se notifiquen los

errores, y que todo ocurre como consecuencia de algo.

EloperadordeString+ ...........................................

Pequeños fallos frecuentes al usar operadores ..........................

Operadores de conversión .........................................

Java no tiene "sizeof" .............................................

Volver a hablar acerca de la precedencia ..............................

Un compendio de operadores ......................................

Control de ejecución ..........................................

Trueyfalse ....................................................

If-else .........................................................

return ........................................................

Iteración ......................................................

do-while .......................................................

for ...........................................................

break y continue ................................................

switch ........................................................ Resuiiieil ...................................................

Ejercicios ...................................................

4: Inicialización y limpieza .....................................

Inicialización garantizada con el constructor ........................

Sobrecargademétodos ........................................ Distinguir métodos sobrecargados ..................................

Sobrecarga con tipos primitivos .....................................

Sobrecarga en los valores de retorno ................................

Constructores por defecto .........................................

La palabra clave this .......................................... Limpieza: finalización y recolección de basura ....................... ¿Para qué sirve finalize( )? .........................................

Hay que llevar a cabo la limpieza ....................................

La condición de muerto ...........................................

Cómo funciona un recolector de basura ...............................

Inicialización de miembros ...................................... Especificación de la inicialización ...................................

Inicialización de constructores ......................................

Inicialización de arrays ......................................... Arrays multidimensionales ........................................

Resumen ................................................... Ejercicios ...................................................

5: Ocultar la implementación ...................................

El paquete: la unidad de biblioteca ................................ Creando nombres de paquete únicos .................................

Una biblioteca de herramientas a medida .............................

Utilizar el comando import para cambiar el comportamiento ...............

Advertencia relativa al uso de paquetes ...............................

índice de contenido xi

Modificadores de acceso en Java ................................. "Amistoso" ("Friendly") ...........................................

public: acceso a interfaces ........................................

private: jeso no se toca! ..........................................

protected: "un tipo de amistad" ....................................

Interfaz e implementación ...................................... Acceso a clases .............................................. Resumen ...................................................

Ejercicios ...................................................

6: Reutilizando clases ........................................

Sintaxis de la composición ......................................

Sintaxis de la herencia ......................................... Inicializando la clase base .........................................

Combinando la composición y la herencia .......................... Garantizar una buena limpieza ......................................

Ocultación de nombres ...........................................

Elcción entre composición y herencia ............................. Protegido (protected) .......................................... Desaerrollo incremental ........................................ Conversión hacia arriba ........................................

¿Por qué "conversión hacia arriba"? .................................

Lapalabraclavefinal .......................................... Paradatos .....................................................

Métodosconstante ..............................................

Clases constantes ...............................................

Precaución con constantes ........................................

Carga de clases e inicialización ..................................

Inicialización con herencia .........................................

Resumen ................................................... Ejercicios ...................................................

De nuevo la conversión hacia arriba ..............................

Olvidando el tipo de objeto ........................................

Elcambio ................................................... La ligadura en las llamadas a métodos ................................

Produciendo el comportamiento adecuado ............................

Extensibilidad ..................................................

Superposición frente a sobrecarga ................................ Clases y métodos abstractos .................................... Clases y métodos abstractos ....................................

Orden de llamadas a constructores ..................................

Herencia y finahe( ) ............................................

Comportamiento de métodos polimórficos dentro de constructores .........

xii Piensa en Java

Diseñoconherencia ........................................... Herencia pura frente a extensión ....................................

Conversión hacia abajo e identificación de tipos en tiempo de ejecución ......

Resumen ................................................... Ejercicios ...................................................

8: Interfaces y clases internas ..................................

Interfaces ................................................... "Herencia múltiple" en Java ........................................

Extender una interfaz con herencia ..................................

Constantes de agrupamiento .......................................

Iniciando atributos en interfaces ....................................

Interfaces anidados ..............................................

Clases internas ...............................................

Clases internas y conversiones hacia arriba ............................

Ámbitos y clases internas en métodos ................................

Clases internas anónimas .........................................

El enlace con la clase externa ......................................

Clases internas estáticas ..........................................

Referirse al objeto de la clase externa ................................ Acceso desde una clase múltiplemente anidada .........................

Heredar de clases internas ........................................

¿Pueden superponerse las clases internas? ............................

Identificadores de clases internas ...................................

¿Por qué clases internas? ..........................................

Clases internas y sistema de control .................................

Resumen .........................................................

Ejercicios ........................................................

9: Guardar objetos ...........................................

Arrays ...........................................................

Los arrays son objetos de primera clase ...............................

Devolverunarray ...............................................

LaclaseArrays .................................................

Rellenarunarray ................................................

Copiarunarray .................................................

Comparar arrays ................................................

Comparaciones de elementos de arrays ...............................

Ordenar un array ..................................................

Buscar en un array ordenado ......................................

Resumen de arrays ............................................

Introducción a los contenedores .....................................

Visualizar contenedores ...........................................

Rellenar contenedores ............................................

Desventaja de los contenedores: tipo desconocido ......................

índice de contenido xiii

En ocasiones funciona de cualquier modo .............................

Hacer un ArrayList consciente de los tipos ...........................

Iteradores ........................................................

Taxonomía de contenedores ........................................

Funcionalidad de la Collection ......................................

Funcionalidad del interfaz List ......................................

Construir una pila a partir de un objeto LinkedList ....................

Construir una cola a partir de un objeto LinkedList .....................

Funcionalidad de la interfaz Set .....................................

Conjunto ordenado (SortedSet) ....................................

Funcionalidad Map ................................................

Mapa ordenado (Sorted Map) ...................................... Hashing y códigos de hash ........................................

Superponer el método hashCode( ) .................................

Guardar referencias ................................................

El nhjetn HasMap dkhil (WeakHashMa~) ............................

Revisitando los iteradores ...........................................

Elegir una implementación ..........................................

Elegir entre Listas ..............................................

Elegir entre Conjuntos ............................................

Elegir entre Mapas ..............................................

Ordenar y buscar elementos en Listas ...............................

Utilidades ........................................................

Hacer inmodificable una Colección o un Mapa ........................

Sincronizar una Colección o Mapa ..................................

Operaciones no soportadas .........................................

Contenedores de Java 1.0/1.1 .......................................

Vector y enumeration .............................................

Hashtable .....................................................

Pila(Stack) ....................................................

Conjunto de bits (BitSet) ..........................................

Resumen .........................................................

Ejercicios ........................................................

10: Manejo de errores con excepciones ..........................

Excepciones básicas ...............................................

Parámetros de las excepciones ..................................... . . Capturarunaexcepcion ............................................

Elbloquetry ...................................................

Manejadores de excepciones .......................................

Crear sus propias excepciones .......................................

La especificación de excepciones ....................................

Capturar cualquier excepción ......................................

Relanzarunaexcepción ...........................................

ExcepcionesestándardeJava .......................................

xiv Piensa en Java

El caso especial de RuntimeException ..............................

Limpiando con finally ..............................................

~Paraquésirvefinally? ...........................................

Peligro: la excepción perdida .......................................

Restricciones a las excepciones ......................................

Constructores .....................................................

Emparejamiento de excepciones .....................................

Guías de cara a las excepciones .....................................

Resumen .........................................................

Ejercicios ........................................................

11: El sistema de E/S de Java ..................................

La clase File ...................................................... Un generador de listados de directorio ...............................

Comprobando y creando directorios ................................. Entradaysalida .................................................

TiposdeInputStream ...........................................

TiposdeOutputStream ..........................................

Añadir atributos e interfaces útiles ...................................

Leer de un InputStream con un FilterInputStream ....................

Escribir en un OutputStream con FilterOutputStream .................

Readers & Writers ...............................................

Fuentes y consumidores de datos ...................................

Modificar el comportamiento del flujo ................................

Clases no cambiadas .............................................

Por sí mismo: RandomAccessFile ....................................

Usos típicos de flujos de E/S ........................................

Flujosdeentrada ................................................

Flujosdesalida .................................................

¿Unerror? .....................................................

Flujosentubados ................................................

E/Sestándar .....................................................

Leerdelaentradaestándar ........................................

Convirtiendo System.out en un PrintWriter ..........................

RedingiendolaE/Sestándar .......................................

Compresión ......................................................

Compresión sencilla con GZIP ......................................

Almacenamiento múltiple con ZIP ...................................

ARchivos Java UAR) .............................................

Serialización de objetos .............................................

Encontrarlaclase ...............................................

Controlar la serialización ..........................................

Utilizar la persistencia ............................................

Identificar símbolos de una entrada ..................................

StreamTokenizer ................................................

índice de contenido xv

StringTokenizer .................................................

Comprobar el estilo de escritura de mayúsculas ........................

Resumen .........................................................

Ejercicios ........................................................

12: Identificación de tipos en tiempo de ejecución ...................

La necesidad de RTTI ..............................................

ElobjetoClass .................................................

Comprobar antes de una conversión .................................

Sintaxis RTTI .....................................................

Reflectividad: información de clases en tiempo de ejecución ..............

Un extractor de métodos de clases ...................................

Resuinen .........................................................

Ejercicios ........................................................

13: Crear ventanas y applets ...................................

El applet básico ...................................................

Restricciones de applets ...........................................

Ventajas de los applets ............................................

Marcos de trabajo de aplicación .....................................

Ejecutar applets dentro de un navegador web ..........................

Utilizar Appletviewer .............................................

Probarapplets ..................................................

Ejecutar applets desde la línea de comandos ...........................

Un marco de trabajo de visualización ....................................

Usar el Explorador de Windows ....................................

Hacer un botón ...................................................

Capturarunevento ................................................

Áreas de texto ....................................................

Controlar la disposición ............................................

Borderhyout ...................................................

Flowhyout ....................................................

Gridhyout .....................................................

GridBagLayout .................................................

Posicionamiento absoluto .........................................

Boxhyout .....................................................

¿Elmejorenfoque? ..............................................

El modelo de eventos de Swing ......................................

Tipos de eventos y oyentes ........................................

Seguimiento de múltiples eventos ...................................

Un catálogo de componentes Swing ..................................

Botones .......................................................

Iconos ........................................................

Etiquetas de aviso ...............................................

Camposdetexto ................................................

xvi Piensa en Java

Bordes ........................................................

JScrollPanes ...................................................

Unminieditor ..................................................

Casillas de verificación ............................................

Botonesdeopción ...............................................

Combo boxes (listas desplegables) ..................................

Listas .........................................................

PanelesTabulados ...............................................

Cajasdemensajes ...............................................

Menús ........................................................

Menúsemergentes ..............................................

Generacióndedibujos ............................................

Cajasdediálogo ................................................

Diálogos de archivo ..............................................

HTMLencomponentesSwing ......................................

Deslizadores y barras de progreso ..................................

Árboles ....................................................... Tablas ........................................................

Seleccionar Apariencia ............................................

Elportapapeles .................................................

Empaquetando un applet en un fichero JAR ...........................

Técnicas de programación ..........................................

Correspondencia dinámica de objetos ................................

Separar la lógica de negocio de la lógica IU ...........................

Una forma canónica ..............................................

Programación visual y Beans ........................................

~QuéesunBean? ...............................................

Extraer BeanInfo con el Introspector ...............................

Un Bean más sofisticado ..........................................

EmpaquetarunBean .............................................

Soporte a Beans más complejo .....................................

MássobreBeans ................................................

Resumen .........................................................

Ejercicios ........................................................

14: Hilos múltiples ..........................................

Interfaces de respuesta de usuario rápida .......................... HeredardeThread .................................................

Hilos para una interfaz con respuesta rápida ...........................

Combinar el hilo con la clase principal ...............................

Construir muchos hilos ...........................................

Hilosdemonio ..................................................

Compartir recursos limitados ........................................

Acceder a los recursos de forma inadecuada ...........................

Cómo comparte Java los recursos ...................................

índice de contenido xvii

Revisar los JavaBeans ............................................

Bloqueo ........................................................

Bloqueándose ..................................................

Interbloqueo ...................................................

Prioridades .......................................................

Leer y establecer prioridades .......................................

Gruposdehilos .................................................

Volver a visitar Runnable ...........................................

Demasiados hilos ................................................

Resumen .........................................................

Ejercicios ........................................................

15: Computación distribuida ...................................

Programación en red ...............................................

Identificar una máquina ...........................................

Sockets .......................................................

Servir a múltiples clientes .........................................

Datagramas ....................................................

Utilizar URL en un applet .........................................

Más aspectos de redes ...........................................

Conectividad a Bases de Datos de Java (JDBC) ........................

Hacer que el ejemplo funcione .....................................

Una versión con IGU del programa de búsqueda .......................

Por qué el API JDBC parece tan complejo .............................

Un ejemplo más sofisticado ........................................

Servlets ..........................................................

El servlet básico ................................................

Servlets y multihilo ..............................................

Gestionar sesiones con servlets .....................................

Ejecutar los ejemplos de servlets ....................................

Java Server Pages .................................................

Objetos implícitos ...............................................

Directivas JSP ..................................................

Elementos de escritura de guiones JSP ...............................

Extraer campos y valores ..........................................

Atributos JSP de página y su ámbito .................................

Manipular sesiones en JSP ........................................

Crear y modificar cookies .........................................

ResumendeJSP ................................................ RMI (Invocation Remote Method) ...................................

Interfaces remotos ...............................................

Implementar la interfaz remota .....................................

Crearstubsyskeletons ........................................... Utilizar el objeto remoto ..........................................

CORBA ....................................................

xviii Piensa en Java

FundamentosdeCORBA .......................................... 773

Unejemplo .................................................... 775

Applets de Java y CORBA ......................................... 780

CORBAfrenteaRMI ............................................. 780

Enterprise JavaBeans .............................................. 780

JavaBeans frente a EJB ........................................... 781

La especificación EJB ............................................ 782

ComponentesEJB ............................................... 783

Las partes de un componente EJB ................................... 784

Funcionamiento de un EJB ........................................ 785

TiposdeEJB ................................................... 785

Desarrollar un EJB .............................................. 786

ResumendeEJB ................................................ 791

Jini: servicios distribuidos .......................................... 791

Jini en contcxto ................................................. 791

¿Qué es Jini? ................................................... 792

Cómo funciona Jini .............................................. 792

El proceso de discovery .......................................... 793

El proceso join .................................................. 793

El proceso lookup ............................................... 794

Separación de interfaz e implementación .............................. 795

Abstraer sistemas distribuidos ...................................... 796

Resumen ...................................................... 796

Ejercicios ...................................................... 796

A: Paso y Retorno de Objetos ..........

Pasando referencias ...............................................

Usodealias ....................................................

Haciendo copias locales ............................................

Pasoporvalor ..................................................

Clonandoobjetos ................................................

Añadiendo a una clase la capacidad de ser clonable .....................

Clonación con éxito ..............................................

El efecto de Object.clone( ) ........................................

Clonando un objeto compuesto .....................................

Una copia en profundidad con ArrayList ..............................

Copia en profundidad vía serialización ................................

Añadiendo "clonabilidad" a lo largo de toda una jerarquía .................

{Por qué un diseño tan extraño? ....................................

Controlando la "clonabilidad" ........................................

Elconstructordecopias ..........................................

Clases de sólo lectura ..............................................

Creando clases de sólo lectura .....................................

Los inconvenientes de la inmutabilidad ...............................

Strings inmutables ...............................................

índice de contenido xix

Las clases String y StringBuffer .....................................

Los Strings son especiales .........................................

Resumen .........................................................

Ejercicios ........................................................

B . El Interfaz Nativo Java (JNI1) ................................

Invocando a un método nativo .......................................

El generador de cabeceras de archivo: javah ...........................

renombrado de nombres y signaturas de funciones ......................

Implementando la DLL ...........................................

Accediendo a funciones JNI: el parámetro JNIEnv .....................

Accediendo a Strings Java .........................................

Pasando y usando objetos Java .....................................

JNI y las excepciones Java .........................................

JNIyloshilos ..................................................

Usando un código base preexistente .................................

Información adicional ............................................

C: Guías de programación Java ................................

Diseño ...........................................................

Implemenentación ............................................

D: Recursos Software ........................................

Libros ...........................................................

Análisis y Diseño ..................................................

Python ...........................................................

Mi propia lista de libros ............................................

E: Correspondencias español-inglés de clases. bases de datos. tablas

y campos del CD ROM que acompaña al libro ...................



Prólogo

Sugerí a mi hermano Todd, que está dando el

ción, que la siguiente gran revolución será en

salto del hardware a la programaingeniería genética.

Tendremos microbios diseñados para hacer comida, combustible y plástico; limpiarán la polución y

en general, nos permitirán dominar la manipulación del mundo físico por una fracción de lo que

cuesta ahora. De hecho yo afirmé que la revolución de los computadores parecería pequeña en comparación.

Después, me di cuenta de que estaba cometiendo un error frecuente en los escritores de ciencia ficción: perderme en la tecnología (lo que por supuesto es fácil de hacer en ciencia ficción). Un escritor experimentado sabe que la historia nunca tiene que ver con los elementos, sino con la gente. La

genética tendrá un gran impacto en nuestras vidas, pero no estoy seguro de que haga sombra a la

revolución de los computadores (que hace posible la revolución genética) -o al menos la revolución de la información. La información hace referencia a comunicarse con otros: sí, los coches, los

zapatos y especialmente la terapia genética son importantes, pero al final, ésto no son más que adornos. Lo que verdaderamente importa es cómo nos relacionamos con el mundo. Y cuánto de eso es

comunicación.

Este libro es un caso. La mayoría de colegas pensaban que estaba un poco loco al poner todo en la

Web. "¿Por qué lo compraría alguien?", se preguntaban. Si hubiera sido de naturaleza más conservadora no lo habría hecho, pero lo que verdaderamente no quería era escribir más libros de computación al estilo tradicional. No sabía qué pasaría pero resultó que fue una de las cosas más inteligentes que he hecho con un libro.

Por algún motivo, la gente empezó a mandar correcciones. Éste ha sido un proceso divertido, porque todo el mundo ha recorrido el libro y ha detectado tanto los errores técnicos como los gramaticales, y he podido eliminar fallos de todos los tipos que de otra forma se habrían quedado ahí. La

gente ha sido bastante amable con ésto, diciendo a menudo " yo no quiero decir esto por criticar...",

y tras darme una colección de errores estoy seguro de que de otra forma nunca los hubiera encontrado. Siento que éste ha sido un tipo de grupo de procesos que ha convertido el libro en algo especial.

Pero cuando empecé a oír: "De acuerdo, bien, está bien que hayas puesto una versión electrónica,

pero quiero una copia impresa proveniente de una auténtica editorial", puse mi mayor empeño en

facilitar que todo se imprimiera con formato adecuado, pero eso no frenó la demanda de una versión publicada. La mayoría de la gente no quiere leer todo el libro en pantalla, y merodear por un

conjunto de papeles, sin que importe cuán bien impresos estén, simplemente no era suficiente.

(Además, tampoco creo que resulte tan barato en términos de tóner para impresora láser.) Parece

que a fin de cuentas, la revolución de los computadores no conseguirá dejar sin trabajo a las editoriales. Sin embargo, un alumno me sugirió que éste podría ser un modelo para publicaciones finales: los libros se publicarán primero en la Web, y sólo si hay el suficiente interés, merecerá la pena

pasar el libro a papel. Actualmente, la gran mayoría de libros conllevan problemas financieros, y quizás este nuevo enfoque pueda hacer que el negocio de la publicación sea más beneficioso. Este li-

xxii Piensa en Java

bro se convirtió en una experiencia reveladora para mí de otra forma. Originalmente me acerqué a

Java como "simplemente a otro lenguaje de programación", lo que en cierto sentido es verdad. Pero

a medida que pasaba el tiempo y lo estudiaba más en profundidad, empecé a ver que la intención

fundamental de este lenguaje es distinta de la de otros lenguajes que he visto.

La programación está relacionada con gestionar la complejidad: la complejidad del problema que se

quiere solucionar, que yace sobre la complejidad de la máquina en que se soluciona. Debido a esta

complejidad, la mayoría de nuestros proyectos fallan. Y lo que es más, de todos los lenguajes de programación de los que soy consciente, ninguno se ha lanzado completamente decidiendo que la meta

de diseño principal fuera conquistar la complejidad del desarrollo y mantenimiento de programas1.

Por supuesto, muchas decisiones de diseño de lenguajes se hicieron sin tener en mente la complejidad, pero en algún punto había siempre algún otro enfoque que se consideraba esencial añadirlo

al conjunto. Inevitablemente, estos otros aspectos son los que hacen que generalmente los programadores "se den con la pared" contra ese lenguaje. Por ejemplo, C++ tenía que ser compatible con

C (para permitir la migración fácil a los programadores de C), además de eficiente. Estas metas son

ambas muy útiles y aportan mucho al éxito de Ctt, pero también exponen complejidad extra que

evita que los proyectos se acaben (ciertamente, se puede echar la culpa a los programadores y la

gestión, pero si un lenguaje puede ayudar 'a capturar los errores, ¿por qué no hacer uso de ello?).

Como otro ejemplo, Visual Basic (VB) estaba atado a BASIC, que no estaba diseñado verdaderamente para ser un lenguaje ampliable, por lo que todas las aplicaciones que se apilaban sobre VB

producían sintaxis verdaderamente horribles e inmantenibles. Perl es retrocompatible con Awk,

Sed, Grep y otras herramientas Unix a las que iba a reemplazar, y como resultado se le acusa a menudo, de producir "código de sólo escritura" (es decir, código que tras unos pocos meses no hay

quien lea). Por otro lado, C++, VB, Perl, y otros lenguajes como Smalltalk han visto cómo algunos

de sus esfuerzos de diseño se centraban en el aspecto de la complejidad y como resultado son remarcadamente exitosos para solucionar ciertos tipos de problemas.

Lo que más me impresionó es que he llegado a entender que Java parece tener el objetivo de reducir la complejidad para el programador. Como si se dijera "no nos importa nada más que reducir el

tiempo y la dificultad para producir un código robusto". En los primeros tiempos, esta meta llevaba

a un código que no se ejecutaba muy rápido (aunque se habían hecho promesas sobre lo rápido que

se ejecutaría Java algún día), pero sin duda ha producido reducciones sorprendentes de tiempo de

desarrollo; la mitad o menos del tiempo que lleva crear un programa C++ equivalente. Este resultado sólo puede ahorrar cantidades increíbles de tiempo y dinero, pero Java no se detiene ahí. Envuelve todas las tareas complejas que se han convertido en importantes, como el multihilo y la programación en red, en bibliotecas o aspectos del lenguaje que en ocasiones pueden convertir esas

tareas en triviales. Y finalmente, asume muchos problemas de complejidad grandes: programas multiplataforma, cambios dinámicos de código, e incluso seguridad, cada uno de los cuales pueden encajar dentro de un espectro de complejidades que oscila en el rango de "impedimento" a "motivos

de cancelación". Por tanto, a pesar de los problemas de rendimiento que se han visto, la promesa

de Java es tremenda: puede convertirnos en programadores significativamente más productivos.

Uno de los sitios en los que veo el mayor impacto de esto es en la Web. La programación en red

siempre ha sido complicada, y Java la convierte en fácil Or los diseñadores el lenguaje Java están

Esto lo retomo de la 2." edición: creo que el lenguaje Python se acerca aun más a esto. Ver http://www.Python.org.

Prefacio xxiii

trabajando en facilitarla aún más). La programación en red es como hablar simultáneamente de forma efectiva y de forma más barata de lo que nunca se logró con teléfonos (sólo el correo electrónico ya ha revolucionado muchos negocios). Al intercomunicarnos más, empiezan a pasar cosas

divertidas, probablemente mucho más interesantes que las que pasarán con la ingeniería genética.

De todas formas -al crear los programas, trabajar para crear programas, construir interfaces para

los programas, de forma que éstos se puedan comunicar con el usuario, ejecutar los programas en

distintos tipos de máquinas, y escribir de forma sencilla programas que pueden comunicarse a través de Internet- Java incrementa el ancho de banda de comunicación entre la gente. Creo que quizás los resultados de la revolución de la comunicación no se contemplarán por lo que conlleva el

transporte de grandes cantidades de bits; veremos la auténtica revolución porque podremos comunicarnos con mayor facilidad: de uno en uno, pero también en grupos y, como planeta. He oído la

sugerencia de que la próxima revolución es la formación de cierto tipo de mente global para suficiente gente y suficiente nivel de interconectividad. Puede decirse que Java puede fomentar o no esa

revolución, pero al menos la mera posibilidad me ha hecho sentir como si estuviera haciendo algo

lleno de sentido al intentar ensenar ese lenguaje.

Prólogo a la 2.a edición

La gente ha hecho muchos, muchos comentarios maravillosos sobre la primera edición de este libro, cosa que ha sido para mí muy, pero que muy, placentero. Sin embargo, en todo momento habrá quien tenga quejas, y por alguna razón una queja que suele aparecer periódicamente es que "el

libro es demasiado grande". Para mí, esto no es verdaderamente una queja, si se reduce a que "tiene demasiadas páginas". (Uno se acuerda de las quejas del Emperador de Austria sobre el trabajo

de Mozart: "¡Demasiadas páginas!", y no es que me esté intentando comparar con Mozart de ninguna forma). Además, sólo puedo asumir que semejante queja puede provenir de gente que no tiene aún una idea clara de la vasta extensión del propio lenguaje Java en sí, y que no ha visto el resto de libros sobre la materia -por ejemplo, mi referencia favorita es el Core Java de Cay Horstmann

& Cary Cornell (Prentice-Hall), que creció tanto que hubo que dividirlo en dos tomos. A pesar de

esto, una de las cosas que he intentado hacer en esta edición es eliminar las portes que se han vuelto obsoletas o al menos no esenciales. Me siento a gusto haciendo esto porque el material original

sigue en la Web y en el CD ROM que acompaña al libro, en la misma forma de descarga gratuita

que la primera edición del libro (en http: / / www.BruceEckel.com). Si se desea el material antiguo,

sigue ahí, y esto es algo maravilloso para un autor. Por ejemplo, puede verse que el último capítulo

original, "Proyectos", ya no está aquí; dos de los proyectos se han integrado en los otros capítulos,

y el resto ya no son adecuados. También el capítulo de "Patrones de diseño" se volvió demasiado

extenso y ha sido trasladado a un libro que versa sobre ellos (descargable también en el sitio web).

Por tanto, el libro debería ser más fino.

Pero no lo es.

El aspecto mayor es el continuo desarrollo del lenguaje Java en sí, y en particular las API que se expanden, y prometen proporcionar interfaces estándar para casi todo lo que se desee hacer (y no me

sorprendería ver aparecer la API "JTostadora"). Cubrir todas estas API se escapa por supuesto del

ámbito de este libro, y es una tarea relegada a otros autores, pero algunos aspectos no pueden ig-

xxiv Piensa en Java

norarse. El mayor de éstos incluye el Java de lado servidor (principalmente Servlets & Java Server

Pages o JSP), que es verdaderamente una solución excelente al problema de la World Wide Web,

donde se descubrió que las distintas plataformas de navegadores web no son lo suficientemente consistentes como para soportar programación en el lado cliente. Además, está todo el problema de

crear de forma sencilla aplicaciones que interactúen de forma sencilla con bases de datos, transacciones, seguridad y semejante, cubiertos gracias a los Enterprise Java Beans (EJB). Estos temas están desarrollados en el capítulo que antes se llamaba "Programación de red" y ahora "Computación

distribuida", un tema que se está convirtiendo en esencial para todo el mundo. También se verá que

se ha compilado este capítulo para incluir un repaso de Jini (pronunciado "yeni", y que no es un

acrónimo, sino sólo un nombre), que es una tecnología emergente que permite que cambiemos la

forma de pensar sobre las aplicaciones interconectadas. Y por supuesto, el libro se ha cambiado para

usar la biblioteca IGU Swing a lo largo de todo el mismo. De nuevo, si se desea el material Java

1.0/1.1 antiguo, es posible conseguirlo gratuitamente del libro de descarga gratuita de

http:llwww.BruceEckel.corn (también está incluido en el nuevo CD ROM de esta edición, que se adjunta al mismo; hablaré más de él un poco más adelante).

Aparte de nuevas características del lenguaje añadidas a Java 2, y varias correcciones hechas a lo

largo de todo el libro, el otro cambio principal está en el capítulo de colecciones que ahora se centra en las colecciones de Java 2, que se usan a lo largo de todo el libro. También he mejorado ese

capítulo para que entre más en profundidad en algunos aspectos importantes de las colecciones, en

particular, en cómo funcionan las funciones de hashing (de forma que se puede saber cómo crear

una adecuadamente). Ha habido otros movimientos y cambios, incluida la reescritura del Capítulo

1, y la eliminación de algunos apéndices y de otros materiales que ya no consideraba necesarios

para el libro impreso, que son un montón de ellos. En general, he intentado recorrer todo, eliminar

de la 2." edición lo que ya no es necesario (pero que sigue existiendo en la primera edición electrónica), incluir cambios y mejorar todo lo que he podido. A medida que el lenguaje continúa cambiando -aunque no a un ritmo tan frenético como antiguamente- no cabe duda de que habrá más

ediciones de este libro.

Para aquellos de vosotros que siguen sin poder soportar el tamaño del libro, pido perdón. Lo creáis

o no, he trabajado duro para que se mantenga lo menos posible. A pesar de todo, creo que hay bastantes alternativas que pueden satisfacer a todo el mundo. Además, el libro está disponible electrónicamente (en idioma inglés desde el sitio web, y desde el CD ROM que acompaña al libro), por lo

que si se dispone de un ordenador de bolsillo, se puede disponer del libro sin tener que cargar un

gran peso. Si sigue interesado en tamaños menores, ya existen de hecho versiones del libro para

Palm Pilot. (Alguien me dijo en una ocasión que leería el libro en la cama en su Palm, con la luz encendida a la espalda para no molestar a su mujer. Sólo espero que le ayude a entrar en el mundo de

los sueños.) Si se necesita en papel, sé de gente que lo va imprimiendo capítulo a capítulo y se lo

lee en el tren.

Java 2

En el momento de escribir el libro, es inminente el lanzamiento del Java Development Kit UDK) 1.3

de Sun, y ya se ha publicado los cambios propuestos para JDK 1.4. Aunque estos números de versión se corresponden aún con los "unos", la forma estándar de referenciar a las versiones posterio-

Prefacio xxv

res a la JDK 1.2 es llamarles "Java 2". Esto indica que hubo cambios muy significativos entre el "viejo Java" -que tenía muchas pegas de las que ya me quejé en la primera edición de este libro- y

esta nueva versión más moderna y mejorada del lenguaje, que tiene menos pegas y más adiciones

y buenos diseños.

Este libro está escrito para Java 2. Tengo la gran ventaja de librarme de todo el material y escribir

sólo para el nuevo lenguaje ya mejorado porque la información vieja sigue existiendo en la l." versión

electrónica disponible en la Web y en el CD-ROM (que es a donde se puede ir si se desea obcecarse

en el uso de versiones pre-Java 2 del lenguaje). También, y dado que cualquiera puede descargarse

gratuitamente el JDK de http: / / java.sun.com, se supone que por escribir para Java 2, no estoy imponiendo ningún criterio financiero o forzando a nadie a hacer una actualización del software.

Hay, sin embargo, algo que reseñar. JDK 1.3 tiene algunas mejoras que verdaderamente me gustaría usar, pero la versión de Java que está siendo actualmente distribuida para Linux es la JDK 1.2.2

(ver http:/ /www.Linux.org). Linux es un desarrollo importante en conjunción con Java, porque es

rápido, robusto, seguro, está bien mantenido y es gratuito; una auténtica revolución en la historia de

la computación (no creo que se hayan visto todas estas características unidas en una única herramienta anteriormente). Y Java ha encontrado un nicho muy importante en la programación en el

lado servidor en forma de Serulets, una tecnología que es una grandísima mejora sobre la programación tradicional basada en CGI (todo ello cubierto en el capítulo "Computación Distribuida").

Por tanto, aunque me gustaría usar sólo las nuevas características, es crítico que todo se compile

bajo Linux, y por tanto, cuando se desempaquete el código fuente y se compile bajo ese SO (con el

último JDK) se verá que todo compila. Sin embargo, se verá que he puesto notas sobre características de JDK 1.3 en muchos lugares.

El CD ROM

Otro bonus con esta edición es el CD ROM empaquetado al final del libro. En el pasado me he resistido a poner CD ROM al final de mis libros porque pensaba que no estaba justificada una carga

de unos pocos Kbytes de código fuente en un soporte tan grande, prefiriendo en su lugar permitir

a la gente descargar los elementos desde el sitio web. Sin embargo, pronto se verá que este CD

ROM es diferente.

El CD contiene el código fuente del libro, pero también contiene el libro en su integridad, en varios

formatos electrónicos. Para mí, el preferido es el formato HTML porque es rápido y está completamente indexado -simplemente se hace clic en una entrada del índice o tabla de contenidos y se estará inmediatamente en esa parte del libro.

La carga de más de 300 Megabytes del CD, sin embargo, es un curso multimedia denominado Thinking in C: Foundations for C++ & Java. Originalmente encargué este seminario en CD ROM a Chuck

Allison, como un producto independiente, pero decidí incluirlo con la segunda edición tanto de Thinking in C++ como de Piensa en Java, gracias a la consistente experiencia de haber tenido gente viniendo a los seminarios sin la requerida experiencia en C. El pensamiento parece aparentemente

ser: "Soy un programador inteligente y no deseo aprender C, y sí C++ o Java, por lo que me saltaré

C e iré directamente a C++/Java." Tras llegar al seminario, todo el mundo va comprendiendo que el

xxvi Piensa en Java

prerrequisito de aprender C está ahí por algo. Incluyendo el CD ROM con el libro, se puede asegurar que todo el mundo atienda al seminario con la preparación adecuada.

El CD también permite que el libro se presente para una audiencia mayor. Incluso aunque el Capítulo 3 («Controlando el flujo del programa») cubre los aspectos fundamentales de las partes de Java

que provienen de C, el CD es una introducción más gentil, y asume incluso un trasfondo de C menor que el que supone el libro. Espero que al introducir el CD será más la gente que se acerque a

la programación en Java.

Prólogo a la edición

en espanoi

Java se convierte día a día en un lenguaje de programación universal; es decir, ya no sólo sirve como

lenguaje para programar en entornos de Internet, sino que se está utilizando cada vez más como herramienta de programación orientada a objetos y también como herramienta para cursos específicos de programación o de estructuras de datos, aprovechando sus características de lenguaje "multiparadigma". Por estas razones, los libros que afronten temarios completos y amplios sobre los

temas anteriores siempre serán bienvenidos. Si, además de reunir estos requisitos, el autor es uno

de los más galardonados por sus obras anteriores, nns enfrentamos ante iin reto considerable: "la

posibilidad de encontrarnos" ante un gran libro, de esos que hacen "historia". Éste, pensamos, es el

caso del libro que tenemos entre las manos. ¿Por qué pensamos así?

El libro como referencia obligada a Java

Piensa en Java introduce todos los fundamentos teóricos y prácticos del lenguaje Java, tratando de

explicar con claridad y rigor no sólo lo que hace el lenguaje sino también el porqué. Eckel introduce

los fundamentos de objetos y cómo los utiliza Java. Éste es el caso del estudio que hace de la ocultación de las implementaciones, reutilización de clases y polimorfismo. Además, estudia en profundidad propiedades y características tan importantes como AWT, programación concurrente (multihilo, multithreading2), programación en red, e incluso diseño de patrones.

Es un libro que puede servir para iniciarse en Java y llegar hasta un nivel avanzado. Pero, en realidad se sacará el máximo partido al libro si se conoce otro lenguaje de programación, o al menos técnicas de programación (como haber seguido un curso de Fundamentos de Programación, Metodología de la Programación, Algoritmos, o cursos similares) y ya se puede apostar por un alto y eficiente

rendimiento si la migración a Java se hace desde un lenguaje orientado a objetos, como C++.

El libro como formación integral de programador

Una de las fortalezas más notables del libro es su contenido y la gran cantidad de temas importantes cubiertos con toda claridad y rigor, y con gran profundidad. El contenido es muy amplio y sobre

todo completo. Eckel prácticamente ha tocado casi todas las técnicas existentes y utilizadas hoy día

en el mundo de la programación y de la ingeniería del software. Algunos de los temas más sobresalientes analizados en el libro son: fundamentos de diseño orientado a objetos, implementación de

herencia y polimorfismo, manejo de excepciones, multihilo y persistencia, Java en Internet, recolección de basura, paquetes Java, diseño por reutilización: composición, herencia, interfaces y clases internas, arrays y contenedores de clases, clases de E/S Java, programación de redes con sockets, JDBC para bases de datos, JSPs (JavaServer Pages), RMI, CORBA, EJBs (Enterprise

JauaBeans) y Jini, JNI (Java Native Interface).

xxviii Piensa en Java

El excelente y extenso contenido hacen al libro idóneo para la preparación de cursos de nivel medio

y avanzado de programación, tanto a nivel universitario como profesional. Asimismo, por el enfoque

masivamente profesional que el autor da al libro, puede ser una herramienta muy útil como referencia básica o complementaria para preparar los exámenes de certificación Java que la casa Sun

Microsystems otorga tras la superación de las correspondientes pruebas. Esta característica es un

valor añadido muy importante, al facilitar considerablemente al lector interesado las directrices técnicas necesarias para la preparación de la citada certificación.

Recursos gratuitos en línea

Si las características citadas anteriormente son de por sí lo suficientemente atractivas para la lectura del libro, es sin duda el excelente sitio en Internet del autor otro valor añadido difícil de medir,

por no decir inmedible y valiosísimo. La generosidad del autor -y, naturalmente, de Pearson-, que

ofrece a cualquier lector, sin necesidad de compra previa, todo el contenido en línea, junto a las frecuentes revisiones de la obra y soluciones a ejercicios seleccionados, con la posibilidad de descargarse gratuitamente todo este inmenso conocimiento incluido en el libro, junto al conocimiento complementario ofertado (ejercicios, revisiones, actualizaciones...), hacen a esta experiencia innovadora

del autor digna de los mayores agradecimientos por parte del cuerpo de programadores noveles o

profesionales de cualquier lugar del mundo donde se utilice Java (que hoy es prácticamente "todo

el mundo mundial", que dirían algunos periodistas).

De igual forma es de agradecer el CD kOM que acompaña al libro y la oferta de un segundo CD

gratuito que se puede conseguir siguiendo las instrucciones incluidas en el libro con el texto completo de la versión original en inglés y un gran número de ejercicios seleccionados resueltos y recursos Java de todo tipo.

Para facilitar al lector el uso del CD ROM incluido en el libro, el equipo de revisión técnica ha realizado el Apéndice E: Correspondencias español-inglés de clases, bases de datos, tablas y campos del CD

ROM que acompaña al libro, a fin de identificar el nombre asignado en la traducción al español, con

el nombre original en inglés de dichas clases.

Unas palabras todavía más elogiosas

Para las personas que, como el autor de este prólogo, llevamos muchos años (ya décadas) dedicándonos a programar computadores, enseñar a programar y escribir sobre programación, un libro

como éste sólo nos trae elevados y elogiosos pensamientos. Consideramos que es un libro magnífico, maduro, consistente, intelectualmente honesto, bien escrito y preciso. Sin duda, como lo demuestra su larga lista de premios y sus numerosas y magníficas cualidades, Piensa en Java, no sólo

es una excelente obra para aprender y llegar a dominar el lenguaje Java y su programación, sino

también una excelente obra para aprender y dominar las técnicas modernas de programación.

Luis Joyanes Aguilar

Director del Departamento de Lenguajes y Sistemas Informáticos e Zngeniená de Software

Universidad Pontificia de Salamanca campus Madrid

Comentarios los lectores

Mucho mejor que cualquier otro libro de Java que haya visto. Esto se entiende "en orden de magnitud" ... muy completo, con ejemplos directos y al grano, excelentes e inteligentes, sin embarullarse, lleno de explicaciones .... En contraste con muchos otros libros de Java lo he encontrado inusualmente maduro, consistente, intelectualmente honesto, bien escrito y preciso. En mi honesta opinión,

un libro ideal para estudiar Java. Anatoly Vorobey, Technion University, Haifa, Israel.

Uno de los mejores tutoriales de programación, que he visto de cualquier lenguaje. Joakim Ziegler,

FIX sysop.

Gracias por ese libro maravilloso, maravilloso en Java. Dr. Gavin Pillary, Registrar, King

Eduard VI11 Hospital, Suráfrica.

Gracias de nuevo por este maravilloso libro. Yo estaba completamente perdido (soy un programador que no viene de C) pero tu libro me ha permitido avanzar con la misma velocidad con la que lo

he leído. Es verdaderamente fácil entender los principios subyacentes y los conceptos desde el principio, en vez de tener que intentar construir todo el modelo conceptual mediante prueba y error.

Afortunadamente podré acudir a su seminario en un futuro no demasiado lejano. Randa11 R. Hawley, Automation Technician, Eli Lilly & Co.

El mejor libro escrito de computadores que haya visto jamás. Tom Holland.

Éste es uno de los mejores libros que he leído sobre un lenguaje de programación ... El mejor libro

sobre Java escrito jamás. Revindra Pai, Oracle Corporation, línea de productos SUNOS.

¡Éste es el mejor libro sobre Java que haya visto nunca! Has hecho un gran trabajo. Tu profundidad

es sorprendente. Compraré el libro en cuanto se publique. He estado aprendiendo Java desde octubre

del 96. He leído unos pocos libros y considero el tuyo uno que "SE DEBE LEER". En estos últimos

meses nos hemos centrado en un producto escrito totalmente en Java. Tu libro ha ayudado a consolidar algunos temas en los que andábamos confusos y ha expandido mi conocimiento base. Incluso he

usado algunos de tus ejemplos y explicaciones como información en mis entrevistas para ayudar al

equipo. He averiguado el conocimiento de Java que tienen preguntándoles por algunas de las cosas

que he aprendido a partir de la lectura de tu libro (por ejemplo, la diferencia entre arrays y Vectores).

¡El libro es genial! Steve Wilkinson, Senior Staff Specialist, MCI Telecommunications.

Gran libro. El mejor libro de Java que he visto hasta la fecha. Jeff Sinlair, ingeniero de Software, Kestral Computing.

Gracias por Piensa en Java. Ya era hora de que alguien fuera más allá de una mera descripción del

lenguaje para lograr un tutorial completo, penetrante, impactante y que no se centra en los fabricante. He leído casi todos los demás -y sólo el tuyo y el de Patrick Winston han encontrado un lugar en mi corazón. Se lo estoy recomendando ya a los clientes. Gracias de nuevo. Richard Brooks,

consultor de Java, Sun Professional Services, Dallas.

Otros libros contemplan o abarcan el QUÉ de Java (describiendo la sintaxis y las bibliotecas) o el

CÓMO de Java (ejemplos de programación prácticos). Piensa en Jaual es el único libro que conoz-

' Thinking in Java (titulo original de la obra en inglés).

xxx Piensa en Java

co que explica el PORQUÉ de Java; por qué se diseñó de la manera que se hizo, por qué funciona

como lo hace, por qué en ocasiones no funciona, por qué es mejor que C++, por qué no lo es. Aunque hace un buen trabajo de enseñanza sobre el qué y el cómo del lenguaje, Piensa en Java es la

elección definitiva que toda persona interesada en Java ha de hacer. Robert S. Stephenson.

Gracias por escribir un gran libro. Cuanto más lo leo más me gusta. A mis estudiantes también les

gusta. Chuck Iverson.

Sólo quiero comentarte tu trabajo en Piensa en Java. Es la gente como tú la que dignifica el futuro

de Internet y simplemente quiero agradecerte el esfuerzo. Patrick Barrell, Network Officer

Mamco, QAF M@. Inc.

La mayoría de libros de Java que existen están bien para empezar, y la mayoría tienen material para

principiantes y muchos los mismos ejemplos. El tuyo es sin duda el mejor libro y más avanzado para

pensar que he visto nunca. iPor favor, publícalo rápido! ... También compré Thinking in C++ simplemente por lo impresionado que me dejó Piensa en Java. George Laframboise, LightWorx Technology Consulting Inc.

Te escribí anteriormente con mis impresiones favorables relativas a Piensa en Java (un libro que empieza prominentemente donde hay que empezar). Y hoy que he podido meterme con Java con tu libro electrónico en mi mano virtual, debo decir (en mi mejor Chevy Chase de Modern Problems)

"¡Me gusta!". Muy informativo y explicativo, sin que parezca que se lee un texto sin sustancia. Cubres los aspectos más importantes y menos tratados del desarrollo de Java: los porqués. Sean

Brady.

Tus ejemplos son claros y fáciles de entender. Tuviste cuidado con la mayoría de detalles importantes de Java que no pueden encontrarse fácilmente en la débil documentación de Java. Y no malgastas el tiempo del lector con los hechos básicos que todo programador conoce. Kai Engert, Innovative Software, Alemania.

Soy un gran fan de Piensa en Java y lo he recomendado a mis asociados. A medida que avanzo por

la versión electrónica de tu libro de Java, estoy averiguando que has retenido el mismo alto nivel de

escritura. Peter R. Neuvald.

Un libro de Java MW BIEN escrito ... Pienso que has hecho un GRAN trabajo con él. Como líder

de un grupo de interés especial en Java del área de Chicago, he mencionado de forma favorable tu

libro y sitio web muy frecuentemente en mis últimas reuniones. Me gustaría usar Piensa en Java

como la base de cada reunión mensual del grupo, para poder ir repasando y discutiendo sucesivamente cada capítulo. Mark Ertes.

Verdaderamente aprecio tu trabajo, y tu libro es bueno. Lo recomiendo aquí a nuestros usuarios y

estudiantes de doctorado. Hughes Leroy // Irisa-Inria Rennes France, jefe de Computación

Científica y Transferencia Industrial.

De acuerdo, sólo he leído unas 40 páginas de Piensa en Java, pero ya he averiguado que es el libro

de programación mejor escrito y más claro que haya visto jamás ... Yo también soy escritor, por lo

que probablemente soy un poco crítico. Tengo Piensa en Java encargado y ya no puedo esperar

más -soy bastante nuevo en temas de programación y no hago más que enfrentarme a curvas de

Comentarios de los lectores xxxi

aprendizaje en todas partes. Por tanto, esto no es más que un comentario rápido para agradecerte

este trabajo tan excelente. Ya me había empezado a quemar de tanto navegar por tanta y tanta prosa

de tantos y tantos libros de computadores -incluso muchos que venían con magníficas recomendaciones. Me siento muchísimo mejor ahora. Glenn Becker, Educational Theatre ssociation.

Gracias por permitirme disponer de este libro tan maravilloso. Lo he encontrado inmensamente útil

en el entendimiento final de lo que he experimentado -algo confuso anteriormente- con Java y

C++. Leer tu libro ha sido muy gratificante. Felix Bizaoui, Twin Oaks Industnes, Luisa, Va.

Debo felicitarte por tu excelente libro. He decidido echar un vistazo a Piensa en Java guiado por mi

experiencia en Thinking in C++, y no me ha defraudado. Jaco van der Merwe, Software Specialist, DataFusion Systems Ltd., Steíienbosch, Suráfnca.

Este libro hace que todos los demás libros de Java que he leído parezcan un insulto o sin duda inútiles. 13rett g Porter, Senior Programmer, Art & Logic.

He estado leyendo tu libro durante una semana o dos y lo he comparado con otros libros de Java

que he leído anteriormente. Tu libro parece tener un gran comienzo. He recomendado este libro a

muchos de mis amigos y todos ellos lo han calificado de excelente. Por favor, acepta mis felicitaciones por escribir un libro tan excelente. Rama Krishna Bhupathi, Ingeniera de Software, TCSI

Corporation, San José.

Simplemente quería decir lo "brillante" que es tu libro. Lo he estado usando como referencia principal durante mi trabajo de Java hecho en casa. He visto que la tabla de contenidos es justo la más

adecuada para localizar rápidamente la sección que se requiere en cada momento. También es genial ver un libro que no es simplemente una compilación de las API o que no trata al programador

como a un monigote. Grant Sayer, Java Components Group Leader, Ceedata Systems Pty

Ltd., Australia.

~Gu~u! Un libro de Java profundo y legible. Hay muchos libros pobres (y debo admitir también que

un par de ellos buenos) de Java en el mercado, pero por lo que he visto, el tuyo es sin duda uno de

los mejores. John Root, desarrollador Web, Departamento de la Seguridad Social, Londres.

*Acabo* de empezar Piensa en Java. Espero que sea bueno porque me gustó mucho Thinking in

C++ (que leí como programador ya experimentado en C++, intentado adelantarme a la curva de

aprendizaje). En parte estoy menos habituado a Java, pero espero que el libro me satisfaga igualmente. Eres un autor maravilloso. Kevin K. Lewis, Tecnólogo, ObjectSpace Inc.

Creo que es un gran libro. He aprendido todo lo que sé de Java a partir de él. Gracias por hacerlo

disponible gratuitamente a través de Internet. Si no lo hubieras hecho no sabría nada de Java. Pero

lo mejor es que tu libro no es un mero folleto publicitario de Java. También muestra sus lados negativos. TÚ has hecho aquí un gran trabajo. FrederikFix, Bélgica.

Siempre me han enganchado tus libros. Hace un par de años, cuando quería empezar con C++, fue

C++ Inside & Out el que me introdujo en el fascinante mundo de C++. Me ayudó a disponer de mejores oportunidades en la vida. Ahora, persiguiendo más conocimiento y cuando quería aprender

Java, me introduje en Piensa en Java -sin dudar de que gracias a él ya no necesitaría ningún otro

libro. Simplemente fantástico. Es casi como volver a descubrirme a mí mismo a medida que avanzo

xxxii Piensa en Java

en el libro. Apenas hace un mes que he empezado con Java y mi corazón late gracias a ti. Ahora lo

entiendo todo mucho mejor. Anand Kumar S., ingeniero de Software Computervision, India.

Tu libro es una introducción general excelente. Peter Robinson, Universidad de Cambridge,

Computar Laboratory.

Es con mucho el mejor material al que he tenido acceso al aprender Java y simplemente quería que

supieras la suerte que he tenido de poder encontrarlo. ¡GRACIAS! Chuck Peterson, Product Leader, Internet Product Line, MS International.

Este libro es genial. Es el tercer libro de Java que he empezado y ya he recorrido prácticamente dos

tercios. Espero acabar éste. Me he enterado de su existencia porque se usa en algunas clases internas de Lucen Technologies y un amigo me ha dicho que el libro estaba en la Red. Buen trabajo.

Jerry Nowlin, M13, Lucent Technologies.

De los aproximadamente seis libros de Java que he acumulado hasta la fecha, tu Piensa en Java es

sin duda el mejor y el más claro. Michael Van Waas, doctor, presidente, TMR Associates.

Simplemente quiero darte las gracias por Piensa en Java. ¡Qué libro tan maravilloso has hecho! iY

para qué mencionar el poder bajárselo gratis! Como estudiante creo que tus libros son de valor incalculable, tengo una copia de C++ Inside & Out, otro gran libro sobre C++), porque no sólo me enseñan el cómo hacerlo, sino que también los porqués, que sin duda son muy importantes a la hora

de sentar unas buenas bases en lenguajes como C++ y Java. Tengo aquí bastantes amigos a los que

les encanta programar como a mí, y les he hablado de tus libros. ¡Todos piensan que son geniales!

Por cierto, soy indonesio y vivo en Java. Ray Frederick Djajadinata, estudiante en Trisakti University, Jakarta.

El mero hecho de que hayas hecho que este trabajo esté disponible gratuitamente en la Red me deja

conmocionado. Pensé que debía decirte cuánto aprecio y respeto lo que estás haciendo. Shane KeBouthillier, estudiante de Ingeniería en Informática, Universidad de Alberta, Canadá.

Tengo que decirte cuánto ansío leer tu columna mensual. Como novato en el mundo de la programación orientada a objetos, aprecio el tiempo y el grado de conocimiento que aportas en casi todos

los temas elementales. He descargado tu libro, pero puedes apostar a que compraré una copia en

papel en cuanto se publique. Gracias por toda tu ayuda. Dan Cashmer, D. C. Ziegler & Co.

Simplemente quería felicitarte por el buen trabajo que has hecho. Primero me recorrí la versión PDF

de Piensa en Java. Incluso antes de acabar de leerla, corrí a la tienda y compré Thinking in C++. Ahora que llevo en el negocio de la informática ocho años, como consultor, ingeniero de software, profesor/formador, y últimamente autónomo, creo que puedo decir que he visto suficiente (fíjate que no

digo haber visto "todo" sino suficiente). Sin embargo, estos libros hacen que mi novia me llame

"geek. No es que tenga nada contra el concepto en sí -simplemente pensaba que ya había dejado

atrás esta fase. Pero me veo a mí mismo disfrutando sinceramente de ambos libros, de una forma que

no había sentido con ningún otro libro que haya tocado o comprado hasta la fecha. Un estilo de escritura excelente, una introducción genial de todos los temas y mucha sabiduría en ambos textos.

Bien hecho. Simon Goland, simonsez@smartt.com, Simon Says Consulting, Inc.

Comentarios de los lectores xxxiii

¡Debo decir que tu Piensa en Java es genial! Es exactamente el tipo de documentación que buscaba. Especialmente las secciones sobre los buenos y malos diseños basados en Java. Dirk Duehr,

Lexikon Verlag, Bertelsmann AG, Alemania.

Gracias por escribir dos grandes libros (Thinking in C++, Piensa en Java). Me has ayudado inmensamente en mi progresión en la programación orientada a objetos. Donald Lawon, DCL Enterprises.

Gracias por tomarte el tiempo de escribir un libro de Java que ayuda verdaderamente. Si enseñar

hace que aprendas algo, tú ya debes estar más que satisfecho. Dominic Turner, GEAC Support.

Es el mejor libro de Java que he leído jamás -y he leído varios. Jean-Yves MENGANT, Chief

Software Architect NAT-SYSTEM, París, Francia.

Piensa en Java proporciona la mejor cobertura y explicación. Muy fácil de leer, y quiero decir que

esto se extiende también a los fragmentos de código. Ron Chan, Ph. D., Expert Choice Ind.,

Pittsburg PA.

Tu libro es genial. He leído muchos libros de programación y el tuyo sigue añadiendo luz a la programación en mi mente. Ningjian Wang, Information System Engineer, The Vanguard Group.

Piensa en Java es un libro excelente y legible. Se lo recomiendo a todos mis alumnos. Dr. Paul

Gorman, Department of Computer Sciente, Universidad de Otago, Dunedin, Nueva Zelanda.

Haces posible que exista el proverbial almuerzo gratuito, y no simplemente una comida basada en

sopa de pollo, sino una delicia de gourmet para aquéllos que aprecian el buen software y los libros

sobre él mismo. Jose Suriol, Scylax Corporation.

¡Gracias por la oportunidad de ver cómo este libro se convierte en una obra maestra! ES EL MEJOR libro de la materia que he leído o recorrido. Jeff Lapchinsky, programador, Net Result

Tecnologies.

Tu libro es conciso, accesible y gozoso de leer. Keith Ritchie, Java Research & Develpment

Team, KL Group Inc.

¡ES sin duda el mejor libro de Java que he leído! Daniel Eng.

¡ES el mejor libro de Java que he visto! Rich Hoffarth, Arquitecto Senior, West Group.

Gracias por un libro tan magnífico. Estoy disfrutando mucho a medida que leo capítulos. Fred

Trimble, Actium Corporation.

Has llegado a la maestría en el arte de hacernos ver los detalles, despacio y con éxito. Haces que la

lectura sea MUY fácil y satisfactoria. Gracias por un tutorial tan verdaderamente maravilloso. Rajesh Rau, Software Consultant.

Piensa en Java es un rock para el mundo libre! Miko O'Sullivan, Presidente, Idocs Inc.

xxxiv Piensa en Java

Sobre Thinking in C++:

Best Book! Ganador en 1995 del Software Development Magazine Jolt Award!

"Este libro es un tremendo logro. Deberías tener una copia en la estantería. El capítulo sobre flujos

de E/S presenta el tratamiento más comprensible y fácil de entender sobre ese tema que jamás haya

visto."

Al Stevens

Editor, Doctor Dobbs Journal

"El libro de Eckel es el único que explica claramente cómo replantearse la construcción de programas para la orientación a objetos. Que el libro es también un tutorial excelente en las entradas y en

las salidas de C++ es un valor añadido."

Andrew Binstock

Editor, Unix Review

"Bruce continúa deleitándome con esta introspección de C++, y Thinking in C++ es la mejor colección de ideas hasta la fecha. Si se desean respuestas rápidas a preguntas difíciles sobre C++, compre este libro tan sobresaliente."

Gary Entsminger

Autor, The Tao of Objects

"Thinking in C++" explora paciente y metódicamente los aspectos de cuándo y cómo usar los interlineado~, referencias, sobrecargas de operadores, herencia, y objetos dinámicos, además de temas

avanzados como el uso adecuado de plantillas, excepciones y la herencia múltiple. Todo el esfuerzo

se centra en un producto que engloba la propia filosofía de Eckel del diseño de objetos y programas.

Un libro que no debe faltar en la librería de un desarrollador de C++, Piensa en Jaua es el libro de

C++ que hay que tener si se están haciendo desarrollos serios con C++."

Richard Hale Shaw

Ayudante del Editor, PC Magazine

Introducción

Como cualquier lenguaje humano, Java proporciona una forma de expresar conceptos. Si tiene éxito, la expresión media será significativamente más sencilla y

más flexible que las alternativas, a medida que los problemas crecen en tamaño

y complejidad.

No podemos ver Java como una simple colección de características -algunas de las características

no tienen sentido aisladas. Se puede usar la suma de partes sólo si se está pensando en diseño, y no

simplemente en codificación. Y para entender Java así, hay que entender los problemas del lenguaje y de la programación en general. Este libro habla acerca de problemas de programación, por qué

son problemas y el enfoque que Java sigue para solucionarlos. Por consiguiente, algunas características que explico en cada capítulo se basan en cómo yo veo que se ha solucionado algún problema en particular con el lenguaje. Así, espero conducir poco a poco al lector, hasta el punto en que

Java se convierta en lengua casi materna.

Durante todo el tiempo, estaré tomando la actitud de que el lector construya un modelo mental que

le permita desarrollar un entendimiento profundo del lenguaje; si se encuentra un puzzle se podrá

alimentar de éste al modelo para tratar de deducir la respuesta.

Prerrequisitos

Este libro asume que se tiene algo de familiaridad con la programación: se entiende que un programa es una colección de sentencias, la idea de una subrutina/función/macro, sentencias de control como "ir' y bucles estilo "while", etc. Sin embargo, se podría haber aprendido esto en muchos

sitios, como, por ejemplo, la programación con un lenguaje de macros o el trabajo con una herramienta como Perl. A medida que se programa hasta el punto en que uno se siente cómodo con las

ideas básicas de programación, se podrá ir trabajando a través de este libro. Por supuesto, el libro

será más fácil para los programadores de C y aún más para los de C++, pero tampoco hay por qué

excluirse a sí mismo cuando se desconocen estos lenguajes (aunque en este caso es necesario tener la voluntad de trabajar duro; además, el CD multimedia que acompaña a este texto te permitirá

conocer rápidamente los conceptos de la sintaxis de C necesarios para aprender Java). Presentaré

los conceptos de la programación orientada a objetos (POO) y los mecanismos de control básicos

de Java, para tener conocimiento de ellos, y los primeros ejercicios implicarán las secuencias de flujo de control básicas.

Aunque a menudo aparecerán referencias a aspectos de los lenguajes C y C++, no deben tomarse

como comentarios profundos, sino que tratan de ayudar a los programadores a poner Java en perspectiva con esos lenguajes, de los que, después de todo, es de los que desciende Java. Intentaré hacer que estas referencias sean lo más simples posibles, y explicar cualquier cosa que crea que una

persona que no haya programado nunca en C o C++ pueda desconocer.

xxxvi Piensa en Java

Aprendiendo Java

Casi a la vez que mi primer libro Using C++ (Osborne/McGraw-Hill, 1989)apareció, empecé a enseñar ese lenguaje. Enseñar lenguajes de programación se ha convertido en mi profesión; he visto

cabezas dudosas, caras en blanco y expresiones de puzzle en audiencias de todo el mundo desde

1989. A medida que empecé con formación in situ a grupos de gente más pequeños, descubrí algo

en los ejercicios. Incluso aquéllos que sonreían tenían pegas con muchos aspectos. Al dirigir la sesión de C++ en la Software Development Conference durante muchos años (y después la sesión de

Java), descubrí que tanto yo como otros oradores tendíamos a ofrecer a la audiencia, en general,

muchos temas demasiado rápido. Por tanto, a través, tanto de la variedad del nivel de audiencia

como de la forma de presentar el material, siempre se acababa perdiendo parte de la audiencia. Quizás es pedir demasiado, pero dado que soy uno de ésos que se resisten a las conferencias tradicionales (y en la mayoría de casos, creo que esta resistencia proviene del aburrimiento), quería intentar algo que permitiera tener a todo el mundo enganchado.

Durante algún tiempo, creé varias presentaciones diferentes en poco tiempo. Por consiguiente, acabé aprendiendo a base de experimentación e iteración (una técnica que también funciona bien en

un diseño de un programa en Java). Eventualmente, desarrollé un curso usando todo lo que había

aprendido de mi experiencia en la enseñanza -algo que me gustaría hacer durante bastante tiempo. Descompone el problema de aprendizaje en pasos discretos, fáciles de digerir, y en un seminario en máquina (la situación ideal de aprendizaje) hay ejercicios seguidos cada uno de pequeñas lecciones. Ahora doy cursos en seminarios públicos de Java, que pueden encontrarse en

http:/ /www.BruceEckel.com. (El seminario introductorio también está disponible como un CD

ROM. En el sitio web se puede encontrar más información al respecto.)

La respuesta que voy obteniendo de cada seminario me ayuda a cambiar y reenfocar el material hasta que creo que funciona bien como medio docente. Pero este libro no es simplemente un conjunto

de notas de los seminarios -intenté empaquetar tanta información como pude en este conjunto de

páginas, estructurándola de forma que cada tema te vaya conduciendo al siguiente. Más que otra

cosa, el libro está diseñado para servir al lector solitario que se está enfrentando y dando golpes con

un nuevo lenguaje de programación.

Objetivos

Como en mi libro anterior Thinking in C++, este libro pretende estar estructurado en torno al proceso de enseñanza de un lenguaje. En particular, mi motivación es crear algo que me proporcione

una forma de enseñar el lenguaje en mis propios seminarios. Cuando pienso en un capítulo del libro, lo pienso en términos de lo que constituiría una buena lección en un seminario. Mi objetivo es

lograr fragmentos que puedan enseñarse en un tiempo razonable, seguidos de ejercicios que sean

fáciles de llevar a cabo en clase.

Mis objetivos en este libro son:

1. Presentar el material paso a paso de forma que se pueda digerir fácilmente cada concepto antes de avanzar.

Introducción xxxvii

2. Utilizar ejemplos que sean tan simples y cortos como se pueda. Esto evita en ocasiones acometer problemas del "mundo real", pero he descubierto que los principiantes suelen estar más

contentos cuando pueden entender todos los detalles de un ejemplo que cuando se ven impresionados por el gran rango del problema que solucionan. Además, hay una limitación severa de cara a la cantidad de código que se puede absorber en una clase. Por ello, no dudaré

en recibir críticas por usar "ejemplos de juguete", sino que estoy deseoso de aceptarlas en aras

de lograr algo pedagógicamente útil.

3. Secuenciar cuidadosamente la presentación de características de forma que no se esté viendo

algo que aún no se ha expuesto. Por supuesto, esto no es siempre posible; en esas situaciones

sc da11 br-cves descr-ipcioiies iiitr-oductoi-ias.

4. Dar lo que yo considero que es importante que se entienda del lenguaje, en lugar de todo lo

que sé. Creo que hay una jerarquía de importancia de la información, y que hay hechos que

el 95% de los programadores nunca necesitarán saber y que simplemente confunden a la gente y añaden su percepción de la complejidad del lenguaje. Por tomar un ejemplo de C, si se

memoriza la tabla de precedencia de los operadores (algo que yo nunca hice) se puede escribir un código más inteligente. Pero si se piensa en ello, también confundirá la legibilidad y

mantenibilidad de ese código. Por tanto, hay que olvidarse de la precedencia, y usar paréntesis cuando las cosas no estén claras.

5. Mantener cada sección lo suficientemente enfocada de forma que el tiempo de exposición

-el tiempo entre periodos de ejercicios- sea pequeño. Esto no sólo mantiene más activas

las mentes de la audiencia, que están en un seminario en máquina, sino que también transmite más sensación de avanzar.

6. Proporcionar una base sólida que permita entender los aspectos lo suficientemente bien como

para avanzar a cursos y libros más difíciles.

Documentación en línea

El lenguaje Java y las bibliotecas de Sun Microsystems (de descarga gratuita) vienen con su documentación en forma electrónica, legible utilizando un navegador web, y casi toda implementación de

Java de un tercero tiene éste u otro sistema de documentación equivalente. Casi todos los libros publicados de Java, incorporan esta documentación. Por tanto, o ya se tiene, o se puede descargar, y a

menos que sea necesario, este libro no repetirá esa documentación pues es más rápido encontrar

las descripciones de las clases en el navegador web que buscarlas en un libro Cy la documentación

en línea estará probablemente más actualizada). Este libro proporcionará alguna descripción extra

de las clases sólo cuando sea necesario para complementar la documentación, de forma que se pueda entender algún ejemplo particular.

xxxviii Piensa en Java

Capítulos

Este libro se diseñó con una idea en la cabeza: la forma que tiene la gente de aprender Java. La realimentación de la audiencia de mis seminarios me ayudó a ver las partes difíciles que necesitaban

aclaraciones. En las áreas en las que me volvía ambiguo e incluía varias características a la vez, descubrí -a través del proceso de presentar el material- que si se incluyen muchas características de

golpe, hay que explicarlas todas, y esto suele conducir fácilmente a la confusión por parte del alumno. Como resultado, he tenido bastantes problemas para presentar las características agrupadas de

tan pocas en pocas como me ha sido posible.

El objetivo, por tanto, es que cada capítulo enseñe una única característica, o un pequeño grupo de

características asociadas, sin pasar a características adicionales. De esa forrria se puede diger-ir- cada

fragmento en el contexto del conocimiento actual antes de continuar.

He aquí una breve descripción de los capítulos que contiene el libro, que corresponde a las conferencias y periodos de ejercicio en mis seminarios en máquina.

Capítulo 1: Introducción a los objetos

Este capítulo presenta un repaso de lo que es la programación orientada a objetos, incluyendo la respuesta a la cuestión básica "¿Qué es un objeto?", interfaz frente a implementación, abstracción y

encapsulación, mensajes y funciones, herencia y composición, y la importancia del polimorfismo.

También se obtendrá un repaso a los aspectos de la creación de objetos como los constructores, en

los que residen los objetos, dónde ponerlos una vez creados, y el mágico recolector de basura que

limpia los objetos cuando dejan de ser necesarios. Se presentarán otros aspectos, incluyendo el manejo de errores con excepciones, el multihilo para interfaces de usuario con buen grado de respuesta, y las redes e Internet. Se aprenderá qué convierte a Java en especial, por qué ha tenido tanto éxito, y también algo sobre análisis y diseño orientado a objetos.

Capítulo 2: Todo es un objeto

Este capítulo te lleva al punto donde tú puedas crear el primer programa en Java, por lo que debe dar

un repaso a lo esencial, incluyendo el concepto de referencia a un objeto; cómo crear un objeto; una

introducción de los tipos primitivos y arrays; el alcance y la forma en que destruye los objetos el recolector de basura; cómo en Java todo es un nuevo tipo de datos (clase) y cómo crear cada uno sus

propias clases; funciones, argumentos y valores de retorno; visibilidad de nombres y el uso de componentes de otras bibliotecas; la palabra clave static; y los comentarios y documentación embebida.

Capítulo 3: Controlando el flujo

de los programas

Este capítulo comienza con todos los operadores que provienen de C y C++. Además, se descubrirán los fallos de los operadores comunes, la conversión de tipos, la promoción y la precedencia. Des-

Introducción xxxix

pués se presentan las operaciones básicas de control de flujo y selección existentes en casi todos los

lenguajes de programación: la opción con if-else; los bucles con while y for; cómo salir de un bucle

con break y continue, además de sus versiones etiquetadas en Java (que vienen a sustituir al "goto

perdido" en Java); la selección con switch. Aunque gran parte de este material tiene puntos comunes con el código de C y C++, hay algunas diferencias. Además, todos los ejemplos estarán hechos

completamente en Java por lo que el lector podrá estar más a gusto con la apariencia de Java.

Capítulo 4: Inicialización y limpieza

Este capítulo comienza presentando el constructor, que garantiza una inicialización adecuada. La definición de constructor conduce al concepto de sobrecarga de funciones (puesto que puede haber

varios constructores). Éste viene seguido de una discusión del proceso de limpieza, que no siempre

es tan simple como parece. Normalmente, simplemente se desecha un objeto cuando se ha acabado con él y el recolector de basura suele aparecer para liberar la memoria. Este apartado explora el

recolector de basura y algunas de sus idiosincrasias. El capítulo concluye con un vistazo más cercano a cómo se inicializan las cosas: inicialización automática de miembros, especificación de inicialización de miembros, el orden de inicialización, la inicialización static y la inicialización de

arrays.

Capítulo Ocultando implementación

Este capítulo cubre la forma de empaquetar junto el código, y por qué algunas partes de una biblioteca están expuestas a la vez que otras partes están ocultas. Comienza repasando las palabras

clave package e import, que llevan a cabo empaquetado a nivel de archivo y permiten construir bibliotecas de clases. Después examina el tema de las rutas de directorios y nombres de fichero. El

resto del capítulo echa un vistazo a las palabras clave public, private y protected, el concepto de

acceso "friendly", y qué significan los distintos niveles de control de acceso cuando se usan en los

distintos conceptos.

Capítulo 6: clases

El concepto de herencia es estándar en casi todos los lenguajes de POO. Es una forma de tomar una

clase existente y añadirla a su funcionalidad (además de cambiarla, que será tema del Capítulo 7).

La herencia es a menudo una forma de reutilizar código dejando igual la "clase base", y simplemente

parcheando los elementos aquí y allí hasta obtener lo deseado. Sin embargo, la herencia no es la

única forma de construir clases nuevas a partir de las existentes. También se puede empotrar un objeto dentro de una clase nueva con la composición. En este capítulo, se aprenderán estas dos formas

de reutilizar código en Java, y cómo aplicarlas.

Capítulo 7: Polimorfismo

Cada uno por su cuenta, podría invertir varios meses para descubrir y entender el polimorfismo, claves en POO. A través de pequeños ejemplos simples, se verá cómo crear una familia de tipos con

xl Piensa en Java

herencia y manipular objetos de esa familia a través de su clase base común. El polimorfismo de

Java permite tratar los objetos de una misma familia de forma genérica, lo que significa que la mayoría del código no tiene por qué depender de un tipo de información específico. Esto hace que los

programas sean extensibles, por lo que se facilita y simplifica la construcción de programas y el

mantenimiento de código.

Capítulo 8: Interfaces y clases internas

Java proporciona una tercera forma de establecer una relación de reutilización a través de la interfaz, que es una abstracción pura del interfaz de un objeto. La interfaz es más que una simple clase

abstracta llevada al extremo, puesto que te permite hacer variaciones de la "herencia múltiple" de

C++, creando una clase sobre la que se puede hacer una conversión hacia arriba a más de una clase base.

A primera vista, las clases parecen un simple mecanismo de ocultación de código: se colocan clases

dentro de otras clases. Se aprenderá, sin embargo, que la clase interna hace más que eso -conoce

y puede comunicarse con la clase contenedora- y que el tipo de código que se puede escribir con

clases internas es más elegante y limpio, aunque es un concepto nuevo para la mayoría de la gente

y lleva tiempo llegar a estar cómodo utilizando el diseño clases internas.

Capítulo 9: Guardando tus objetos

Es un programa bastante simple que sólo tiene una cantidad fija de objetos de tiempo de vida conocido. En general, todos los programas irán creando objetos nuevos en distintos momentos, conocidos sólo cuando se está ejecutando el programa. Además, no se sabrá hasta tiempo de ejecución

la cantidad o incluso el tipo exacto de objetos que se necesitan. Para solucionar el problema de programación general, es necesario crear cualquier número de objetos, en cualquier momento y en

cualquier lugar. Este capítulo explora en profundidad la biblioteca de contenedores que proporciona Java 2 para almacenar objetos mientras se está trabajando con ellos: los simples arrays y contenedores más sofisticados (estructuras de datos) como ArrayList y HashMap.

Capítulo 10: Manejo de errores

con excepciones

La filosofía básica de Java es que el código mal formado no se ejecutará. En la medida en que sea

posible, el compilador detecta problemas, pero en ocasiones los problemas -debidos a errores del

programador o a condiciones de error naturales que ocurren como parte de la ejecución normal del

programa- pueden detectarse y ser gestionados sólo en tiempo de ejecución. Java tiene el manejo

de excepciones para tratar todos los problemas que puedan surgir al ejecutar el programa. Este capítulo muestra cómo funcionan en Java las palabras clave try, catch, throw, throws y finally; cuándo

se deberían lanzar excepciones y qué hacer al capturarlas. Además, se verán las excepciones estándar de Java, cómo crear las tuyas propias, qué ocurre con las excepciones en los constructores y

cómo se ubican los gestores de excepciones.

Introducción xli

Capítulo 11: El sistema de E/S de Java

Teóricamente, se puede dividir cualquier programa en tres partes: entrada, proceso y salida. Esto

implica que la E/S (entrada/salida) es una parte importante de la ecuación. En este capítulo se

aprenderá las distintas clases que proporciona Java para leer y escribir ficheros, bloques de memoria y la consola. También se mostrará la distinción entre E/S "antigua" y "nueva". Además, este capítulo examina el proceso de tomar un objeto, pasarlo a una secuencia de bytes (de forma que pueda ser ubicado en el disco o enviado a través de una red) y reconstruirlo, lo que realiza

automáticamente la serialización de objetos de Java. Además, se examinan las bibliotecas de compresión de Java, que se usan en el formato de archivos de Java CJAR).

Capítulo 12: Identificación de tipos en tiempo

de ejecución

La identificación de tipos en tiempo de ejecución (RTTI) te permite averiguar el tipo exacto de un

objeto cuando se tiene sólo una referencia al tipo base. Normalmente, se deseará ignorar intencionadamente el tipo exacto de un objeto y dejar que sea el mecanismo de asignación dinámico de Java

(polimorfismo) el que implemente el comportamiento correcto para ese tipo. A menudo, esta información te permite llevar a cabo operaciones de casos especiales, más eficientemente. Este capítulo

explica para qué existe la RTTI, cómo usarlo, y cómo librarse de él cuando sobra. Además, este capítulo presenta el mecanismo de reflectividad de Java.

Capítulo 13: Creación de ventanas y applets

Java viene con la biblioteca IGU Swing, que es un conjunto de clases que manejan las ventanas de

forma portable. Estos programas con ventanas pueden o bien ser applets o bien aplicaciones independientes. Este capítulo es una introducción a Swing y a la creación de applets de World Wide

Web. Se presenta la importante tecnología de los "JavaBeansn, fundamental para la creación de herramientas de construcción de programas de Desarrollo Rápido de Aplicaciones (RAD).

Capítulo 14: Hilos múltiples

Java proporciona una utilidad preconstruida para el soporte de múltiples subtareas concurrentes denominadas hilos, que se ejecutan en un único programa. (A menos que se disponga de múltiples procesadores en la máquina, los múltiples hilos sólo son aparentes.) Aunque éstas pueden usarse en todas partes, los hilos son más lucidos cuando se intenta crear una interfaz de usuario con alto grado

de respuesta, de forma que, por ejemplo, no se evita que un usuario pueda presionar un botón o introducir datos mientras se está llevando a cabo algún procesamiento. Este capítulo echa un vistazo

a la sintaxis y la semántica del multihilo en Java.

xlii Piensa en Java

Capítulo 15: Computación distribuida

Todas las características y bibliotecas de Java aparecen realmente cuando se empieza a escribir programas que funcionen en red. Este capítulo explora la comunicación a través de redes e Internet, y

las clases que proporciona Java para facilitar esta labor. Presenta los tan importantes conceptos de

Serulets y JSP (para programación en el lado servidor), junto con Java DataBase Connectiuity CJDBC)

y el Remote Method Inuocation (RMI). Finalmente, hay una introducción a las nuevas tecnologías de

JINI, JauaSpaces, y Enterprise JavaBeans (EJBS) .

Apéndice A: Paso y retorno de objetos

Puesto que la única forma de hablar con los objetos en Java es mediante referencias, los conceptos

de paso de objetos a una función y de devolución de un objeto de una función tienen algunas consecuencias interesantes. Este apéndice explica lo que es necesario saber para gestionar objetos

cuando se está entrando y saliendo de funciones, y también muestra la clase String, que usa un enfoque distinto al problema.

Apendice B: La Interfaz Nativa de Java (JNI)

Un programa Java totalmente portable tiene importantes pegas: la velocidad y la incapacidad

para acceder a servicios específicos de la plataforma. Cuando se conoce la plataforma sobre la

que está ejecutando, es posible incrementar dramáticamente la velocidad de ciertas operaciones

construyéndolas como métodos nativos, que son funciones escritas en otro lenguaje de programación (actualmente, sólo están soportados C/C++). Este apéndice da una introducción más que

satisfactoria que debería ser capaz de crear ejemplos simples que sirvan de interfaz con código

no Java.

Apendice C: Guías de programación Java

Este apéndice contiene sugerencias para guiarle durante la realización del diseño de programas de

bajo nivel y la escritura de código.

Apéndice D: Lecturas recomendadas

Una lista de algunos libros sobre Java que he encontrado particularmente útil.

tjercicios

He descubierto que los ejercicios simples son excepcionalmente útiles para completar el entendimiento de los estudiantes durante un seminario, por lo que se encontrará un conjunto de ellos al final de cada capítulo.

Introducción xliii

La mayoría de ejercicios están diseñados para ser lo suficientemente sencillos como para poder ser

resueltos en un tiempo razonable en una situación de clase mientras que observa el profesor, asegurándose de que todos los alumnos asimilen el material. Algunos ejercicios son más avanzados

para evitar que los alumnos experimentados se aburran. La mayoría están diseñados para ser resueltos en poco tiempo y probar y pulir el conocimiento. Algunos suponen un reto, pero ninguno

presenta excesivas dificultades. (Presumiblemente, cada uno podrá encontrarlos -o más probablemente te encontrarán ellos a ti.)

En el documento electrónico The Thinking in Java Annotated Solution Guide pueden encontrarse

soluciones a ejercicios seleccionados, disponibles por una pequeña tasa en http://www.BruceEckeI.com.

CD ROM Multimedia

Hay dos CD multimedia asociados con este libro. El primero está en el propio libro: Thinking in C,

descritos al final del prefacio. que te preparan para el libro aportando velocidad en la sintaxis de C

necesaria para poder entender Java.

Hay disponible un segundo CD ROM multimedia, basado en los contenidos del libro. Este CD ROM

es un producto separado y contiene los contenidos enteros del seminario de formación "Hands-On

Java" de una semana de duración. Esto son grabaciones de conferencias de más de 15 horas que he

grabado, y sincronizado con cientos de diapositivas de información. Dado que el seminario se basa

en este libro, es el acompañamiento ideal.

El CD ROM contiene todas las conferencias (¡con la importante excepción de la atención personalizada!) de los seminarios de cinco días de inmersión total. Creemos que establece un nuevo estándar de calidad.

El CD ROM "Hands-On Java" está disponible sólo bajo pedido, que se cursa directamente del sitio

web http:llwww.BruceEckel.com.

Código fuente

Todo el código fuente de este libro está disponible de modo gratuito sometido a copyright, distribuido como un paquete único, visitando el sitio web http://www.BruceEcke1.com. Para asegurarse de

obtener la versión más actual, éste es el lugar oficial para distribución del código y de la versión

electrónica del libro. Se pueden encontrar versiones espejo del código y del libro en otros sitios (algunos de éstos están referenciados en http://www. BruceEckel.com), pero habría que comprobar el

sitio oficial para asegurarse de obtener la edición más reciente. El código puede distribuirse en clases y en otras situaciones con fines educativos.

La meta principal del copyright es asegurar que el código fuente se cite adecuadamente, y prevenir

que el código se vuelva a publicar en medios impresos sin permiso. (Mientras se cite la fuente, utilizando los ejemplos del libro, no habrá problema en la mayoría de los medios.)

En cada fichero de código fuente, se encontrará una referencia a la siguiente nota de copyright:

xliv Piensa en Java

:! :CopyRght.txt

Copyright (c) 2000 Bruce Eckel

Source code file from the 2nd edition of the book

"Thinking in Java." Al1 rights reserved EXCEPT as

allowed by the following statements:

You can freely use this file

for your own work (personal or commercial),

including modifications and distribution in

executable form only. Permission is granted to use

this file in classroom situations, including its

use in presentation materials, as long as the book

"Thinking in Java" is cited as the source.

Except in classroom situations, you cannot copy

and distribute this code; instead, the sole

distribution point is http://www.BruceEckel.com

(and official mirror sites) where it is

freely available. You cannot remove this

copyright and notice. You cannot distribute

modified versions of the source code in this

package. You cannot use this file in printed

media without the express permission of the

author. Bruce Eckel makes no representation about

the suitability of this software for any purpose.

It is provided "as is" without express or implied

warranty of any kind, including any implied

warranty of merchantability, fitness for a

particular purpose or non-infringement. The entire

risk as to the quality and performance of the

software is with you. Bruce Eckel and the

publisher shall not be liable for any damages

suffered by you or any third party as a result of

using or distributing software. In no event will

Bruce Eckel or the publisher be liable for any

lost revenue, profit, or data, or for direct,

indirect, special, consequential, incidental, or

punitive darnages, however caused and reqardless of

the theory of liability, arising out of the use of

or inability to use software, even if Bruce Eckel

and the publisher have been advised of the

possibility of such damages. Should the software

prove defective, you assume the cost of al1

necessary servicing, repair, or correction. If you

think you've found an error, please submit the

correction using the form you will find at

www.BruceEckel.com. (Please use the same

form for non-code errors found in the book. )

///:-

Introducción xlv

El código puede usarse en proyectos y en clases (incluyendo materiales de presentación) mientras

se mantenga la observación de copyright que aparece en cada archivo fuente.

Estandares de codificación

En el texto de este libro, los identificadores (nombres de fimciones, variables y clases) están en negrita. La mayoría de palabras clave también están en negrita, excepto en aquellos casos en que las palabras

se usan tanto que ponerlas en negrita podría volverse tedioso, como es el caso de la palabra "clase".

Para los ejemplos de este libro, uso un estilo de codificación bastante particular. Este estilo sigue

al estilo que la propia Sun usa en prácticamente todo el código de sitio web (véase

http://]ava.sun.com/docs/codeconv/index.html), y parece quc es1á supui-tado por la mayoría de entornos de desarrollo Java. Si ha leído el resto de mis trabajos, también verá que el estilo de codificación de Sun coincide con el mío -esto me alegra, aunque no tenía nada que hacer con él. El aspecto del estilo de formato es bueno para lograr horas de tenso debate, por lo que simplemente diré

que no pretendo dictar un estilo correcto mediante mis ejemplos; tengo mi propia motivación para

usar el estilo que uso. Java es un lenguaje de programación de forma libre, se puede seguir usando

cualquier estilo con el que uno esté a gusto.

Los programas de este libro son archivos incluidos por el procesador de textos, directamente sacados de archivos compilados. Por tanto, los archivos de código impresos en este libro deberían funcionar sin errores de compilador. Los errores que deberían causar mensajes de error en tiempo de

compilación están comentados o marcados mediante //!, por lo que pueden ser descubiertos fácilmente, y probados utilizando medios automáticos. Los errores descubiertos de los que ya se haya

informado al autor, aparecerán primero en el código fuente distribuido y posteriormente en actualizaciones del libro (que también aparecerán en el sitio web http:llwww. BruceEckel.com).

Versiones de Java

Generalmente confío en la implementación que Sun hace de Java como referencia para definir si un

determinado comportamiento es o no correcto.

Con el tiempo, Sun ha lanzado tres versiones principales de Java: la 1.0, la 1.1 y la 2 (que se llama

versión 2, incluso aunque las versiones del JDK de Sun siguen usando el esquema de numeración

de 1.2, 1.3, 1.4, etc.). La versión 2 parece llevar finalmente a Java a la gloria, especialmente en lo que

concierne a las herramientas de interfaces. Este libro se centra en, y está probado con, Java 2, aunque en ocasiones hago concesiones a las características anteriores de Java 2, de forma que el código pueda compilarse bajo Linux (vía el JDK de Linux que estaba disponible en el momento de escribir el libro).

Si se necesita aprender versiones anteriores del lenguaje no cubiertas en esta edición, la primera

edición del libro puede descargarse gratuitamente de http:llwww.BruceEckel.corn, y también está en

el CD adjunto a este libro.

xlvi Piensa en Java

Algo de lo que uno se dará cuenta es de que, cuando menciono versiones anteriores del lenguaje,

no uso los números de sub-revisión. En este libro me referiré sólo a Java 1.0, 1.1 y 2, para protegerme de errores tipográficos producidos por sub-revisiones posteriores de estos productos.

Seminarios y mi papel como mentor

Mi empresa proporciona seminarios de formación de cinco días, en máquina, públicos e in situ, basados en el material de este libro. Determinado material de cada capítulo representa una lección, seguida de un periodo de ejercicios guiados de forma que cada alumno recibe atención personal. Las

conferencias y las diapositivas del seminario introductorio también están en el CD ROM para proporcional al menos alguna de la experiencia del seminario sin el viaje y el coste que conllevaría. Para

más información, visitar http:llwww.BruceEckel.corn.

Mi compañía también proporciona consultoría, servicios de orientación y acompañamiento para ayudar a guiar un proyecto a lo largo de su ciclo de desarrollo -especialmente indicado para el primer

proyecto en Java de una empresa.

Errores

Sin que importe cuántos trucos utiliza un escritor para detectar errores, siempre hay alguno que se

queda ahí y que algún lector encontrará.

Hay un formulario para remitir errores al principio de cada capítulo en la versión HTML del libro

(y en el CD ROM unido al final de este libro, además de descargable de http:llwww.BruceEckel.corn)

y también en el propio sitio web, en la página correspondiente a este libro. Si se descubre algo que

uno piense que puede ser un error, por favor, utilice el formulario para remitir el error junto con la

corrección sugerida. Si es necesario, incluya el archivo de código fuente original y cualquier modificación que se sugiera. Su ayuda será apreciada.

Nota sobre el diseño de la portada

La portada de Piensa en Java está inspirada en el American Arts & Crafts Movement, que se fundó

al cambiar de siglo y alcanzó su cenit entre los años 1900 y 1920. Empezó en Inglaterra como una

reacción tanto a la producción de las máquinas de la Revolución Industrial y al estilo victoriano, excesivamente ornamental. Arts & Crafts hacía especial énfasis en el mero diseño, en las formas de la

naturaleza tal y como se ven en el movimiento del Art Nouveau, las manualidades y la importancia

del trabajo individual, y sin embargo sin renunciar al uso de herramientas modernas. Hay muchas

réplicas con la situación de hoy en día: el cambio de siglo, la evolución de los principios puros de la

revolución de los computadores a algo más refinado y más significativo para las personas individuales, y el énfasis en el arte individual que hay en el software, frente a su simple manufactura.

Veo Java de esta misma forma: como un intento de elevar al programador más allá de la mecánica

de un sistema operativo y hacia el "arte del software".

Introducción xlvii

Tanto el autor como el diseñador del libro/portada (que han sido amigos desde la infancia) encuentran la inspiración en este movimiento, y ambos poseen muebles, lámparas y otros elementos

que o bien son originales, o bien están inspirados en este periodo.

El otro tema de la cubierta sugiere una caja de colecciones que podría usar un naturalista para mostrar los especímenes de insectos que ha guardado. Estos insectos son objetos, ubicados dentro de

la caja de objetos. Los objetos caja están a su vez ubicados dentro del "objeto cubierta", que ilustra

el concepto fundamental de la agregación en la programación orientada a objetos. Por supuesto, un

programador no puede ayudar si no es produciendo "errores" en la asociación, y aquí los errores se

han capturado siendo finalmente confinados en una pequeña caja de muestra, como tratando de

mostrar la habilidad de Java para encontrar, mostrar y controlar los errores (lo cual es sin duda uno

de sus más potentes atributos).

Agradecimientos

En primer lugar, gracias a los asociados que han trabajado conmigo para dar seminarios, proporcionar consultoría y desarrollar productos de aprendizaje: Andrea Provaglio, Dave Bastlett (que también contribuyó significativamente al Capítulo 15), Bill Venners y Larry O'Brien. Aprecio vuestra

paciencia a medida que sigo intentando desarrollar el mejor modelo para que tipos tan independientes como nosotros podamos trabajar juntos. Gracias a Rolf André Klaedtke (Suiza); Martin

Vleck, Martin Byer, Vlada & Pavel Lahoda, Martin el Oso, y Hanka (Praga); y a Marco Cantu (Italia) por darme alojamiento durante mi primera gira seminario auto organizada por Europa.

Gracias a la Doyle Street Cohousing Community por soportarme durante los dos años que me llevó

escribir la primera edición de este libro (y por aguantarme en general). Muchas gracias a Kevin y

Sonda Donovan por subarrendarme su magnífico lugar en Creste Butte, Colorado, durante el verano mientras trabajaba en la primera edición del libro. Gracias también a los amigables residentes de

Crested Butte y al Rocky Mountain Biologial Laboratory que me hizo sentir tan acogido.

Gracias a Claudette Moore de la Moore Literary Agency por su tremenda paciencia y perseverancia

a la hora de lograr que yo hiciera exactamente lo que yo quería hacer.

Mis dos primeros libros se publicaron con Jeff Pepper como editor de Osborne/McGraw-Hill. Jeff

apareció en el lugar oportuno y en la hora oportuna en Prentice-Hall y me ha allanado el camino y

ha hecho que ocurra todo lo que tenía que ocurrir para que ésta se convirtiera en una experiencia

de publicación agradable. Gracias, Jeff -significa mucho para mí.

Estoy especialmente en deuda con Gen Kiyooka y su compañía, Digigami, que me proporcionó gentilmente mi primer servidor web durante los muchos años iniciales de presencia en la Web. Esto

constituyó una ayuda de valor incalculable.

Gracias a Cay Hostmann (coautor de Core Java, Prentice-Hall, 2000), D'Arcy Smith (Symantec) y

Paul Tyma (coautor de Java Primer Plus, The Waite Group, 1996), por ayudarme a aclarar conceptos sobre el lenguaje.

xlviii Piensa en Java

Gracias a la gente que ha hablado en mi curso de Java en la Software Development Conference, y a

los alumnos de mis cursos, que realizan las preguntas que necesito oír para poder hacer un material más claro.

Gracias espaciales a Larry y Tina O'Brien, que me ayudaron a volcar mis seminarios en el CD ROM

original Hands-On Java. (Puede encontrarse más información en http:llwww.BruceEckel.com.)

Mucha gente me envió correcciones y estoy en deuda con todos ellos, pero envío gracias en particular a (por la primera edición): Kevin Raulerson (encontró cientos de errores enormes), Bob Resendes (simplemente increíble), John Pinto, Joe Dante, Jose Sharp (los tres son fabulosos), David

Coms (muchas correcciones gramaticales y aclaraciones), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennos P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson, y otros muchos. El profesor Marc Meurrens puso gran cantidad de

esfuerzo en publicitar y hacer disponible la versión electrónica de la primera edición del libro en

toda Europa.

Ha habido muchísimos técnicos en mi vida que se han convertido en amigos y que también han

sido, tanto influyentes, como inusuales por el hecho de que hacen yoga y practican otras formas de

ejercicio espiritual, que yo también encuentro muy instructivo e inspirador. Son Karig Borckschmidt, Gen Kiyooka y Andrea Provaglio, (que ayuda en el entendimiento de Java y en la programación general en Italia, y ahora en los Estados Unidos como un asociado del equipo MindView).

No es que me haya sorprendido mucho que entender Delphi me ayudara a entender Java, pues tienen muchas decisiones de diseño del lenguaje en común. Mis amigos de Delphi me proporcionaron

ayuda facilitándome a alcanzar profundidad en este entorno de programación tan maravilloso. Son

Marco Cantu (otro italiano -¿quizás aprender Latín es una ayuda para entender los lenguajes de

programación?), Neil Rubenking (que solía hacer yoga, era vegetariano,. . . hasta que descubrió los

computadores) y por supuesto, Zack Urlocker, un colega de hace tiempo con el que me he movido

por todo el mundo.

Las opiniones y el soporte de mi amigo Richard Hale Shaw han sido de mucha ayuda (y la de Kim

también). Richard y yo pasamos muchos meses dando seminarios juntos e intentando averiguar cuál

era la experiencia de aprendizaje perfecta desde el punto de vista de los asistentes. Gracias a KoAnn

Vikoren, Eric Faurot, Marco Pardi, y el resto de equipo y tripulación de MFI. Gracias especialmente a Tara Arrowood, que me volvió a inspirar en las posibilidades de las conferencias.

El diseño del libro, de la portada, y la foto de ésta fueron creadas por mi amigo Daniel Hill-Harris,

autor y diseñador de renombre (http:llwww.Wil-Harris.com), que solía jugar con letras de goma en

el colegio mientras esperaba a que se inventaran los computadores y los ordenadores personales, y

se quejaba de que yo siempre estuviera enmarañado con mis problemas de álgebra. Sin embargo,

he producido páginas listas para la cámara por mí mismo, por lo que los errores de tipografía son

míos. Para escribir el libro se us6 Microsoft 8 Word 97 for Windows, y para crear páginas listas para

fotografiar en Adobe Acrobat; el libro se creó directamente a partir de los ficheros Acrobat PDE

(Como un tributo a la edad electrónica, estuve fuera en las dos ocasiones en que se produjo la versión final del libro -la primera edición se envío desde Capetown, Sudáfrica, y la segunda edición se

Introducción xlix

envío desde Praga.) La tipología del cuerpo es Georgia y los títulos están en Vérdana. La tipografía

de la portada es ITC Rennie Mackintosch.

Gracias a los vendedores que crearon los compiladores. Borland, el Blackdown Group (para Linux),

y por supuesto, Sun.

Gracias especiales a todos mis profesores y alumnos (que son a su vez mis profesores). La persona

que me enseñó a escribir fue Gabrielle Rico (autora de Writing the Natural Way, Putnam, 1985).

Siempre guardaré como un tesoro aquella terrorífica semana en Esalen.

El conjunto de amigos que me han ayudado incluyen, sin ser los únicos a: Andrew Binstock, Steve

Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinckely Barr, Hill Gates de Midnight

Engineering Magazine, Larry Constantine y Lucy Lockwood, Grez Perry, Dan Putterman, Christi

Westphal, GeneWang, Dave Mayer, David Intersiomne, Andrea Rosenfield, Claire Sawyers, más italianos (Laura Fallai, Corrado, ILSA, y Cristina Guistozzi). Chris y Laura Strand, los Alrnquists, Brad

Jerbic, Marilyn Cvitanic, los Mabrys, los Haflingers, los Pollocks, Peter Vinci, las familias Rohhins,

las familias Moelter (y los McMillans), Michael Wilk, Dave Stoner, Laurie Adams, los Cranstons,

Larry Fogg, Mike y Karen Sequeiro, Gary Entsminger y Allison Brody, Kevin Donovan y Sonda Eastlack, Chester y Shannon Andersen, Joe Lordy, Dave y Brenda Bartlett, David Lee, los Rentschlers,

los Sudeks, Dick, Patty y Lee Eckel, Lynn y Todd y sus familias. Y por supuesto, papá y mamá.

Colaboradores Internet

Gracias a aquellos que me han ayudado a reescribir los ejemplos para usar la biblioteca Swing, y por

cualquier otra ayuda: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajes Jain, Ravi Manthena, Banu

Rajarnani, Jens Brandt, Mitin Shivaram, Malcolm Davis y todo el mundo que mostró su apoyo. Verdaderamente, esto me ayudó a dar el primer salto.



1: Introducción

a los objetos

La génesis de la revolución de los computadores se encontraba en una máquina,

y por ello, la génesis de nuestros lenguajes de programación tiende a parecerse

a esa máquina.

Pero los computadores, más que máquinas, pueden considerarse como herramientas que permiten

ampliar la mente ("bicicletas para la mente", como se enorgullece de decir Steve Jobs), además de

un medio de expresión inherentemente diferente. Como resultado, las herramientas empiezan a parecerse menos a máquinas y más a partes de nuestra mente, al igual que ocurre con otros medios

de expresión como la escritura, la pintura, la escultura, la animación o la filmación de películas. La

programación orientada a objetos (POO) es una parte de este movimiento dirigido a utilizar los computadores como si de un medio de expresión se tratara.

Este capítulo introducirá al lector en los conceptos básicos de la POO, incluyendo un repaso a los métodos de desarrollo. Este capítulo y todo el libro, toman como premisa que el lector ha tenido experiencia en algún lenguaje de programación procedural (por procedimientos), sea C u otro lenguaje.

Si el lector considera que necesita una preparación mayor en programación y/o en la sintaxis de C

antes de enfrentarse al presente libro, se recomienda hacer uso del CD ROM formativo Thinking in

C: Foundations for C++ and Java, que se adjunta con el presente libro, y que puede encontrarse también la URL, http://www. BruceEckel.com.

Este capítulo contiene material suplementario, o de trasfondo (background). Mucha gente no se siente cómoda cuando se enfrenta a la programación orientada a objetos si no entiende su contexto, a

grandes rasgos, previamente. Por ello, se presentan aquí numerosos conceptos con la intención de

proporcionar un repaso sólido a la POO. No obstante, también es frecuente encontrar a gente que

no acaba de comprender los conceptos hasta que tiene acceso a los mecanismos; estas personas

suelen perderse si no se les ofrece algo de código que puedan manipular. Si el lector se siente identificado con este último grupo, estará ansioso por tomar contacto con el lenguaje en sí, por lo que

debe sentirse libre de saltarse este capítulo -lo cual no tiene por qué influir en la comprensión que

finalmente se adquiera del lenguaje o en la capacidad de escribir programas en él mismo. Sin embargo, tarde o temprano tendrá necesidades ocasionales de volver aquí, para completar sus nociones en aras de lograr una mejor comprensión de la importancia de los objetos y de la necesidad de

comprender cómo acometer diseños haciendo uso de ellos.

El progreso de la abstracción

Todos los lenguajes de programación proporcionan abstracciones. Puede incluso afirmarse que la

complejidad de los problemas a resolver es directamente proporcional a la clase (tipo) y calidad de

las abstracciones a utilizar, entendiendo por tipo "clase", aquello que se desea abstraer. El lenguaje

2 Piensa en Java

ensamblador es una pequeña abstracción de la máquina subyacente. Muchos de los lenguajes denominados "imperativos" desarrollados a continuación del antes mencionado ensamblador (como

Fortran, BASIC y C) eran abstracciones a su vez del lenguaje citado. Estos lenguajes supusieron una

gran mejora sobre el lenguaje ensamblador, pero su abstracción principal aún exigía pensar en términos de la estructura del computador más que en la del problema en sí a resolver. El programador

que haga uso de estos lenguajes debe establecer una asociación entre el modelo de la máquina (dentro del "espacio de la solución", que es donde se modela el problema, por ejemplo, un computador)

y el modelo del problema que de hecho trata de resolver (en el "espacio del problema", que es donde de hecho el problema existe). El esfuerzo necesario para establecer esta correspondencia, y el

hecho de que éste no es intrínseco al lenguaje de programación, es causa directa de que sea difícil

escribir programas, y de que éstos sean caros de mantener, además de fomentar, como efecto colateral (lateral), toda una la industria de "métodos de programación".

La alternativa al modelado de la máquina es modelar el problema que se trata de resolver. Lenguajes

primitivos como LISP o APL eligen vistas parciales o particulares del mundo (considerando respectivamente que los problemas siempre se reducen a "listas" o a "algoritmos"). PROLOG convierte todos los problemas en cadenas de decisiones. Los lenguajes se han creado para programación basada en limitaciones o para programar exclusivamente mediante la manipulación de símbolos gráficos

(aunque este último caso resultó ser excesivamente restrictivo). Cada uno de estos enfoques constituyc una solución buena para determinadas clases (tipos) de problemas (aquéllos para cuya snliición fueron diseñados), pero cuando uno trata de sacarlos de su dominio resultan casi impracticables.

El enfoque orientado a objetos trata de ir más allá, proporcionando herramientas que permitan al

programador representar los elementos en el espacio del problema. Esta representación suele ser

lo suficientemente general como para evitar al programador limitarse a ningún tipo de problema específico. Nos referiremos a elementos del espacio del problema, denominando "objetos" a sus representaciones dentro del espacio de la solución (por supuesto, también serán necesarios otros objetos que no tienen su análogo dentro del espacio del problema). La idea es que el programa pueda

autoadaptarse al lingo del problema simplemente añadiendo nuevos tipos de objetos, de manera que

la mera lectura del código que describa la solución constituya la lectura de palabras que expresan

el problema. Se trata, en definitiva, de una abstracción del lenguaje mucho más flexible y potente

que cualquiera que haya existido previamente. Por consiguiente, la PO0 permite al lector describir

el problema en términos del propio problema, en vez de en términos del sistema en el que se ejecutará el programa final. Sin embargo, sigue existiendo una conexión con el computador, pues cada

objeto puede parecer en sí un pequeño computador; tiene un estado, y se le puede pedir que lleve

a cabo determinadas operaciones. No obstante, esto no quiere decir que nos encontremos ante una

mala analogía del mundo real, al contrario, los objetos del mundo real también tienen características

y comportamientos.

Algunos diseñadores de lenguajes han dado por sentado que la programación orientada a objetos,

de por sí, no es adecuada para resolver de manera sencilla todos los problemas de programación, y

hacen referencia al uso de lenguajes de programación multiparadigmal.

' N. del autor: Ver Multiparadigrn Programming in Leda, por Timothy Budd (Addison-Wesley, 1995).

1: Introducción a los objetos 3

Alan Kay resumió las cinco características básicas de Smalltalk, el primer lenguaje de programación

orientado a objetos que tuvo éxito, además de uno de los lenguajes en los que se basa Java. Estas

características constituyen un enfoque puro a la programación orientada a objetos:

Todo es un objeto. Piense en cualquier objeto como una variable: almacena datos, permite

que se le "hagan peticiones", pidiéndole que desempeñe por sí mismo determinadas operaciones, etc. En teoría, puede acogerse cualquier componente conceptual del problema a resolver (bien sean perros, edificios, servicios, etc.) y representarlos como objetos dentro de un

programa.

Un programa es un cúmulo de objetos que se dicen entre sí lo que tienen que hacer

mediante el envío de mensajes. Para hacer una petición a un objeto, basta con "enviarle un

mensaje". Más concretamente, puede considerarse que un mensaje en sí es una petición para

solicitar una llamada a una función que pertenece a un objeto en particular.

Cada objeto tiene su propia memoria, constituida por otros objetos. Dicho de otra manera, uno crea una nueva clase de objeto construyendo un paquete que contiene objetos ya

existentes. Por consiguiente, uno puede incrementar la complejidad de un programa, ocultándola tras la simplicidad de los propios objetos.

Todo objeto es de algún tipo. Cada objeto es un elemento de una clase, entendiendo por "clase" un sinónimo de "tipo". La característica más relevante de una clase la constituyen "el conjunto de mensajes que se le pueden enviar".

Todos los objetos de determinado tipo pueden recibir los mismos mensajes. Ésta es una

afirmación de enorme trascendencia como se verá más tarde. Dado que un objeto de tipo "círculo" es también un objeto de tipo "polígono", se garantiza que todos los objetos "círculo"

acepten mensajes propios de "polígono". Esto permite la escritura de código que haga referencia a polígonos, y que de manera automática pueda manejar cualquier elemento que encaje con la descripción de "polígono". Esta capacidad de suplantación es uno de los conceptos

más potentes de la POO.

Todo objeto tiene una interfaz

Aristóteles fue probablemente el primero en estudiar cuidadosamente el concepto de tipo; hablaba de "la clase de los pescados o la clase de los peces". La idea de que todos los objetos, aún

siendo únicos, son también parte de una clase de objetos, todos ellos con características y comportamientos en común, ya fue usada en el primer lenguaje orientado a objetos, Simula-67, que

ya incluye la palabra clave clase, que permite la introducción de un nuevo tipo dentro de un programa.

Simula, como su propio nombre indica, se creó para el desarrollo de simulaciones, como el clásico

del cajero de un banco, en el que hay cajero, clientes, cuentas, transacciones y unidades monetarias

-un montón de "objetos". Todos los objetos que, con excepción de su estado, son idénticos durante la ejecución de un programa se agrupan en "clases de objetos", que es precisamente de donde

proviene la palabra clave clase. La creación de tipos abstractos de datos (clases) es un concepto fun-

4 Piensa en Java

damental en la programación orientada a objetos. Los tipos abstractos de datos funcionan casi como

los tipos de datos propios del lenguaje: es posible la creación de variables de un tipo (que se denominan objetos o instancias en el dialecto propio de la orientación a objetos) y manipular estas variables (mediante el envío o recepción de mensajes; se envía un mensaje a un objeto y éste averigua que

debe hacer con él). Los miembros (elementos) de cada clase comparten algunos rasgos comunes:

toda cuenta tiene un saldo, todo cajero puede aceptar un ingreso, etc. Al mismo tiempo, cada miembro tiene su propio estado, cada cuenta tiene un saldo distinto, cada cajero tiene un nombre. Por

consiguiente, los cajeros, clientes, cuentas, transacciones, etc. también pueden ser representados

mediante una entidad única en el programa del computador. Esta entidad es el objeto, y cada objeto pertenece a una clase particular que define sus características y comportamientos.

Por tanto, aunque en la programación orientada a objetos se crean nuevos tipos de datos, virtualmente todos los lenguajes de programación orientada a objetos hacen uso de la palabra clave "clase". Siempre que aparezca la palabra clave "tipo" (type) puede sustituirse por "clase" (class) y viceversa2.

Dado que una clase describe a un conjunto de objetos con características (datos) y comportamientos (funcionalidad) idénticos, una clase es realmente un tipo de datos, porque un número en coma

flotante, por ejemplo, también tiene un conjunto de características y comportamientos. La diferencia

radica en que un programador define una clase para que encaje dentro de un problema en vez de

verse forzado a utilizar un tipo de datos existente que fue diseñado para representar una unidad de

almacenamiento en una máquina. Es posible extender el lenguaje de programación añadiendo nuevos tipos de datos específicos de las necesidades de cada problema. El sistema de programación

acepta las nuevas clases y las cuida, y' asigna las comprobaciones que da a los tipos de datos predefinidos.

El enfoque orientado a objetos no se limita a la construcción de simulaciones. Uno puede estar de

acuerdo o no con la afirmación de que todo programa es una simulación del sistema a diseñar, mientras que las técnicas de PO0 pueden reducir de manera sencilla un gran conjunto de problemas a

una solución simple.

Una vez que se establece una clase, pueden construirse tantos objetos de esa clase como se desee,

y manipularlos como si fueran elementos que existen en el problema que se trata de resolver. Sin

duda, uno de los retos de la programación orientada a objetos es crear una correspondencia uno a

uno entre los elementos del espacio del problema y los objetos en el espacio de la solución.

Pero, ¿cómo se consigue que un objeto haga un trabajo útil para el programador? Debe de haber

una forma de hacer peticiones al objeto, de manera que éste desempeñe alguna tarea, como completar una transacción, dibujar algo en la pantalla o encender un interruptor. Además, cada objeto

sólo puede satisfacer determinadas peticiones. Las peticiones que se pueden hacer a un objeto se

encuentran definidas en su interfaz, y es el tipo de objeto el que determina la interfaz. Un ejemplo

sencillo sería la representación de una bombilla:

Wgunas personas establecen una distinción entre ambos, remarcando que un tipo determina la interfaz, mientras que una clase es una implementación particular de una interfaz.

1: Introducción a los objetos 5

Tipo

lnterfaz

Luz lz = new Luz () ;

lz . encender ( ) ;

1 Luz l

La interfaz establece qm6 peticiones pueden hacerse a un objeto particular Sin embargo, debe hacer

código en algún lugar que permita satisfacer esas peticiones. Este, junto con los datos ocultos, constituye la implementación. Desde el punto de vista de un lenguaje de programación procedural, esto

no es tan complicado. Un tipo tiene una función asociada a cada posible petición, de manera que

cuando se hace una petición particular a un objeto, se invoca a esa función. Este proceso se suele

simplificar diciendo que se ha "enviado un mensaje" (hecho una petición) a un objeto, y el objeto

averigua qué debe hacer con el mensaje (ejecuta el código).

Aquí, el nombre del tipo o clase es Luz, el nombre del objeto Luz particular es lz, y las peticiones

que pueden hacerse a una Luz son encender, apagar, brillar o atenuar. Es posible crear una Luz definiendo una "referencia" (12) a ese objeto e invocando a new para pedir un nuevo objeto de ese tipo.

Para enviar un mensaje al objeto, se menta el nombre del objeto y se conecta al mensaje de petición

mediante un punto. Desde el punto de vista de un usuario de una clase predefinida, éste es el no va

más de la programación con objetos.

El diagrama anteriormente mostrado sigue el formato del Lenguaje de Modelado Unificado o

Un@ed Modeling Language (UML). Cada clase se representa mediante una caja, en la que el nombre del tipo se ubica en la parte superior, cualquier dato necesario para describirlo se coloca en la

parte central, y lasfknciones miembro (las funciones que pertenecen al objeto) en la parte inferior

de la caja. A menudo, solamente se muestran el nombre de la clase y las funciones miembro públicas en los diagramas de diseño UML, ocultando la parte central. Si únicamente interesan los nombres de las clases, tampoco es necesario mostrar la parte inferior de la caja.

La implementación oculta

Suele ser de gran utilidad descomponer el tablero de juego en creadores de clases (elementos que

crean nuevos tipos de datos) y programadores clientes3 (consumidores de clases que hacen uso de

los tipos de datos en sus aplicaciones). La meta del programador cliente es hacer uso de un gran

repertorio de clases que le permitan acometer el desarrollo de aplicaciones de manera rápida. La

Nota del autor: Término acuñado por mi amigo Scott Meyers.

6 Piensa en Java

meta del creador de clases es construir una clase que únicamente exponga lo que es necesario al

programador cliente, manteniendo oculto todo lo demás. ¿Por qué? Porque aquello que esté oculto no puede ser utilizado por el programador cliente, lo que significa que el creador de la clase

puede modificar la parte oculta a su voluntad, sin tener que preocuparse de cualquier impacto que

esta modificación pueda implicar. La parte oculta suele representar las interioridades de un objeto que podrían ser corrompidas por un programador cliente poco cuidadoso o ignorante, de

manera que mientras se mantenga oculta su implementación se reducen los errores en los programas.

En cualquier relación es importante determinar los límites relativos a todos los elementos involucrados. Al crear una biblioteca, se establece una relación con el programador cliente, que es también un programador, además de alguien que está construyendo una aplicación con las piezas que se encueriLrari e11 esta biblioteca, quizás con la intención de construir una biblioteca aún mayor.

Si todos los miembros de una clase están disponibles para todo el mundo, el programador cliente

puede hacer cualquier cosa con esa clase y no hay forma de imponer reglas. Incluso aunque prefiera que el programador cliente no pueda manipular alguno de los miembros de su clase, sin control de accesos, no hay manera de evitarlo. Todo se presenta desnudo al mundo.

Por ello, la primera razón que justifica el control de accesos es mantener las manos del programador cliente apartadas de las porciones que no deba manipular -partes que son necesarias para las

maquinaciones internas de los tipos de datos pero que no forman parte de la interfaz que los usuarios necesitan en aras de resolver sus problemas particulares. De hecho, éste es un servicio a los

usuarios que pueden así ver de manera sencilla aquello que es sencillo para ellos, y qué es lo que

pueden ignorar.

La segunda razón para un control de accesos es permitir al diseñador de bibliotecas cambiar el funcionamiento interno de la clase sin tener que preocuparse sobre cómo afectará al programador

cliente. Por ejemplo, uno puede implementar una clase particular de manera sencilla para simplificar el desarrollo y posteriormente descubrir que tiene la necesidad de reescribirla para que se ejecute más rápidamente. Si tanto la interfaz como la implementación están claramente separadas y

protegidas, esto puede ser acometido de manera sencilla.

Java usa tres palabras clave explícitas para establecer los límites en una clase: public, private y protected. Su uso y significado son bastante evidentes. Estos mod$cadores de acceso determinan quién

puede usar las definiciones a las que preceden. La palabra public significa que las definiciones

siguientes están disponibles para todo el mundo. El término private, por otro lado, significa que

nadie excepto el creador del tipo puede acceder a esas definiciones. Así, private es un muro de ladrillos entre el creador y el programador cliente. Si alguien trata de acceder a un miembro private,

obtendrá un error en tiempo de compilación. La palabra clave protected actúa como private, con

la excepción de que una clase heredada tiene acceso a miembros protected pero no a los private.

La herencia será definida algo más adelante.

Java también tiene un "acceso por defecto", que se utiliza cuando no se especifica ninguna de las palabras clave descritas en el párrafo anterior. Este modo de acceso se suele denominar "amistoso" o

friendly porque implica que las clases pueden acceder a los miembros amigos de otras clases que

1 : Introducción a los objetos 7

estén en el mismo package o paquete, sin embargo, fuera del paquete, estos miembros amigos se

convierten en private.

Una vez que se ha creado y probado una clase, debería (idealmente) representar una unidad útil de

código. Resulta que esta reutilización no es siempre tan fácil de lograr como a muchos les gustaría;

producir un buen diseño suele exigir experiencia y una visión profunda de la problemática. Pero si

se logra un diseño bueno, parece suplicar ser reutilizado. La reutilización de código es una de las

mayores ventajas que proporcionan los lenguajes de programación orientados a objetos.

La manera más simple de reutilizar una clase es simplemente usar un objeto de esa clase directamente, pero también es posible ubicar un objeto de esa clase dentro de otra clase. Esto es

lo que se denomina la "creación de un objeto miembro ". La nueva clase puede construirse a

partir de un número indefinido de otros objetos, de igual o distinto tipo, en cualquier combinación necesaria para lograr la funcionalidad deseada dentro de la nueva clase. Dado que uno está

construyendo una nueva clase a partir de otras ya existentes, a este concepto se le denomina

composición (o, de forma más general, agregación). La composición se suele representar mediante una relación "es-parte-de", como en "el motor es una parte de un coche" ( "carro" en

Latinoamérica).

(Este diagrama UML indica la composición, y el rombo relleno indica que hay un coche.

Normalmente, lo representaré simplemente mediante una línea, sin el diamante, para indicar una

asociación4.)

La composición conlleva una gran carga de flexibilidad. Los objetos miembros de la nueva clase suelen ser privados, haciéndolos inaccesibles a los programadores cliente que hagan uso de la clase.

Esto permite cambiar los miembros sin que ello afecte al código cliente ya existente. También es

posible cambiar los objetos miembros en tiempo de ejecución, para así cambiar de manera dinámica el comportamiento de un programa. La herencia, que se describe a continuación, no tiene esta

flexibilidad, pues el compilador debe emplazar restricciones de tiempo de compilación en las clases

que se creen mediante la herencia.

Dado que la herencia es tan importante en la programación orientada a objetos, casi siempre se enfatiza mucho su uso, de manera que un programador novato puede llegar a pensar que hay que ha-

"ste ya suele ser un nivel de detalle suficiente para la gran mayoría de diagramas, de manera que no es necesario indicar de ma- nera explícita si se está utilizando agregación o composición.

8 Piensa en Java

cer uso de la misma en todas partes. Este pensamiento puede provocar que se elaboren diseños

poco elegantes y desmesuradamente complicados. Por el contrario, primero sería recomendable intentar hacer uso de la composición, mucho más simple y sencilla. Siguiendo esta filosofía se lograrán diseños mucho más limpios. Una vez que se tiene cierto nivel de experiencia, la detección de

los casos que precisan de la herencia se convierte en obvia.

Herencia: reutilizar interfaz

Por sí misma, la idea de objeto es una herramienta más que buena. Permite empaquetar datos y funcionalidad juntos por concepto, de manera que es posible representar cualquier idea del espacio del

problema en vez de verse forzado a utilizar idiomas propios de la máquina subyacente. Estos conceptos se expresan como las unidades fundamentales del lenguaje de programación haciendo uso

de la palabra clave class.

Parece una pena, sin embargo, acometer todo el problema para crear una clase y posteriormente

verse forzado a crear una nueva que podría tener una funcionalidad similar. Sería mejor si pudiéramos hacer uso de una clase ya existente, clonarla, y después hacer al "clon" las adiciones y modificaciones que sean necesarias. Efectivamente, esto se logra mediante la herencia, con la excepción

de que si se cambia la clase original (denominada la clase base, clase super o clase padre), el "clon"

modificado (denominado clase derivada, clase heredada, subclase o clase hijo) también reflejaría esos

cambios.

E Derivada

(La flecha de este diagrama UML apunta de la clase derivada a la clase base. Como se verá, puede

haber más de una clase derivada.)

Un tipo hace más que definir los limites de un conjunto de objetos; también tiene relaciones con

otros tipos. Dos tipos pueden tener características y comportamientos en común, pero un tipo puede contener más características que otro y también puede manipular más mensajes (o gestionarlos

de manera distinta). La herencia expresa esta semejanza entre tipos haciendo uso del concepto de

tipos base y tipos derivados. Un tipo base contiene todas las características y comportamientos que

comparten los tipos que de él se derivan. A partir del tipo base, es posible derivar otros tipos para

expresar las distintas maneras de llevar a cabo esta idea.

1 : Introducción a los objetos 9

Por ejemplo, una máquina de reciclaje de basura clasifica los desperdicios. El tipo base es "basura",

y cada desperdicio tiene su propio peso, valor, etc. y puede ser fragmentado, derretido o descompuesto. Así, se derivan tipos de basura más específicos que pueden tener características adicionales

(una botella tiene un color), o comportamientos (el aluminio se puede modelar, una lata de acero

tiene capacidades magnéticas). Además, algunos comportamientos pueden ser distintos (el valor del

papel depende de su tipo y condición). El uso de la herencia permite construir una jerarquía de tipos que expresa el problema que se trata de resolver en términos de los propios tipos.

Un segundo ejemplo es el clásico de la "figura geométrica" utilizada generalmente en sistemas de

diseño por computador o en simulaciones de juegos. El tipo base es "figura" y cada una de ellas tiene un tamaño, color, posición, etc. Cada figura puede dibujarse, borrarse, moverse, colorearse, etc.

A partir de ésta, se pueden derivar (heredar) figuras específicas: círculos, cuadrados, triángulos,

etc., pudiendo tener cada uno de los cuales características y comportamientos adicionales. Algunos

comportamientos pueden ser distintos, como pudiera ser el cálculo del área de los distintos tipos de

figuras. La jerarquía de tipos engloba tanto las similitudes como las diferencias entre las figuras.

1 Figura l

1 Círculo 1 1 Cuadrado " Triánguio 1

Representar la solución en los mismos términos que el problema es tremendamente beneficioso

puesto que no es necesario hacer uso de innumerables modelos intermedios para transformar una

descripción del problema en una descripción de la solución. Con los objetos, el modelo principal lo

constituye la jerarquía de tipos, de manera que se puede ir directamente de la descripción del sistema en el mundo real a la descripción del sistema en código. Sin duda, una de las dificultades que

tiene la gente con el diseño orientado a objetos es la facilidad con que se llega desde el principio al

final: las mentes entrenadas para buscar soluciones completas suelen verse aturdidas inicialmente

por esta simplicidad.

Al heredar a partir de un tipo existente, se crea un nuevo tipo. Este nuevo tipo contiene no sólo los

miembros del tipo existente (aunque los datos privados "private" están ocultos e inaccesibles) sino

lo que es más importante, duplica la interfaz de la clase base. Es decir, todos los mensajes que pueden ser enviados a objetos de la clase base también pueden enviarse a los objetos de la clase derivada. Dado que sabemos el tipo de una clase en base a los mensajes que se le pueden enviar, la cla-

10 Piensa en Java

se derivada es del mismo tipo que la clase base. Así, en el ejemplo anterior, "un círculo en una figura". Esta equivalencia de tipos vía herencia es una de las pasarelas fundamentales que conducen al

entendimiento del significado de la programación orientada a objetos.

Dado que, tanto la clase base como la derivada tienen la misma interfaz, debe haber alguna implementación que vaya junto con la interfaz. Es decir, debe haber algún código a ejecutar cuando un

objeto recibe un mensaje en particular. Si simplemente se hereda la clase sin hacer nada más, los

métodos de la interfaz de la clase base se trasladan directamente a la clase derivada. Esto significa

que los objetos de la clase derivada no sólo tienen el mismo tipo sino que tienen el mismo comportamiento, aunque este hecho no es particularmente interesante.

Hay dos formas de diferenciar una clase nueva derivada de la clase base original. El primero es bastante evidente: se añaden nuevas funciones a la clase derivada. Estas funciones nuevas no forman

parte de la interfaz de la clase base, lo que significa que la clase base simplemente no hacía todo lo

que ahora se deseaba, por lo que fue necesario añadir nuevas funciones. Ese uso simple y primitivo

rle la herencia es, en ocasiones, la solución perfecta a los problemas. Sin embargo, debería considerarse detenidamente la posibilidad de que la clase base llegue también a necesitar estas funciones adicionales. Este proceso iterativo y de descubrimiento de su diseño es bastante frecuente en la

programación orientada a objetos.

Figura r-7

dibujar ()

borrar ()

getColor ()

setColor ()

El Círculo 1 Cuadrado 1 m Triángulo

Girarvertical ()

GirarHorizontal ()

Aunque la herencia puede implicar en ocasiones (especialmente en Java, donde la palabra clave que

hace referencia a la misma es extends) que se van a añadir funcionalidades a una interfaz, esto no

tiene por qué ser siempre así. La segunda y probablemente más importante manera de diferenciar

una nueva clase es variar el comportamiento de una función ya existente en la clase base. A esto se

le llama redefinición5 (anulación o superposición) de la función.

Para redefinir una función simplemente se crea una nueva definición de la función dentro de la clase derivada. De esta manera puede decirse que "se está utilizando la misma función de la interfaz

pero se desea que se comporte de manera distinta dentro del nuevo tipo".

' En el original ouerriding (N. del T.).

1: Introducción a los objetos 11

Figura

dibujar ()

borrar ()

getColor ()

setColor ()

m Círculo

dibujar ()

borrar () 1

I I Triángulo

dibujar () 1 1 dibujar () 1

borrar () 1 1 borrar ()

La relación es-un frente a la relación

es-como-un

Es habitual que la herencia suscite un pequeño debate: ¿debería la herencia superponer sólo las

funciones de la clase base (sin añadir nuevas funciones miembro que no se encuentren en ésta)?

Esto significaría que el tipo derivado sea exactamente el mismo tipo que el de la clase base, puesto que tendría exactamente la misma interfaz. Consecuentemente, es posible sustituir un objeto

de la clase derivada por otro de la clase base. A esto se le puede considerar sustitución pura, y a

menudo se le llama el principio de sustitución. De cierta forma, ésta es la manera ideal de tratar

la herencia. Habitualmente, a la relación entre la clase base y sus derivadas que sigue esta filosofía se le denomina relación es-un, pues es posible decir que "un círculo es un polígono". Una manera de probar la herencia es determinar si es posible aplicar la relación es-un a las clases en liza,

y tiene sentido.

Hay veces en las que es necesario añadir nuevos elementos a la interfaz del tipo derivado, extendiendo así la interfaz y creando un nuevo tipo. Éste puede ser también sustituido por el tipo base, pero la

sustitución no es perfecta pues las nuevas funciones no serían accesibles desde el tipo base. Esta relación puede describirse como la relación es-como-un" el nuevo tipo tiene la interfaz del viejo pero además contiene otras funciones, así que no se puede decir que sean exactamente iguales. Considérese

por ejemplo un acondicionador de aire. Supongamos que una casa está cableada y tiene las botoneras

para refrescarla, es decir, tiene una interfaz que permite controlar la temperatura. Imagínese que se

estropea el acondicionador de aire y se reemplaza por una bomba de calor que puede tanto enfriar

como calentar. La bomba de calor es-como-un acondicionador de aire, pero puede hacer más funciones.

Dado que el sistema de corilrol de la casa está diseñado exclusivamenle para controlar el enfriado, se

encuentra restringido a la comunicación con la parte "enfriadora" del nuevo objeto. Es necesario cxtender la interfaz del nuevo objeto, y el sistema existente únicamente conoce la interfaz original.

Término acuñado por el autor.

12 Piensa en Java

1 Termostato 1 ~ontrola I Sistema de enfriado

1 enfriar O 1

1 Acondicionador de aire / 1 Bomba de Calor

enfriar ()

Por supuesto, una vez que uno ve este diseño, está claro que la clase base "sistema de enfriado" no

es lo suficientemente general, y debería renombrarse a "sistema de control de temperatura" de manera que también pueda incluir calentamiento -punto en el que el principio de sustitución funcionará. Sin embargo, este diagrama es un ejemplo de lo que puede ocurrir en el diseño y en el mundo real.

Cuando se ve el principio de sustitución es fácil sentir que este principio (la sustitución pura) es la

única manera de hacer las cosas, y de hecho, es bueno para los diseños que funcionen así. Pero hay

veces que está claro que hay que añadir nuevas funciones a la interfaz de la clase derivada. Con la

experiencia, ambos casos irán pareciendo obvios.

Objetos intercambiables con

polimorfismo

Al tratar con las jerarquías de tipos, a menudo se desea tratar un objeto no como el tipo específico

del que es, sino como su tipo base. Esto permite escribir código que no depende de tipos específicos.

En el ejemplo de los polígonos, las funciones manipulan polígonos genéricos sin que importe si son

círculos, cuadrados, triángulos o cualquier otro polígono que no haya sido aún definido. Todos los polígono~ pueden dibujarse, borrarse y moverse, por lo que estas funciones simplemente envían un

mensaje a un objeto polígono; no se preocupan de qué base hace este objeto con el mensaje.

Este tipo de código no se ve afectado por la adición de nuevos tipos, y esta adición es la manera más

común de extender un programa orientado a objetos para que sea capaz de manejar nuevas situaciones. Por ejemplo, es posible derivar un nuevo subtipo de un polígono denominado pentágono sin

tener que modificar las funciones que solamente manipulan polígonos genéricos. Esta capacidad

para extender un programa de manera sencilla derivando nuevos subtipos es importante, ya que mejora considerablemente los diseños a la vez que reduce el coste del mantenimiento de software.

Sin embargo, hay un problema a la hora dc tratar los objetos de tipos derivados como sus tipos base

genéricos (los círculos como polígonos, las bicicletas como vehículos, los cormoranes como pájaros,

etc.). Si una función va a decir a un polígono genérico que la dibuje, o a un vehículo genérico que

se engrane, o a un pájaro genérico que se mueva, el compilador no puede determinar en tiempo de

1: Introducción a los objetos 13

compilación con exactitud qué fragmento de código se ejecutará. Éste es el punto clave -cuando

se envía el mensaje, el programador no quiere saber qué fragmento de código se ejecutará; la función dibujar se puede aplicar de manera idéntica a un círculo, un cuadrado o un triángulo, y el objeto ejecutará el código correcto en función de su tipo específico. Si no es necesario saber qué fragmento de código se ejecutará, al añadir un nuevo subtipo, el código que ejecute puede ser diferente

sin necesidad de modificar la llamada a la función. Por consiguiente, el compilador no puede saber

exactamente qué fragmento de código se está ejecutando, ¿y qué es entonces lo que hace? Por ejemplo, en el diagrama siguiente, el objeto ControlaPájaros trabaja con objetos Pájaro genéricos, y no

sabe exactamente de qué tipo son. Esto es conveniente para la perspectiva de ControlaPájaros

pues no tiene que escribir código especial para determinar el tipo exacto de Pájaro con el que está

trabajando, ni el comportamiento de ese Pájaro. Entonces, ¿cómo es que cuando se invoca a mover() ignorando el tipo específico de Pájaro se dará el comportamiento correcto (un Ganso corre,

vuela o nada,

7

y un Pingüino corre o nada)?

?,Qué pasa al invocar a

F mover ()

l Ganso 1 1 Pingüino l I I

mover () 1 1 mover ()

La respuesta es una de las principales novedades en la programación orientada a objetos: el compilador iiu pudc liaccr uria llarriada a furiciúri eri el serilido lradicio~ial. La llarriada a íurici0ri generada por un compilador no-PO0 hace lo que se denomina una ligadura temprana, un término que puede que el lector no haya visto antes porque nunca pensó que se pudiera hacer de otra forma. Esto

significa que el compilador genera una llamada a una función con nombre específico, y el montador

resuelve esta llamada a la dirección absoluta del código a ejecutar. En POO, el programa no puede

determinar la dirección del código hasta tiempo de ejecución, por lo que es necesario otro esquema

cuando se envía un mensaje a un objeto genérico.

Para resolver el problema, los lenguajes orientados a objetos usan el concepto de ligadura tardía. Al

enviar un mensaje a un objeto, no se determina el código invocado hasta tiempo de ejecución. El

cornpilador se asegura de que la luriciím exisla y hace la comprobación de tipos de los argumentos

y del valor de retorno (un lenguaje en el que esto no se haga así se dice que es débilmente tipificado), pero se desconoce el código exacto a ejecutar.

Para llevar a cabo la ligadura tardía, Java utiliza un fragmento de código especial en vez de la llamada absoluta. Este código calcula la dirección del cuerpo de la función utilizando información almacenada en el objeto (este proceso se relata con detalle en el Capítulo 7). Por consiguiente, cada

objeto puede comportarse de manera distinta en función de los contenidos de ese fragmento de có-

14 Piensa en Java

digo especial. Cuando se envía un mensaje a un objeto, éste, de hecho, averigua qué es lo que debe

hacer con ese mensaje.

En algunos lenguajes (C++ en particular) debe establecerse explícitamente que se desea que una

función tenga la flexibilidad de las propiedades de la ligadura tardía. En estos lenguajes, por defecto, la correspondencia con las funciones miembro no se establece dinámicamente, por lo que es necesario recordar que hay que añadir ciertas palabras clave extra para lograr el polimorfismo.

Considérese el ejemplo de los polígonos. La familia de clases (todas ellas basadas en la misma interfaz uniforme) ya fue representada anteriormente en este capítulo. Para demostrar el polimorfismo, se escribirá un único fragmento de código que ignora los detalles específicos de tipo y solamente hace referencia a la clase base. El código está desvinculado de información específica del tipo,

y por consiguiente es más fácil de escribir y entender. Y si se añade un nuevo tipo -por ejemplo un

Hexágono- mediante herencia, el código que se escriba trabajará tan perfectamente con el nuevo

Polígono como lo hacia con los tipos ya exisle~iles, y por- curisiguiente, el programa es arrzpliable.

Si se escribe un método en Java (y pronto aprenderá el lector a hacerlo):

void hacerAlgo (Poligono p) {

p. borrar () ;

// ...

p.dibujar () ;

1

Esta función se entiende con cualquier Polígono, y por tanto, es independiente del tipo específico

de objeto que esté dibujando y borrando. En cualquier otro fragmento del programa se puede usar

la función hacerAlgo( ) :

Circulo c = new Circulo() ;

Triangulo t = new Triangulo () ;

Linea 1 = new Linea () ;

hacerAlgo (c) ;

hacerAlgo (t) ;

hacerAlgo (1) ;

Las llamadas a hacerAlgo( ) trabajan correctamente, independientemente del tipo de objeto.

De hecho, éste es un truco bastante divertido. Considérese la línea:

Lo que está ocurriendo es que se está pasando un Círculo a una función que espera un Polígono.

Como un Círculo es un Polígono, puede ser tratado como tal por hacerAlgo(). Es decir, cualquier

mensaje que hacerAigo() pueda enviar a un Polígono, también podrá aceptarlo un Círculo. Por

tanto, obrar así es algo totalmente seguro y lógico.

A este proceso de tratar un tipo derivado como si fuera el tipo base se le llama conversión de tipos

(moldeado) hacia arriba7. El nombre moldear (cast) se utiliza en el sentído de moldear (convertir) un

' En el original inglés, casting.

1: Introducción a los objetos 15

molde, y es hacia arriba siguiendo la manera en que se representa en los diagramas la herencia, con

el tipo base en la parte superior y las derivadas colgando hacia abajo. Por consiguiente, hacer un moldeado (casting) a la clase base es moverse hacia arriba por el diagrama de herencias: moldeado hacia

arriba.

Un programa orientado a objetos siempre tiene algún moldeado hacia arriba pues ésta es la manera de desvincularse de tener que conocer el tipo exacto con que se trabaja en cada instante. Si se

echa un vistazo al código de hacerAlgo() :

Obsérvese que no se dice "caso de ser un Círculo, hacer esto; caso de ser un Cuadrado, hacer esto

otro, etc.". Si se escribe código que compruebe todos los tipos posibles que puede ser un Polígono,

el tipo de código se complica, además de hacerse necesario modificarlo cada vez que se añade un

nuevo tipo de Polígono. Aquí, simplemente se dice que "en el caso de los polígonos, se sabe que es

posible aplicarles las operaciones de borrar() y dibujar(), eso sí, teniendo en cuenta todos los detalles de manera correcta".

Lo que más llama la atención del código de hacerAlgo() es que, de alguna manera, se hace lo correcto. Invocar a dibujar() para Círculo hace algo distinto que invocar a dibujar() para Cuadrado o

Iínea, pero cuando se envía el mensaje dibujar() a un Polígono anónimo, se da el comportamiento

correcto basándose en el tipo actual de Polígono. Esto es sorprendente porque, como se mencionó

anteriormente, cuando el compilador de Java está compilando el código de hacerAlgo(), no puede saber exactamente qué tipos está manipulando. Por ello, generalmente, se espera que acabe invocando

a la versión de borrar() y dibujar() de la clase base Polígono y no a las específicas de Círculo,

Cuadrado y Iánea. Y sigue ocurriendo lo correcto por el polimorfismo. El compilador y el sistema de

tiempo real se hacen cargo de los detalles; todo lo que hace falta saber es qué ocurre, y lo que es más

importante, cómo diseñar haciendo uso de ello. Al enviar un mensaje a un objeto, el objeto hará lo correcto, incluso cuando se vea involucrado el moldeado hacia arriba.

Clases base abstractas e interfaces

A menudo es deseable que la clase base únicamente presente una interfaz para sus clases derivadas.

Es decir, no se desea que nadie cree objetos de la clase base, sino que sólo se hagan moldeados ha-

16 Piensa en Java

cia arriba de la misma de manera que se pueda usar su interfaz. Esto se logra convirtiendo esa clase en abstracta usando la palabra clave abstract. Si alguien trata de construir un objeto de una clase abstracta el compilador lo evita. Esto es una herramienta para fortalecer determinados diseños.

También es posible utilizar la palabra clave abstract para describir un método que no ha sido aún

implementado -indicando "he aquí una función interfaz para todos los tipos que se hereden de esta

clase, pero hasta la fecha no existe una implementación de la misma". Se puede crear un método

abstracto sólo dentro de una clase abstracta. Cuando se hereda la clase, debe implementarse el método o de lo contrario también la clase heredada se convierte en abstracta. La creación de métodos

abstractos permite poner un método en una interfaz sin verse forzado a proporcionar un fragmento de código, posiblemente sin significado, para ese método.

La palabra clave interface toma el concepto de clase abstracta un paso más allá, evitando totalmente las definiciones de funciones. La interfaz es una herramienta muy útil y utilizada, ya que proporcionar la separación perfecta entre interfaz e implementación. Además. si se desea. es posible

combinar muchos elementos juntos mientras que no es posible heredar de múltiples clases normales o abstractas.

Localización de objetos y longevidad

Técnicamente, la PO0 consiste simplemente en tipos de datos abstractos, herencia y polimorfismo,

aunque también hay otros aspectos no menos importantes. El resto de esta sección trata de analizar esos aspectos.

Uno de los factores más importantes es la manera de crear y destruir objetos. ¿Dónde están los datos de un objeto y cómo se controla su longevidad (tiempo de vida)? En este punto hay varias filosofías de trabajo. En C++ el enfoque principal es el control de la eficiencia, proporcionando una alternativa al programador. Para lograr un tiempo de ejecución óptimo, es posible determinar el

espacio de almacenamiento y la longevidad en tiempo de programación, ubicando los objetos en la

pila (creando las variables scoped o automatic) o en el área de almacenamiento estático. De esta manera se prioriza la velocidad de la asignación y liberación de espacio de almacenamiento, cuyo control puede ser de gran valor en determinadas situaciones. Sin embargo, se sacrifica en flexibilidad

puesto que es necesario conocer la cantidad exacta de objetos, además de su longevidad y su tipo,

mientras se escribe el programa. Si se está tratando de resolver un problema más general como un

diseño asistido por computador, la gestión de un almacén o el control de tráfico aéreo, este enfoque

resulta demasiado restrictivo.

El segundo enfoque es crear objetos dinámicamente en un espacio de memoria denominado el montículo o montón (heap). En este enfoque, no es necesario conocer hasta tiempo de ejecución el numero de objetos necesario, cuál es su longevidad o a qué tipo exacto pertenecen. Estos aspectos se

deter-minar-án justo en el preciso momento en que se ejecute el programa. Si se necesita un nuevo ob

jeto, simplemente se construye en el montículo en el instante en que sea necesario. Dado que el almacenamiento se gestiona dinámicamente, en tiempo de ejecución, la cantidad de tiempo necesaria

1: Introducción a los objetos 17

para asignar espacio de almacenamiento en el montículo es bastante mayor que el tiempo necesario

para asignar espacio a la pila. (La creación de espacio en la pila suele consistir simplemente en una

instrucción al ensamblador que mueve hacia abajo el puntero de pila, y otra para moverlo de nuevo

hacia arriba.) El enfoque dinámico provoca generalmente el pensamiento lógico de que los objetos

tienden a ser complicados, por lo que la sobrecarga debida a la localización de espacio de almacenamiento y su liberación no deberían tener un impacto significativo en la creación del objeto. Es más,

esta mayor flexibilidad es esencial para resolver en general el problema de programación.

Java utiliza exclusivamente el segundo enfoque8. Cada vez que se desea crear un objeto se usa la palabra clave new para construir una instancia dinámica de ese objeto.

Hay otro aspecto, sin embargo, a considerar: la longevidad de un objeto. Con los lenguajes que permiten la creación de objetos en la pila, el compilador determina cuánto dura cada objeto y puede destruirlo cuando no es necesario. Sin embargo, si se crea en el montículo, el compilador no tiene conocimiento alguno sobre su longevidad. En un lenguaje como C++ hay que determinar en tiempo de

programación cuándo destruir el objeto, lo cual puede conducir a fallos de memoria si no se hace de

manera correcta & este problema es bastante común en los programas en C++). Java proporciona un

recolector de basura que descubre automáticamente cuándo se ha dejado de utilizar un objeto, que

puede, por consiguiente, ser destruido. Un recolector de basura es muy conveniente, al reducir el número de aspectos a tener en cuenta, así como la cantidad de código a escribir. Y lo que es más importante, el recolector de basura proporciona un nivel de seguridad mucho mayor contra el problema

de los fallos de memoria (que ha hecho abandonar más de un proyecto en Ctt).

El resto de esta sección se centra en factores adicionales relativos a la longevidad de los objetos y

su localización.

Colecciones e iteradores

Si se desconoce el número de objetos necesarios para resolver un problema en concreto o cuánto

deben durar, también se desconocerá cómo almacenar esos objetos. ¿Cómo se puede saber el espacio a reservar para los mismos? De hecho, no se puede, pues esa información se desconocerá hasta tiempo de ejecución.

La solución a la mayoría de problemas de diseño en la orientación a objetos parece sorprendente: se

crea otro tipo de objeto. El nuevo tipo de objeto que resuelve este problema particular tiene referencias a otros objetos. Por supuesto, es posible hacer lo mismo con un array, disponible en la mayoría

de lenguajes. Pero hay más. Este nuevo objeto, generalmente llamado contenedor (llamado también colección, pero la biblioteca de Java usa este término con un sentido distinto así que este libro empleará

la palabra "contenedor"), se expandirá a sí mismo cuando sea necesario para albergar cuanto se coloque dentro del contenedor. Simplemente se crea el objeto contenedor, y él se encarga de los detalles.

Afortunadamente, un buen lenguaje PO0 viene con un conjunto de contenedores como parte del

propio lenguaje. En C++, es parte de la Biblioteca Estándar C++ (Standard C++ Library), que en oca-

' Los tipos primitivos, de los que se hablará más adelante, son un caso especial.

18 Piensa en Java

siones se denomina la Standard Template Library, Biblioteca de plantillas estándar, (STL). Object

Pascal tiene contenedores en su Visual Component Library (VCL). Smalltalk tiene un conjunto de

contenedores muy completo, y Java también tiene contenedores en su biblioteca estándar. En algunas bibliotecas, se considera que un contenedor genérico es lo suficientemente bueno para todas las

necesidades, mientras que en otras (como en Java, por ejemplo) la biblioteca tiene distintos tipos de

contenedores para distintas necesidades: un vector (denominado en Java ArrayList) para acceso

consistente a todos los elementos, y una lista enlazada para inserciones consistentes en todos los

elementos, por ejemplo, con lo que es posible elegir el tipo particular que satisface las necesidades

de cada momento. Las bibliotecas de contenedores también suelen incluir conjuntos, colas, tablas

de hasing, árboles, pilas, etc.

Todos los contenedores tienen alguna manera de introducir y extraer cosas; suele haber funciones para

añadir elementos a un contenedor, y otras para extraer de nuevo esos elementos. Pero sacar los elementos puede ser más problemático porque una función de selección única suele ser restrictiva. ¿Qué

ocurre si se desea manipular o comparar un conjunto de eleinerilos del co~ite~iedor y no u~io sdo?

La solución es un iterador, que es un objeto cuyo trabajo es seleccionar los elementos de dentro de un

contenedor y presentárselos al usuario del iterador. Como clase, también proporciona cierto nivel de

abstracción. Esta abstracción puede ser usada para separar los detalles del contenedor del código al

que éste está accediendo. El contenedor, a través del iterador, se llega a abstraer hasta convertirse en

una simple secuencia, que puede ser recorrida gracias al iterador sin tener que preocuparse de la estructura subyacente -es decir, sin preocuparse de si es un ArrayLBst (lista de arrays), un LinkedList

(lista enlazado), un Stack, (pila) u otra cosa. Esto proporciona la flexibilidad de cambiar fácilmente la

estructura de datos subyacente sin que el código de un programa se vea afectado. Java comenzó (en

las versiones 1.0 y 1.1) con un iterador estándar denominado Enumeration, para todas sus clases contenedor. Java 2 ha añadido una biblioteca mucho más completa de contenedores que contiene un iterador denominado Iterator mucho más potente que el antiguo Enumeration.

Desde el punto de vista del diseño, todo lo realmente necesario es una secuencia que puede ser manipulada en aras de resolver un problema. Si una secuencia de un sólo tipo satisface todas las necesidades de un problema, entonces no es necesario hacer uso de distintos tipos. Hay dos razones

por las que es necesaria una selección de contenedores. En primer lugar, los contenedores proporcionan distintos tipos de interfaces y comportamientos externos. Una pila tiene una interfaz y un

comportamiento distintos del de las colas, que son a su vez distintas de los conjuntos y las listas.

Cualquiera de éstos podría proporcionar una solución mucho más flexible a un problema. En segundo lugar, distintos contenedores tienen distintas eficiencias en función de las operaciones. El mejor ejemplo está en ArrayList y LinkedList. Ambos son secuencias sencillas que pueden tener interfaces y comportamientos externos idénticos. Pero determinadas operaciones pueden tener

costes radicalmente distintos. Los accesos aleatorios a ArrayList tienen tiempos de acceso constante; se invierte el mismo tiempo independientemente del elemento seleccionado. Sin embargo, en

una LinkedList moverse de elemento en elemento a lo largo de la lista para seleccionar uno al azar

es altamente costoso, y es necesario muchísimo más tiempo para localizar un elemento cuanto más

adelante se encuentre. Por otro lado, si se desea insertar un elemento en el medio de una secuencia, es mucho menos costoso hacerlo en un LinkedList quc cn un ArrayList. Esta y otras opera

ciones tienen eficiencias distintas en función de la estructura de la secuencia subyacente. En la fase

de diseño, podría comenzarse con una LinkedList y, al primar el rendimiento, cambiar a un

1: Introducción a los objetos 19

ArrayList. Dado que la abstracción se lleva a cabo a través de iteradores, es posible cambiar de uno

a otro con un impacto mínimo en el código.

Finalmente, debe recordarse que un contenedor es sólo un espacio de almacenamiento en el que colocar objetos. Si este espacio resuelve todas las necesidades, no importa realmente cómo está implementado (concepto compartido con la mayoría de tipos de objetos). Si se está trabajando en un

entorno de programación que tiene una sobrecarga inherente debido a otros factores, la diferencia

de costes entre ArrayList y LinkedList podría no importar. Con un único tipo de secuencia podría

valer. Incluso es posible imaginar la abstracción contenedora "perfecta", que pueda cambiar su implementación subyacente automáticamente en función de su uso.

La jerarquía de raíz Única

Uno de los aspectos de la PO0 que se ha convertido especialmente prominente desde la irrupción

de C++ es si todas las clases en última instancia deberían ser heredadas de una única clase base. En

Java (como virtualmente en todos los lenguajes PO0 ) la respuesta es "sí" y el nombre de esta última clase base es simplemente Object. Resulta que los beneficios de una jerarquía de raíz única son

enormes.

Todos los objetos en una jerarquía de raíz única tienen una interfaz en común, por lo que en última

instancia son del mismo tipo. La alternativa (proporcionada por C++) es el desconocimiento de que

todo pertenece al mismo tipo fundamental. Desde el punto de vista de la retrocompatibilidad, esto

encaja en el modelo de C mejor, y puede pensarse que es menos restrictivo, pero cuando se desea

hacer programación orientada a objetos pura, es necesario proporcionar una jerarquía completa para

lograr el mismo nivel de conveniencia intrínseco a otros lenguajes POO. Y en cualquier nueva biblioteca de clases que se adquiera, se utilizará alguna interfaz incompatible. Hacer funcionar esta

nueva interfaz en un diseño lleva un gran esfuerzo (y posiblemente herencia múltiple). Así que ¿merece la pena la "flexibilidad" extra de C++? Si se necesita -si se dispone de una gran cantidad de

código en C- es más que valiosa. Si se empieza de cero, otras alternativas, como Java, resultarán

mucho más productivas.

Puede garantizarse que todos los objetos de una jerarquía de raíz única (como la proporcionada por

Java) tienen cierta funcionalidad. Se sabe que es posible llevar a cabo ciertas operaciones básicas

con todos los objetos del sistema. Una jerarquía de raíz única, junto con la creación de todos los objetos en el montículo, simplifica enormemente el paso de argumentos (uno de los temas más complicados de C++).

Una jerarquía de raíz única simplifica muchísimo la implementación de un recolector de basura (incluido en Java). El soporte necesario para el mismo puede instalarse en la clase base, y el recolector de basura podrá así enviar los mensajes apropiados a todos los objetos del sistema. Si no existiera este tipo de jerarquía rii la posibilidad de rriariipular un objeto a través de reierencias, sería muy

dificil implementar un recolector de basura.

Dado que está garantizado que en tiempo de ejecución la información de tipos está en todos los objetos, jamás será posible encontrar un objeto cuyo tipo no pueda ser determinado. Esto es especial-

20 Piensa en Java

mente importante con operaciones a nivel de sistema, tales como el manejo de excepciones, además

de proporcionar una gran flexibilidad a la hora de programar.

Bibliotecas de colecciones y soporte al fácil

manejo de coIecciones

Dado que un contenedor es una herramienta de uso frecuente, tiene sentido tener una biblioteca de

contenedores construidos para ser reutilizados, de manera que se puede elegir uno de la estantería

y enchufarlo en un programa determinado. Java proporciona una biblioteca de este tipo, que satisface la gran mayoría de necesidades.

Moldeado hacia abajo frente a plantillas/genéricos

Yara lograr que estos contenedores sean reutilizables, guardan un tipo universal en Java ya mencionado anteriormente: Object (Objeto). La jerarquía de raíz única implica que todo sea un Object,

de forma que un contenedor que tiene objetos de tipo Object puede contener de todo, logrando así

que los contenedores sean fácil de reutilizar.

Para utilizar uno de estos contenedores, basta con añadirle referencias a objetos y finalmente preguntar por ellas. Pero dado que el contenedor sólo guarda objetos de tipo Object, al añadir una referencia al contenedor, se hace un moldeado hacia arriba a Object, perdiendo por consiguiente su

identidad. Al recuperarlo, se obtiene una referencia a Object y no una referencia al tipo que se había introducido. ¿Y cómo se convierte de nuevo en algo útil con la interfaz del objeto que se introdujo en el contenedor?

En este caso, también se hace uso del moldeado, pero en esta ocasión en vez de hacerlo hacia arriba siguiendo la jerarquía de las herencias hacia un tipo más general, se hace hacia abajo, hacia un

tipo más específico. Esta forma de moldeado se denomina moldeado hacia abajo. Con el moldeado

hacia arriba, como se sabe, un Círculo, por ejemplo, es un tipo de Polígono, con lo que este tipo

de moldeado es seguro, pero lo que no se sabe es si un Object es un Círculo o un Polígono, por

lo que no es muy seguro hacer moldeado hacia abajo a menos que se sepa exactamente qué es lo

que se está manipulando.

Esto no es completamente peligroso, sin embargo, dado que si se hace un moldeado hacia abajo, a

un tipo erróneo, se mostrará un error de tiempo de ejecución denominado excepción, que se describirá en breve. Sin embargo, al recuperar referencias a objetos de un contenedor, es necesario tener

alguna manera de recordar exactamente lo que son para poder llevar a cabo correctamente un moldeado hacia abajo.

El moldeado hacia abajo y las comprobaciones en tiempo de ejecución requieren un tiempo extra

durante la ejecución del programa, además de un esfuerzo extra por parte del programador. 2No tendría sentido crear, de alguna manera, el contenedor de manera que conozca los tipos que guarda,

eliminando la necesidad de hacer moldeado hacia abajo y por tanto, de que aparezca algún error?

La solución la constituyen los tipos parametrizados, que son clases que el compilador puede adaptar automáticamente para que trabajen con tipos determinados. Por ejemplo, con un contenedor parametrizado, el compilador podría adaptar el propio contenedor para que solamente aceptara y per-

1: Introducción a los objetos 21

mitiera la recuperación de Polígonos.

Los tipos parametrizados son un elemento importante en C++, en parte porque este lenguaje no tiene una jerarquía de raíz única. En C++, la palabra clave que implementa los tipos parametrizados es

"template". Java actualmente no tiene tipos parametrizados pues se puede lograr lo mismo -aunque de manera complicada- explotando la unicidad de raíz de su jerarquía. Sin embargo, una propuesta actualmente en curso para implementar tipos parametrizados utiliza una sintaxis muy semejante a las plantillas (templates) de C++.

El dilema de las labores del hogar:

¿quién limpia la casa?

Cada objeto requiere recursos simplemente para poder existir, fundamentalmente memoria. Cuando

un objeto deja de ser necesario debe ser eliminado de manera que estos recursos queden disponibles

para poder reutilizarse. En situaciones de programación sencillas la cuestión de cuándo eliminar un

objeto no se antoja complicada: se crea el objeto, se utiliza mientras es necesario y posteriormente

debe ser destruido. Sin embargo, no es difícil encontrar situ~iones en las que esto se corriplica.

Supóngase, por ejemplo, que se está diseñando un sistema para gestionar el tráfico aéreo de un aeropuerto. (El mismo modelo podría funcionar también para gestionar paquetes en un almacén, o un

sistema de alquiler de vídeos, o una residencia canina.) A primera vista, parece simple: construir un

contenedor para albergar aviones, crear a continuación un nuevo avión y ubicarlo en el contenedor

(para cada avión que aparezca en la zona a controlar). En el momento de eliminación, se borra (suprime) simplemente el objeto aeroplano correcto cuando un avión sale de la zona barrida.

Pero quizás, se tiene otro sistema para guardar los datos de los aviones, datos que no requieren

atención inmediata, como la función de control principal. Quizás, se trata de un registro del plan de

viaje de todos los pequeños aviones que abandonan el aeropuerto. Es decir, se dispone de un segundo contenedor de aviones pequeños, y siempre que se crea un objeto avión también se introduce en este segundo contenedor si se trata de un avión pequeño. Posteriormente, algún proceso en

segundo plano lleva a cabo operaciones con los objetos de este segundo contenedor cada vez que el

sistema está ocioso.

Ahora el problema se complica: jcómo se sabe cuándo destruir los objetos? Cuando el programa

principal (el controlador) ha acabado de usar el objeto, puede que otra parte del sistema lo esté

usando (o lo vaya a usar en un futuro). Este problema surge en numerosísimas ocasiones, y los sistemas de programación (como C++) en los que los objetos deben de borrarse explícitamente cuando acaba de usarlos, pueden volverse bastante complejos.

Con Java, el problema de vigilar que se libere la memoria se ha implementado en el rccolector de

basura (aunque no incluye otros aspectos de la supresión de objetos). El recolector "sabe" cuándo

se ha dejado de utilizar un objeto y libera la memoria que ocupaba automáticamente. Esto (combinado con el hecho de que todos los objetos son heredados de la clase raíz única Object y con la

existencia de una única forma de crear objetos, en el montículo) hace que el proceso de programar

en Java sea mucho más sencillo que el hacerlo en C++. Hay muchas menos decisiones que tomar y

menos obstáculos que sortear.

22 Piensa en Java

Los recolectores de basura frente a la eficiencia y flexibilidad

Si todo esto es tan buena idea, ¿por qué no se hizo lo mismo en C++? Bien, por supuesto, hay un

precio que pagar por todas estas comodidades de programación, y este precio consiste en sobrecarga en tiempo de ejecución. Como se mencionó anteriormente, en C++ es posible crear objetos en

la pila, y en este caso, éstos se eliminan automáticamente (pero no se dispone de la flexibilidad de

crear tantos como se desee en tiempo de ejecución). La creación de objetos en la pila es la manera

más eficiente de asignar espacio a los objetos y de liberarlo. La creación de objetos en el montículo

puede ser mucho más costosa. Heredar siempre de una clase base y hacer que todas las llamadas

a función sean polimórficas también conlleva un pequeño peaje. Pero el recolector de basura es un

problema concreto pues nunca se sabe cuándo se va a poner en marcha y cuánto tiempo conllevará

su ejecución. Esto significa que hay inconsistencias en los ratios (velocidad) de ejecución de los programas escritos en Java, por lo que éstos no pueden ser utilizados en determinadas situaciones,

como por ejemplo, cuando el tiempo de ejecución de un programa es uniformemente crítico. (Se trata de los programas denominados generalmente de tiempo real, aunque no todos los problemas de

programación en tiempo real son tan rígidos.)

Los diseñadores del lenguaje C++, trataron de ganarse a los programadores de C (en lo cual tuvieron bastante éxito), no quisieron añadir nuevas características al lenguaje que pudiesen influir en la

velocidad o el uso de C++ en cualquier situación en la que los programadores pudiesen decantarse

por C. Se logró la meta, pero a cambio de una mayor complejidad cuando se programa en C++. Java

es más simple que C++, pero a cambio es menos eficiente y en ocasiones ni siquiera aplicable. Sin

embargo, para un porcentaje elevado de problemas de programación, Java es la mejor elección.

Manejo de excepciones:

tratar con errores

El manejo de errores ha sido, desde el principio de la existencia de los lenguajes de programación,

uno de los aspectos más difíciles de abordar. Dado que es muy complicado diseñar un buen

esquema de manejo de errores, muchos lenguajes simplemente ignoran este aspecto, pasando el

problema a los diseñadores de bibliotecas que suelen contestar con soluciones a medias que funcionan en la mayoría de situaciones, pero que pueden ser burladas de manera sencilla; es decir, simplemente ignorándolas. Un problema importante con la mayoría de los esquemas de tratamiento de

errores es que dependen de la vigilancia del programador de cara al seguimiento de una convención preestablecida no especialmente promovida por el propio lenguaje. Si el programador no está

atento -cosa que ocurre muchas veces, especialmente si se tiene prisa- es posible olvidar estos

esquemas con relativa facilidad.

El manejo de excepciones está íntimamente relacionado con el lenguaje de programación y a veces

incluso con el sistema operativo. Una excepción es un objeto que es "lanzado", "arrojadowq desde el

lugar en que se produce el error, y que puede ser "capturado" por el gestor de excepción apropiado

Y N. del traductor: en inglés se emplea el verbo throw.

1: Introducción a los objetos 23

diseñado para manejar ese tipo de error en concreto. Es como si la gestión de excepciones constituyera un cauce de ejecución diferente, paralelo, que puede tomarse cuando algo va mal. Y dado que

usa un cauce de ejecución distinto, no tiene por qué interferir con el código de ejecución normal. De

esta manera el código es más simple de escribir puesto que no hay que estar comprobando los errores continuamente. Además, una excepción lanzada no es como un valor de error devuelto por una

función, o un indicador (bandera) que una función pone a uno para indicar que se ha dado cierta

condición de error (éstos podrían ser ignorados). Una excepción no se puede ignorar, por lo que se

garantiza que será tratada antes o después. Finalmente, las excepciones proporcionan una manera de

recuperarse de manera segura de una situación anormal. En vez de simplemente salir, muchas veces

es posible volver a poner las cosas en su sitio y reestablecer la ejecución del programa, logrando así

que éstos sean mucho más robustos.

El manejo de excepciones de Java destaca entre los lenguajes de programación pues en Java, éste

se encuentra imbuido desde el principio, y es obligatorio utilizarlo. Si no se escribe un código de

manera que maneje excepciones correctamente, se obtendrá un mensaje de error en tiempo de

compilación. Esta garantía de consistencia hace que la gestión de errores sea mucho más sencilla.

Es importante destacar el hecho de que el manejo de excepciones no es una característica orientada

a objetos, aunque en los lenguajes orientados a objetos las excepciones se suelan representar me

diante un objeto. El manejo de excepciones existe desde antes de los lenguajes orientados a objetos.

Multihilo

Un concepto fundamental en la programación de computadores es la idea de manejar más de una

tarea en cada instante. Muchos problemas de programación requieren que el programa sea capaz

de detener lo que esté haciendo, llevar a cabo algún otro problema, y volver a continuación al proceso principal. Se han buscando múltiples soluciones a este problema. Inicialmente, los programadores que tenían un conocimiento de bajo nivel de la máquina, escribían rutinas de servicio de interrupciones, logrando la suspensión del proceso principal mediante interrupciones hardware.

Aunque este enfoque funcionaba bastante bien, era dificultoso y no portable, por lo que causaba que

transportar un programa a una plataforma distinta de la original fuera lento y caro.

A veces, es necesario hacer uso de las interrupciones para el manejo de tareas críticas en el tiempo, pero hay una gran cantidad de problemas en los que simplemente se intenta dividir un problema en fragmentos de código que pueden ser ejecutados por separado, de manera que se logra un

menor tiempo de respuesta para todo el programa en general. Dentro de un programa, estos fragmentos de código que pueden ser ejecutados por separado, se denominan hilos, y el concepto general se denomina multihilos. Un ejemplo común de aplicación multihilo es la interfaz de usuario.

Gracias al uso de hilos, un usuario puede presionar un botón y lograr una respuesta rápida en vez

de verse forzado a esperar a que el programa acabe su tarea actual.

Normalmente, los hilos no son más que una herramienta para facilitar la planificación en un monoprocesador. Pero si el sistema operativo soporta múltiples procesadores, es posible asignar cada hilo

a un procesador distinto de manera que los hilos se ejecuten verdaderamente en paralelo. Uno de

los aspectos más destacables de la programación multihilo es que el programador no tiene que pre-

24 Piensa en Java

ocuparse de si hay uno o varios procesadores. El programa se divide de forma lógica en hilos y si

hay más de un procesador, se ejecuta más rápidamente, sin que sea necesario llevar a cabo ningún

ajuste adicional sobre el código.

Todo esto hace que el manejo de hilos parezca muy sencillo. Hay un inconveniente: los recursos

compartidos. Si se tiene más de un hilo en ejecución tratando de acceder al mismo recurso, se plantea un problema. Por ejemplo, dos procesos no pueden enviar simultáneamente información a una

impresora. Para resolver el problema, los recursos que pueden ser compartidos como la impresora,

deben bloquearse mientras se están usando. Por tanto, un hilo bloquea un recurso, completa su tarea y después libera el bloqueo de manera que alguien más pueda usar ese recurso.

El hilo de Java está incluido en el propio lenguaje, lo que hace que un tema de por sí complicado se

presente de forma muy sencilla. El manejo de hilos se soporta a nivel de objeto, de manera que un

hilo de ejecución se representa por un objeto. Java también proporciona bloqueo dc rccursos limitados; puede bloquear la memoria de cualquier objeto (que en el fondo, no deja de ser un tipo de

recurso compartido) de manera que sólo un objeto pueda usarlo en un instante dado. Esto se logra

mediante la palabra clave synchronized. Otros tipos de recursos deben ser explícitamente bloqueados por el programador, generalmente, creando un objeto que represente el bloqueo que todos los

hilos deben comprobar antes de acceder al recurso.

Persistencia

Al crear un objeto, existe tanto tiempo como sea necesario, pero bajo ninguna circunstancia sigue

existiendo una vez que el programa acaba. Si bien esta circunstancia parece tener sentido a primera vista, hay situaciones en las que sería increíblemente útil el que un objeto pudiera existir y mantener su información incluso cuando el programa ya no esté en ejecución. De esta forma, la siguiente vez que se lance el programa, el objeto estará ahí y seguirá teniendo la misma información

que tenía la última vez que se ejecutó el programa. Por supuesto, es posible lograr un efecto similar escribiendo la información en un archivo o en una base de datos, pero con la idea de hacer que

todo sea un objeto, sería deseable poder declarar un objeto como persistente y hacer que alguien o

algo se encargue de todos los detalles, sin tener que hacerlo uno mismo.

Java proporciona soporte para "persistencia ligera", lo que significa que es posible almacenar objetos de manera sencilla en un disco para más tarde recuperarlos. La razón de que sea "ligera" es que

es necesario hacer llamadas explícitas a este almacenamiento y recuperación. Además, los

JavaSpaces (descritos en el Capítulo 15) proporcionan cierto tipo de almacenamiento persistente de

los objetos. En alguna versión futura, podría aparecer un soporte completo para la persistencia.

Java Internet

Si Java es, de hecho, otro lenguaje de programación de computadores entonces uno podría preguntarse por qué es tan importante y por qué debería promocionarse como un paso revolucionario en

la programación de computadores. La respuesta no es obvia ni inmediata si se procede de la perspectiva de programación tradicional. Aunque Java es muy útil de cara a la solución de problemas de

1: Introducción a los objetos 25

programación tradicionales autónomos, también es importante por resolver problemas de programación en la World Wide Web.

¿Qué es la Web?

La Web puede parecer un gran misterio a primera vista, especialmente cuando se oye hablar de "navegar", "presencia" y "páginas iniciales" (home pages). Ha habido incluso una reacción creciente contra la

"Internet-manía", cuestionando el valor económico y el beneficio de un movimiento tan radical. Es útil

dar un paso atrás y ver lo que es realmente, pero para hacer esto es necesario entender los sistemas

cliente/servidor, otro elemento de la computación lleno de aspectos que causan también confusión.

Computación cliente/servidor

La idea principal de un sistema cliente/servidor es que se dispone de un depósito (repositorio) central de información -cierto tipo de datos, generalmente en una base de datos- que se desea distribuir bajo demanda a cierto conjunto de máquinas o personas. Una clave para comprender el concepto de cliente/servidor es que el depósito de información está ubicado centralmente, de manera

que puede ser modificado y de forma que los cambios se propaguen a los consumidores de la información. A la(s) máquina(s) en las que se ubican conjuntamente el depósito de información y el

software que la distribuye se la denomina el servidor. El software que reside en la máquina remota

se comunica con el servidor, toma la información, la procesa y después la muestra en la máquina remota, denominada el cliente.

El concepto básico de la computación cliente/servidor, por tanto, no es tan complicado. Aparecen

problemas porque se tiene un único servidor que trata de dar servicio a múltiples clientes simultáneamente. Generalmente, está involucrado algún sistema gestor de base de datos de manera que el

diseñador "reparte" la capa de datos entre distintas tablas para lograr un uso óptimo de los mismos.

Además, estos sistemas suelen admitir que un cliente inserte nueva información en el servidor. Esto

significa que es necesario asegurarse de que el nuevo dato de un cliente no machaque los nuevos

datos de otro cliente, o que no se pierda este dato en el proceso de su adición a la base de datos (a

esto se le denomina procesamiento de la transacción). Al cambiar el software cliente, debe ser construido, depurado e instalado en las máquinas cliente, lo cual se vuelve bastante más complicado y

caro de lo que pudiera parecer. Es especialmente problemático dar soporte a varios tipos de computadores y sistemas operativos. Finalmente, hay un aspecto de rendimiento muy importante: es posible tener cientos de clientes haciendo peticiones simultáneas a un mismo servidor, de forma que

un mínimo retraso sea crucial. Para minimizar la latencia, los programadores deben empeñarse a

fondo para disminuir las cargas de las tareas en proceso, generalmente repartiéndolas con las máquinas cliente, pero en ocasiones, se dirige la carga hacia otras máquinas ubicadas junto con el servidor, denominadas intermediarios "middleware"(que también se utiliza para mejorar la mantenibilidad del sistema global).

La simple idea de distribuir la información a la gente, tiene muchas capas de complejidad en la fase

de implementación, y el problema como un todo puede parecer desesperanzador. E incluso puede

ser crucial: la computación cliente/servidor se lleva prácticamente la mitad de todas las actividades

de programación. Es responsable de todo, desde recibir las órdenes y transacciones de tarjetas de

26 Piensa en Java

crédito hasta la distribución de cualquier tipo de datos -mercado de valores, datos científicos, del

gobierno,. . . Hasta la fecha, en el pasado, se han intentado y desarrollado soluciones individuales

para problemas específicos, inventando una solución nueva cada vez. Estas soluciones eran difíciles

de crear y utilizar, y el usuario debía aprenderse nuevas interfaces para cada una de ellas. El problema cliente/servidor completo debe resolverse con un enfoque global.

La Web como un servidor gigante

La Web es, de hecho, un sistema cliente/servidor gigante. Es un poco peor que eso, puesto que todos los servidores y clientes coexisten en una única red a la vez. No es necesario, sin embargo, ser

conscientes de este hecho, puesto que simplemente es necesario preocuparse de saber cómo conectarse y cómo interactuar con un servidor en un momento dado (incluso aunque sea necesario

merodear por todo el mundo para encontrar el servidor correcto).

Inicialmente, este proceso era unidireccional. Se hacía una petición de un servidor y éste te proporcionaba un archivo que el software navegador (por ejemplo, el cliente) de tu máquina podía interpretar dándole el formato adecuado en la máquina local. Pero en poco tiempo, la gente empezó a

demandar más servicios que simplemente recibir páginas de un servidor. Se pedían capacidades

cliente/servidor completas, de manera que el cliente pudiera retroalimentar de información al servidor; por ejemplo, para hacer búsquedas en base de datos en el servidor, añadir nueva información

al mismo, o para ubicar una orden (lo que requería un nivel de seguridad mucho mayor que el que

ofrecían los sistemas originales). Éstos son los cambios de los que hemos sido testigos a lo largo

del desarrollo de la Web.

El navegador de la Web fue un gran paso hacia delante: el concepto de que un fragmento de información pudiera ser mostrado en cualquier tipo de computador sin necesidad de modificarlo. Sin embargo, los navegadores seguían siendo bastante primitivos y pronto se pasaron de moda debido a

las demandas que se les hacían. No eran especialmente interactivos, y tendían a saturar tanto el servidor como Internet puesto que cada vez que requería hacer algo que exigiera programación había

que enviar información de vuelta al servidor para que fuera procesada. Encontrar algo que por ejemplo, se había tecleado incorrectamente en una solicitud, podía llevar muchos minutos o segundos.

Dado que el navegador era únicamente un visor no podía desempeñar ni siquiera las tareas de computación más simples. (Por otro lado, era seguro, puesto que no podía ejecutar programas en la máquina local que pudiera contener errores (bugs) o virus.)

Para resolver el problema, se han intentado distintos enfoques. El primero de ellos consistió en mejorar los estándares gráficos para permitir mejores animaciones y vídeos dentro de los navegadores. El resto del problema se puede resolver incorporando simplemente la capacidad de ejecutar

programas en el cliente final, bajo el navegador. Esto se denomina programación en la parte

cliente.

Programación en el lado del cliente

El diseño original servidor-navegador de la Web proporcionaba contenidos interactivos, pero la capacidad de interacción la proporcionaba completamente el servidor. Éste producía páginas estáticas para el navegador del cliente, que simplemente las interpretaba y visualizaba. El HTML básico

1 : Introducción a los objetos 27

contiene mecanismos simples para la recopilación de datos: cajas de entrada de textos, cajas de

prueba, cajas de radio, listas y listas desplegables, además de un botón que sólo podía programarse para borrar los datos del formulario o "enviar" los datos del formulario de vuelta al servidor.

Este envío de datos se lleva a cabo a través del Common Gateway Interface (CGI), proporcionado

por todos los servidores web. El texto del envío transmite a CGI qué debe hacer con él. La acción

más común es ejecutar un programa localizado en el servidor en un directorio denominado generalmente "cgi-bin". (Si se echa un vistazo a la ventana de direcciones de la parte superior del navegador al presionar un botón de una página Web, es posible ver en ocasiones la cadena "cgi-bin"

entre otras cosas.) Estos programas pueden escribirse en la mayoría de los lenguajes. Perl es una

elección bastante frecuente pues fue diseñado para la manipulación de textos, y es interpretado, lo

que permite que pueda ser instalado en cualquier servidor sin que importe el procesador o sistema operativo instalado.

Muchos de los sitios web importantes de hoy en día se siguen construyendo estrictamente con CGI,

y es posible, de hecho, hacer casi cualquier cosa con él. Sin embargo, los sitios web cuyo funcionamiento se basa en programas CGI se suelen volver difíciles de mantener, y presentan además problemas de tiempo de respuesta. (Además, poner en marcha programas CGI suele ser bastante lento.) Los diseñadores iniciales de la Web no previeron la rapidez con que se agotaría el ancho de

banda para los tipos de aplicaciones que se desarrollaron. Por ejemplo, es imposible llevar a cabo

cualquier tipo de generación dinámica de gráficos con consistencia, pues es necesario crear un

archivo GIF que pueda ser después trasladado del servidor al cliente para cada versión del gráfico.

Y seguro que todo el mundo ha tenido alguna experiencia con algo tan simple como validar datos

en un formulario de entrada. Se presiona el botón de enviar de una página; los datos se envían de

vuelta al servidor; el servidor pone en marcha un programa CGI y descubre un error, da formato a

una página H'I'ML inIormando del error y después vuelve a mandar la pagina de vuelta; entonces es

necesario recuperar el formulario y volver a empezar. Esto no es solamente lento, sino que es además poco elegante.

La solución es la programación en el lado del cliente. La mayoria de las máquinas que ejecutan navegadores Web son motores potentes capaces de llevar a cabo grandes cantidades de trabajo, y con

el enfoque HTML estático original, simplemente estaban allí "sentadas", esperando ociosas a que el

servidor se encargara de la página siguiente. La programación en el lado del cliente quiere decir que

el servidor web tiene permiso para hacer cualquier trabajo del que sea capaz, y el resultado para el

usuario es una experiencia mucho más rápida e interactiva en el sitio web.

El problema con las discusiones sobre la programación en el lado cliente es que no son muy distintas de las discusiones de programación en general. Los parámetros son casi los mismos, pero la

plataforma es distinta: un navegador web es como un sistema operativo limitado. Al final, uno debe

seguir programando, y esto hace que siga existiendo el clásico conjunto de problemas y soluciones,

producidos en este caso por la programación en el lado del cliente. El resto de esta sección proporciona un repaso de los aspectos y enfoques en la programación en el lado del cliente.

Conecta bles (plug-ins)

Uno de los mayores avances en la programación en la parte cliente es el desarrollo de los conectables (plug-ins). Éstos son modos en los que un programador puede añadir nueva funcionalidad al

28 Piensa en Java

navegador descargando fragmentos de código que se conecta en el punto adecuado del navegador.

Le dice al navegador "de ahora en adelante eres capaz de llevar a cabo esta nueva actividad". (Es

necesario descargar cada conectable únicamente una vez.) A través de los conectables, se añade

comportamiento rápido y potente al navegador, pero la escritura de un conectable no es trivial y desde luego no es una parte deseable para hacer como parte de un proceso de construcción de un sitio web. El valor del conectable para la programación en el lado cliente es tal que permite a un programador experto desarrollar un nuevo lenguaje y añadirlo a un navegador sin permiso de la parte

que desarrolló el propio navegador. Por consiguiente, los navegadores proporcionan una "puerta trasera que permite la creación de nuevos lenguajes de programación en el lado cliente (aunque no todos los lenguajes se encuentren implementados como conectables).

Lenguajes de guiones

Los conectables condujeron a la explosión de los lenguajes de guiones (scripting). Con uno de estos

lenguajes se integra el código fuente del programa de la parte cliente directamente en la página HTML,

y el conectable que interpreta ese lenguaje se activa automáticamente a medida que se muestra la página HTML. Estos lenguajes tienden a ser bastante sencillos de entender y, dado que son simplemente

texto que forma parte de una página HTML, se cargan muy rápidamente como parte del único acceso

al servidor mediante el que se accede a esa página. El sacrificio es que todo el mundo puede ver (y robar) el código así transportado. Sin embargo, generalmente, si no se pretende hacer cosas excesivamente complicadas, los lenguajes de guiones constituyen una buena herramienta, al no ser complicados.

Esto muestra que los lenguajes de guiones utilizados dentro de los navegadores web se desarrollaron verdaderamente para resolver tipos de problemas específicos, en particular la creación de interfaces gráficos de usuario (IGUs) más interactivos y ricos. Sin embargo, uno de estos lenguajes

puede resolver el 80% de los problemas que se presentan en la programación en el lado cliente. Este

80% podría además abarcar todos los problemas de muchos programadores, y dado que los lenguajes de programación permiten desarrollos mucho más sencillos y rápidos, es útil pensar en utilizar

uno de estos lenguajes antes de buscar soluciones más complicadas, como la programación en Java

o ActiveX.

Los lenguajes de guiones de navegador más comunes son JavaScript (que no tiene nada que ver con

Java; se denominó así simplemente para aprovechar el buen momento de marketing de Java),

VBScript (que se parece bastante a Visual Basic), y Tcl/Tk, que proviene del popular lenguaje de

construcción de IGU (Interfaz Gráfica de Usuario) de plataformas cruzadas. Hay otros más, y seguro que se desarrollarán muchos más.

JavaScript es probablemente el que recibe más apoyo. Viene incorporado tanto en el navegador

Netscape Navigator como en el Microsoft Internet Explorer (IE). Además, hay probablemente más libros de JavaScritpt que de otros lenguajes de navegador, y algunas herramientas crean páginas automáticamente haciendo uso de JavaScript. Sin embargo, si se tiene habilidad en el manejo de Visual

Basic o Tcl/Tk, será más productivo hacer uso de esos lenguajes de guiones en vez de aprender uno

nuevo. (De hecho, ya se habrá hecho uso de aspectos web para estas alturas.)

Java

Si un lenguaje de programación puede resolver el 80 por ciento de los problemas de programación en el lado cliente, ¿qué ocurre con el 20 por ciento restante -que constituyen de hecho "la

1: Introducción a los objetos 29

parte seria del problema"? La solución más popular hoy en día es Java. No sólo se trata de un

lenguaje de programación potente, construido para ser seguro, de plataforma cruzada (multiplataforma) e internacional, sino que se está extendiendo continuamente para proporcionar aspectos de lenguaje y bibliotecas que manejan de manera elegante problemas que son complicados

para los lenguajes de programación tradicionales, como la ejecución multihilo, el acceso a base

de datos, la programación en red, y la computación distribuida. Java permite programación en el

lado cliente a través del applet.

Un applet es un miniprograma que se ejecutará únicamente bajo un navegador web. El applet se

descarga automáticamente como parte de una página web (igual que, por ejemplo, se descarga

un gráfico, de manera automática). Cuando se activa un applet, ejecuta un programa. Ésta es parte de su belleza -proporciona una manera de distribuir automáticamente software cliente desde

el servidor justo cuando el usuario necesita software cliente, y no antes. El usuario se hace con

la última versión del software cliente, sin posibilidad de fallo, y sin tener que llevar a cabo reinstalaciones complicadas. Gracias a cómo se ha diseñado Java, el programado simplemente tiene

que crear un único programa, y este programa trabaja automiticamente en todos los computadores que tengan navegadores que incluyan intérpretes de Java. (Esto incluye seguramente a la

gran mayoría de plataformas.) Dado que Java es un lenguaje de programación para novatos, es

posible hacer tanto trabajo como sea posible en el cliente, antes y después de hacer peticiones

al servidor. Por ejemplo, no se deseará enviar un formulario de petición a través de Internet para

descubrir que se tiene una fecha o algún otro parámetro erróneo, y el computador cliente puede

llevar a cabo rápidamente la labor de registrar información en vez de tener que esperar a que lo

haga el servidor para enviar después una imagen gráfica de vuelta. No sólo se consigue un incremento de velocidad y capacidad de respuesta inmediatas, sino que el tráfico en general de la

red y la carga en los servidores se reduce considerablemente, evitando que toda Internet se vaya

ralentizando.

Una ventaja que tienen los applets de Java sobre los lenguajes de guiones es que se encuentra en

formato compilado, de forma que el código fuente no está disponible para el cliente. Por otro

lado, es posible descompilar un applet Java sin excesivo trabajo, pero esconder un código no es

un problema generalmente importante. Hay otros dos factores que pueden ser importantes.

Como se verá más tarde en este libro, un applet Java compilado puede incluir varios módulos e

implicar varios accesos al servidor para su descarga (en Java 1.1 y superiores, esto se minimiza

mediante archivos Java, denominados archivos JAR, que permiten que los módulos se empaqueten todos juntos y se compriman después para que baste con una única descarga). Un programa

de guiones se integrará simplemente en una página web como parte de su texto (y generalmente será más pequeño reduciendo los accesos al servidor). Esto podría ser importante de cara al

tiempo de respuesta del sitio web. Otro factor importante es la curva de aprendizaje. A pesar de

lo que haya podido oírse, Java no es un lenguaje cuyo aprendizaje resulte trivial. Para los programadores en Visual Basic, moverse a VBScript siempre será la solución más rápida, y dado

que probablemente este lenguaje resolverá los problemas cliente/servidor más típicos, puede resultar bastante complicado justificar la necesidad de aprender Java. Si uno ya tiene experiencia

con un lenguaje de guiones, seguro que se obtendrán beneficios simplemente haciendo uso de

JavaScript o VBScript antes de lanzarse a utilizar Java, ya que estos lenguajes pueden resolver

todos los problemas de manera sencilla, y se logrará un nivel de productividad elevado en un

tiempo menor.

30 Piensa en Java

ActiveX

Hasta cierto grado, el competidor principal de Java es el ActiveX de Microsoft, aunque se base en

un enfoque totalmente diferente. ActiveX era originalmente una solución válida exclusivamente para

Windows, aunque ahora se está desarrollando mediante un consorcio independiente de manera que

acabará siendo multiplataforma (plataforma cruzada). Efectivamente, ActiveX se basa en que "si un

programa se conecta a su entorno de manera que puede ser depositado en una página web y ejecutado en un navegador, entonces soporta ActiveX. (IE soporta ActiveX directamente, y Netscape

también, haciendo uso de un conectable.) Por consiguiente, ActiveX no se limita a un lenguaje particular. Si, por ejemplo, uno es un programador Windows experimentado, haciendo uso de un lenguaje como C++, Visual Basic o en Delphi de Borland, es posible crear componentes ActiveX sin casi

tener que hacer ningún cambio a los conocimientos de programación que ya se tengan. Además,

ActiveX proporciona un modo de usar código antiguo (base dado) en páginas web.

Seguridad

La capacidad para descargar y ejecutar programas a través de Internet puede parecer el sueño de

un constructor de virus. ActiveX atrae especialmente el espinoso tema de la seguridad en la programación en la parte cliente. Si se hace clic en el sitio web, es posible descargar automáticamente

cualquier número de cosas junto con la página HTML: archivos GIF, código de guiones, código Java

compilado, y componentes ActiveX. Algunos de estos elementos son benignos: los archivos GIF no

pueden hacer ningún daño, y los lenguajes de guiones se encuentran generalmente limitados en lo

que pueden hacer. Java también fue diseñado para ejecutar sus applets dentro de un "envoltorio" de

seguridad, lo que evita que escriba en el disco o acceda a la memoria externa a ese envoltorio.

ActiveX está en el rango opuesto del espectro. Programar con ActiveX es como programar Windows

-es posible hacer cualquier cosa. De esta manera, si se hace clic en una página web que descarga

un componente ActiveX, ese componente podría llegar a dañar los archivos de un disco. Por supuesto, los programas que uno carga en un computador, y que no están restringidos a ejecutarse

dentro del navegador web podrían hacer lo mismo. Los virus que se descargaban desde una BBS

(Bulletin-Board Systems) hace ya tiempo que son un problema, pero la velocidad de Internet amplifica su gravedad.

La solución parecen aportarla las "firmas digitales", que permiten la verificación de la autoría del código. Este sistema se basa en la idea de que un virus funciona porque su creador puede ser anónimo, de manera que si se evita la ejecución de programas anónimos, se obligará a cada persona a ser

responsable de sus actos. Esto parece una buena idea, pues permite a los programas ser mucho más

funcionales, y sospecho que eliminará las diabluras maliciosas. Si, sin embargo, un programa tiene

un error (bug) inintencionadamente destructivo, seguirá causando problemas.

El enfoque de Java es prevenir que estos problemas ocurran, a través del envoltorio. El intérprete

de Java que reside en el navegador web local examina el applet buscando instrucciones adversas a

medida que se carga el applet. Más en concreto, el applet no puede escribir ficheros en el disco o

borrar ficheros (una de las principales vías de ataque de los virus). Los applets se consideran generalmente seguros, y dado que esto es esencial para lograr sistemas cliente/servidor de confianza,

cualquier error (bug) que produzca virus en lenguaje Java será rápidamente reparado. (Merece la

1: Introducción a los objetos 31

pena destacar que el software navegador, de hecho, refuerza estas restricciones de seguridad, y algunos navegadores permiten seleccionar distintos niveles de seguridad para proporcionar distintos

grados de acceso a un sistema.)

También podría uno ser escéptico sobre esta restricción tan draconiana en contra de la escritura de

ficheros en un disco local. Por ejemplo, uno puede desear construir una base de datos o almacenar

datos para utilizarlos posteriormente, finalizada la conexión. La visión inicial parecía ser tal que

eventualmente todo el mundo podría conseguir hacer cualquier cosa importante estando conectado,

pero pronto se vio que esta visión no era práctica (aunque los "elementos Internet" de bajo coste

puedan satisfacer algún día las necesidades de un segmento de usuarios significativo). La solución

es el "applet firmado" que utiliza cifrado de clave pública para verificar que un applet viene efectivamente de donde dice venir. Un applet firmado puede seguir destrozando un disco local, pero la teoría es que dado que ahora es posible localizar al creador del applet, éstos no actuarán de manera

perniciosa. Java proporciona un marco de trabajo para las firmas digitales, de forma que será posible permitir que un applet llegue a salir fuera del envoltorio si es necesario.

Las firmas digitales han olvidado un aspecto importante, que es la velocidad con la que la gente se

mueve por Internet. Si se descarga un programa con errores (bugs) que hace algo dañino, ¿cuánto

tiempo se tardará en descubrir el daño? Podrían pasar días o incluso semanas. Para entonces, ¿cómo

localizar el programa que lo ha causado? ¿Y será todo el mundo capaz de hacerlo?

Internet frente a Intranet

La Web es la solución más general al problema cliente/servidor, de forma que tiene sentido que se

pueda utilizar la misma tecnología para resolver un subconjunto del problema, en particular, el clásico problema cliente/servidor dentro de una compañía. Con los enfoques cliente/servidor tradicionales, se tiene el problema de la multiplicidad de tipos de máquinas cliente, además de la dificultad

de instalar un nuevo software cliente, si bien ambos problemas pueden resolverse sencillamente con

navegadores web y programación en el lado cliente. Cuando se utiliza tecnología web para una red

de información restringida a una compañía en particular, se la denomina una Intranet. Las Intranets

proporcionan un nivel de seguridad mucho mayor que el de Internet, puesto que se puede controlar físicamente el acceso a los servidores dentro de la propia compañía. En términos de formación,

parece que una vez que la gente entiende el concepto general de navegador es mucho más sencillo

que se enfrenten a distintas páginas y applets, de manera que la curva de aprendizaje para nuevos

tipos de sistemas parece reducirse.

El problema de la seguridad nos conduce ante una de las divisiones que parece estar formándose

automáticamente en el mundo de la programación en el lado del cliente. Si un programa se ejecuta

en Internet, no se sabe bajo qué plataforma estará funcionando, y si se desea ser extremadamente

cauto, no se diseminará código con error. Es necesario algo multiplataforma y seguro, como un lenguaje de guiones o Java.

Si se está ejecutando código en una Intranet, es posible tener un conjunto de limitaciones distinto. No

es extraño que las máquinas de una red puedan ser todas plataformas Intel/Windows. En una Intranet,

uno es responsable de la calidad de su propio código y puede reparar errores en el iriomenlo en que

se descubren. Además, se podría tener cierta cantidad de código antiguo (heredado, legacy) que se ha

32 Piensa en Java

estado utilizando en un enfoque cliente/servidor más tradicional, en cuyo caso sería necesario instalar físicamente programas cliente cada vez que se construya una versión más moderna. El tiempo malgastado en instalar actualizaciones (upgrades) es la razón más apabullante para comenzar a usar navegadores, en los que estas actualizaciones son invisibles y automáticas. Para aquéllos que tengan

intranets, el enfoque más sensato es tomar el camino más corto que permita usar el código base

existente, en vez de volver a codificar todos los programas en un nuevo lenguaje.

Se ha hecho frente a este problema presentando un conjunto desconcertante de soluciones al problema de programación en el lado cliente, y la mejor determinación para cada caso es la que determine un análisis coste-beneficio. Deben considerarse las restricciones de cada problema y cuál sería el camino más corto para encontrar la solución en cada caso. Dado que la programación en la

parte cliente sigue siendo programación, suele ser buena idea tomar el enfoque de desarrollo más

rápido para cada situación. Ésta es una postura agresiva para prepararse de cara a inevitables enfrentamiento~ con los problemas del desarrollo de programas.

Programación en el lado del servidor

Hasta la fecha toda discusión ha ignorado el problema de la programación en el lado del servidor.

¿Qué ocurre cuando se hace una petición a un servidor? La mayoría de las veces la petición es simplemente "envíame este archivo". A continuación, el navegador interpreta el archivo de la manera

adecuada: como una página HTML, como una imagen gráfica, un applet Java, un programa de guiones, etc. Una petición más complicada hecha a un servidor puede involucrar una transacción de

base de datos. Un escenario común involucra una petición para una búsqueda compleja en una base

de datos, que el servidor formatea en una página HTML para enviarla a modo de resultado (por supuesto, si el cliente tiene una inteligencia mayor vía Java o un lenguaje de guiones, pueden enviarse los datos simplemente, sin formato, y será el extremo cliente el que les dé el formato adecuado,

lo cual es más rápido, además de implicar una carga menor para el servidor). Un usuario también

podría querer registrar su nombre en una base de datos al incorporarse a un grupo o presentar una

orden, lo cual implica cambios a esa base de datos. Estas peticiones deben procesarse vía algún código en el lado servidor, que se denomina generalmente programación en el lado servidor.

Tradicionalmente, esta programación se ha desempeñado mediante Perl y guiones CGI, pero han

ido apareciendo sistemas más sofisticados. Entre éstos se encuentran los servidores web basados

en Java que permiten llevar a cabo toda la programación del lado servidor en Java escribiendo lo

que se denominan servlets. Éstos y sus descendientes, los JSP, son las dos razones principales por

las que las compañías que desarrollan sitios web se están pasando a Java, especialmente porque eliminan los problemas de tener que tratar con navegadores de distintas características.

Un ruedo separado: las aplicaciones

Muchos de los comentarios en torno a Java se referían a los applets. Java es actualmente un lenguaje

de programación de propósito general que puede resolver cualquier tipo de problema -al menos

en teoría. Y como se ha señalado anteriormente, cuando uno se sale del ruedo de los applets (y simultáneamente se salta las restricciones, como la contraria a la escritura en el disco) se entra en el

mundo de las aplicaciones de propósito general que se ejecutan independientemente, sin un nave-

1 : Introducción a los objetos 33

gador web, al igual que hace cualquier programa ordinario. Aquí, la fuerza de Java no es sólo su portabilidad, sino también su programabilidad (facilidad de programación). Como se verá a lo largo del

presente libro, Java tiene muchos aspectos que permiten la creación de programas robustos en un

período de tiempo menor al que requerían los lenguajes de programación anteriores.

Uno debe ser consciente de que esta bendición no lo es del todo. El precio a pagar por todas estas

mejoras es una velocidad de ejecución menor (aunque se está haciendo bastante trabajo en este área

-JDK 1.3, en particular, presenta las mejoras de rendimiento denominadas "hotspot"). Como cualquier lenguaje, Java tiene limitaciones intrínsecas que podrían hacerlo inadecuado para resolver

cierto tipo de problemas de programación. Java es un lenguaje que evoluciona rápidamente, no obstante, y cada vez que aparece una nueva versión, se presenta más y más atractivo de cara a la solución de conjuntos mayores de problemas.

Análisis y diseño

El paradigma de la orientación a obietos es una nueva manera de enfocar la programación. Son muchos los que tienen problemas a primera vista para enfrentarse a un proyecto de POO. Dado que se

supone que todo es un objeto, y a medida que se aprende a pensar de forma orientada a objetos, es

posible empezar a crear "buenos" diseños y sacar ventaja de todos los beneficios que la PO0 puede ofrecer.

Una metodología es un conjunto de procesos y heurísticas utilizadas para descomponer la complejidad de un problema de programación. Se han formulado muchos métodos de PO0 desde que enunció la programación orientada a objetos. Esta sección presenta una idea de lo que se trata de lograr

al utilizar un método.

Especialmente en la POO, la metodología es un área de intensa experimentación, por lo que es importante entender qué problema está intentando resolver el método antes de considerar la adopción

de uno de ellos. Esto es particularmente cierto con Java, donde el lenguaje de programación se ha

desarrollado para reducir la complejidad (en comparación con C) necesaria para expresar un programa. Esto puede, de hecho, aliviar la necesidad de metodologías cada vez más complejas. En vez

de esto, puede que las metodologías simples sean suficientes en Java para conjuntos de problemas

mucho mayores que los que se podrían manipular utilizando metodologías simples con lenguajes

procedimentales.

También es importante darse cuenta de que el término "metodología" es a menudo muy general y

promete demasiado. Se haga lo que se haga al diseñar y escribir un programa, se sigue un método.

Puede que sea el método propio de uno, e incluso puede que uno no sea consciente de utilizarlo,

pero es un proceso que se sigue al crear un programa. Si el proceso es efectivo, puede que simplemente sea necesario afinarlo ligeramente para poder trabajar con Java. Si no se está satisfecho con

el nivel de productividad y la manera en que se comportan los programas, puede ser buena idea co~isiderar la adopción de un método formal, o la selección dc fragmentos de entre los muchos métodos formales existentes.

Mientras se está en el propio proceso de desarrollo, el aspecto más importante es no perderse, aunque puede resultar fácil. Muchos de los métodos de análisis y desarrollo fueron concebidos para re-

34 Piensa en Java

solver los problemas más grandes. Hay que recordar que la mayoría de proyectos no encajan en esta

categoría, siendo posible muchas veces lograr un análisis y un diseño con éxito con sólo un pequeño subconjunto de los que el método recomienda"'. Pero algunos tipos de procesos, sin importar lo

limitados que puedan ser, le permitirán encontrar el camino de manera más sencilla que si simplemente se empieza a codificar.

También es fácil desesperarse, caer en "parálisis de análisis", cuando se siente que no se puede

avanzar porque no se han cubierto todos los detalles en la etapa actual. Debe recordarse que, independientemente de cuánto análisis lleve a cabo, hay cosas de un sistema que no aparecerán hasta la fase de diseño, y otras no aflorarán incluso hasta la fase de codificación o en un extremo, hasta que el programa esté acabado y en ejecución. Debido a esto, es crucial moverse lo

suficientemente rápido a través de las etapas de análisis y diseño e implementar un prototipo del

sistema propuesto.

Debe prestarse un especial énfasis a este punto. Dado que ya se conoce la misma historia con los

lenguajes procedimentales, es recomendable que el equipo proceda de manera cuidadosa y comprenda cada detalle antes de pasar del diseño a la implementación. Ciertamente, al crear un SGBD,

esto pasa por comprender completamente la necesidad del cliente. Pero un SGBD es la clase de

problema bien formulada y bien entendida; en muchos programas, es la estructura de la base de

datos la que debe ser desmenuzada. La clase de problema de programación examinada en el presente capítulo es un "juego de azar"", en el que la solución no es simplemente la formulación de

una solución bien conocida, sino que involucra además a uno o más "factores de azar" -elementos para los que no existe una solución previa bien entendida, y para los cuales es necesario algún

tipo de proceso de investigaciónl7. Intentar analizar completamente un problema al azar antes de

pasar al diseño e implementación conduce a una parálisis en el análisis, al no tener suficiente información para resolver este tipo de problemas durante la fase de análisis. Resolver un problema

así, requiere iterar todo el ciclo, y precisa de un comportamiento que asuma riesgos (lo cual tiene

sentido, pues está intentando hacer algo nuevo y las recompensas potenciales crecen). Puede parecer que el riesgo se agrava al precipitarse hacia una implementación preliminar, pero ésta puede

reducir el riesgo en los problemas al azar porque se está averiguando muy pronto si un enfoque

particular al problema es o no viable. El desarrollo de productos conlleva una gestión del riesgo.

A menudo, se propone "construir uno para desecharlo". Con PO0 es posible tirar parte, pero dado

que el código está encapsulado en clases, durante la primera pasada siempre se producirá algún diseño de clases útil y se desarrollarán ideas que merezcan la pena para el diseño del sistema de las

que no habrá que deshacerse. Por tanto, la primera pasada rápida por un problema no sólo suministra información crítica para las ulteriores pasadas por análisis, diseño e implementación, sino que

también crea la base del código.

lo Un ejemplo excelente dr esto es UML Uistilled, 2." edición, de Martin Fowler (Addison-Wesley 2000). que reducc cl proccso, en

ocasiones aplastante, a un subconjunto rriariejable (existe vei-sión española con el título UMI, gota a gota).

" N. del traductor: Término wild-card, acunado por el autor original.

" Regla del pulgar -acuñada por el autor- para estimar este tipo de proyectos: si hay más de un factor al azar, ni siquiera debe

intentarse planificar la duración o el coste del proyecto hasta que no se ha creado un prototipo que funcione. Existen demasiados

grados de libertad.

1 : Introducción a los objetos 35

Dicho esto, si se está buscando una metodología que contenga un nivel de detalle tremendo, y sugiera muchos pasos y documentos, puede seguir siendo difícil saber cuándo parar. Debe recomendarse lo que se está intentando descubrir.

1. ¿Cuáles son los objetos? (¿Cómo se descompone su proyecto en sus componentes?)

2. ¿Cuáles son las interfaces? (¿Qué mensajes es necesario enviar a cada objeto?)

Si se delimitan los objetos y sus interfaces, ya es posible escribir un programa. Por diversas razones, puede que sean necesarias más descripciones y documentos que éste, pero no es posible avanzar con menos.

El proceso puede descomponerse en cinco fases, y la Fase O no es más que la adopción de un compromiso para utilizar algún tipo de estructura.

Fase O: Elaborar un plan

En primer lugar, debe decidirse qué pasos debe haber en un determinado proceso. Suena bastante

simple (de hecho, todo esto suena simple) y la gente no obstante, suele seguir sin tomar esta decisión antes de empezar a codificar. Si el plan consiste en "empecemos codificando", entonces, perfecto (en ocasiones, esto es apropiado, si uno se está enfrentando a un problema que conoce perfectamente). Al menos, hay que estar de acuerdo en que eso también es tener un plan.

También podría decidirse en esta fase que es necesaria alguna estructura adicional de proceso, pero

no toda una metodología completa. Para que nos entendamos, a algunos programadores les gusta

trabajar en "modo vacación", en el que no se imponga ninguna estructura en el proceso de desarrollar de su trabajo; "se hará cuando se haga". Esto puede resultar atractivo a primera vista, pero a

medida que se tiene algo de experiencia uno se da cuenta de que es mejor ordenar y distribuir el

esfuerzo en distintas etapas en vez de lanzarse directamente a "finalizar el proyecto". Además, de

esta manera se divide el proyecto en fragmentos más asequibles, y se resta miedo a la tarea de enfrentarse al mismo (además, las distintas fases o hitos proporcionan más motivos de celebración).

Cuando empecé a estudiar la estructura de la historia (con el propósito de acabar escribiendo algún

día una novela), inicialmente, la idea que más me disgustaba era la de la estructura, pues parecía

que uno escribe mejor si simplemente se dedica a rellenar páginas. Pero más tarde descubrí que al

escribir sobre computadores, tenía la estructura tan clara que no había que pensar demasiado en

ella. Pero aún así, el trabajo se estructuraba, aunque sólo fuera semiconscientemente en mi cabeza.

Incluso cuando uno piensa que el plan consiste simplemente en empezar a codificar, todavía se atraviesan algunas fases al plantear y contestar ciertas preguntas.

El enunciado de la misión

Cualquier sistema que uno construya, independientemente de lo complicado que sea, tiene un propósito fundamental: el negocio intrínseco en el mismo, la necesidad básica que cumple. Si uno puede mirar a través de la interfaz de usuario, a los detalles específicos del hardware o del sistema, los

algoritinos de codificación y los problemas de eficiencia, entonces se encuentra el centro de su existencia -simple y directo. Como el denominado alto concepto (high concept) en las películas de

36 Piensa en Java

Hollywood, uno puede describir el propósito de un programa en dos o tres fases. Esta descripción,

pura, es el punto de partida.

El alto concepto es bastante importante porque establece el tono del proyecto; es el enunciado de su

misión. Uno no tiene por qué acertar necesariamente a la primera (puede ser que uno esté en una fase

posterior del problema cuando se le ocurra el enunciado completamente correcto) pero hay que se

guir intentándolo hasta tener la certeza de que está bien. Por ejemplo, en un sistema de control de trá.

fico aéreo, uno puede comenzar con un alto concepto centrado en el sistema que se está construyendo: "El programa de la torre hace un seguimiento del avión". Pero considérese qué ocurre cuando se

introduce el sistema en un pequeño aeródromo; quizás sólo hay un controlador humano, o incluso ninguno. Un modelo más usual no abordará la solución que se está creando como describe el problema:

"Los aviones llegan, descargan, son mantenidos y recargan, a continuación, salen".

Fase 1: ¿Qué estamos construyendo?

En la generación previa del diseño del programa (denominada diseño procedural) a esta fase se le de

nominaba "creación del análisis de requisitos y especificación del sistema". Éstas, por supuesto, eran fases en las que uno se perdía; documentos con nombres intimidadores que podían de por sí convertirse en grandes proyectos. Sin embargo, su intención era buena. El análisis de requisitos dice:

"Construya una lista de directrices que se utilizarán para saber cuándo se ha acabado el trabajo y cuándo el cliente está satisfecho". La especificación del sistema dice: "He aquí una descripción de lo que el

programa hará (pero no cómo) para satisfacer los requisitos hallados". El análisis de requisitos es verdaderamente un contrato entre usted y el cliente (incluso si el cliente trabaja en la misma compañía o

es cualquier otro objeto o sistema). La especificación del sistema es una exploración de alto nivel en

el problema, y en cierta medida, un descubrimiento de si puede hacerse y cuánto tiempo llevará. Dado

que ambos requieren de consenso entre la gente (y dado que generalmente variarán a lo largo del

tiempo) lo mejor es mantenerlos lo más desnudos posible -idealmente, tratará de listas y diagrarnas

básicos para ahorrar tiempo. Se podría tener otras limitaciones que exijan expandirlos en documentos

de mayor tamaño, pero si se mantiene que el documento inicial sea pequeño y conciso, es posible cre

arlo en unas pocas sesiones de tormenta de ideas (brainstorming) en grupo, con un líder que dinámicamente va creando la descripción. Este proceso no sólo exige que todos aporten sus ideas sino que

fomenta el que todos los miembros del equipo lleguen a un acuerdo inicial. Quizás lo más importante

es que puede incluso ayudar a que se acometa el proyecto con una gran dosis de entusiasmo.

Es necesario mantenerse centrado en el corazón de lo que se está intentando acometer en esta fase:

determinar qué es lo que se supone que debe hacer el sistema. La herramienta más valiosa para

esto es una colección de lo que se denomina "casos de uso". Los casos de uso identifican los aspectos claves del sistema, que acabarán por revelar las clases fundamentales que se usarán en éste.

De hecho, los casos de uso son esencialmente soluciones descriptivas a preguntas como1":

''¿Quién usará el sistema?"

''¿Qué pueden hacer esos actores con el sistema?"

" Agradecemos la ayuda de James H. Jarrett

1 : Introducción a los objetos 37

¿Cómo se las ingenia cada actor para hacer eso con este sistema?"

"¿De qué otra forma podría funcionar esto si alguien más lo estuviera haciendo, o si el mismo

actor tuviera un objetivo distinto?" (Para encontrar posibles variaciones.)

''¿Qué problemas podrían surgir mientras se hace esto con el sistema?" (Para localizar posibles

excepciones.)

Si se está diseñando, por ejemplo, un cajero automático, el caso de uso para un aspecto particular de

la funcionalidad del sistema debe ser capaz de describir qué hace el cajero en cada situación posible.

Cada una de estas "situaciones" se denomina un escenario, y un caso de uso puede considerarse como

una colección de escenarios. Uno puede pensar que un escenario es como una pregunta que empieza

por: ''¿Qué hace el sistema si...?". Por ejemplo: ''¿Qué hace el cajero si un cliente acaba de depositar

durante las últimas 24 horas un cheque y no hay dinero suficiente en la cuenta, sin haber procesado

el cheque, para proporcionarle la retirada el efectivo que ha solicitado?"

Deben utilizarse diagramas de caso de uso intencionadamente simples para evitar ahogarse prematuramente en detalles de implementación del sistema :

Cada uno de los monigotes representa a un "actor", que suele ser generalmente un humano o cualquier otro tipo de agente (por ejemplo, otro sistema de computación, como "ATM")14. La caja representa los límites de nuestro sistema. Las elipses representan los casos de uso, que son descripciones del trabajo útil que puede hacerse dentro del sistema. Las líneas entre los actores y los casos

de uso representan las interacciones.

De hecho no importa cómo esté el sistema implementado, siempre y cuando tenga una apariencia

como ésta para el usuario.

l4 ATM, siglas en inglés de cajero automático. (N. del T. )

38 Piensa en Java

Un caso de uso no tiene por qué ser terriblemente complejo, aunque el sistema subyacente sea complejo. Solamente se pretende que muestre el sistema tal y como éste se muestra al usuario. Por

ejemplo:

o ~ l nvernadero

Temperatura

Jardinero ~

Los casos de uso proporcionan las especificaciones de requisitos determinando todas las interacciones que el usuario podría tener con el sistema. Se trata de descubrir un conjunto completo de casos de uso para su sistema, y una vez hecho esto, se tiene el núcleo de lo que el sistema se supone

que hará. Lo mejor de centrarse en los casos de uso es que siempre permiten volver a la esencia

manteniéndose alejado de aspectos que no son críticos para lograr culminar el trabajo. Es decir, si

se tiene un conjunto completo de casos de uso, es posible describir el sistema y pasar a la siguiente fase. Posiblemente no se podrá configurar todo a la primera, pero no pasa nada. Todo irá surgiendo a su tiempo, y si se demanda una especificación perfecta del sistema en este punto, uno se

quedará parado.

Cuando uno se quede bloqueado, es posible comenzar esta fase utilizando una extensa herramienta de aproximación: describir el sistema en unos pocos párrafos y después localizar los sustantivos

y los verbos. Los sustantivos pueden sugerir quiénes son los actores, el contexto del caso de uso

(por ejemplo, "corredor"), o artefactos manipulados en el caso de uso. Los verbos pueden sugerir

interacciones entre los actores y los casos de uso, y especificar los pasos dentro del caso de uso.

También será posible descubrir que los sustantivos y los verbos producen objetos y mensajes durante la fase de diseño (y debe tenerse en cuenta que los casos de uso describen interacciones entre subsistemas, de forma que la técnica de "el sustantivo y el verbo" puede usarse sólo como una

herramienta de tormenta de ideas, pues no genera casos de uso)15.

La frontera entre un caso de uso y un actor puede señalar la existencia de una interfaz de usuario, pero

no lo define. Para ver el proceso de cómo definir y crear interfaces de usuario, véase Softwarefor Use de

Larry Constantine y Lucy Lockwood, (Addison-Wesley Longman, 1999) o ir a http://www. forUse.com.

Aunque parezca magia negra, en este punto es necesario algún tipo de planificación. Ahora se tiene

una visión de lo que se está construyendo, por lo que probablemente se pueda tener una idea de

cuánto tiempo le llevará. En este momento intervienen muchos factores. Si se estima una planificación larga, la compañía puede decidir no construirlo (y por consiguiente usar sus recursos en algo

más razonable -esto es bueno). Pero un director podría tener decidido de antemano cuánto tiempo

debería llevar el proyecto y podría tratar de influir en la estimación. Pero lo mejor es tener una estimación honesta desde el principio y tratar las decisiones duras al principio. Ha habido muchos inl5 Puede encontrarse más información sobre casos de uso en Applying Use Cases, de Schneider & Winters (Addison-Weley 1998) y

Use Case Driven Object modeling with UML de Rosenberg (Addison-Welsey 1999).

1 : Introducción a los objetos 39

tentos de desarrollar técnicas de planificación exactas (muy parecidas a las técnicas de predicción

del mercado de valores), pero probablemente el mejor enfoque es confiar en la experiencia e intuición. Debería empezarse por una primera estimación del tiempo que llevaría, para posteriormente

multiplicarla por dos y añadirle el 10 por ciento. La estimación inicial puede que sea correcta; a lo

mejor se puede hacer que algo funcione en ese tiempo. Al "doblarlo" resultará que se consigue algo

decente, y en el 10 por ciento añadido se puede acabar de pulir y tratar los detalles finalesl6. Sin embargo, es necesario explicarlo, y dejando de lado las manipulaciones y quejas que surgen al presentar una planificación de este tipo, normalmente funcionará.

Fase 2: ¿Cómo construirlo?

En esta fase debe lograrse un diseño que describe cómo son las clases y cómo interactuarán. Una

técnica excelente para determinar las clases e interacciones es la tarjeta Clase-ResponsabilidadColaboración (CRC)17. Parte del valor de esta herramienta se basa en que es de muy baja tecnología: se comienza con un conjunto de tarjetas de 3 x 5, y se escribe en ellas. Cada tarjeta representa

una única clase, y en ella se escribe:

1. El nombre de la clase. Es importante que este nombre capture la esencia de lo que hace la clase, de manera que tenga sentido a primera vista.

2. Las "responsabilidades" de la clase: qué debería hacer. Esto puede resumirse típicamente escribiendo simplemente los nombres de las funciones miembros (dado que esas funciones deberían ser descriptivas en un buen diseño), pero no excluye otras anotaciones. Si se necesita

ayuda, basta con mirar el problema desde el punto de vista de un programador holgazán: ¿qué

objetos te gustaría que apareciesen por arte de magia para resolver el problema?

3. Las "colaboraciones" de la clase: ¿con qué otras clases interactúa? "Interactuar" es un término

amplio intencionadamente; vendría a significar agregación, o simplemente que cualquier otro

objeto existente ejecutara servicios para un objeto de la clase. Las colaboraciones deberían

considerar también la audiencia de esa clase. Por ejemplo, si se crea una clase Petardo,

¿quién la va a observar, un Químico o un Observador? En el primer caso estamos hablando

de punto de vista del químico que va a construirlo, mientras que en el segundo se hace referencia a los colores y las formas que libere al explotar.

Uno puede pensar que las tarjetas deberían ser más grandes para que cupiera en ellas toda la información que se deseara escribir, pero son pequeñas a propósito, no sólo para mantener pequeño

el tamaño de las clases, sino también para evitar que se caiga en demasiado nivel de detalle muy

pronto. Si uno no puede encajar todo lo que necesita saber de una clase en una pequeña tarjeta, la

clase es demasiado compleja (o se está entrando en demasiado nivel de detalle, o se debería crear

más de una clase). La clase ideal debería ser comprensible a primera vista. La idea de las tarjetas

CRC es ayudar a obtener un primer diseño de manera que se tenga un dibujo a grandes rasgos que

pueda ser después refinado.

Mi opinión en este sentido ha cambiado últimamente. Al doblar y añadir el 10 por ciento se obtiene una estimación razonablemente exacta (asumiendo que no hay demasiados factores al azar) pero todavía hay que trabajar con bastante diligencia para finaliar en ese tiempo. Si se desea tener tiempo suficiente para lograr un producto verdaderamente elegante y disfrutar durante el proceso, el multiplicador correcto, en mi opinión, puede ser por tres o por cuatro.

l7 En inglés, Class-Responsibility-Collaboration. (N. del R.T.)

40 Piensa en Java

Una de las mayores ventajas de las tarjetas CRC se logra en la comunicación. Cuando mejor se hace

es en tiempo real, en grupo y sin computadores. Cada persona se considera responsable de varias

clases (que al principio no tienen ni nombres ni otras informaciones). Se ejecuta una simulación en

directo resolviendo cada vez un escenario, decidiendo qué mensajes se mandan a los distintos objetos para satisfacer cada escenario. A medida que se averiguan las responsabilidades y colaboraciones de cada una, se van rellenando las tarjetas correspondientes. Cuando se han recorrido todos

los casos de uso, se debería tener un diseño bastante completo.

Antes de empezar a usar tarjetas CRC, tuve una experiencia de consultoría de gran éxito, que me

permitió presentar un diseño inicial a todo el equipo, que jamás había participado en un proyecto

de POO, y que consistió en ir dibujando objetos en una pizarra, después de hablar sobre cómo se

deberían comunicar los objetos entre sí, y tras borrar algunos y reemplazar otros. Efectivamente,

estaban haciendo uso de "tarjetas CRC" en la propia pizarra. El equipo (que sabía que el proyecto se iba a hacer) creó, de hecho, el diseño; ellos eran los "propietarios" del diseño, más que recibirlo hecho directamente. Todo lo que yo hacía era guiar el proceso haciendo en cada momento las preguntas adecuadas, poniendo a prueba los distintos supuestos, y tomando la

realimentación del equipo para ir modificando los supuestos. La verdadera belleza del proyecto es

que el equipo aprendió cómo hacer diseño orientado a objetos no repasando ejemplos o resúmenes de ejemplos, sino trabajando en el diseño que les pareció más interesante en ese momento:

el de ellos mismos.

Una vez que se tiene un conjunto de tarjetas CRC se desea crear una descripción más formal del diseño haciendo uso de UML18. No es necesario utilizar UML, pero puede ser de gran ayuda, especialmente si se desea poner un diagrama en la pared para que todo el mundo pueda ponderarlo, lo

cual es una gran idea. Una alternativa a UML es una descripción textual de los objetos y sus interfaces, o, dependiendo del lenguaje de programación, el propio cÓdigol9.

UML también proporciona una notación para diagramas que permiten describir el modelo dinámico del sistema. Esto es útil en situaciones en las que las transiciones de estado de un sistema

o subsistema son lo suficientemente dominantes como para necesitar sus propios diagramas

(como ocurre en un sistema de control). También puede ser necesario describir las estructuras

de datos, en sistemas o subsistemas en los que los datos sean un factor dominante (como una

base de datos).

Sabemos que la Fase 2 ha acabado cuando se han descrito los objetos y sus interfaces. Bueno, la

mayoría -hay generalmente unos pocos que quedan ocultos y que no se dan a conocer hasta la

Fase 3. Pero esto es correcto. En lo que a uno respecta, esto es todo lo que se ha podido descubrir

de los objetos a manipular. Es bonito descubrirlos en las primeras etapas del proceso pero la PO0

proporciona una estructura tal, que no presenta problema si se descubren más tarde. De hecho, el

diseño de un objeto tiende a darse en cinco etapas, a través del proceso completo de desarrollo de

un programa.

'Vara los principiantes, recomiendo UML Distilled, 2." edición.

'"han (http://www.Python.orgJ suele utilizarse como "pseudocódigo ejecutable".

1: Introducción a los objetos 41

Las cinco etapas del diseño de un objeto

La duración del diseño de un objeto no se limita al tiempo empleado en la escritura del programa, sino

que el diseño de un objeto conlleva una serie de etapas. Es útil tener esta perspectiva porque se deja de

esperar la perfección; por el contrario, uno comprende lo que hace un objeto y el nombre que debería

tener surge con el tiempo. Esta visión también se aplica al diseño de varios tipos de programas; el patrón

para un tipo de programa particular emerge al enfrentarse una y otra vez con el problema (esto se encuentra descrito en el libro Thinking in Patterns with Java, descargable de http://www. BruceEckel.com).

Los objetos, también tienen su patrón, que emerge a través de su entendimiento, uso y reutiliiación.

1. Descubrimiento de los objetos. Esta etapa ocurre durante el análisis inicial del programa. Se

descubren los objetos al buscar factores externos y limitaciones, elementos duplicados en el sistema, y las unidades conceptuales más pequeñas. Algunos objetos son obvios si ya se tiene un conjunto de bibliotecas de clases. La comunidad entre clases que sugieren clases bases y herencia, puede aparecer también en este momento, o más tarde dentro del proceso de diseño.

2. Ensamblaje de objetos. Al construir un objeto se descubre la necesidad de nuevos miembros

que no aparecieron durante el descubrimiento. Las necesidades internas del objeto pueden requerir de otras clases que lo soporten.

3. Construcción del sistema. De nuevo, pueden aparecer en esta etapa más tardía nuevos requisitos para el objeto. Así se aprende que los objetos van evolucionando. La necesidad de un objeto de

comunicarse e interconectarse con otros del sistema puede hacer que las necesidades de las clases

existentes cambien, e incluso hacer necesarias nuevas clases. Por ejemplo, se puede descubrir la necesidad de clases que faciliten o ayuden, como una lista enlazada, que contiene poca o ninguna información de estado y simplemente ayuda a la función de otras clases.

4. Aplicación del sistema. A medida que se añaden nuevos aspectos al sistema, puede que se descubra que el diseño previo no soporta una ampliación sencilla del sistema. Con esta nueva información, puede ser necesario reestructurar partes del sistema, generalmente añadiendo nuevas clases

o nuevas jerarquías de clases.

5. Reutilización de objetos. Ésta es la verdadera prueba de diseño para una clase. Si alguien trata de reutilizarla en una situación completamente nueva, puede que descubra pequeños inconvenientes. Al cambiar una clase para adaptarla a más programas nuevos, los principios generales de la

clase se mostrarán más claros, hasta tener un tipo verdaderamente reutilizable. Sin embargo, no

debe esperarse que la mayoría de objetos en un sistema se diseñen para ser reutilizados -es perfectamente aceptable que un porcentaje alto de los objetos sean específicos del sistema para el que

fueron diseñados. Los tipos reutilizables tienden a ser menos comunes, y deben resolver problemas

más generales para ser reutilizables.

Guías para el desarrollo de objetos

Estas etapas sugieren algunas indicaciones que ayudarán a la hora de pensar en el desarrollo de

clases:

1. Debe permitirse que un problema específico genere una clase, y después dejar que la clase

crezca y madure durante la solución de otros problemas.

Piensa en Java

Debe recordarse que descubrir las clases (y SUS interfaces) que uno necesita es la tarea principal del diseño del sistema. Si ya se disponía de esas clases, el proyecto será fácil.

No hay que forzar a nadie a saber todo desde el principio; se aprende sobre la marcha.Y esto

ocurrirá poco a poco.

Hay que empezar programando; es bueno lograr algo que funcione de manera que se pueda

probar la validez o no de un diseño. No hay que tener miedo a acabar con un código de estilo

procedimental malo -las clases segmentan el problema y ayudan a controlar la anarquía y la

entropía. Las clases malas no estropean las clases buenas.

Hay que mantener todo lo más simple posible. Los objetos pequeños y limpios con utilidad obvia son mucho mejores que interfaces grandes y complicadas. Cuando aparecen puntos de diseño puede seguirse el enfoque de una afeitadora de Occam: se consideran las alternativas y

se selecciona la más simple, porque las clases simples casi siempre resultan mejor. Hay que

empezar con algo pequeño y sencillo, siendo posible ampliar la interfaz de la clase al entenderla mejor. A medida que avance el tiempo será difícil eliminar elementos de una clase.

Fase 3: Construir el núcleo

Ésta es la conversión inicial de diseño pobre en un código compilable y ejecutable que pueda ser

probado, y especialmente, que pueda probar la validez o no de la arquitectura diseñada. Este proceso no se puede hacer de una pasada, sino que consistirá más bien en una serie de pasos que permitirán construir el sistema de manera iterativa, como se verá en la Fase 4.

Su objetivo es encontrar el núcleo de la arquitectura del sistema que necesita implementar para generar un sistema ejecutable, sin que importe lo incompleto que pueda estar este sistema en esta fase

inicial. Está creando un armazón sobre el que construir en posteriores iteraciones. También se está

llevando a cabo la primera de las muchas integraciones y pruebas del sistema, a la vez que proporcionando a los usuarios una realimentación sobre la apariencia que tendrá su sistema, y cómo va

progresando. Idealmente, se están además asumiendo algunos riesgos críticos. De hecho, se descubrirán posibles cambios y mejoras que se pueden hacer sobre el diseño original -cosas que no

se hubieran descubierto de no haber implementado el sistema.

Una parte de la construcción del sistema es comprobar que realmente se cumple el análisis de requisitos y la especificación del sistema que realmente cumple el analisis de requisitos y la especificación del sistema (independientemente de la forma en que estén planteados). Debe asegurarse que

las pruebas verifican los requerimientos y los casos de uso. Cuando el corazón del sistema sea estable, será posible pasar a la siguiente fase y añadir nuevas funcionalidades.

Fase 4: Iterar los casos de uso

Una vez que el núcleo del sistema está en ejecución, cada característica que se añada es en sí misma un pequeño proyecto. Durante cada iteración, entendida como un periodo de desarrollo razonablemente pequeño, se añade un conjunto de características.

1 : Introducción a los objetos 43

$tíal debe ser la duración de una iteración? Idealmente, cada iteración dura de una a tres semanas

(la duración puede variar en función del lenguaje de implementación). Al final de ese periodo, se tiene un sistema integrado y probado con una funcionalidad mayor a la que tenía previamente. Pero lo

particularmente interesante es la base de la iteración: un único caso de uso. Cada caso de uso es un

paquete de funcionalidad relacionada que se construye en el sistema de un golpe, durante una iteración. Esto no sólo proporciona una mejor idea de lo que debería ser el ámbito de un caso de uso,

sino que además proporciona una validación mayor de la idea del mismo, dado que el concepto no

queda descartado hasta después del análisis y del diseño, pues éste es una unidad de desarrollo fundamental a lo largo de todo el proceso de construcción de software.

Se deja de iterar al lograr la funcionalidad objetivo, o si llega un plazo y el cliente se encuentra satisfecho con la versión actual (debe recordarse que el software es un negocio de suscripción). Dado

que el proceso es iterativo, uno puede tener muchas oportunidades de lanzar un producto, más que

tener un único punto final; los proyectos abiertos trabajan exclusivamente en entornos iterativos de

gran nivel de realimentación, que es precisamente lo que les permite acabar con éxito.

Un proceso de desarrollo iterativo tiene gran valor por muchas razones. Si uno puede averiguar y

resolver pronto los riesgos críticos, los clientes pueden tener muchas oportunidades de cambiar de

idea, la satisfacción del programador es mayor, y el proyecto puede guiarse con mayor precisión.

Pero otro beneficio adicional importante es la realimentación a los usuarios, que pueden ver a través del estado actual del producto cómo va todo. Así es posible reducir o eliminar la necesidad de

reuniones de estado "entumece-mentes" e incrementar la confianza y el soporte de los usuarios.

Fase 5: Evolución

Éste es el punto del ciclo de desarrollo que se ha denominado tradicionalmente "mantenimiento",

un término global que quiere decir cualquier cosa, desde "hacer que funcione de la manera que se

suponía que lo haría en primer lugar", hasta "añadir aspectos varios que el cliente olvidó mencionar", pasando por el tradicional "arreglar los errores que puedan aparecer" o "la adición de nuevas

características a medida que aparecen nuevas necesidades". Por ello, al término "mantenimiento" se

le han aplicado numerosos conceptos erróneos, lo que ha ocasionado un descenso progresivo de su

calidad, en parte porque sugiere que se construyó una primera versión del programa en la cual hay

que ir cambiando partes, además de engrasarlo para evitar que se oxide. Quizás haya un término

mejor para describir lo que está pasando.

Prefiero el término evolución2". De esta forma, "uno no acierta a la primera, por lo que debe concederse la libertad de aprender y volver a hacer nuevos cambios". Podríamos necesitar muchos cambios a medida que vamos aprendiendo y comprendiendo con más detenimiento el problema. A corto y largo plazo, será el propio programa el que se verá beneficiado de este proceso continuo de

evolución. De hecho, ésta permitirá que el programa pase de bueno a genial, haciendo que se aclaren aquellos aspectos que no fueron verdaderamente entendidos en la primera pasada. También es

20 El libro de Martin Fowler Refactoring: improuing the design of existing code (Addison-Wesley, 1999) cubre al menos un aspecto de

la evolución, utilizando exclusivamente ejemplos en Java.

44 Piensa en Java

en este proceso en el que las clases se convierten en recursos reutilizables, en vez de clases diseñadas para su uso en un solo proyecto.

"Hacer el proyecto bien" no sólo implica que el programa funcione de acuerdo con los requisitos y

casos de uso. También quiere decir que la estructura interna del código tenga sentido, y que parezca que encaja bien, sin aparentar tener una sintaxis extraña, objetos de tamaño excesivo o con

fragmentos inútiles de código. Además, uno debe tener la sensación de que la estructura del programa sobrevivirá a los cambios que inevitablemente irá sufriendo a lo largo de su vida, y de que

esos cambios se podrán hacer de forma sencilla y limpia. Esto no es trivial. Uno no sólo debe entender qué es lo que está construyendo, sino también cómo evolucionará el programa (lo que yo

denomino el vector del cambio). Afortunadamente, los lenguajes de programación orientada a objetos son especialmente propicios para soportar este tipo de modificación continua -los límites creados por los objetos son los que tienden a lograr una estructura sólida. También permiten hacer cambios -que en un programa procedural parecerían drásticos- sin causar terremotos a lo largo del

código. De hecho, el soporte a la evolución podría ser el beneficio más importante de la POO.

Con la evolución, se crea algo que al menos se aproxima a lo que se piensa que se-está construyendo, se compara con los requisitos, y se ve dónde se ha quedado corto. Después, se puede volver

y ajustarlo diseñando y volviendo a implementar las porciones del programa que no funcionaron correctamente". De hecho, es posible que se necesite resolver un problema, o determinado aspecto

de un problema, varias veces antes de dar con la solución correcta (suele ser bastante útil estudiar

en este momento el Diseño de Patrones). También es posible encontrar información en Thinking in

Patterns with Java, descargable de http://www. BruceEcke1.com).

La evolución también se da al construir un sistema, ver que éste se corresponda con los requisitos,

y descubrir después que no era, de hecho, lo que se pretendía. Al ver un sistema en funcionamiento, se puede dcscubrir que verdaderamente se pretendía que solucionase otro problema. Si uno espera que se dé este tipo de evolución, entonces se debe construir la primera versión lo más rápidamente posible con el propósito de averiguar sin lugar a dudas qué es exactamente lo que se desea.

Quizás lo más importante que se ha de recordar es que por defecto, si se modifica una clase, sus

súper y subclases seguirán funcionando. Uno no debe tener miedo a la modificación (especialmente si se dispone de un conjunto de pruebas, o alguna prueba individual que permita verificar la corrección de las modificaciones). Los cambios no tienen por qué estropear el programa, sino que

cualquiera de las consecuencias de un cambio se limitarán a las subclases y/o colaboradores específicos de la clase que se modifica.

Los planes merecen la pena

Por supuesto, uno jamás construiría una casa sin unos planos cuidadosamente elaborados. Si construyéramos un hangar o la casa de un perro, los planes no tendrían tanto nivel de detalle, pero pro-

?' Esto es semejante a la elaboración de "prototipos rápidos", donde se supone que uno construyc una versión "rápida y sucia" que

permite comprender mejor el sistema, pero que es después desechada para construirlo correctamente. El problema con el prototipado rápido es que los equipos de desarrollo no suelen desechar completamente el prototipo, sino que lo utilizan como base sobre la que construir. Si se combina, en la programación procedural, con la falta de estructura, se generan sistemas totalmente com- plicados, y difíciles de mantener.

1: Introducción a los objetos 45

bablemente comenzaríamos con una serie de esbozos que nos permitiesen guiar el proceso. El desarrollo de software ha llegado a extremos. Durante mucho tiempo, la gente llevaba a cabo desarrollos sin mucha estructura, pero después, comenzaron a fallar los grandes procesos. Como reacción, todos acabamos con metodologías que conllevan una cantidad considerable de estructura y

detalle, eso sí, diseñadas, en principio, para estos grandes proyectos. Estas metodologías eran demasiado tediosas de usar -parecía que uno invertiría todo su tiempo en escribir documentos, y que

no le quedaría tiempo para programar (y esto ocurría a menudo). Espero haber mostrado aquí una

serie de sugerencias intermedias. Independientemente de lo pequeño que sea, es necesario algún

tipo de plan, que redundará en una gran mejora en el proyecto, especialmente respecto del que se

obtendría si no se hiciera ningún plan de ningún tipo. Es necesario recordar que en muchas estimaciones, falla más del 50 por ciento del proyecto (iincluso en ocasiones se llega al 70 por ciento!).

Siguiendo un plan -preferentemente uno simple y breve- y siguiendo una estructura de diseño

antes de la codificación, se descubre que los elementos encajan mejor, de modo más sencillo que si

uno se zambulle y empieza a escribir código sin ton ni son. También se alcanzará un nivel de satisfacción elevado. La experiencia dice que al lograr una solución elegante uno acaba completamente

satisfecho, a un nivel totalmente diferente; uno se siente más cercano al arte que a la tecnología. Y

la elegancia siempre merece la pena; no se trata de una pcrsccución frívola. De hccho, no solamente proporciona un programa más fácil de construir y depurar, sino que éste es mucho más fácil de

entender y mantener, que es precisamente donde reside su valor financiero.

Programación extrema

Una vez estudiadas las técnicas de análisis y diseño, por activa y por pasiva durante mucho tiempo,

quizás el concepto de programación extrema (Extreme Programming, XP) sea el más radical y sorprendente que he visto. Es posible encontrar información sobre él mismo en Extreme Programming

Explained, de Kent Beck (Addison-Wesley 2000), que puede encontrarse también en la

Web en http://www.xprogramming. com.

XP es tanto una filosofía del trabajo de programación como un conjunto de guías para acometer esta

tarea. Algunas de estas guías se reflejan en otras metodologías recientes, pero las dos contribuciones más distintivas e importantes en mi opinión son "escribir las pruebas en primer lugar" y "la programación a pares". Aunque Beck discute bastante todo el proceso en sí, señala que si se adoptan

únicamente estas dos prácticas, uno mejorará enormemente su productividad y nivel de confianza.

Escritura de las pruebas en primer lugar

El proceso de prueba casi siempre ha quedado relegado al final de un proyecto, una vez que "se tiene todo trabajando, pero hay que asegurarlo". Implícitamente, tenía una prioridad bastante baja, y la

gente que se especializa en las pruebas nunca ha gozado de un gran estatus, e incluso suele estar

ubicada en el sótano, lejos de los "programadores de verdad". Los equipos de pruebas se han amoldado tanto a esta consideración que incluso han llegado a vestir de negro, y han chismorreado alegremente cada vez que lograban encontrar algún fallo (para ser honestos, ésta es la misma sensación que yo tenía cada vez que lograba encontrar algún fallo en un compilador).

46 Piensa en Java

XP revoluciona completamente el concepto de prueba dándole una prioridad igual (o incluso mayor)

que a la codificación. De hecho, se escriben los tests antes de escribir el código a probar, y los códigos se mantienen para siempre junto con su código destino. Es necesario ejecutar con éxito los

tests cada vez que se lleva a cabo un proceso de integración del proyecto (lo cual ocurre a menudo,

en ocasiones más de una vez al día).

Al principio la escritura de las pruebas tiene dos efectos extremadamente importantes.

El primero es que fuerza una definición clara de la interfaz de cada clase. Yo, en numerosas ocasiones he sugerido que la gente "imagine la clase perfecta para resolver un problema particular" como

una herramienta a utilizar a la hora de intentar diseñar el sistema. La estrategia de pruebas XP va

más allá -especifica exactamente qué apariencia debe tener la clase para el consumidor de la clase, y cómo ésta debe comportarse exactamente. No puede haber nada sin concretar. Es posible escribir toda la prosa o crear todos los diagramas que se desee, describiendo cómo debería comportarse una clase, pero nada es igual que un conjunto de pruebas. Lo primero es una lista de deseos,

pero las pruebas son un contrato reforzado por el compilador y el programa en ejecución. Cuesta

imaginar una descripción más exacta de una clase que la de los tests.

Al crear los tests, uno se ve forzado a pensar completamente en la clase, y a menudo, descubre la

funcionalidad deseada que podría haber quedado en el tintero durante las experiencias de pensamiento de los diagramas XML, las tarjetas CRC, los casos de uso, etc.

El segundo efecto importante de escribir las pruebas en primer lugar, proviene de la ejecución de

las pruebas cada vez que se construye un producto software. Esta actividad proporciona la otra

mitad de las pruebas que lleva a cabo el compilador. Si se observa la evolución de los lenguajes

de programación desde esta perspectiva, se llegará a la conclusión de que las verdaderas mejoras

en lo que a tecnología se refiere han tenido que ver con las pruebas. El lenguaje ensamblador solamente comprobaba la sintaxis, pero C imponía algunas restricciones semánticas, que han evitado que se produzca cierto tipo de errores. Los lenguajes PO0 imponen incluso más restricciones

semánticas, que miradas así no son, de hecho, sino métodos de prueba. "¿Se está utilizando correctamente este tipo de datos?", y "¿se está invocando correctamente a esta función?" son algunos de los tipos de preguntas que hace un compilador o un sistema en tiempo de ejecución. Se

han visto los resultados de tener estas pruebas ya incluidas en el lenguaje: la gente parece ser capaz de escribir sistemas más completos y hacer que funcionen, con menos cantidad de tiempo y

esfuerzo. He intentado siempre averiguar la razón, pero ahora lo tengo claro, son las pruebas:

cada vez que se hace algo mal, la red de pruebas de seguridad integradas dice que hay un problema y determina dónde.

Pero las pruebas integradas permitidas por el diseño del lenguaje no pueden ir mucho más allá.

En cierto punto, cada uno debe continuar y añadir el resto de pruebas que producen una batería

de pruebas completa (en cooperación con el compilador y el sistema en tiempo de ejecución) que

verifique todo el programa. Y, exactamente igual que si se dispusiera de un compilador observando por encima del hombro, ¿no desearía uno que estas pruebas le ayudasen a hacer todo bien

desde el principio? Por eso es necesario escribir las pruebas en primer lugar y ejecutarlas cada

vez que se reconstruya el sistema. Las pruebas se convierten en una extensión de la red de seguridad proporcionada por el lenguaje.

1 : Introducción a los objetos 47

Una de las cosas que he descubierto respecto del uso de lenguajes de programación cada vez más

y más potentes es que conducen a la realización de experimentos cada vez más duros, pues se sabe

a priori que el propio lenguaje evitará pérdidas innecesarias de tiempo en la localización de errores.

El esquema de pruebas XP hace lo mismo para todo el proyecto. Dado que se sabe que las pruebas

localizarán cualquier problema que pueda aparecer en la vida del proyecto (y cada vez que se nos

ocurra alguno), simplemente se introducen nuevas pruebas), es posible hacer cambios, incluso

grandes, cuando sea necesario sin preocuparse de que éstos puedan cargarse todo el proyecto. Esto

es increíblemente potente.

Programación a pares

La programación a pares (por parejas) va más allá del férreo individualismo al que hemos sido adoctrinados desde el principio, a través de las escuelas (donde es uno mismo el que fracasa o tiene éxito), de los medios de comunicación, especialmente las películas de Hollywood, en las que el héroe

siempre lucha contra la conformidad sin sentido". Los programadores, también, suelen considerarse abanderados de la individualidad -"los vaqueros codificadores" como suele llamarlos Larry

Constantine. Y por el contrario, XP, que trata, de por sí, de luchar contra el pensamiento convencional, enuncia lo contrario, afirmando que el código debería siempre escribirse entre dos personas por

cada estación de trabajo. Y esto debería hacerse en áreas en las que haya grupos de estaciones de

trabajo, sin las barreras de las que la gente de facilidades de diseno suelen estar tan orgullosos. De

hecho, Beck dice que la primera tarea para convertirse a XP es aparecer con destornilladores y llaves Allen y desmontar todo aquello que parezca imponer barreras o separaciones'" (esto exige contar con un director capaz de hacer frente a todas las quejas del departamento de infraestructuras).

El valor de la programación en pareja es que una persona puede estar, de hecho, codificando mientras la otra piensa en lo que se está haciendo. El pensador es el que tiene en la cabeza todo el esbozo -y no sólo una imagen del problema que se está tratando en ese momento, sino todas las

guías del XP. Si son dos las personas que están trabajando, es menos probable que uno de ellos huya

diciendo "No quiero escribir las pruebas lo primero", por ejemplo. Y si el codificador se queda clavado, pueden cambiar de sitio. Si los dos se quedan parados, puede que alguien más del área de trabajo pueda contribuir al oír sus meditaciones. Trabajar a pares hace que todo fluya mejor y a tiempo. Y lo que probablemente es más importante: convierte la programación en una tarea mucho más

divertida y social.

He comenzado a hacer uso de la programación en pareja durante los periodos de ejercitación en algunos de mis seminarios, llegando a la conclusión de que mejora significativamente la experiencia

de todos.

" Aunque probablemente ésta sea mas una perspectiva americana, las historias de Hollywood llegan a todas partes.

23 Incluido (especialmente) el sistema PA. Trabajé una vez en una compañia que insistía en difundir a todo el mundo cualquier Ilamada entrante que recibieran los ejecutivos, lo cual interrumpía continuamente la productividad del equipo (pero los directores no

podían empezar siquiera a pensar en prescindir de un servicio tan importante como el PA). Al final, y cuando nadie me veía, me

encargué de cortar los cables de los altavoces.

48 Piensa en Java

Por qué Java tiene éxito

La razón por la que Java ha tenido tanto éxito es que su propósito era resolver muchos de los problemas a los que los desarrolladores se enfrentan hoy en día. El objetivo de Java es mejorar la productividad. Esta productividad se traduce en varios aspectos, pero el lenguaje fue diseñado para ayudar lo máximo posible, dejando en manos de cada uno la mínima cantidad posible, tanto de reglas

arbitrarias, como de requisitos a usar en determinados conjuntos de aspectos. Java fue diseñado

para ser práctico; las decisiones de diseño del lenguaje Java se basaban en proporcionar al programador la mayor cantidad de beneficios posibles.

Los sistemas son más fáciles de expresar

y entender

Las clases diseñadas para encajar en el problema tienden a expresarlo mejor. Esto significa que al

escribir el código uno está describiendo su solución en términos del espacio del problema, en vez

de en términos del computador, que es el espacio de la solución ("Pon el bit en el chip que indica

que el relé se va cerrar"). Uno maneja conceptos de alto nivel y puede hacer mucho más con una

única línea de código.

El otro beneficio del uso de esta expresión es la mantenibilidad que (si pueden creerse los informes) se lleva una porción enorme del coste de un programa durante toda su vida. Si un programa

es fácil de entender, entonces es fácil de mantener. Esto también puede reducir el coste de crear y

mantener la documentación.

Ventajas máximas con las bibliotecas

La manera más rápida de crear un programa es utilizar código que ya esté escrito: una biblioteca.

Uno de los principales objetivos de Java es facilitar el uso de bibliotecas. Esta meta se logra convirtiendo las bibliotecas en nuevos tipos de datos (clases), de forma que la incorporación de una biblioteca equivale a la inserción de nuevos tipos al lenguaje. Dado que el compilador de Java se encarga del buen uso de las bibliotecas -garantizando una inicialización y eliminación completas, y

asegurando que se invoca correctamente a las funciones- uno puede centrarse en lo que desea que

haga la biblioteca en vez de cómo tiene que hacerlo.

Manejo de errores

El manejo de errores en C es un importante problema, que suele ser frecuentemente ignorado o

que se trata de evitar cruzando los dedos. Si se está construyendo un programa grande y complejo,

no hay nada peor que tener un error enterrado en algún sitio sin tener ni siquiera una pista de dónde puede estar. El manejo de excepciones de Java es una forma de garantizar que se notifiquen los

errores, y que todo ocurre como consecuencia de algo.

programación a lo grande 

Muchos lenguajes de programación "tradicionales" tenían limitaciones intrínsecas en lo que al tamaño y complejidad del programa se refiere. BASIC, por ejemplo, puede ser muy bueno para poner 

juntas soluciones rápidas para cierto tipo de problemas, pero si el programa se hace mayor de varias páginas, o se sale del dominio normal del problema, es como intentar nadar en un fluido cada 

vez más viscoso. No hay una línea clara que permita separar cuándo está fallando el lenguaje, y si 

la hubiera, la ignoraríamos. Uno no dice "Mi programa en BASIC simplemente creció demasiado; 

tendré que volver a escribirlo en C". Más bien se intenta meter con calzador unas pocas líneas para 

añadir alguna nueva característica. Por tanto, el coste extra viene dependiendo de uno mismo. 

Java está diseñado para ayudar a programar a lo grande -es decir, para borrar esos límites de complejidad entre un programa pequeño y uno grande. Uno no tiene por qué usar PO0 al escribir un 

programa de utilidad del estilo de "iHola, mundo!", pero estas características siempre están ahí 

cuando son necesarias. Y el compilador se muestra agresivo a la hora de descubrir las causas generadora~ de errores, tanto eri el caso de programas gr arides, corrio pequeíius. 

Estrategias para la transición 

Si uno se introduce en la POO, la siguiente pregunta será probablemente "¿Cómo puedo hacer que 

mi director, mis colegas, mi departamento,. . . empiecen a usar objetos?". Uno debe pensar en cómo 

él mismo -un programador independiente- se sentiría a la hora de aprender un nuevo lenguaje y 

un nuevo paradigma de programación. A fin de cuentas, ya lo ha hecho antes. Lo primero es la educación y el uso de ejemplos, después viene un proyecto de prueba que proporcione una idea clara 

de los fundamentos sin hacer algo demasiado confuso. Después viene un proyecto "del mundo real" 

que, de hecho, haga algo útil. A lo largo de los primeros proyectos, uno sigue su educación leyendo y preguntando a los expertos, a la vez que solucionando pequeños inconvenientes con los colegas. Éste es el enfoque que muchos programadores experimentados sugieren de cara a migrar a 

Java. Cambiar una compañía entera, por supuesto implicaría la introducción de alguna dinámica de 

grupo, pero ayudará a recordar en cada paso cómo debería desenvolverse cada uno. 

Guías 

He aquí algunas ideas o guías a tener en cuenta cuando se haga la transición a PO0 y Java: 

1. Formación 

El primer paso es algún tipo dc educación. Hay que recordar la inversión en código de la compañía, 

e intentar no tirar todo a la basura durante los seis a nueve meses que lleve a todo el mundo enterarse de cómo funcionan las interfaces. Es mejor seleccionar un pequeño grupo para adoctrinarles, 

compuesto preferentemente por personas curiosas, y que trabajen bien en grupo, que pueda luego 

funcionar como una red de soporte propia mientras se esté aprendiendo Java. 

50 Piensa en Java 

Un enfoque alternativo recomendado en ocasiones, es formar a todos los niveles de la compañía a 

la vez, incluidos cursos muy por encima para los directores de estrategia, además de cursos de diseño y programación para los constructores de proyectos. Esto es especialmente bueno para las pequeñas compañías que cambian continuamente la manera de hacer las cosas, o a nivel de divisiones 

en aquellas compañías de gran tamaño. Dado que el coste es elevado, sin embargo, hay que elegir 

empezar de alguna manera con la formación a nivel de proyecto, llevar a cabo un proyecto piloto 

(posiblemente con un formador externo) y dejar que el equipo de proyecto se convierta en el grupo de profesores del resto de la compañía. 

2. Proyecto de bajo riesgo 

Es necesario empezar con un proyecto de bajo riesgo y permitir los errores. Una vez que se ha adquirido cierta experiencia, uno puede alimentarse bien de proyectos de miembros del mismo equipo, o bien utilizar a los miembros del equipo como personal de soporte técnico para POO. Puede 

que el primer proyecto no funcione correctamente a la primera, por lo que no debería ser crítico con 

la misión de la compañía. Debería ser simple, independiente, e instructivo; esto significa que debería conllevar la creación de clases con significado para cuando les llegue el turno de aprender Java 

al resto de empleados de la compañía. 

3. Modelo que ya ha tenido éxito 

Es necesario buscar ejemplos con un buen diseño orientado a objetos en vez de empezar de la nada. 

Hay muchas posibilidades de que exista alguien que ya haya solucionado el problema en cuestión, 

o que si no lo ha solucionado del todo pueda aplicar lo ya aprendido sobre la abstracción para modificar un diseño ya existente en aras de que se ajuste a tus necesidades. Éste es el concepto general de los patrones de diseño, cubiertos en Thinking in Patterns with Java, descargable de 

http://www. BruceEcke1. com. 

4. Utilizar bibliotecas de clases existentes 

La motivación económica principal para cambiar a PO0 es la facilidad de usar código ya existente 

en forma de bibliotecas de clases (en particular las bibliotecas estándares de Java, cubiertas completamente a lo largo de este libro). Se obtendrá el ciclo de desarrollo más pequeño posible cuando 

se puedan crear y utilizar objetos de bibliotecas preconfeccionadas. Sin embargo, algunos programadores novatos no entienden este concepto, y son inconscientes de la existencia de bibliotecas de 

clases. El éxito con la PO0 y Java será óptimo si se hace un esfuerzo para buscar y reutilizar el código ya desarrollado cuanto antes en el proceso de transición. 

5. No reescribir en Java código ya existente 

No suele ser la mejor de las ideas tomar código ya existente y que funcione y reescribirlo en Java 

(si se convierten en objetos, es posible interactuar con código ya escrito en C o C++ haciendo uso 

de la Interfaz Nativa Java (lava Native Interface) descrito en el Apéndice B). Hay beneficios incrementales, especialmente si cl código va a ser reutilizado. Pero todas las opciones pasan porque no 

se darán los incrementos drásticos de productividad que uno pudiera esperar para su primer pro- 

1 : Introducción a los objetos 51 

yecto a no ser que se acometa uno totalmente nuevo. Java y la PO0 brillan mucho más cuando se 

pasa de un proyecto conceptual al real correspondiente. 

Obstáculos de gestión 

Para aquél que sea director, su trabajo consiste en adquirir los recursos para el equipo, superar las 

barreras que puedan dificultar el éxito del equipo, y en general, intentar proporcionar el entorno 

más productivo que permita al equipo disfrutar y conseguir así, llevar a cabo esos milagros que 

siempre se exigen. Pasarse a Java implica estas tres características, y sería maravilloso que el coste 

fuera, además nulo. Aunque pasarse a Java puede ser más barato -en función de las limitaciones 

de cada uno- que las alternativas de la PO0 para un equipo de programadores en C (y probablemente para los programadores de otros lenguajes procedurales) no es gratuito, y hay obstáculos de 

los que uno debería ser consciente a la hora de vender el pasarse a Java dentro de una compañía y 

quedar totalmente embarrancado. 

Costes iniciales 

El coste de pasarse a Java es mayor que el de adquirir compiladores de Java (el compilador de Java 

de Sun es gratuito, así que éste difícilmente podría constituir un obstáculo). Los costes a medio y 

largo plazo se minimizan si se invierte en formación (y posiblemente si se utiliza un formador durante el primer proyecto) y también si se identifica y adquiere una biblioteca de clases que solucione el problema en vez de intentar construir esas bibliotecas uno mismo. Éstos son costes muy elevados que deben ser cuantificados en una propuesta realista. Además, están los costes ocultos de la 

pérdida de productividad implícita en el aprendizaje de un nuevo lenguaje, y probablemente un nuevo entorno de programación. La formación y la búsqueda de un formador pueden, a ciencia cierta, 

minimizar estos costes, pero los miembros del equipo deberán sobreponerse a sus propios problemas para comprender la nueva tecnología. Durante este proceso, ellos cometerán más fallos (éste 

es un aspecto importante, pues los errores reconocidos son la forma más rápida de aprender) y serán menos productivos. Incluso entonces, con algunos tipos de problemas de programación, las clases correctas y el entorno de desarrollo correcto, es posible ser más productivo mientras se está 

aprendiendo Java (incluso considerando que se están cometiendo más fallos y escribiendo menos 1íneas de código cada día) que si se continuara con C. 

Aspectos de rendimiento 

Una pregunta frecuente es "¿La PO0 hace que los programas se conviertan en más grandes y lentos 

automáticamente?". La respuesta es: "Depende". Los aspectos extra de seguridad de Java tradicionalmente han conllevado una penalización en el rendimiento, frente a lenguajes como C++. Las tecnologías como "hotspot" y las tecnologías de compilación han mejorado significativamente la velocidad en 

la mayoría dc los casos, y se continúan haciendo esfuerzos para lograr un rendimiento aún mayor. 

Cuando uno se centra en un prototipado rápido, es posible desechar conjuntamente componentes lo 

más rápido posible, a la vez que se ignoran ciertos aspectos de eficiencia. Si se utilizan bibliotecas 

de un tercero, éstas suelen estar optimizadas por el propio fabricante; en cualquier caso, esto no es 

un problema cuando uno está en modo de desarrollo rápido. Cuando se tiene el sistema deseado, 

52 Piensa en Java 

que sea lo suficientemente pequeño y rápido, entonces, ya está. Si no, hay que empezar a reescribir 

pequeñas porciones de código. Si a pesar de esto no se mejora, hay que pensar cómo hacer modificaciones en la implementacion subyacente, de forma que no haya ningún código que use una clase 

concreta que vaya a ser modificada. Sólo si no se encuentra ninguna otra solución al problema se 

acometerán posibles cambios en el diseño. El hecho de que el rendimiento sea crítico en esa porción del diseño es un indicador que debe formar parte del criterio de diseño principal. La utilización 

del desarrollo rápido ofrece la ventaja de poder averiguar esto muy pronto. 

Si se encuentra una función que constituya un cuello de botella, es posible reescribirla en C/C++ haciendo uso de los métodos nativos de Java, sobre los que versa el Apéndice B. 

Errores de diseño comunes 

Cuando un equipo empieza a trabajar en PO0 y Java, los programadores cometerán una serie de 

errores de diseño comunes. Esto ocurre a menudo debido a que hay una realimentación insuficiente 

por parte de los expertos durante el discño e implementación de los primeros proyectos, puesto que 

no han aparecido expertos dentro de la compañía y porque puede que haya cierta resistencia en la 

empresa para retener a los consultores. Es fácil que si alguien cree entender la PO0 desde las primeras etapas del ciclo trate de atajar a través de una tangente errónea. Algo que es obvio a los ojos 

de una persona experta en el lenguaje, puede llegar a constituir un gran problema o debate interno 

para un novato. Podría evitarse un porcentaje elevado de este trauma si se utilizara un experto externo experimentado como formador y consejero. 

LJava frente a C++? 

Java se parece bastante a C++, y naturalmente podría parecer que C++ está siendo reemplazado por 

Java. Pero me empiezo a cuestionar esta lógica. Para algunas cosas, C++ sigue teniendo una serie 

de características que Java no tiene, y aunque ha habido muchas promesas de que algún día Java 

llegará a ser tan o más rápido que C++, hasta la fecha solamente hemos sido testigos de ligeras mejoras, sin innovaciones drásticas. También parece que sigue habiendo un interés continuo en C++, 

por lo que es improbable que este lenguaje desaparezca con el tiempo. (Los lenguajes siempre merodean por ahí. En uno de los "Seminarios de Java Intermedio/Avanzado" del autor Allen Holub afirmó que los lenguajes más comúnmente utilizados son Rexx y COBOL, en ese orden.) 

Comienzo a pensar que la fuerza de Java reside en un ruedo ligeramente diferente al de C++. Éste 

es un lenguaje que no trata de encajar en un molde. Verdaderamente, se ha adaptado de distintas 

maneras para resolver problemas particulares. Algunas herramientas de C++ combinan bibliotecas, 

modelos de componente, y herramientas de generación de código para resolver el problema de desarrollar aplicaciones de ventanas para usuarios finales (para Microsoft Windows). Y sin embargo, 

¿qué es lo que utilizan la gran mayoría de desarrolladores en Windows? Visual Basic m) de 

Microsoft. Y esto a pesar del hecho de que VB produce el tipo de código que se convierte en inmanejable en cuanto el programa tiene una ampliación de unas pocas páginas (además de proporcionar una sintaxis que puede ser incluso mística). VB es tan mal ejemplo de lenguaje de diseño 

como exitoso y popular. Por ello sería bueno disponer de la facilidad y potencia de VB sin que el resultado fuera código imposible de gestionar. Y es aquí donde Java debería destacar: como el "próxi- 

1 : Introducción a los objetos 53 

mo VB". Uno puede estremecerse al leer esto, o no, pero al menos debería pensar en ello: es tan 

grande la porción de Java diseñada para facilitar la tarea del programador a la hora de enfrenarse a 

problemas de nivel de aplicación como las redes o las interfaces de usuario multiplataforma, y además tiene un diseño de lenguaje que hace posible la creación de bloques de código flexibles y de 

gran tamaño. Si se añade a esto el hecho de que Java es el lenguaje con los sistemas de comprobación de tipos y manejo de errores más robustos jamás vistas en un lenguaje, se tienen las bases para 

dar un gran paso adelante en lo que se refiere a productividad de la programación. 

¿Debería utilizarse Java en vez de C++ para un proyecto determinado? En vez de applets de web, deben considerarse dos aspectos. El primero es que si se desea utilizar muchas de las bibliotecas de 

C++ ya existentes (logrando una considerable ganancia en productividad) o si se dispone de un código base ya existente en C o C++, Java podría ralentizar el desarrollo en vez de acelerarlo. 

Si se está desarrollando el código por primera vez desde la nada, la simplicidad de Java frente a C++ 

acortará significativamente el tiempo de desarrollo -la evidencia anecdótica (historias de equipos 

que desarrollan en C++ y que siempre cuento a aquéllos que se pasan a Java) sugiere que se doble 

la velocidad de desarrollo frente a C++. Si el rendimiento de Java no importa o puede compensarse, 

los aspectos puramente de tiempo de lanzamiento hacen difícil justificar la elección de C++ frente a 

Java. 

El aspecto más importante es el rendimiento. El código Java interpretado siempre ha sido lento, incluso entre 20 y 50 veces más lento que C en el caso de los primeros intérpretes de Java. Este aspecto, no obstante, ha mejorado considerablemente a lo largo del tiempo, aunque sigue siendo del 

orden de varias veces superior. Los computadores se fundamentan en la velocidad; si hacer algo en 

un computador no es considerablemente más rápido, lo hacemos a mano. (Incluso se sugiere que 

se empiece con Java, para reducir el tiempo de desarrollo, para posteriormente utilizar una herramienta y bibliotecas de soporte que permitan traducir el código a C++, cuando se necesite una velocidad de ejecución más rápida.) 

La clave para hacer Java adecuado para la mayoría de proyectos de desarrollo es la aparición de mejoras en cuanto a velocidad, como los denominados compiladores just-in-time WIT), la tecnología 

"hotspot" de Sun, e incluso compiladores de código nativo. Por supuesto, estos últimos eliminan la ejecución multiplataforma de los programas compilados, pero también proporcionan una mejora de velocidad al ejecutable, que se acerca a la que se lograría con C y C++. Y compilar un programa multiplataforma en Java sería bastante más sencillo que hacerlo en C o C++. (En teoría, simplemente es 

necesario recompilar, pero esto ya se ha prometido también antes en otros lenguajes de programación). 

Es posible encontrar comparaciones entre Java y C++, y observaciones sobre las realidades de Java 

en los apéndices de la primera edición de este libro (disponible en el CD ROM que acompaña al presente texto, además de en http://www. BruceEcke1.com). 

Resumen 

Este capítulo trata de dar un repaso a los aspectos más importantes de la programación orientada a 

objetos y Java, incluyendo el porqué la PO0 es diferente, y por qué Java en particular es diferente, 

54 Piensa en Java 

conceptos de metodologías de POO, y finalmente las situaciones que se dan al hacer que una compañía pase a PO0 y Java. 

La PO0 y Java pueden no ser para todo el mundo. Es importante evaluar las propias necesidades y 

decidir si Java podría satisfacer completamente esas necesidades, o si no sería mejor hacer uso de 

otro sistema de programación (incluyendo el que se esté utilizando actualmente). Si se sabe que las 

necesidades serán muy especializadas en un futuro próximo y que se tienen limitaciones específicas, puede que Java no sea la solución más satisfactoria, por lo que uno debe investigar las posibles 

alternativasz4. Incluso si eventualmente se elige Java como lenguaje, uno debe al menos entender 

cuáles eran las opciones y tener una visión clara de por qué eligió dirigirse en esa dirección. 

La apariencia de un lenguaje de programación procedural es conocida: definiciones de datos y llamadas a funciones. Para averiguar el significado de estos programas hay que invertir cierto tiempo, 

echando un vistazo a las llamadas a función y a conceptos de bajo nivel para crearse un modelo en 

la mente. Ésta es la razón por la que son necesarias representaciones intermedias al diseñar programas procedurales -por sí mismos, estos programas tienden a ser confusos porque los términos 

de expresión suelen estar más orientados hacia el computador que hacia el problema que se trata 

de resolver. 

Dado que Java añade muchos conceptos nuevos sobre lo que tienen los lenguajes procedurales, es 

algo natural pensar que el método main() de un programa en Java será bastante más complicado 

que su equivalente en un programa en C. Se verá que las definiciones de los objetos que representan conceptos en el espacio del problema (en vez de hacer uso de aspectos de representación del 

computador) además de los mensajes que se envían a los mismos, representan las actividades en 

ese mismo espacio. Una de las maravillas de la programación orientada a objetos es ésa: con un programa bien diseñado, es fácil entender el código simplemente leyéndolo. Generalmente hay también 

menos código, porque muchos de los problemas se resolverán reutilizando código de las bibliotecas 

ya existentes. 

2Tecomiendo, en particular, echar un vistazo a Python (http:(//www.Python.org). 

2: Todo es 

un objeto 

Aunque se basa en C++, Java es más un lenguaje orientado a objetos "puro". 

Tanto C++ como Java son lenguajes híbridos, pero en Java los diseñadores pensaban que esa "hibridación" no era tan importante como lo era en C++. Un lenguaje híbrido permite múltiples estilos 

de programación; la razón por la que C++ es híbrido es soportar la compatibilidad hacia atrás con el 

lenguaje C. Dado que C++ es un superconjunto del lenguaje C, incluye muchas de las características no deseables de ese lenguaje, lo que puede provocar que algunos aspectos de C++ sean demasiado complicados. 

El lenguaje Java asume que se desea llevar a cabo exclusivamente programación orientada a objetos. Esto significa que antes de empezar es necesario cambiar la forma de pensar hacia el mundo 

de la orientación a objetos (a menos que ya esté en él). El beneficio de este esfuerzo inicial es la habilidad para programar en un lenguaje que es más fácil de aprender y usar que otros muchos lenguajes de POO. En este capítulo, veremos los componentes básicos- de un programa Java y aprenderemos que todo en Java es un objeto, incluido un programa Java. 

Los objetos se manipulan 

mediante referencias 

Cada lenguaje de programación tiene sus propios medios de manipular datos. Algunas veces, el 

programador debe ser consciente constantemente del tipo de manipulación que se está produciendo. ¿Se está manipulando directamente un objeto, o se está tratando con algún tipo de representación indirecta (un puntero en C o C++) que debe ser tratada con alguna sintaxis especial? 

Todo esto se simplifica en Java. Todo se trata como un objeto, de forma que hay una única sintaxis 

consistente que se utiliza en todas partes. Aunque se trata todo como un objeto, el identificador que 

se manipula es una "referencia" a un objeto1. Se podría imaginar esta escena como si se tratara de 

' Esto puede suponer un tema de debate. Existe quien piensa que "claramente, es un puntero", pero esto presupone una implementación subyacente. Además, las referencias de Java son mucho más parecidas en su sintaxis a las referencias de C++ que a punteros. En la primera edición del presente libro, el autor decidió inventar un nuevo término, "empuñadura" porque las referencias 

C++ y las referencias Java tienen algunas diferencias importantes. El autor provenía de C++ y no deseaba confundir a los programadores de C++ que supuestamente serían la mejor audiencia para Java. En la 2" edición, el autor decidió que el término más co- múnmente usado era el término "referencia", y que cualquiera que proviniera de C++ tendría que lidiar con mucho más que con la 

terminología de las referencias, por lo que podrán incorporarse sin problemas. Sin embargo, hay personas que no están de acuer- do siquiera con el término "referencia". El autor leyó una vez un libro en el que "era incorrecto decir que Java soporta el paso por 

referencia", puesto que los identificadores de objetos en Java (en concordancia con el citado autor) son de hecho "referencias a objetos". 'Y (continúa el citado texto), todo se pasa de hecho por valor. Por tanto, si no se pasan parámetros por referencia, se está pasando una referencia a un objeto por valor". Se podría discutir la precisión de semejantes explicaciones, pero el autor considera que 

su enfoque simplifica el entendimiento del concepto sin herir a nadie (bueno, los abogados del lenguaje podrían decir que el autor 

miente, pero creo que la abstracción que se presenta es bastante apropiada). 

56 Piensa en Java 

una televisión (el objeto) con su mando a distancia (la referencia). A medida que se hace uso de la 

referencia, se está conectado a la televisión, pero cuando alguien dice "cambia de canal" o "baja el 

volumen", lo que se manipula es la referencia, que será la que manipule el objeto. Si desea moverse por la habitación y seguir controlando la televisión, se toma el mando a distancia (la referencia), 

en vez de la televisión. 

Además, el mando a distancia puede existir por sí mismo, aunque no haya televisión. Es decir, el 

mero hecho de tener una referencia no implica necesariamente la existencia de un objeto conectado al mismo. De esta forma si se desea tener una palabra o frase, se crea una referencia String: 

String S; 

Pero esta sentencia solamente crea la referencia, y no el objeto. Si se decide enviar un mensaje a S 

en este momento, se obtendrá un error (en tiempo de ejecución) porque S no se encuentra, de hecho, vinculado a nada (no hay televisión). Una práctica más segura, por consiguiente, es inicializar 

la referencia en el mismo momento de su creación: 

String S = "asdf'; 

Sin embargo, esta sentencia hace uso de una característica especial de Java: las cadenas de texto 

pueden inicializarse con texto entre comillas. Normalmente, es necesario usar un tipo de inicialización más general para los objetos. 

Uno debe crear 

todos los objetos 

Cuando se crea una referencia, se desea conectarla con un nuevo objeto. Así se hace, en general, 

con la palabra clave new, que dice "Créame un objeto nuevo de ésos". Por ello, en el ejemplo anterior se puede decir: 

String s = new String ( "asdf" ) ; 

Esto no sólo significa "Créame un nuevo String", sino que también proporciona información sobre 

cómo crear el String proporcionando una cadena de caracteres inicial. 

Por supuesto, String no es el único tipo que existe. Java viene con una plétora de tipos predefinidos. Lo más importante es que uno puede crear sus propios tipos. De hecho, ésa es la actividad 

fundamental de la programación en Java, y es precisamente lo que se irá aprendiendo en este 

libro. 

Dónde reside el almacenamiento 

Es útil visualizar algunos aspectos relativos a cómo se van disponiendo los elementos al ejecutar el 

programa, y en particular, sobre cómo se dispone la memoria. Hay seis lugares diferentes en los que 

almacenar información: 

2: Todo es un objeto 57 

1. Registros. Son el elemento de almacenamiento más rápido porque existen en un lugar distinto al de cualquier otro almacenamiento: dentro del procesador. Sin embargo, el número de 

registros está severamente limitado, de forma que los registros los va asignando el compilador en función de sus necesidades. No se tiene control directo sobre ellos, y tampoco hay ninguna evidencia en los programas de que los registros siquiera existan. 

2. La pila. Reside en la memoria RAM (memoria de acceso directo) general, pero tiene soporte directo del procesador a través del puntero de pila. Éste se mueve hacia abajo para crear 

más memoria y de nuevo hacia arriba para liberarla. Ésta es una manera extremadamente rápida y eficiente de asignar espacio de almacenamiento, antecedido sólo por los registros. El 

compilador de Java debe saber, mientras está creando el programa, el tamaño exacto y la vida 

de todos los datos almacenados en la pila, pues debe generar el código necesario para mover 

el puntero hacia arriba y hacia abajo. Esta limitación pone límites a la flexibilidad de nuestros 

programas, de forma que mientras existe algún espacio de almacenamiento en la pila -referencias a objetos en particular- los propios objetos Java no serán ubicados en la pila. 

El montículo. Se trata de un espacio de memoria de propósito general (ubicado también en 

el área RAM) en el que residen los objetos Java. Lo mejor del montículo es que, a diferencia 

de la pila, el compilador no necesita conocer cuánto espacio de almacenamiento necesita asignar al montículo o durante cuánto tiempo debe permanecer ese espacio dentro del montículo. 

Por consiguiente, manejar este espacio de almacenamiento proporciona una gran flexibilidad. 

Cada vez que se desee crear un objeto, simplemente se escribe el código, se crea utilizando la 

palabra new, y se asigna el espacio de almacenamiento en el montículo en el momento en que 

este código se ejecuta. Por supuesto hay que pagar un precio a cambio de esta flexibilidad: lleva más tiempo asignar espacio de almacenamiento del montículo que lo que lleva hacerlo en 

la pila (es decir, si se pudieran crear objetos en la pila en Java, como se hace en C++). 

4. Almacenamiento estático. El término "estático" se utiliza aquí con el sentido de "con una 

ubicación/posición fija" (aunque también sea en RAM). El almacenamiento estático contiene 

datos que están disponibles durante todo el tiempo que se esté ejecutando un programa. 

Podemos usar la palabra clave static para especificar que un elemento particular de un objeto 

sea estático, pero los objetos en sí nunca se sitúan en el espacio de almacenamiento estático. 

5. Almacenamiento constante. Los valores constantes se suelen ubicar directamente en el código del programa, que es seguro, dado que estos valores no pueden cambiar. En ocasiones, 

las constantes suelen ser acordonadas por sí mismas, de forma que puedan ser opcionalmente ubicadas en memoria de sólo lectura (ROM). 

6. Almacenamiento no-RAM. Si los datos residen completamente fuera de un programa, pueden existir mientras el programa no se esté ejecutando, fuera del control de dicho programa. 

Los dos ejemplos principales de esto son los objetos de flujo de datos (strearn), que se convierten en flujos o corrientes de bytes, generalmente para ser enviados a otra máquina, y los 

objetos persistentes, que son ubicados en el disco para que mantengan su estado incluso cuando el programa ha terminado. El truco con estos tipos de almacenamiento es convertir los objetos en algo que pueda existir en otro medio, y que pueda así recuperarse en forma de objeto basado en RAM cuando sea necesario. Java proporciona soporte para persistencia ligera, y 

58 Piensa en Java 

las versiones futuras de Java podrían proporcionar soluciones aún más complejas para la persistencia. 

Un caso especial: los tipos primitivos 

Hay un grupo de tipos que tiene un tratamiento especial: se trata de los tipos "primitivos", que se 

usarán frecuentemente en los programas. La razón para el tratamiento especial es que crear un objeto con new -especialmente variables pequeñas y simples- no es eficiente porque new coloca el 

objeto en el montículo. Para estos tipos, Java vuelve al enfoque de C y C++. Es decir, en vez de crear la variable utilizando new, se crea una variable "automática" que no es una referencia. La variable 

guarda el valor, y se coloca en la pila para que sea más eficiente. 

Java determina el tamaño de cada tipo primitivo. Estos tamaños no varían de una plataforma a otra 

como ocurre en la mayoría de los lenguajes. La invariabilidad de tamaño es una de las razones por 

las que Java es tan llevadero. 

Tipo primitivo 

boolean 

char 

byte 

short 

Tamaño 

- 

16 bits 

8 bits 

int 

long 

Todos los tipos numéricos tienen signo, de forma que es inútil tratar de utilizar tipos sin signo. 

1 1 1 1 

16 bits 

float 

double 

void 

El tamaño del tipo boolean no está explícitamente definido; sólo se especifica que debe ser capaz 

de tomar los valores true o false. 

Mínimo 

- 

Unicode O 

- 12s 

32 bits 

64 bits 

Los tipos de datos primitivos también tienen clases "envoltura". Esto quiere decir que si se desea 

hacer un objeto no primitivo en el montículo para representar ese tipo primitivo, se hace uso del envoltorio asociado. Por ejemplo: 

- 21s 

32 bits 

64 bits 

- 

char c = 'x'; 

Character C = new Character (c) ; 

Máximo 

- 

Unicode 2'"l 

+127 

-231 

- 263 

Tipo de envoltura 

Boolean 

Character 

Byte 

+215-1 

IEEE754 

IEEE754 

- 

Short 

+231-1 

+26:-1 

Integer 

hng 

IEEE754 

IEEE754 

- 

Float 

Double 

Void 

2: Todo es un objeto 59 

O también se podría utilizar: 

Character C = new ~haracter ( 'x ' ) ; 

Las razones para hacer esto se mostrarán más adelante en este capítulo. 

Números de alta precisión 

Java incluye dos clases para llevar a cabo aritmética de alta precisión: BigInteger y BigDecimal. 

Aunque estos tipos vienen a encajar en la misma categoría que las clases "envoltorio", ninguna de 

ellas tiene un tipo primitivo. 

Ambas clases tienen métodos que proporcionan operaciones análogas que se lleven a cabo con tipos primitivos. Es decir, uno puede hacer con BigInteger y BigDecimal cualquier cosa que pueda 

hacer con un int o un float, simplemente utilizando llamadas a métodos en vez de operadores. 

Además, las operaciones serán más lentas dado que hay más elementos involucrados. Se sacrifica la 

velocidad en favor de la exactitud. 

BigInteger soporta enteros de precisión arbitraria. Esto significa que uno puede representar valores enteros exactos de cualquier tamaño y sin perder información en las distintas operaciones. 

BigDecimal es para números de coma flotante de precisión arbitraria; pueden usarse, por ejemplo, 

para cálculos monetarios exactos. 

Para conocer los detalles de los constructores y métodos que pueden invocarse para estas dos clases, puede recurrirse a la documentación existente en línea. 

Arrays en Java 

Virtualmente, todos los lenguajes de programación soportan arrays. Utilizar arrays en C y C++ es 

peligroso porque los arrays no son sino bloques de memoria. Si un programa accede al array fuera 

del rango de su bloque de memoria o hace uso de la memoria antes de la inicialización (errores de 

programación bastante frecuentes) los resultados pueden ser impredecibles. 

Una de los principales objetos de Java es la seguridad, de forma que muchos de los problemas habituales en los programadores de C y C++ no se repiten en Java. Está garantizado que un array en 

Java estará siempre inicializado, y que no se podrá acceder más allá de su rango. La comprobación 

de rangos se resuelve con una pequeña sobrecarga de memoria en cada array, además de verificar 

el índice en tiempo de ejecución, pero se asume que la seguridad y el incremento de productividad 

logrados merecen este coste. 

Cuando se crea un array de objetos, se está creando realmente un array de referencias a los objetos, y cada una de éstas se inicializa automáticamente con un valor especial representado por la palabra clave null. Cuando Java ve un null, reconoce que la referencia en cuestión no está señalando 

ningún objeto. Debe asignarse un objeto a cada referencia antes de utilizarla, y si se intenta hacer 

uso de una referencia que aún vale null, se informará de que se ha dado un problema en tiempo de 

ejecución. Por consiguiente, en Java se evitan los errores típicos de los arrays. 

60 Piensa en Java 

Uno también puede crear un array de tipos primitivos. De nuevo, es el compilador el que garantiza 

la inicialización al poner a cero la memoria que ocupará ese array. 

Se hablará del resto de arrays más detalladamente en capítulos posteriores. 

Nunca es necesario 

destruir un objeto 

En la mayoría de los lenguajes de programación, el concepto de tiempo de vida de una variable ocupa una parte importante del esfuerzo de programación. ¿Cuánto dura una variable? Si se supone que 

uno va a destruirla, ¿cuándo debe hacerse? La confusión relativa a la vida de las variables puede conducir a un montón de fallos, y esta sección muestra cómo Java simplifica enormemente esto al hacer el trabajo de limpieza por ti. 

Ámbito 

La mayoría de lenguajes procedurales tienen el concepto de alcance o ámbito. Éste determina tanto 

la visibilidad como la vida de los nombres definidos dentro de ese ámbito. En C, C++ y Java, el ámbito se determina por la ubicación de llaves O. Así, por ejemplo: 

I 

int x = 12; 

/* sólo x disponible */ 

t 

int q = 96; 

/* tanto x como q están disponibles */ 

/* sólo x disponible */ 

/* q está "fuera del ámbito o alcance" */ 

Una variable definida dentro de un ámbito solamente está disponible hasta que finalice su ámbito. 

Las tabulaciones hacen que el código Java sea más fácil de leer. Dado que Java es un lenguaje de formato libre, los espacios extra, tabuladores y retornos de carro no afectan al programa resultante. 

Fíjese que uno no puede hacer lo siguiente, incluso aunque sea legal en C y C++: 

int x = 12; 

t 

int x = 96; /* ilegal */ 

1 

2: Todo es un objeto 61 

El compilador comunicará que la variable x ya ha sido definida. Por consiguiente, la capacidad de C 

y C++ para "esconder" una variable de un ámbito mayor no está permitida, ya que los diseñadores 

de Java pensaron que conducía a programas confusos. 

Ámbito de los objetos 

Los objetos en Java no tienen la misma vida que los tipos primitivos. Cuando se crea un objeto Java 

haciendo uso de new, éste perdura hasta el final del ámbito. Por consiguiente, si se escribe: 

I 

String s = new String ("un string" ) ; 

1 /* Fin del ámbito */ 

la referencia S desaparece al final del ámbito. Sin embargo, el objeto String al que apunta S sigue 

ocupando memoria. En este fragmento de código, no hay forma de acceder al objeto, pues la única 

referencia al mismo se encuentra fuera del ámbito. En capítulos posteriores se verá cómo puede pasarse la referencia al objeto, y duplicarla durante el curso de un programa. 

Resulta que, dado que los objetos creados con new se mantienen durante tanto tiempo como se desee, en Java desaparecen un montón de posibles problemas propios de C++. Los problemas mayores parecen darse en C++ puesto que uno no recibe ningún tipo de ayuda del lenguaje para asegurarse de que los objetos estén disponibles cuando sean necesarios. Y lo que es aún más importante, 

en C++ uno debe asegurarse de destruir los objetos cuando se ha acabado con ellos. 

Esto nos conduce a una cuestión interesante. Si Java deja los objetos vivos por ahí, ¿qué evita que 

se llene la memoria provocando que se detenga la ejecución del programa? Éste es exactamente el 

tipo de problema que ocurriría en C++. Es en este punto en el que ocurren un montón de cosas "mágicas". Java tiene un recolector de basura, que recorre todos los objetos que fueron creados con new 

y averigua cuáles no serán referenciados más. Posteriormente, libera la memoria de los que han dejado de ser referenciados, de forma que la memoria pueda ser utilizada por otros objetos. Esto quiere decir que no es necesario que uno se preocupe de reivindicar ninguna memoria. Simplemente se 

crean objetos, y cuando posteriormente dejan de ser necesarios, desaparecen por sí mismos. Esto 

elimina cierta clase de problemas de programación: el denominado "agujero de memoria", que se 

da cuando a un programador se le olvida liberar memoria. 

Crear nuevos 

tipos de datos: clases 

Si todo es un objeto, ¿qué determina qué apariencia tiene y cómo se comporta cada clase de objetos? O dicho de otra forma, ¿qué establece el tipo de un objeto? Uno podría esperar que haya una 

palabra clave "type", lo cual ciertamente hubiera tenido sentido. Sin embargo, históricamente, la mayoría de lenguajes orientados a objetos han hecho uso de la palabra clave class para indicar Voy a 

decirte qué apariencia tiene un nuevo tipo de objeto". La palabra clave class (que se utilizará tanto 

62 Piensa en Java 

que no se pondrá en negrita a lo largo del presente libro) siempre va seguida del nombre del nuevo tipo. Por ejemplo: 

class UnNombreDeTipo { /* Aquí va el cuerpo de la clase */ } 

Esto introduce un nuevo tipo, de forma que ahora es posible crear un objeto de este tipo haciendo 

uso de la palabra clave new: 

UnNombreDeTipo u = new UnNombreDeTipo (); 

En UnNombreDeTipo, el cuerpo de la clase sólo consiste en un comentario (los asteriscos, las barras inclinadas y lo que hay dentro, que se discutirán más adelante en este capítulo), con lo que no 

hay demasiado que hacer con él. De hecho, uno no puede indicar que se haga mucho de nada (es 

decir, no se le puede mandar ningún mensaje interesante) hasta que se definan métodos para ella. 

Campos y métodos 

Cuando se define una clase @ todo lo que se hace en Java es definir clases, se hacen objetos de esas 

clases y se envían mensajes a esos objetos), es posible poner dos tipos de elementos en la nueva clase: datos miembros (denominados generalmente campos), y funciones miembros (típicamente llamados métodos). Un dato miembro es un objeto de cualquier tipo con el que te puedes comunicar a 

través de su referencia. También puede ser algún tipo primitivo (que no sea una referencia). Si es 

una referencia a un objeto, hay que inicializar esa referencia para conectarla a algún objeto real (utilizando new, como se ha visto antes) en una función especial denominada constructor (descrita completamente en el Capítulo 4). Si se trata de un tipo primitivo es posible inicializarla directamente en 

el momento de definir la clase (como se verá después, también es posible inicializar las referencias 

en este punto de la definición). 

Cada objeto mantiene el espacio de almacenamiento necesario para todos sus datos miembro; éstos 

no son compartido con otros objetos. He aquí un ejemplo de una clase y algunos de sus datos miembros: 

class SoloDatos t 

int i; 

f loat f; 

boolean b; 

1 

Esta clase no hace nada, pero es posible crear un objeto: 

SoloDatos S = new SoloDatos(); 

Es posible asignar valores a los datos miembros, pero primero es necesario saber cómo hacer referencia a un miembro de un objeto. Esto se logra escribiendo el nombre de la referencia al objeto, 

seguido de un punto, y a continuación el nombre del miembro del objeto: 

2: Todo es un objeto 63 

Por ejemplo: 

s.i = 47; 

s.f. = l.lf; 

f .b = false; 

También es posible que un objeto pueda contener otros datos que se quieran modificar. Para ello, 

hay que seguir "conectando los puntos". Por ejemplo: 

La clase SoloDrrtos no puede hacer nada que no sea guardar datos porque no tiene funciones miembro (métodos). Para entender cómo funcionan los métodos, es necesario entender los parámetros y 

valores de retorno, que se describirán en breve. 

Valores por defecto para los miembros primitivos 

Cuando un tipo de datos primitivo es un miembro de una clase, se garantiza que tenga un valor por 

defecto siempre que no se inicialice: 

1 Tipo primitivo 1 Valor por defecto 1 

1 boolean 1 false 1 

1 char 1 ~u0000~(null) 1 

1 short 1 (short)O 1 

1 int 

1 double 1 O.Od I 

Debe destacarse que los valores por defecto son los que Java garantiza cuando se usa la variable 

como miembro de una clase. Esto asegura que las variables miembro de tipos primitivos siempre serán inicializadas (algo que no ocurre en C++), reduciendo una fuente de errores. Sin embargo, este 

valor inicial puede no ser correcto o incluso legal dentro del programa concreto en el que se esté 

trabajando. Es mejor inicializar siempre todas las variables explícitamente. 

Esta garantía no se aplica a las variables "locales" -aquellas que no sean campos de clases. Por consiguiente, si dentro de una definición de función se tiene: 

1 int x; 

64 Piensa en Java 

Entonces x tomará algún valor arbitrario (como en C y C++); no se inicializará automáticamente a 

cero. Cada uno es responsable de asignar un valor apropiado a la variable x antes de usarla. Si uno 

se olvida, Java seguro que será mejor que C++: se recibirá un error en tiempo de compilación indicando que la variable debería haber sido inicializada. (Muchos compiladores de C++ advertirán sobre variables sin inicializar, pero en Java éstos se presentarán como errores.) 

Métodos, parámetros 

y valores de retorno 

Hasta ahora, el término fünción se ha utilizado para describir una subrutina con nombre. El término que se ha usado más frecuentemente en Java es método, al ser "una manera de hacer algo". Si se 

desea, es posible seguir pensando en funciones. Verdaderamente sólo hay una diferencia sintáctica, 

pero de ahora en adelante se usará el término "método" en lugar del término "función". 

Los métodos en Java determinan los mensajes que puede recibir un objeto. En esta sección se 

aprenderá lo simple que es definir un método. 

Las partes fundamentales de un método son su nombre, sus parámetros, el tipo de retorno y el cuerpo. He aquí su forma básica: 

tipoRetorno nombreMetodo ( /* lista de parámetros */ ) { 

/* Cuerpo del método */ 

1 

El tipo de retorno es el tipo del valor que surge del método tras ser invocado. La lista de parámetros indica los tipos y nombres de las informaciones que es necesario pasar a ese método. Cada método se identifica unívocamente mediante el nombre del método y la lista de parámetros. 

En Java los métodos pueden crearse como parte de una clase. Es posible que un método pueda ser invocado sólo por un objeto2, y ese objeto debe ser capaz de llevar a cabo esa llamada al método. Si se 

invoca erróneamente a un método de un objeto, se generará un error en tiempo de compilación. Se invoca a un método de un objeto escribiendo el nombre del objeto seguido de un punto y el nombre del 

método con su lista de argumentos, como: nombreObjeto.nombreMetodo(argl, arg2, arg3). Por 

ejemplo, si se tiene un método f( ) que no recibe ningún parámetro y devuelve un dato de tipo int, y 

si se tiene un objeto a para el que puede invocarse a f( ), es posible escribir: 

int x = a.f(); 

El tipo del valor de retorno debe ser compatible con el tipo de x. 

LOS métodos static, que se verán más adelante, pueden ser invocados por la clase, sin necesidad de un objeto. 

2: Todo es un objeto 65 

Este acto de invocar a un método suele denominarse envío de un mensaje a un objeto. En el ejemplo de arriba, el mensaje es f( ) y el objeto es a. La programación orientada a objetos suele resumirse como un simple "envío de mensajes a objetos". 

La lista de parametros 

La lista de parámetros de un método especifica la información que se le pasa. Como puede adivinarse, esta información -como todo lo demás en Java- tiene forma de objetos. Por tanto, lo que 

hay que especificar en la lista de parámetros son los tipos de objetos a pasar y el nombre a utilizar 

en cada uno. Como en cualquier situación en Java en la que parece que se estén manipulando directamente objetos, se están pasando referencias". El tipo de referencia, sin embargo, tiene que ser 

correcto. Si se supone, por ejemplo, que un parámetro debe ser un String, lo que se le pase debe 

ser una cadena de caracteres. 

Consideremos un método que reciba como parámetro un String, cuya definición, que debe ser ubicada dentro de la definición de la clase para que sea compilada, puede ser la siguiente: 

int almacenamiento (String S) { 

return s.length ) * 2; 

1 

Este método dice cuántos bytes son necesarios para almacenar la información de un String en particular (cada carácter de una cadena tiene 16 bits, o 2 bytes para soportar caracteres Unicode). El 

parámetro S es de tipo String. Una vez que se pasa S al método, es posible tratarlo como a cualquier 

otro objeto (se le pueden enviar mensajes). Aquí se invoca al método length( ), que es uno de los 

métodos para String; devuelve el número de caracteres que tiene la cadena. 

También es posible ver el uso de la palabra clave return, que hace dos cosas. Primero, quiere decir, "abandona el método, que ya hemos acabado". En segundo lugar, si el método produce un valor, ese valor se ubica justo después de la sentencia return. En este caso, el valor de retorno se produce al evaluar la expresión s.length( )*2. 

Se puede devolver el tipo que se desee, pero si no se desea devolver nada, hay que indicar que el 

método devuelve void. He aquí algunos ejemplos: 

boolean indicador () { return true; } 

float naturalLogBase () { return 2.718f; ] 

void nada () { return; } 

void nada2 () { } 

Cuando el tipo de retorno es void, se utiliza la palabra clave return sólo para salir del método, y es, 

por consiguiente, innecesaria cuando se llega al final del mismo. Es posible salir de un método en 

cualquier punto, pero si se te da un valor de retorno distinto de void, el compilador te obligará (meCon la excepción habitual de los ya mencionados tipos de datos "especiales" boolean, char, byte, short. int, long, float y double. Normalmente se pasan objetos, lo cual verdaderamente quiere decir que se pasan referencias a objetos. 

66 Piensa en Java 

diante mensajes de error) a devolver el tipo apropiado de datos independientemente de lo que devuelvas. 

En este punto, puede parecer que un programa no es más que un montón de objetos con métodos 

que toman otros objetos como parámetros y envían mensajes a esos otros objetos. Esto es, sin duda, 

mucho de lo que está ocurriendo, pero en el capítulo siguiente se verá cómo hacer el trabajo de bajo 

nivel detallado, tomando decisiones dentro de un método. Para este capítulo, será suficiente con el 

envío de mensajes. 

Construcción 

programa Java 

Hay bastantes aspectos que se deben comprender antes de ver el primer programa Java. 

Visibilidad de los nombres 

Un problema de los lenguajes de programación es el control de nombres. Si se utiliza un nombre 

en un módulo del programa, y otro programador utiliza el mismo nombre en otro módulo ¿cómo 

se distingue un nombre del otro para evitar que ambos nombres "colisionen"? En C éste es un problema particular puesto que un programa es un mar de nombres inmanejable. En las clases de Ctt 

(en las que se basan las clases de Java) anidan funciones dentro de las clases, de manera que no 

pueden colisionar con nombres de funciones anidadas dentro de otras clases. Sin embargo, C++ sigue permitiendo los datos y funciones globales, por lo que las colisiones siguen siendo posibles. 

Para solucionar este problema, C++ introdujo los espacios de nombres utilizando palabras clave 

adicionales. 

Java pudo evitar todo esto siguiendo un nuevo enfoque. Para producir un nombre no ambiguo para 

una biblioteca, el identificador utilizado no difiere mucho de un nombre de dominio en Internet. De 

hecho, los creadores de Java utilizaron los nombres de dominio de Internet a la inversa, dado que es 

posible garantizar que éstos sean únicos. Dado que mi nombre de dominio es BruceEckel.com, mi 

biblioteca de utilidad de manías debería llamarse com.bruceEckel.utilidad.manias. Una vez que 

se da la vuelta al nombre de dominio, los nombres supuestamente representan subdirectorios. 

En Java 1.0 y 1.1, las extensiones de dominio com, edu, org, net, etc. se ponían en mayúsculas por 

convención, de forma que la biblioteca aparecería como COM.bruceEckel.utilidad.manias. Sin 

embargo, a mitad de camino del desarrollo de Java 2, se descubrió que esto causaba problemas, por 

lo que de ahora en adelante se utilizarán minúsculas para todas las letras de los nombres de paquetes. 

Este mecanismo hace posible que todos sus ficheros residan automáticamente en sus propios espacios de nombres, y cada clase de un fichero debe tener un identificador único. Por tanto, uno 

no necesita aprender ninguna característica especial del lenguaje para resolver el problema -el 

lenguaje lo hace por nosotros. 

2: Todo es un objeto 67 

Utilización de otros componentes 

Cada vez que se desee usar una clase predefinida en un programa, el compilador debe saber dónde 

localizarla. Por supuesto, la clase podría existir ya en el mismo fichero de código fuente que la está 

invocando. En ese caso, se puede usar simplemente la clase -incluso si la clase no se define hasta 

más adelante dentro del archivo. Java elimina el problema de las "referencias hacia delante" de forma que no hay que pensar en ellos. 

¿Qué hay de las clases que ya existen en cualquier otro archivo? Uno podría pensar que el compilador debería ser lo suficientemente inteligente como para localizarlo por sí mismo, pero hay un problema. Imagínese que se quiere usar una clase de un nombre determinado, pero existe más de una 

definición de esa clase presumiblemente se trata de definiciones distintas). O peor, imagine que 

se está escribiendo un programa, y a medida que se está construyendo se añade una nueva clase a 

la biblioteca cuyo nombre choca con el de alguna clase ya existente. 

Para resolver este problema, debe eliminarse cualquier ambigüedad potencial. Esto se logra diciéndole al compilador de Java exactamente qué clases se quieren utilizar mediante la palabra clave import. Esta palabra clave dice al compilador que traiga un paquete, que es una biblioteca de clases 

(en otros lenguajes, una biblioteca podría consistir en funciones y datos además de clases, pero 

debe recordarse que en Java todo código debe escribirse dentro de una clase). 

La mayoría de las veces se utilizarán componentes de las bibliotecas de Java estándar que vienen 

con el propio compilador. Con ellas, no hay que preocuparse de los nombres de dominio largos y 

dados la vuelta; uno simplemente dice, por ejemplo: 

import java.util.ArrayList; 

para indicar al compilador que se desea utilizar la clase ArrayList de Java. Sin embargo, util contiene bastantes clases y uno podría querer utilizar varias de ellas sin tener que declararlas todas explícitamente. Esto se logra sencillamente utilizando el '*' que hace las veces de comodín: 

import java.util.*; 

Es más común importar una colección de clases de esta forma que importar las clases individualmente. 

La palabra clave static 

Generalmente, al crear una clase se está describiendo qué apariencia tienen sus objetos y cómo se 

comportan. No se tiene nada hasta crear un objeto de esa clase con new, momento en el que se crea 

el espacio de almacenamiento y los métodos pasan a estar disponibles. 

Pero hay dos situaciones en las que este enfoque no es suficiente. Una es cuando se desea tener solamente un fragmento de espacio de almacenamiento para una parte concreta de datos, independientemente de cuántos objetos se creen, o incluso aunque no se cree ninguno. La otra es si se necesita un método que no esté asociado con ningún objeto particular de esa clase. Es decir, se 

necesita un método al que se pueda invocar incluso si no se ha creado ningún objeto. Ambos efec- 

68 Piensa en Java 

tos se pueden lograr con la palabra clave estático. Al decir que algo es estático se está indicando 

que el dato o método no está atado a ninguna instancia de objeto de esa clase en particular. Por ello, 

incluso si nunca se creó un objeto de esa clase se puede invocar a un método estático o acceder a 

un fragmento de datos estático. Con los métodos y datos ordinarios no estático, es necesario crear 

un objeto y utilizarlo para acceder al dato o método, dado que los datos y métodos no estático deben conocer el objeto particular con el que está trabajando. Por supuesto, dado que los métodos estático no precisan de la creación de ningún objeto, no pueden acceder directamente a miembros o 

métodos no estático simplemente invocando a esos otros miembros sin referirse a un objeto con 

nombre (dado que los miembros y objetos no estático deber, estar unidos a un objeto en particular). 

Algunos lenguajes orientados a objetos utilizan los términos datos a nivel de clase y métodos a nivel 

de clase, para indicar que los datos y métodos solamente existen para la clase, y no para un objeto 

particular de la clase. En ocasiones, estos términos también se usan en los textos. 

Para declarar un dato o un miembro a nivel de clase estático, basta con colocar la palabra clave estático antes de la definición. Por ejemplo, el siguiente fragmento produce un miembro de datos estáticos y lo inicializa: 

class PruebaEstatica { 

static int i = 47; 

Ahora, incluso si se construyen dos objetos de Tipo PruebaEstatica, sólo habrá un espacio de almacenamiento para PruebaEstatica.i. Ambos objetos compartirán la misma i. Considérese: 

PruebaEstatica stl = new PruebaEstatica(); 

PruebaEstatica st2 = new PruebaEstaticaO; 

En este momento, tanto st1.i como st2.i tienen el valor 47, puesto que se refieren al mismo espacio de memoria. 

Hay dos maneras de referirse a una variable estática. Como se indicó más arriba, es posible nombrarlas a través de un objeto, diciendo, por ejemplo, st2.i. También es posible referirse a ella directamente a través de su nombre de clase, algo que no se puede hacer con miembros no estáticos 

(ésta es la manera preferida de referirse a una variable estática puesto que pone especial énfasis en 

la naturaleza estática de esa variable). 

El operador ++ incrementa la variable. En este momento, tanto st1.i como st2.i valdrán 48. 

Algo similar se aplica a los métodos estáticos. Es posible hacer referencia a ellos, bien a través de 

un objeto especificado al igual, que ocurre con cualquier método, o bien con la sintaxis adicional 

NombreClase.método( ). Un método estático se define de manera semejante: 

class FunEstatico { 

static void incr () { PruebaEstatica. i++; } 

1 

2: Todo es un objeto 69 

Puede observarse que el método incr( ) de FunEstatico incrementa la variable estática i. Se puede invocar a incr( ) de la manea típica, a través de un objeto: 

FunEstatico sf = new FunEstatico () ; 

sf. incr () ; 

O, dado que incr() es un método estático, es posible invocarlo directamente a través de la clase: 

1 FunEstatico. incr () ; 

Mientras que static al ser aplicado a un miembro de datos, cambia definitivamente la manera de 

crear los datos (uno por cada clase en vez de uno por cada objeto no estático), al aplicarse a un método, su efecto no es tan drástico. Un uso importante de estático para los métodos es permitir invocar a un método sin tener que crear un objeto. Esto, como se verá, es esencial en la definición del 

método main( ), que es el punto de entrada para la ejecución de la aplicación. 

Como cualquier método, un método estático puede crear o utilizar objetos con nombre de su propio tipo, de forma que un método estátjco se usa a menudo como un "pastor de ovejas" para un conjunto de instancias de su mismo tipo. 

Tu primer programa Java 

Finalmente, he aquí el programa4. Empieza imprimiendo una cadena de caracteres y posteriormente la fecha, haciendo uso de la clase Date, contenida en la biblioteca estándar de Java. Hay que tener en cuenta que se introduce un estilo de comentarios adicional: el '//', que permite insertar un 

comentario hasta el final de la línea: 

// HolaFecha . j ava 

import java.uti1. *; 

public class HolaFecha { 

public static void main(String[] args) { 

System.out.println ("Hola, hoy es: "); 

System. out .println (new Date () ) ; 

i 

1 

Al principio de cada fichero de programa es necesario poner la sentencia import para incluir cualquier clase adicional que se necesite para el código contenido en ese fichero. Nótese que digo "adi- 

'Algunos entornos de programación irán sacando programas en la pantalla, y luego los cerrarán antes de que uno tenga siquiera op 

ción a ver los resultados. Para detener la salida, se puede escribir el siguiente fragmento de código al final de la función main ( ); 

try I 

System. in. read () ; 

) catch(Exception e) (1 

Esto hará que la salida se detenga hasta presionar "Intro" (o cualquier otra tecla). Este código implica algunos conceptos que no se verán hasta mucho más adelante, por lo que todavía no lo podemos entender, aunque el truco es válido igualmente. 

70 Piensa en Java 

cional"; se debe a que hay una cierta biblioteca de clases que se carga automáticamente en todos 

los ficheros Java: la java.lang. Arranque su navegador web y eche un vistazo a la documentación de 

Sun (si no la ha bajado de java.sun.com o no ha instalado la documentación de algún otro modo, será 

mejor hacerlo ahora). Si se echa un vistazo a la lista de paquetes, se verán todas las bibliotecas de 

clases que incluye Java. Si se selecciona java.lang aparecerá una lista de todas las clases que forman parte de esa biblioteca. Dado que java.lang está incluida implícitamente en todos los archivos 

de código Java, todas estas clases ya estarán disponibles. En java.lang no hay ninguna clase Date, 

lo que significa que será necesario importarla de alguna otra biblioteca. Si se desconoce en qué biblioteca en particular está una clase, o si se quieren ver todas las clases, es posible seleccionar 

"Tree" en la documentación de Java. En ese momento es posible encontrar todas y cada una de las 

clases que vienen con Java. Después, es posible hacer uso de la función "buscar" del navegador 

para encontrar Date. Al hacerlo, se verá que está listada como java.util.Date, lo que quiere decir 

que se encuentra en la biblioteca util, y que es necesario importar java.util.* para poder usar Date. 

Si se vuelve al principio, se selecciona java.lang y después System, se verá que la clase System 

tiene varios campos, y si se selecciona out, se descubrirá que es un objeto estático PrintStream. 

Dado que es estático, no es necesario crear ningún objeto. El objeto out siempre está ahí y se 

puede usar directamente. Lo que se hace con el objeto out está determinado por su tipo: 

PrintStream. La descripción de este objeto se muestra, convenientemente, a través de un 

hipervínculo, por lo que si se hace clic en él se verá una lista de todos los métodos de PrintStream 

a los que se puede invocar. Hay unos cuantos, y se irán viendo según avancemos en la lectura del 

libro. Por ahora, todo lo que nos interesa es println( ), que significa "escribe lo que te estoy dando y finaliza con un retorno de carro". Por consiguiente, en cualquier programa Java que uno escriba se puede decir System.out.println("cosas") cuando se desee para escribir algo en la 

consola. 

El nombre de la clase es el mismo que el nombre del archivo. Cuando se está creando un programa independiente como éste, una de las clases del archivo tiene que tener el mismo nombre que el 

archivo. (El compilador se queja si no se hace así.) Esa clase debe contener un método llamado 

main( ), de la forma: 

1 public static void rnain (String[] args) ( 

La palabra clave public quiere decir que el método estará disponible para todo el mundo (como se 

describe en el Capítulo 5). El parámetro del método main( ) es un array de objetos String. Este 

programa no usará args, pero el compilador Java obliga a que esté presente, pues son los que mantienen los parámetros que se invoquen en la línea de comandos. 

La línea que muestra la fecha es bastante interesante: 

System.out .println (new Date () ) ; 

Considérese su argumento: se está creando un objeto Date simplemente para enviar su valor a 

println. Tan pronto como haya acabado esta sentencia, ese Date deja de ser necesario, y en cualquier momento aparecerá el recolector de basura y se lo llevará. Uno no tiene por qué preocuparse 

de limpiarlo. 

2: Todo es un objeto 7 1 

Compilación y ejecución 

Para compilar y ejecutar este programa, y todos los demás programas de este libro, es necesario disponer, en primer lugar, de un entorno de programación Java. Hay bastantes entornos de desarrollo 

de terceros, pero en este libro asumiremos que se está usando el JDK de Sun, que es gratuito. Si se 

está utilizando otro sistema de desarrollo, será necesario echar un vistazo a la documentación de 

ese sistema para determinar cómo se compilan y ejecutan los programas. 

Conéctese a Internet y acceda a jaua.sun.com. Ahí encontrará información y enlaces que muestran 

cómo descargar e instalar el JDK para cada plataforma en particular. 

Una vez que se ha instalado el JDK, y una vez que se ha establecido la información de path en el computador, para que pueda encontrar javac y java, se puede descargar e instalar el código fuente de este 

libro (que se encuentra en el CD ROM que viene con el libro, o en http.//www.BruceEckel.com). Al hacerlo, se creará un subdirectorio para cada capítulo del libro. Al ir al subdirectorio c02 y escribir: 

1 j avac HolaFecha . j ava 

no se obtendrá ninguna respuesta. Si se obtiene algún mensaje de error, se debe a que no se ha instalado el JDK correctamente, por lo que será necesario ir investigando los problemas que se muestren. 

Por otro lado, si simplemente ha vuelto a aparecer el prompt del intérprete de comandos, basta con 

teclear: 

1 java HolaFecha 

y se obtendrá como salida el mensaje y la fecha. 

Éste es el proceso a seguir para compilar y ejecutar cada uno de los programas de este libro. Sin embargo, se verá que el código fuente de este libro también tiene un archivo denominado makefile en 

cada capítulo, que contiene comandos "make" para construir automáticamente los archivos de ese capítulo. Puede verse la página web del libro en http://www.BruceEcke1.com para ver los detalles de uso 

de los makefiles. 

Comentarios y documentación 

empotrada 

Hay dos tipos de comentarios en Java. El primero es el estilo de comentarios tradicional de C, que 

fue heredado por C++. Estos comentarios comienzan por /* y pueden extenderse incluso a lo largo 

de varias líneas hasta encontrar */. Téngase en cuenta que muchos programadores comienzan cada 

línea de un comentario continuo por el signo *, por lo que a menudo se vera 

/ * Esto es un comentario 

* que se extiende 

* a lo largo de varias líneas 

* / 

72 Piensa en Java 

Hay que recordar, sin embargo, que todo lo que esté entre /* y */ se ignora, por lo que no hay ninguna diferencia con decir: 

/* Éste es un comentario que 

se extiende a lo largo de varias líneas */ 

La segunda forma de hacer comentarios viene de C++. Se trata del comentario en una sola línea que 

comienza por // y continúa hasta el final de la línea. Este tipo de comentario es muy conveniente y 

se utiliza muy frecuentemente debido a su facilidad de uso. Uno no tiene que buscar por el teclado 

donde está el / y el * (basta con pulsar dos veces la misma tecla), y no es necesario cerrar el comentario, por lo que a menudo se verá: 

// esto es un comentario en una sola línea 

Documentación en forma de comentarios 

Una de las partes más interesantes del lenguaje Java es que los diseñadores no sólo tuvieron en 

cuenta que la escritura de código era la única actividad importante -sino que también pensaron en 

la documentación del código. Probablemente el mayor problema a la hora de documentar el código 

es el mantenimiento de esa documentación. Si la documentación y el código están separados, cambiar la documentación cada vez que se cambia el código se convierte en un problema. La solución 

parece bastante simple: unir el código a la documentación. La forma más fácil de hacer esto es poner todo en el mismo archivo. Para completar la estampa, sin embargo, es necesaria alguna sintaxis 

especial de comentarios para marcarlos como documentación especial, y una herramienta para extraer esos comentarios y ponerlos en la forma adecuada. 

La herramienta para extraer los comentarios se denomina javadoc. Utiliza parte de la tecnología del 

compilador de Java para buscar etiquetas de comentario especiales que uno incluye en sus programas. No sólo extrae la información marcada por esas etiquetas, sino que también extrae el nombre 

de la clase o del método al que se adjunta el comentario. De esta manera es posible invertir la mínima cantidad de trabajo para generar una decente documentación para los programas. 

La salida de javadoc es un archivo HTML que puede visualizarse a través del navegador Web. Esta 

herramienta permite la creación y mantenimiento de un único archivo fuente y genera automáticamente documentación útil. Gracias a javadoc se tiene incluso un estándar para la creación de documentación, tan sencillo que se puede incluso esperar o solicitar documentación con todas las bibliotecas Java. 

Sintaxis 

Todos los comandos de javadoc se dan únicamente en comentarios /**. Estos comentarios acaban, 

como siempre, con */. Hay dos formas principales de usar javadoc: empotrar HTML, o utilizar "etiquetas doc". Las etiquetas doc son comandos que comienzan por '@' y se sitúan al principio de una 

línea de comentarios (en la que se ignora un posible primer '*'). 

Hay tres "tipos" de documentación en forma de comentarios, que se corresponden con el elemento 

al que precede el comentario: una clase, una variable o un método. Es decir, el comentario relativo 

2: Todo es un objeto 73 

a una clase aparece justo antes de la definición de la misma; el comentario relativo a una variable 

precede siempre a la definición de la variable, y un comentario de un método aparece inmediatamente antes de la definición de un método. Un simple ejemplo: 

/** Un comentario de clase */ 

public class PruebaDoc { 

/** Un comentario de una variable */ 

public int i; 

/** Un comentario de un método */ 

public void f () {} 

1 

Nótese que javadoc procesará la documentación en forma de comentarios sólo de miembros public 

y protected. Los comentarios para miembros private y "friendly" (véase Capítulo 5) se ignoran, no 

mostrándose ninguna salida (sin embargo es posible usar el modificador -private para incluir los 

miembros privados). Esto tiene sentido, dado que sólo los miembros públicos y protegidos son 

visibles fuera del objeto, que será lo que constituya la perspectiva del programador cliente. Sin embargo, la salida incluirá todos los comentarios de la clase. 

La salida del código anterior es un archivo HTML que tiene el mismo formato estándar que toda la 

documentación Java, de forma que los usuarios se sientan cómodos con el formato y puedan navegar de manera sencilla a través de sus clases. Merece la pena introducir estos códigos, pasarlos a 

través de javadoc y observar el fichero HTML resultante para ver los resultados. 

HTML empotrado 

Javadoc pasa comandos HTML al documento HTML generado. Esto permite un uso total de HTML; 

sin embargo, el motivo principal es permitir dar formato al código, como: 

/** 

* <pre> 

* System.out .println (new Date () ) ; 

* </pre> 

* / 

También puede usarse HTML como se haría en cualquier otro documento web para dar formato al 

propio texto de las descripciones: 

/ * * 

* Uno puede <em>incluso</em> insertar una lista: 

* <01> 

* <li> Elemento uno 

* <li> Elemento dos 

* <li> Elemento tres 

* </ol> 

74 Piensa en Java 

Nótese que dentro de los comentarios de documentación, los asteriscos que aparezcan al principio 

de las líneas serán desechados por javadoc, junto con los espacios adicionales a éstos. Javadoc vuelve a dar formato a todo adaptándolo a la apariencia estándar de la documentación. No deben utilizarse encabezados como <hl> o <hn como HTML empotrado porque javadoc inserta sus propios 

encabezados y éstos interferirían con ellos. 

Todos los tipos de documentación en comentarios -de clases, variables y métodos- soportan 

HTML empotrado. 

asee: referencias a otras clases 

Los tres tipos de comentarios de documentación (de clase, variable y métodos) pueden contener etiquetas asee, que permiten hacer referencia a la documentación de otras clases. Javadoc generará 

HTML con las etiquetas @see en forma de vínculos a la otra documentación. Las formas son: 

@see nombredeclase 

@see nombredeclase-totalmente-cualificada 

Fsee nombredeclase-totalmente-cualifi~ada#nombre-metodo 

Cada una añade un hipervínculo "Ver también" a la documentación generada. Javadoc no comprobará los hipervínculos que se le proporcionen para asegurarse de que sean válidos. 

Etiquetas de documentación de clases 

Junto con el HTML empotrado y las referencias asee, la documentación de clases puede incluir etiquetas de información de la versión y del nombre del autor. La documentación de clases también 

puede usarse para las interfaces (véase Capítulo 8). 

Es de la forma: 

1 @versión información-de-versión 

en el que información-de-versión es cualquier información significativa que se desee incluir. 

Cuando se especifica el indicador -versión en la línea de comandos javadoc, se invocará especialmente a la información de versión en la documentación HTML generada. 

Es de la forma: 

1 Fautor información-del-autor 

donde la información-del-autor suele ser el nombre, pero podría incluir también la dirección de correo electrónico u otra información apropiada. Al activar el parámetro -author en la línea de comandos 

javadoc, se invocará a la información relativa al autor en la documentación HTML generada. 

2: Todo es un objeto 75 

Se pueden tener varias etiquetas de autor, en el caso de tratarse de una lista de autores, pero éstas 

deben ponerse consecutivamente. Toda la información del autor se agrupará en un único párrafo en 

el HTML generado. 

Esta etiqueta permite indicar la versión del código que comenzó a utilizar una característica concreta. Se verá que aparece en la documentación para ver la versión de JDK que se está utilizando. 

Etiquetas de documentación de variables 

La documentación de variables solamente puede incluir HTML empotrado y referencias @see. 

Etiquetas de documentación de métodos 

Además de documentación empotrada y referencias @see, los métodos permiten etiquetas de documentación para los parámetros, los valores de retorno y las excepciones. 

eparam 

Es de la forma: 

1 @paran nombre-pardme tro descripción 

donde nombre-parámetro es el identificador de la lista de parámetros, y descripción es el texto 

que vendrá en las siguientes líneas. Se considera que la descripción ha acabado cuando se encuentra una nueva etiqueta de documentación. Se puede tener cualquier número de estas etiquetas, generalmente una por cada parámetro. 

Es de la forma: 

1 ereturn descripción 

donde descripción da el significado del valor de retorno. Puede ocupar varias líneas. 

Las excepciones se verán en el Capítulo 10, pero sirva como adelanto que son objetos que pueden "lanzarse" fuera del método si éste falla. Aunque al invocar a un método sólo puede lanzarse una excepción, 

podría ocurrir que un método particular fuera capaz de producir distintos tipos de excepciones, necesitando cada una de ellas su propia descripción. Por ello, la etiqueta de excepciones es de la forma: 

1 Fthrows nombre-de-clase-totalmente-cualificada descripción 

76 Piensa en Java 

donde nombre-de-clase-totalmente-cualificada proporciona un nombre sin ambigüedades de una 

clase de excepción definida en algún lugar, y descripción (que puede extenderse a lo largo de varias líneas) indica por qué podría levantarse este tipo particular de excepción al invocar al método. 

Se utiliza para etiquetar aspectos que fueron mejorados. Esta etiqueta es una sugerencia para que 

no se utilice esa característica en particular nunca más, puesto que en algún momento del futuro 

puede que se elimine. Un método marcado como @deprecated hace que el compilador presente 

una advertencia cuando se use. 

Ejemplo de documentación 

He aquí el primer programa Java de nuevo, al que en esta ocasión se ha añadido documentación en 

forma de comentarios: 

//: c02:HolaFecha.java 

import java.uti1. *; 

/** El primer ejemplo de Piensa en Java. 

* Muestra una cadena de caracteres y la fecha de hoy. 

* @author Bruce Eckel 

* @author www.BruceEckel.com 

* @version 2.0 

* / 

public class HolaFecha { 

/** Único punto de entrada para la clase y la aplicación 

* @param args array de cadenas de texto pasadas como 

parámetros 

* @return No hay valor de retorno 

* Fexception exceptions No se generarán excepciones 

* / 

public static void main (String[] args) { 

System.out .printlola, hoy es: ") ; 

System.out .println (new Date O ) ; 

La primera línea del archivo utiliza mi propia técnica de poner ":" como marcador especial de la línea de 

comentarios que contiene el nombre del archivo fuente. Esa línea contiene la información de la trayectoria al fichero (en este caso, c02 indica el Capítulo 2) seguido del nombre del archivo". La última línea 

también acaba con un comentario, esta vez indicando la finalización del listado de código fuente, que permite que sea extraído automáticamente del texto de este libro y comprobado por un compilador. 

Wna herramienta que he creado usando Python (ver http:liwww.Pyihori.org) utiliza esta información para extraer esos ficheros de 

código, ponerlos en los subdirectorios apropiados y crear los "makefiles". 

2: Todo es un objeto 77 

Estilo de codificación 

El estándar no oficial de java dice que se ponga en mayúsculas la primera letra del nombre de una 

clase. Si el nombre de la clase consta de varias palabras, se ponen todas juntas (es decir, no se usan 

guiones bajos para separar los nombres) y se pone en mayúscula la primera letra de cada palabra, 

como por ejemplo: 

En casi todo lo demás: métodos, campos (variables miembro), y nombres de referencias a objeto, el 

estilo aceptado es el mismo que para las clases, con la excepción de que la primera letra del identificador debe ser minúscula. Por ejemplo: 

class TodosLosColoresDelArcoiris { 

int unEnteroQueRepresentaUnColor; 

void cambiarElTonoDelColor (int nuevoTono) { 

// ... 

Por supuesto, hay que recordar que un usuario tendría que teclear después todos estos nombres largos, por lo que se ruega a los programadores que lo tengan en cuenta. 

El código Java de las bibliotecas de Sun también sigue la forma de apertura y cierre de las llaves 

que se utilizan en este libro. 

Resumen 

En este capítulo se ha visto lo suficiente de programación en Java como para entender cómo escribir un programa sencillo, y se ha realizado un repaso del lenguaje y algunas de sus ideas básicas. 

Sin embargo, los ejemplos hasta la fecha han sido de la forma "haz esto, después haz esto otro, y finalmente haz algo más". ¿Y qué ocurre si quieres que el programa presente alternativas, como "si 

el resultado de hacer esto es rojo, haz esto; sino, haz no se qué más?" El soporte que Java proporciona a esta actividad fundamental de programación se verá en el capítulo siguiente. 

tjercicios 

Las soluciones a determinados ejercicios se encuentran en el documento The Thinking in Java Annotated Solution 

Guide, disponible a bajo coste en http://www.BruceEcke1.com. 

1. Siguiendo el ejemplo HolaFecha.java de este capítulo, crear un programa "Hola, mundo" 

que simplemente escriba esa frase. Sólo se necesita un método en la clase (la clase "main" 

que es la que se ejecuta al arrancar el programa). Recordar hacerla static e incluir la lista de 

parámetros, incluso aunque no se vaya a usar. Compilar el programa con javac y ejecutarlo 

78 Piensa en Java 

utilizando java. Si se utiliza un entorno de desarrollo distinto a JDK, aprender a compilar y 

ejecutar programas en ese entorno. 

Encontrar los fragmentos de código involucrados en UnNombreDeTipo y convertirlos en 

un programa que se compile y ejecute. 

Convertir los fragmentos de código de SoloDatos en un programa que se compile y ejecute. 

Modificar el Ejercicio 3, de forma que los valores de los datos de SoloDatos se asignen e impriman en main( ). 

Escribir un programa que incluya y llame al método almacenamiento(), definido como fragmento de código en este capítulo. 

Convertir los fragmentos de código de FunEstatico en un programa ejecutable. 

Escribir un programa que imprima tres parámetros tomados de la línea de comandos. Para 

lograrlo, será necesario indexarlos en el array de Strings de línea de comandos. 

Convertir el ejemplo TodosLosColoresDelArcoiris en un programa que se compile y ejecute. 

Encontrar el código de la segunda versión de HolaFechajava, que es el ejemplo de documentación en forma de comentarios. Ejecutar javadoc del fichero y observar los resultados 

con el navegador web. 

Convertir PruebaDoc en un fichero que se compile y pasarlo por javadoc. Verificar la documentación resultante con el navegador web. 

Añadir una lista de elementos HTML a la documentación del Ejercicio 10. 

Tomar el programa del Ejercicio 10 y añadirle documentación en forma de comentarios. 

Extraer esta documentación en forma de comentarios a un fichero HTML utilizando javadoc 

y visualizarla con un navegador web. 

3: Controlar el flujo 

del programa 

Al igual que una criatura con sentimientos, un programa debe manipular su mundo y tomar decisiones durante su ejecución. 

En Java, se manipulan objetos y datos haciendo uso de operadores, y se toman decisiones con la ejecución de sentencias de control. Java se derivó de C++, por lo que la mayoría de esas sentencias y 

operadores resultarán familiares a los programadores de C y C++. Java también ha añadido algunas 

mejoras y simplificaciones. 

Si uno se encuentra un poco confuso durante este capítulo, acuda al CD ROM multimedia adjunto 

al libro: Thinking in C: Foundations for Java and C++. Contiene conferencias sonoras, diapositivas, 

ejercicios y soluciones diseñadas específicamente para ayudarle a adquirir familiaridad con la sintaxis de C necesaria para aprender Java. 

Utilizar operadores Java 

Un operador toma uno o más parámetros y produce un nuevo valor. Los parámebos se presentan de 

distinta manera que en las llamadas ordinarias a métodos, pero el efecto es el mismo. Uno debería estar razonablemente cómodo con el concepto general de operador con su experiencia de programación 

previa. La suma (+) , la resta y el menos unario (-) , la multiplicación (*), la división (/), y la asignación 

(=) funcionan todos exactamente igual que en el resto de lenguajes de programación. 

Todos los operadores producen un valor a partir de sus operandos. Además, un operador puede variar el valor de un operando. A esto se le llama efecto lateral. El uso más común de los operadores 

que modifican sus operandos es generar el efecto lateral, pero uno debería tener en cuenta que el 

valor producido solamente podrá ser utilizado en operadores sin efectos laterales. 

Casi todos los operadores funcionan únicamente con datos primitivos. Las excepciones las constituyen “=" , "==" y "!=", que funcionan con todos los objetos (y son una fuente de confusión para los objetos). Además, la clase String soporta "+" y "+=". 

Precedencia 

La precedencia de los operadores define cómo se evalúa una expresión cuando hay varios operadores en la misma. Java tiene reglas específicas que determinan el orden de evaluación. La más fácil 

de recordar es que la multiplicación y la división siempre se dan tras la suma y la resta. Los programadores suelen olvidar el resto de reglas de precedencia a menudo, por lo que se deberían usar 

paréntesis para establecer explícitamente el orden de evaluación. Por ejemplo: 

80 Piensa en Java 

tiene un significado diferente que la misma sentencia con una agrupación particular de paréntesis: 

Asignación 

La asignación se lleva a cabo con el operador =. Significa "toma el valor de la parte derecha (denominado a menudo dvalor) y cópialo a la parte izquierda (a menudo denominada ivalor"). Un ivalor 

es cualquier constante, variable o expresión que pueda producir un valor, pero un ivalor debe ser 

una variable única con nombre. (Es decir, debe haber un espacio físico en el que almacenar un valor.) Por ejemplo, es posible asignar un valor constante a una variable (A = 4;), pero no se puede 

asignar nada a un valor constante -no puede ser un ivalor. (No se puede decir 4 = A,.) 

La asignación de tipos primitivos de datos es bastante sencilla y directa. Dado que el dato primitivo 

alberga el valor actual y no una referencia a un objeto, cuando se asignan primitivas se copian los 

contenidos de un sitio a otro. Por ejemplo, si se dice A = B para datos primitivos, los contenidos de 

B se copian a A. Si después se intenta modificar A, lógicamente B no se verá alterado por esta modificación. Como programador, esto es lo que debería esperarse en la mayoría de situaciones. 

Sin embargo, cuando se asignan objetos, las cosas cambian. Siempre que se manipula un objeto, lo 

que se está manipulando es la referencia, por lo que al hacer una asignación "de un objeto a otro" 

se está, de hecho, copiando una referencia de un sitio a otro. Esto significa que si se escribe C = D 

siendo ambos objetos, se acaba con que tanto C como D apuntan al objeto al que originalmente sólo 

apuntaba D. El siguiente ejemplo demuestra esta afirmación. 

He aquí el ejemplo: 

//: c03:Asignacion.java 

// La asignación con objetos tiene su truco. 

class Numero { 

int i; 

public class Asignacion { 

public static void main (String[] args) { 

Numero nl = new Numero(); 

Numero n2 = new Numero () ; 

n1.i = 9; 

n2.i = 47; 

System.out.println("1:nl.i: " + n1.i + ", n2.i: " + n2.i); 

nl = n2; 

System.out.println("2: n1.i: " t n1.i t ", n2.i: " + n2.i); 

n1.i = 27; 

System.out .println ("3: nl. i: " + n1.i + ", n2.i: " + n2.i); 

3: Controlar el flujo del programa 81 

La clase Número es sencilla, y sus dos instancias (nl y n2) se crean dentro del método main(). 

Al valor i de cada Número se le asigna un valor distinto, y posteriormente se asigna n2 a nl, y se 

varía nl. En muchos lenguajes de programación se esperaría que nl y n2 fuesen independientes, 

pero dado que se ha asignado una referencia, he aquí la salida que se obtendrá: 

Al cambiar el objeto nl parece que se cambia el objeto n2 también. Esto ocurre porque, tanto nl, 

como n2 contienen la misma referencia, que apunta al mismo objeto. (La referencia original que estaba en nl que apuntaba al objeto que albergaba el valor 9 fue sobreescrita durante la asignación y, 

en consecuencia, se perdió; su objeto será eliminado por el recolector de basura.) 

A este fenómeno se le suele denominar uso de alias y es una manera fundamental que tiene Java de 

trabajar con los objetos. Pero, ¿qué ocurre si uno no desea que se dé dicho uso de alias en este caso? 

Uno podría ir más allá con la asignación y decir: 

Esto mantiene los dos objetos separados en vez de desechar uno y vincular nl y n2 al mismo objeto, pero pronto nos damos cuenta que manipular los campos de dentro de los objetos es complicado y atenta contra los buenos principios de diseño orientado a objetos. Este asunto no es trivial, 

por lo que se deja para el Apéndice A, dedicado al uso de alias. Mientras tanto, se debe recordar 

que la asignación de objetos puede traer sorpresas. 

Uso de alias durante llamadas a métodos 

También puede darse uso de alias cuando se pasa un objeto a un método: 

//: c03:PasarObjeto.java 

// Pasar objetos a métodos puede no ser aquello a lo que uno está 

// acostumbrado. 

class Carta { 

char c; 

1 

public class PasarObjecto { 

static void f(Carta y) { 

y.c = ' 1. z, 

1 

public static void main (String[] args) { 

Carta x = new Carta(); 

X.C = 'a'; 

System.out.println("I: x.c: " + x.c); 

f (x) ; 

System.out.printl("2:x.c: " + x.c); 

82 Piensa en Java 

En muchos lenguajes de programación el método f( ) parecería estar haciendo una copia de su argumento Carta y dentro del ámbito del método. Pero una vez más, se está pasando una referencia, 

por lo que la línea: 

y.c = 'z'; 

está, de hecho, cambiando el objeto fuera de f( ). La salida tiene el aspecto siguiente: 

El uso de alias y su solución son un aspecto complejo, y aunque uno debe esperar al Apéndice A 

para tener todas las respuestas, hay que ser consciente de este problema desde este momento, de 

forma que podamos estar atentos y no caer en la trampa. 

Operadores matemáticos 

Los operadores matemáticos básicos son los mismos que los disponibles en la mayoría de lenguajes de programación: suma (+), resta (-), división (/), multiplicación (*) y módulo (%, que devuelve 

el resto de una división entera). La división entera trunca, en vez de redondear, el resultado. 

Java también utiliza una notación abreviada para realizar una operación y llevar a cabo una asignación simultáneamente. Este conjunto de operaciones se representa mediante un operador seguido 

del signo igual, y es consistente con todos los operadores del lenguaje (cuando tenga sentido). Por 

ejemplo, para añadir 4 a la variable x y asignar el resultado a x puede usarse: x+=4. 

El siguiente ejemplo muestra el uso de los operadores matemáticos: 

//: c03:OperadoresMatematicos.java 

// Demuestra los operadores matemáticos 

import java.uti1. *; 

public class OperadoresMatematicos { 

// Crear un atajo para ahorrar teclear: 

static void visualizar(String S) { 

System. out .println (S) ; 

1 

// Atajo para visualizar un string y un entero: 

static void pInt (ti S, int. i) { 

visualizar(s + " = " + i); 

1 

// Atajo para visualizar una cadena de caracteres y un float: 

static void pFlt (String S, float f) { 

visualizar(s + " = " + f); 

3: Controlar el flujo del programa 83 

public static void main(String [] args) { 

// Crear un generador de números aleatorios 

// El generador se alimentará por defecto de la hora actual: 

Random aleatorio = new Random() ; 

int i, j, k; 

// '%' limita el valor a 99: 

j = aleatorio. nextInt () % 100; 

k = aleatorio.nextInt () %100; 

pInt ("jl',j); p~nt("k",k); 

i = j t k; p~nt("j + k", i); 

i = j - k; pInt("j - k", i); 

i = k / j; pInt("k / j", i); 

i = k *j; pInt("k * j", i); 

i = k % j; pInt("k % j", i); 

j o-- o- k; p~nt (" j %= k", j) ; 

// Pruebas de números de coma flotante: 

float u,v,w; // Se aplica también a doubles 

v = aleatorio. nextFloat ( ) ; 

w = aleatorio. nextFloat () ; 

pFlt("v", v); pFlt("w", w); 

u = v t w; pFlt("v + w", u); 

U = v - w; pFlt(I1v - w", u); 

U = v * w; pFlt("v * w", u); 

u = v / w; pFlt("v / w", u); 

// Lo siguiente funciona también para char, byte 

// short, int, long, y double: 

u += v; pFlt("u += v", u); 

u -= v; pFlt("u -= v", u) ; 

u *= v; pFlt("u *= v", u); 

u /= v; pFlt("u /= v", u); 

1 

1 ///:- 

Lo primero que se verán serán los métodos relacionados con la visualización por pantalla: el método visualizar( ) imprime un String, el método pInt( ) imprime un String seguido de un int, y el 

médodo pFlt( ) imprime un String seguido de un float. Por supuesto, en última instancia todos 

usan System.out.prhtln( ). 

Para generar números, el programa crea en primer lugar un objeto Random. Como no se le pasan parámetros en su creación, Java usa la hora actual como semilla para el generador de números aleatorio. El programa genera u11 conjunto de números aleatorios de distinto tipo con el objeto Random simplemente llamando a distintos métodos: nextInt( ), nextlong( ), nextFloat( ) o 

nextDouble( ). 

Cuando el operador módulo se usa con el resultado de un generador de números aleatorios, limita 

el resultado a un límite superior del operando menos uno (en este caso 99). 

84 Piensa en Java 

Los operadores unarios de suma y resta 

El menos unario (-) y el más unario (+) son los mismos operadores que la resta y la suma binarios. 

El compilador averigua cuál de los dos usos es el pretendido por la manera de escribir la expresión. 

Por ejemplo, la sentencia: 

tiene un significado obvio. El compilador es capaz de averiguar: 

Pero puede que el lector llegue a confundirse, por lo que es más claro decir: 

El menos unario genera el valor negativo del valor dado. El más unario proporciona simetría con el 

menos unario, aunque no tiene ningún efecto. 

Autoincremento y Autodecremento 

Tanto Java, como C, está lleno de atajos. Éstos pueden simplificar considerablemente el tecleado del 

código, y aumentar o disminuir su legibilidad. 

Dos de los atajos mejores son los operadores de incremento y decremento (que a menudo se llaman operadores de autoincremento y autodecremento). El operador de decremento es -- y significa 

"disminuir en una unidad". El operador de incremento es ++ y significa "incrementar en una unidad". Si a es un entero, por ejemplo, la expresión ++a es equivalente a (a = a + 1). Los operadores 

de incremento y decremento producen el valor de la variable como resultado. 

Hay dos versiones de cada tipo de operador, llamadas, a menudo, versiones prefija y postfija. El 

preincremento quiere decir que el operador ++ aparece antes de la variable o expresión, y el postincremento significa que el operador ++ aparece después de la variable o expresión. De manera análoga, el predecremento quiere decir que el operador -- aparece antes de la variable o expresión, y el 

post-decremento significa que el operador -- aparece después de la variable o expresión. Para el 

preincremento y el predecremento (por ejemplo, ++a o-a), la operación se lleva a cabo y se produce el valor. En el caso del postincremento y postdecremento (por ejemplo, a++ o a--) se produce 

el valor y después se lleva a cabo la operación. Por ejemplo: 

//: c03:AutoInc. java 

// Mostrar el funcionamiento de los operadores ++ y -- 

public class AutoInc { 

public static void main (String[] args) { 

int i = 1; 

visualizar ("i : " + i) ; 

visualizar (I1++i : " + ++i) ; // Pre-incremento 

visualizar (I1i++ : " + i++) ; // Post-incremento 

3: Controlar el flujo del programa 85 

visualizar ("i : " + i) ; 

visualizar ("--i : " + --i) ; // Pre-decremento 

visualizar ("i-- : " + i--) ; // Post-decremento 

visualizar ("i : " + i) ; 

J 

static void visualizar (String S) { 

System.out .println (S) ; 

1 

1 ///:- 

La salida de este programa es: 

Se puede pensar que con la forma prefija se consigue el valor después de que se ha hecho la operación, mientras que con la forma postfija se consigue el valor antes de que la operación se lleve a 

cabo. Éstos son los únicos operadores (además de los que implican asignación) que tienen efectos 

laterales. (Es decir, cambian el operando en vez de usarlo simplemente como valor.) 

El operador de incremento es una explicación para el propio nombre del lenguaje C++, que significa "un paso después de C". En una de las primeras conferencias sobre Java, Bill Joy (uno de sus 

creadores), dijo que "Java=C++-" (C más más menos menos), tratando de sugerir que Java es C++ 

sin las partes duras no necesarias, y por consiguiente, un lenguaje bastante más sencillo. A medida 

que se progrese en este libro, se verá cómo muchas partes son más simples, y sin embargo, Java 

no es mucho más fácil que C++. 

Operadores relacionales 

Los operadores relacionales generan un resultado de tipo boolean. Evalúan la relación entre los valores de los operandos. Una expresión relaciona1 produce true si la relación es verdadera, y false si la relación es falsa. Los operadores relacionales son menor que (<), mayor que (>), menor o igual que (<=), 

mayor o igual que (>=), igual que (==) y distinto que (!=). La igualdad y la desigualdad funcionan con 

todos los tipos de datos predefinidos, pero las otras comparaciones no funcionan con el tipo boolean. 

Probando la equivalencia de objetos 

Im operadores relacionales == y != funcionan con todos los objetos, pero su significado suele confundir al que programa en Java por primera vez. He aquí un ejemplo: 

public class Equivalencia { 

public static void main (String[l args) { 

86 Piensa en Java 

Integer nl = new Integer(47); 

Integer n2 = new Integer (47) ; 

Systern.out .println (n1 == n2) ; 

Systern. out .println (n1 ! = n2) ; 

1 

1 ///:- 

La expresión System.out.println(n1 == n2) visualizará el resultado de la comparación de tipo 1ógico. Seguramente la salida debería ser true y después false, pues ambos objetos Integer son el 

mismo. Pero mientras que los contenidos de los objetos son los mismos, las referencias no son las 

mismas, y los operadores == y != comparan referencias a objetos. Por ello, la salida es, de hecho, 

false y después true. Naturalmente, esto sorprende a la gente al principio. 

¿Qué ocurre si se desea comparar los contenidos de dos objetos? Es necesario utilizar el método especial equals( ) que existe para todos los objetos (no tipos primitivos, que funcionan perfectarnente con == y !=). He aquí cómo usarlo: 

public class MetodoComparacion { 

public static void main(String[] args) { 

Integer nl = new Integer(47); 

Integer n2 = new Integer(47); 

System.out.println(nl.equals(n2)); 

1 

1 ///:- 

El resultado será true, tal y como se espera. Ah, pero no es así de simple. Si uno crea su propia clase, como ésta: 

/ // : cO3 :MetodoComparacion2. java 

class Valor { 

int i; 

1 

public class MetodoCornparacion2 { 

public static void main(String[] args) { 

Valor vl = new Valor () ; 

Valor v2 = new Valor () ; 

v1.i = v2.i = 100; 

System.out.println(vl.equals(v2)); 

1 

1 ///:- 

se obtiene como resultado falso. Esto se debe a que el comportamiento por defecto de equals( ) es 

comparar referencias. Por tanto, a menos que se invalide equals( ) en la nueva clase no se obtendrá 

el comportamiento deseado. Desgraciadamente no se mostrarán las invalidaciones hasta el Capítulo 

3: Controlar el flujo del programa 87 

7, pero debemos ser conscientes mientras tanto de la forma en que se comporta equals( ) podría 

ahorrar algunos problemas. 

La mayoría de clases de la biblioteca Java implementan equals( ), de forma que compara los contenidos de los objetos en vez de sus referencias. 

Operadores lógicos 

Los operadores lógicos AND (&&), OR (11) y NOT(!) producen un valor lógico (true o false) basado en la relación lógica de sus argumentos. Este ejemplo usa los operadores relacionales y lógicos: 

//: c03:Logico.java 

// Operadores relacionales y lógicos 

import java.uti1. *; 

public class Loqico { 

public static void main(String[] args) { 

Random aleatorio = new Random () ; 

int i = aleatorio.nextInt() % 100; 

int j = aleatorio.nextInt() % 100; 

visualizar("i = " + i); 

visualizar("j = " + j); 

visualizar("i > j es " + (i > j)); 

visualizar("i < j es " + (i < j)); 

visualizar ("i >= j es " + (i >= j) ) ; 

visualizar("i <= j es " + (i <= j)); 

visualizar ( " i == j es " + (1 == 1)); 

visualizar("i != j es " + (i != 1)); 

// Tratar un int como un boolean no es legal en Java 

//! visualizar ("i && j es " + (i && j)); 

//! visualizar ("i 11 j es " + (i 11 j)); 

//! visualizar (" ! i es " + ! i) ; 

visualizar(" (i<10) && (j<10) es " + ((i < 10) && (j < 10)); 

visualizar (" (i<10) 1 1 (j<10) es " + ( (i < 10) 1 I (j < 10) ) ; 

static void visualizar (String S) { 

System. out .println (S) : 

Sólo es posible aplicar AND, OR o NOT a valores boolean. No se puede construir una expresión 1ógica con valores que no sean de tipo boolean, cosa que sí se puede hacer en C y C++. Se pueden 

88 Piensa en Java 

ver intentos fallidos de hacer esto en las líneas que comienzan por //! en el ejemplo anterior. Sin 

embargo, las sentencias que vienen a continuación producen valores lógicos utilizando comparaciones relacionales, y después se usan operaciones lógicas en los resultados. 

El listado de salida tendrá la siguiente apariencia: 

i = 8 5 ; 

j = 4; 

i > j es true 

i < j es false 

i >= j es true 

i <= j es false 

i == j es false 

i != es true 

(i < 10) && (j < 10) es false 

(i < 10) 1 I (j > 10) es true 

Obsérvese que un valor lógico se convierte automáticamente a formato de texto si se utiliza allí 

donde se espera un String. 

Se puede reemplazar la definición int en el programa anterior por cualquier otro tipo de datos primitivo, excepto boolean. Hay que tener en cuenta, sin embargo, que la comparación de números en 

coma flotante es muy estricta. Un número que sea diferente por muy poco de otro número sigue 

siendo "no igual". Un número infinitamente próximo a cero es distinto de cero. 

Cortocircuitos 

Al manipular los operadores lógicos se puede entrar en un fenómeno de "cortocircuito". Esto significa que la expresión se evaluará únicamente hasta que se pueda determinar sin ambigüedad la certeza o falsedad de toda la expresión. Como resultado, podría ocurrir que no sea necesario evaluar 

todas las partes de la expresión lógica. He aquí un ejemplo que muestra el funcionamiento de los 

cortocircuitos: 

//: c03:CortoCircuito.java 

// Demuestra el comportamiento de los cortocircuitos con operadores 

lógicos. 

public class Cortocircuito { 

static boolean pruebal (int val) { 

System.out .println ("pruebal (" + val + ") ") ; 

System.out .println ("resultado: " + (val < 1) ) ; 

returri val < 1; 

1 

static boolean prueba2 (int val) { 

System.out .println ("prueba2 (" + val + ") ") ; 

System. out .println ("resultado: " + (val < 2) ) ; 

return val < 2; 

} 

3: Controlar el flujo del programa 89 

static boolean prueba3 (int val) { 

System. out .println ("prueba3 ( " + val + ") ") ; 

System. out .println ("resultado: " + (val < 3) ) ; 

return val < 3; 

1 

public static void main (Stringi] args) { 

if (pruebal (0) && prueba2 (2) && prueba3 (2) ) 

System.out.println("La expresión es verdadera"); 

else 

System.out.println("La expresión es falsa"); 

} 

1 ///:- 

Cada test lleva a cabo una comparación con el argumento pasado y devuelve verdadero o falso. 

También imprime información para mostrar lo que se está invocando. Las comprobaciones se usan 

en la expresión: 

if (pruebal (O) && prueba2 (2) && prueba3 (2) ) 

Naturalmente uno podría pensar que se ejecutarían las tres pruebas, pero en la salida se muestra de 

otra forma: 

pruebal (0) 

resultado : true 

prueba2 (2) 

resultado: false 

la expresión es falsa 

La primera prueba produjo un resultado verdadero, de forma que la evaluación de la expresión 

continúa. Sin embargo, el segundo test produjo un resultado falso. Puesto que esto significa que 

toda la expresión va a ser falso ¿por qué continuar evaluando el resto de la expresión? Podría ser 

costoso. Ésa es precisamente la razón para realizar un cortocircuito; es posible lograr un incremento potencial de rendimiento si no es necesario evaluar todas las partes de la expresión lógica. 

Operadores de bit 

Los operadores a nivel de bit permiten manipular bits individuales de la misma forma que si fueran 

tipos de datos primitivos íntegros. Los operadores de bit llevan a cabo álgebra lógica con los bits correspondientes de los dos argumentos, para producir el resultado. 

Los operadores a nivel de bit provienen de la orientación a bajo nivel de C, para la manipulación directa 

del hardware y el establecimiento de los bits de los registros de hardware. Java se diseñó originalmente 

para ser empotrado en las cajas set-top de los televisores. de forma que esta orientación de bajo nivel tenía sentido. Sin embargo, probablcmcnte no se haga mucho uso de estos operadores de nivel de bit. 

El operador de bit AND (&) produce un uno a la salida si los dos bits de entrada son unos; si no, 

produce un cero. El operador de bit OR (1) produce un uno en la salida si cualquiera de los bits de 

90 Piensa en Java 

entrada es un uno, y produce un cero sólo si los dos bits de entrada son cero. El operador de bit OR 

EXCLUSIVO o XOR (A), produce un uno en la salida si uno de los bits de entrada es un uno, pero 

no ambos. El operador de bit NOT (-, también llamado operador de complemento a uno) es un operador unario; toma sólo un argumento. (Todos los demás operadores de bits son operadores binarios.) El operador de bit NOT produce el contrario del bit de entrada -un uno si el bit de entrada 

es cero y un cero si el bit de entrada es un uno. 

Los operadores de bit y lógicos utilizan los mismos caracteres, por lo que ayuda tener algún mecanismo mnemónico para ayudar a recordar su significado: dado que los bits son "pequeños", sólo hay 

un carácter en los operadores de bits. 

Los operadores de bit se pueden combinar con el signo = para unir la operación a una asignación: 

&=, I= y A= son válidos (dado que - es un operador unario, no puede combinarse con el signo =). 

El tipo boolean se trata como un valor de un bit, por lo que es en cierta medida distinto. Se puede 

llevar a cabo un AND, OR o XOR de bit, pero no se puede realizar un NOT de bit (se supone que 

para evitar la confusión con el NOT lógico). Para los datos de tipo boolean, los operadores de bit 

tienen el mismo efecto que los operadores lógicos, excepto en que no tienen capacidad de hacer cortocircuito~. Además, los operadores de bit sobre datos de tipo boolean incluyen un operador XOR 

lógico no incluido bajo la lista de operadores "lógicos". Hay que tratar de evitar los datos de tipo 

boolean en las expresiones de desplazamiento, descritas a continuación. 

Operadores de desplazamiento 

Los operadores de desplazamiento también manipulan bits. Sólo se pueden utilizar con tipos primitivos enteros. El operador de desplazamiento a la izquierda (<<) provoca que el operando de la izquierda del operador sea desplazado a la izquierda, tantos bits como se especifique tras el operador 

(insertando ceros en los bits menos significativos). El operador de desplazamiento a la derecha con 

signo (>>) provoca que el operando de la izquierda del operador sea desplazado a la derecha el número de bits que se especifique tras el operador. El desplazamiento a la derecha con signo >> utiliza la extensión de signo: si el valor es positivo se insertan ceros en los bits más significativos; si el 

valor es negativo, se insertan unos en los bits más significativos. Java también ha incorporado el 

operador de rotación a la derecha sin signo >>>, que utiliza la extensión cero: independientemente 

del signo, se insertan ceros en los bits más significativos. Este operador no existe ni en C ni en C++. 

Si se trata de desplazar un char, un byte o un short, éste será convertido a int antes de que el desplazamiento tenga lugar y el resultado será también un int. Sólo se utilizarán los cinco bits menos 

significativos de la parte derecha. Esto evita que se desplace un número de bits mayor al número 

de bits de un int. Si se está trabajando con un long, se logrará un resultado long. Sólo se usarán los 

seis bits menos significativos de la parte derecha, por lo que no es posible desplazar más bits que 

los que hay en un long. 

Los desplazamientos pueden combinarse con el signo igual (<<= o >>= o >>>=). El ivalor se reemplaza por el ivalor desplazado por el dvalor. Hay un problema, sin embargo, con el desplazamiento 

sin signo a la derecha combinado con la asignación. Si se utiliza con un byte o short no se logra el 

resultado correcto. En vez de esto, los datos son convertidos a int y desplazados a la derecha, y 

3: Controlar el flujo del programa 91 

teriormente se truncan al ser asignados de nuevo a sus variables, por lo que en esos casos el resultado suele ser -1. El ejemplo siguiente demuestra esto: 

//: c03:DesplDatosSinSigno.java 

// Prueba del desplazamiento a la derecha sin signo. 

public class DesplDatosSinSigno { 

public static void main (String[] args) { 

int i = -1; 

i >>>= 10; 

System.out.println (i) ; 

long 1 = -1; 

1 >>>= 10; 

short S = -1; 

S >>>= 10; 

System. out .println (S) ; 

byte b = -1; 

b >>>= 10; 

System. out .println (b) ; 

b = -1. 

System.out.println(b>>>lO); 

1 

1 ///:- 

En la última línea, no se asigna el valor resultante de nuevo a b, sino que se imprime directamente 

para que se dé el comportamiento correcto. 

He aquí un ejemplo que demuestra el uso de todos los operadores que involucran a bits: 

//: c03:ManipulacionBits.java 

// Utilizando los operadores de bit. 

import java.util. *; 

public class ManipulacionBits { 

public static void main (Stringr] args) { 

Random aleatorio = new Random () ; 

int i = aleatorio. nextInt () ; 

int j = aleatorio. nextInt () ; 

p~in~nt ( " -1 " , -1); 

pBinInt ("+11', +1) ; 

int posmax = 2147483647; 

pBinInt ( "posmax" , posmax) ; 

int negmax - -2147483648; 

p~in~nt ( "negmax" , negmax) ; 

pBinInt ("i", i) ; 

pBinInt ("-i", -i) ; 

92 Piensa en Java 

pBin1nt ( " -i" , -i) ; 

pBinInt ( " j " , j ) ; 

pBinInt("i & j", i & 1); 

pBinInt ("i 1 j ", i 1 j) ; 

pBinInt("i A j", i A 1); 

pBin1nt(I1i << 5", i << 5); 

pBin1nt(I1i >> 5", i >> 5); 

pBin1nt (" (-i) >> 5", (-i) >> 5) ; 

pBin1nt ("i >>> 5", i >>> 5) ; 

pBin1nt ( " (-i) >>> 5", (-i) >>> 5) ; 

long 1 = aleatorio. nextLong () ; 

long m = aleatorio. nextLong () ; 

pBinLong ("-l~", -1L) ; 

pBinLong("+l~", +1L); 

long 11 = 9223372036854775807L; 

pBinLonq ( "maxpos " , 11) : 

long lln = -9223372036854775808L; 

pBinLong ( "maxneg" , lln) ; 

pBinLong ("l", 1) ; 

pBinLong (lb-l", -1) ; 

p~in~ong ( " -1" , -1); 

pBinLong ( "m", m) ; 

pBinLong("1 & m", 1 & m) ; 

pBinLong( "1 I m", 1 1 m) ; 

pBinLong (" 1 A m", 1 A m) ; 

pBinLong ( " 1 << 5", 1 << 5) ; 

pBinLong ( " 1 >> 5", 1 >> 5) ; 

pBinLong (" (-1) >> 5", (-1) >> 5) ; 

pBinLong ( " 1 >>> 5", 1 >>> 5) ; 

pBinLong (" (-1) >>> 5", (-1) >>> 5) ; 

1 

static void pBinInt (String S, int i) { 

System.out.println( 

S + 'Ir int: " + i + ", binario: ") ; 

System. out .print ( " "); 

for(int j = 31; j >=O; j--) 

if(((1 << j) & i) != 0) 

System.out .print (" 1 ") ; 

else 

System.out.print("OM); 

System.out.println(); 

1 

static void pBinLong(String S, long 1) { 

System.out.println( 

3: Controlar el flujo del programa 93 

s + ", long: " + 1 + ", binario: "); 

System. out .print (" "); 

for(int i = 63; i >=O; i--) 

if(((1L << i) & 1) != 0) 

System.out.print("1"); 

else 

System. out .print ( " O" ) ; 

System.out.println(); 

1 

1 ///:- 

Los dos métodos del final, pBinInt( ) y pBinLong( ) toman un int o un long, respectivamente, y 

lo imprimen en formato binario junto con una cadena de caracteres descriptiva. De momento, ignoraremos la implementación de estos métodos. 

Se habrá dado cuenta el lector del uso de System.out.print( ) en vez de System.out.println( ). El 

método print( ) no finaliza con un salto de línea, por lo que permite ir visualizando una línea por 

fragmentos. 

Además de demostrar el efecto de todos los operadores de bit para int y long, este ejemplo también 

muestra los valores mínimo, el máximo, +1 y -1 para int y para long, por lo que puede verse qué aspecto tienen. Nótese que el bit más significativo representa el signo: O significa positivo, y 1 significa negativo. La salida de la porción int tiene la apariencia siguiente: 

-1, int: -1, binario: 

11111111111111111111llllllllllll 

+l, int: 1, binario: 

00000000000000000000000000000001 

posmax, int: 2147483647, binario: 

01111111111111111111111111111111 

negmax, int: -2147483648, binario: 

10000000000000000000000000000000 

i, int: 59081716, binario: 

00000011100001011000001111110100 

-ir int: -59081717, binario: 

11111100011110100111110000001011 

-ir int: -59081716, binarios: 

11111100011110100111110000001100 

j, int: 198850956, binario: 

00001011110110100011100110001100 

i & J, int: 58720644, binario: 

00000011100000000000000110000100 

i 1 j, int: 199212028, binario: 

00001011110111111011101111111100 

i A j, int: 140491384, binario: 

00001000010111111011101001111000 

94 Piensa en Java 

i << 5, int: 1890614912, binario: 

01110000101100000111111010000000 

i >> 5, int: 1846303, binario: 

00000000000111000010110000011111 

(- i) >>5, int: -1846304, binario: 

11111111111000111101001111100000 

i >>> 5, int: 1846303, binario: 

00000000000111000010110000011111 

(- i) >>> 5, int: 132371424, binario 

00000111111000111101001111100000 

La representación binaria de los números se denomina también complemento a dos con signo. 

Operador ternario if-else 

Este operador es inusual por tener tres operandos. Verdaderamente es un operador porque produce un valor, a diferencia de la sentencia if-else ordinaria que se verá en la siguiente sección de este 

capítulo. La expresión es de la forma: 

exp-booleana ? valor0 : valorl 

Si el resultado de la evaluación exp-boolean es true, se evalúa valor0 y su resultado se convierte en 

el valor producido por el operador. Si exp-booleana es false, se evalúa valorl y su resultado se convierte en el valor producido por el operador. 

Por supuesto, podría usarse una sentencia if-else ordinaria (descrita más adelante), pero el operador 

ternario es mucho más breve. Aunque C (del que es originario este operador) se enorgullece de ser 

un lenguaje sencillo, y podría haberse introducido el operador ternario en parte por eficiencia, deberíamos ser cautelosos a la hora de usarlo cotidianamente -es fácil producir código ilegible. 

El operador condicional puede usarse por sus efectos laterales o por el valor que produce, pero en 

general se desea el valor, puesto que es éste el que hace al operador distinto del if-else. He aquí un 

ejemplo: 

static int ternario(int i) { 

return i < 10 ? i * 100 : i * 10; 

1 

Este código, como puede observarse, es más compacto que el necesario para escribirlo sin el operador ternario: 

static int alternativo(int i) { 

if (i < 10) 

return i * 100; 

else 

reLurri i * 10; 

La segunda forma es más sencilla de entender, y no requiere de muchas más pulsacioncs. Por tanto, hay que asegurarse de evaluar las razones a la hora de elegir el operador ternario. 

3: Controlar el flujo del programa 95 

El operador coma 

La coma se usa en C y C++ no sólo como un separador en las listas de parámetros a funciones, sino 

también como operador para evaluación secuencial. El único lugar en que se usa el operador coma 

en Java es en los bucles for, que serán descritos más adelante en este capítulo. 

El operador de S t r i n g + 

Hay un uso especial en Java de un operador: el operador + puede utilizarse para concatenar cadenas 

de caracteres, como ya se ha visto. Parece un uso natural del + incluso aunque no encaje con la manera tradicional de usar el +. Esta capacidad parecía una buena idea en C++, por lo que se añadió la 

sobrecarga de operadores a C++, para permitir al programador de C++ añadir significados a casi todos los operadores. Por desgracia, la sobrecarga de operadores combinada con algunas otras restricciones de C++, parece convertirse en un aspecto bastante complicado para que los programadores la usen al diseñar sus clases. Aunque la sobrecarga de operadores habría sido mucho más fácil 

de implementar en Java que en C++, se seguía considerando que se trataba de un aspecto demasiado complicado, por lo que los programadores de Java no pueden implementar sus propios operadores sobrecargados como pueden hacer los programadores de C++. 

El uso del + de String tiene algún comportamiento interesante. Si una expresión comienza con un 

String, entonces todos los operandos que le sigan deben ser de tipo String (recuerde que el compilador convertirá una secuencia de caracteres entre comas en un String): 

int x = O, y = 1, z = 2; 

String sString = "x, y, z "; 

System.out.println(sString t x t y t z); 

Aquí, el compilador Java convertirá a x, y y z en sus representaciones String en vez de sumarlas. 

Mientras que si se escribe: 

System. out .printl (x t sString) ; 

Java convertirá x en un String. 

Pequeños fallos frecuentes 

al usar operadores 

Uno de los errores frecuentes al utilizar operadores es intentar no utilizar paréntesis cuando se tiene la mhs mínima duda sobre cómo se evaluará una expresión. Esto sigue ocurriendo lambién en 

Java. 

Un error extremadamente frecuente en C y C++ es éste: 

while (x = y) { 

// ... 1 

96 Piensa en Java 

El programador estaba intentando probar una equivalencia (==) en vez de hacer una asignación. En 

C y C++ el resultado de esta asignación siempre será true si y es distinta de cero, y probablemente se entrará en un bucle infinito. En Java, el resultado de esta expresión no es un boolean, y el 

compilador espera un boolean pero no convertirá el int en boolean, por lo que dará el conveniente error en tiempo de compilación, y capturará el problema antes de que se intente siquiera ejecutar el programa. De esta forma, esta trampa jamás puede ocurrir en Java. (El único momento en que 

no se obtendrá un error en tiempo de compilación es cuando x e y sean boolean, en cuyo caso x = 

y es una expresión legal, y en el caso anterior, probablemente un error.) 

Un problema similar en C y C++ es utilizar los operadores de bit AND y OR, en vez de sus versiones lógicas. Los AND y OR de bit utilizan uno de los caracteres (& o 1) y los AND y OR lógicos utilizan dos (&& y 11). Como ocurre con el = y el ==, es fácil escribir sólo uno de los caracteres en vez 

de ambos. En Java, el compilador vuelve a evitar esto porque no los permite utilizar con operadores 

incorrectos. 

Operadores de conversión 

La palabra conversión se utiliza con el sentido de "convertir1 a un molde". Java convertirá automáticamente un tipo de datos en otro cuando sea adecuado. Por ejemplo, si se asigna un valor entero a 

una variable de coma flotante, el compilador convertirá automáticamente el int en float. La conversión permite llevar a cabo estas conversiones de tipos de forma explícita, o forzarlas cuando no se 

diesen por defecto. 

Para llevar a cabo una conversión, se pone el tipo de datos deseado (incluidos todos los modificadores) entre paréntesis a la izquierda de cualquier valor. He aquí un ejemplo: 

void conversiones () { 

int i = 200; 

long 1 = (long) i; 

long 12 = (lon9)2OO; 

} 

Como puede verse, es posible llevar a cabo una conversión, tanto con un valor numérico, como con 

una variable. En las dos conversiones mostradas, la conversión es innecesaria, dado que el compilador convertirá un valor int en long cuando sea necesario. No obstante, se permite usar conversiones innecesarias para hacer el código más limpio. En otras situaciones, puede ser esencial una 

conversión para lograr que el código compile. 

En C y C++, las conversiones pueden conllevar quebraderos de cabeza. En Java, la conversión de tipos es segura, con la excepción de que al llevar a cabo una de las denominadas conversiones reductoras (es decir, cuando se va de un tipo de datos que puede mantener más información a otro que 

no puede contener tanta) se corre el riesgo de perder información. En estos casos, el compilador 

fuerza a hacer una conversión explícita, diciendo, de hecho, "esto puede ser algo peligroso de hacer 

' N. del Traductor: Casting se traduce aquí por convertir. 

3: Controlar el flujo del programa 97 

-si quieres que lo haga de todas formas, tiene que hacer la conversión de forma explícita". Con una 

conversión extensora no es necesaria una conversión explícita porque el nuevo tipo es capaz de albergar la información del viejo tipo sin que se pierda nunca ningún bit. 

Java permite convertir cualquier tipo primitivo en cualquier otro tipo, excepto boolean, que no permite ninguna conversión. Los tipos clase no permiten ninguna conversión. Para convertir una a otra 

debe utilizar métodos especiales (String es un caso especial y se verá más adelante en este libro 

que los objetos pueden convertirse en una familia de tipos; un Roble puede convertirse en Árbol y 

viceversa, pero esto no puede hacerse con un tipo foráneo como Roca.) 

Literales 

Generalmente al insertar un valor literal en un programa, el compilador sabe exactamente de qué 

tipo hacerlo. Sin embargo, en ocasiones, el tipo es ambiguo. Cuando ocurre esto es necesario guiar 

al compilador añadiendo alguna información extra en forma de caracteres asociados con el valor literal. El código siguiente muestra estos caracteres: 

class Literales { 

char c = Oxffff; // Carácter máximo valor hexadecimal 

byte b = Ox7f; // Máximo byte valor hexadecimal 

short S = Ox7fff; // Máximo short valor hexadecimal 

int il = Ox2f; // Hexadecimal (minúsculas) 

int i2 = OX2F; // Hexadecimal (mayúsculas) 

int i3 = 0177; // Octal (Cero delantero) 

// Hex y Oct también funcionan con long. 

long nl = 200L; // sufijo long 

long n2 = 2001; // sufijo long 

long n3 = 200; 

//! long 16(200); // prohibido 

float fl = 1; 

float f2 = 1F; // sufijo float 

float f3 = lf; // sufijo float 

float f4 = le-45f; // 10 elevado a -45 

float f5 = le+9f; // sufijo float 

double dl = Id; // sufijo double 

double d2 = 1D; // sufijo double 

double d3 = 47e47d: // 10 elevado a 47 

1 ///:- 

La base 16 (hexadecimal), que funciona con todos los tipos de datos enteros, se representa mediante 

un Ox o OX delanteros, seguidos de 0-9 y a-f, tanto en mayúsculas como en minúsculas. Si se trata de 

inicializar una variable con un valor mayor que el que puede albergar (independientemente de la forma numérica del valor), el compilador emitirá un mensaje de error. Fíjese en el código anterior, los 

valores hexadecimales máximos posibles para char, byte y short. Si se excede de éstos, el compi- 

98 Piensa en Java 

lador generará un valor int automáticamente e informará de la necesidad de hacer una conversión 

reductora para llevar a cabo la asignación. Se sabrá que se ha traspasado la línea. 

La base 8 (octal) se indica mediante un cero delantero en el número, y dígitos de O a 7. No hay representación literal de números binarios en C, C++ o Java. 

El tipo de un valor literal lo establece un carácter arrastrado por éste. Sea en mayúsculas o minúsculas, L significa long, F significa float, y D significa double. 

Los exponentes usan una notación que yo a veces encuentro bastante desconcertante: 1,39 e-47f. 

En ciencias e ingeniería, la "e" se refiere a la base de los logaritmos naturales, aproximadamente 

2,718. (Hay un valor double mucho más preciso en Java, denominado Math.E.) Éste se usa en expresión exponencial, como 1,39 e-47, que quiere decir 1,39 x 2,718.". Sin embargo, cuando se inventó Fortran se decidió que la e querría indicar "diez elevado a la potencia" lo cual es una mala decisión, pues Fortran fue diseñado para ciencias e ingeniería y podría pensarse que los diseñadores 

deben ser conscientes de que se ha introducido semejante ambigüedad2. En cualquier caso, esta 

costumbre siguió en C y C++, y ahora en Java. Por tanto, si uno está habituado a pensar que e es 

la base de los logaritmos naturales, tendrá que hacer una traslación mental al ver una expresión 

como 1,39 e-47f en Java; significa 1,39 * 

Nótese que no es necesario utilizar el carácter final cuando el compilador puede averiguar el tipo 

apropiado. Con 

1 long n3 = 200; 

no hay ambigüedad, por lo que una L tras el 200 sería superflua. Sin embargo, con 

1 float £4 = le-47f; // 10 elevado a 

el compilador, normalmente, tomará los números exponenciales como double, de forma que sin la 

f arrastrada dará un error indicando que es necesario hacer una conversión de double en un float. 

Promoción 

Al hacer operaciones matemáticas o de bit sobre tipos de datos primitivos, se descubrirá que si son 

más pequeños que un int (es decir, char, byte, o short), estos valores se promocionarán a int antes de hacer las operaciones, y el valor resultante será de tipo int. Por tanto, si se desea asignar el 

valor devuelto, de nuevo al tipo de menor tamaño, será necesario utilizar una conversión. (Y dado 

' John Kirkham escribe: "Empecé a trabajar con computadores en 1962 utilizando FORTRAN 11 en un IBM 1620. En ese tiempo, y 

a través de los años sesenta y setenta, FORTRAN era uri leriguaje todo eri iiiayúsculas. Esto empezó probablemente porque muchos de los primeros dispositivos de enlrada erari viejas unidades de teletipo que utilizaban código Baudot de 5 hits, que no tcnia 

capacidad de empleo de rriiriúsculas. La 'E' para la notación exponencial era también siempre mayúscula y nunca sc confundía con 

la base de los logaritmos naturales 'e', que siempre era minúscula. La 'E' simplemente quería decir siempre exponencial, que era 

la base del sistema de numeración utilizado -generalmente 10. Eri ese ~rioineiito se coriienzó a extender entre los programadores 

el sistema octal. Aunque yo nunca lo vi usar, si hubiera visto un número octal en notación exponencial, habría considerado que tenía base 8. La primera vez que recuerdo ver un exponencial utilizando una 'e' minúscula fue al final de los setenta, y lo encontré 

bastante confuso. El problema aumentó cuando la 'e' se introdujo en FORTRAN, a diferencia de sus principios. De hecho, nosotros 

teníamos funciones para usar cuando realmente se quería usar la base logaritmica natural, pero todas ellas eran en mayúsculas". 

3: Controlar el flujo del programa 99 

que se está haciendo una asignación, de nuevo hacia un tipo más pequeño, se podría estar perdiendo información.) En general, el tipo de datos de mayor tamaño en una expresión será el que determine el tamaño del resultado de esa expresión; si se multiplica un float y un double, el resultado 

será double; si se suman un int y un long, el resultado será long. 

Java no tiene "sizeof" 

En C y C++, el operador sizeof( ) satisface una necesidad específica: nos dice el número de bits asignados a elementos de datos. La necesidad más apremiante de sizeof( ) en C y C++ es la portabilidad. Distintos tipos de datos podrían tener distintos tamaños en distintas máquinas, por lo que el 

programador debe averiguar cómo de grandes son estos tipos de datos, al llevar a cabo operaciones 

sensibles al tamaño. Por ejemplo, un computador podría almacenar enteros en 32 bits, mientras que 

otro podría almacenar enteros como 16 bits. Los programas podrían almacenar enteros con valores 

más grandes en la primera de las máquinas. Como podría imaginarse, la portabilidad es un gran 

quebradero de cabeza para los programadores de C y C++. 

Java no necesita un operador sizeof( ) para este propósito porque todos los tipos de datos tienen 

los mismos tamaños en todas las máquinas. No es necesario pensar en la portabilidad a este nivel -está intrínsecamente diseñada en el propio lenguaje. 

Volver a hablar acerca de la precedencia 

Tras oír quejas en uno de mis seminarios, relativas a la complejidad de recordar la precedencia de 

los operadores uno de mis alumnos sugirió un recurso mnemónico que es simultáneamente un comentario (en inglés); "Ulcer Addicts Really Like C A lot." 

Mnemónico 1 Tipo de operador 1 Operador 

I l 1 Ulcer 1 Unario ( +-++- I 

1 Addicts 1 Aritméticos (y de desplazamiento) 1 * / % + - << >> 1 

1 c / Condicional (ternario) 1 A>B?X:Y 1 

Really 

Like 

Por supuesto, con los operadores de desplazamiento y de bit distribuidos por toda la tabla, el recurso mnemónico no es perfecto, pero funciona para las operacione de no bit. 

Relaciona1 

Lógicos (y de bit) 

A Lot 

> < >= <= == != 

&&lI&IA 

Asignación = (y asignaciones compuestas como *=) 

100 Piensa en Java 

Un compendio de operadores 

El ejemplo siguiente muestra qué tipos de datos primitivos pueden usarse como operadores particulares. Básicamente, es el mismo ejemplo repetido una y otra vez, pero usando distintos tipos de 

datos primitivos. El fichero se compilará sin error porque las líneas que causarían errores están 

marcadas como comentarios con un //!. 

//: c03:TodosOperadores.java 

// Prueba todos los operadores con 

// todos los tipos de datos para probar 

// cuáles son aprobados por el compilador de Java. 

class Todosoperadores { 

// Para aceptar los resultados de un test booleano: 

void f (boolean b) { } 

void pruebaBoo1 (boolean x, boolean y) { 

// Operadores aritméticos: 

//! x = x * y; 

//! x = x / y; 

//! x = x % y; 

//! x = x t y; 

//! x = x - y; 

//! x++; 

//! x--; 

//! x = +y; 

//! x = -y; 

// Relacionales y lógicos : 

! f(x > y); 

! £(x >= y); 

! f(x < y); 

! f(x <= y); 

f (x == y) ; 

f (x != y); 

f(!y); 

x = x && y; 

x = x II y; 

// Operadores de bit: 

//! x = -y; 

x=x&y; 

x=x 1 y; 

X = x A y; 

//! x = x << 1; 

//! x = x >> 1; 

//! x = x >>> 1; 

// Asignación compuesta: 

3: Controlar el flujo del programa 101 

//! x += y; 

//! x -= y; 

//! x *= Y; 

//! x /= y; 

//! x %= y; 

//! x <<= 1; 

//! x >>= 1; 

//! x >>>= 1; 

x &= y; 

x A= Y; 

x l= y; 

// Conversión: 

! char c = (char)~; 

//! byte B = by te)^; 

! short S = (short)~; 

! int i = (int)x; 

//! long 1 = (1ong)x; 

! float f = (f1oat)x; 

//! double d = (double)~; 

1 

void pruebalhar (char x, char y) { 

// Operadores aritméticos: 

x = (char) (x * y) ; 

x = (char) (x / y) ; 

x = (char) (x % y) ; 

x = (char) (x + y) ; 

x = (char) (x - y) ; 

x++; 

x--; 

x = (char)ty; 

x = (char)-y; 

// Relacionales y lógicos : 

f(x > y); 

f (x >= y); 

f(x < y); 

f (x <= y) ; 

f (x == y) ; 

f (x != y); 

! f (!x); 

! f(x && y); 

! f(x l l y); 

// Operadores de bit: 

x= (char) -y; 

x = (char) (x & y) ; 

x = (char) (x I y); 

102 Piensa en Java 

x = (char) (x A y); 

x = (char) (x << 1) ; 

x = (char) (x >> 1) ; 

x = (char) (x >>> 1); 

// Asignación compuesta: 

x += y; 

x -= Y; x *= Y; 

x /= y; 

X eo- y; 

x <<= 1; 

x >>= 1; 

x >>>= 1; 

x &= y; 

X "= Y; x I= y; 

// Conversión: 

//! boolean b = (boolean)~; 

byte B = by te)^; 

short S = (short)~; 

int i = (int)x; 

long 1 = (long) x; 

float f = (f1oat)x; 

double d = (double) x; 

1 

void pruebaByte(byte x, byte y) { 

// Operadores aritméticos: 

x = (byte) (x* y) ; 

x = (byte) (x / Y) ; 

x = (byte) (x % y) ; 

x = (byte) (x + y) ; 

x = (byte) (x - y) ; 

x+f; 

x--; 

x = (byte)+ y; 

x = (byte) - y; 

// Relacionales y lógicos : 

f(x > y); 

f (x >= y) ; 

f(x < Y); 

f (x <= y); 

f (x == y) ; 

f (x != y); 

! f (!x); 

! f(x && y); 

3: Controlar el flujo del programa 103 

! f(x l l y); 

// Operadores de bit: 

x = (byte) -y; 

x = (byte) (x & y) ; 

x = (byte) (x I y); 

x = (byte) (x A y) ; 

x = (byte) (x << 1) ; 

x = (byte) (x >> 1) ; 

x = (byte) (x >>> 1) ; 

// Asignación compuesta: 

x += y; 

x -= y; 

X *= Y; x /= y: 

X Po- y; 

x <<= 1; 

x >>= 1; 

x >>>= 1; 

x &= y; 

x "= Y; 

x I= y; 

// Conversión: 

//! boolean b = (boolean)~; 

char c = (char) x; 

short S = (short)~; 

int i = (int) x; 

long 1 = (1ong)x; 

float f = (float) x; 

double d = (double)~; 

void pruebashort (short x, short y) { 

// Operadores aritméticos: 

x = (short) (x * y) ; 

x = (short) (x / y) ; 

x = (short) (x % y) ; 

x = (short) (x t y) ; 

x = (short) (x - y) ; 

x+t; 

x--; 

x = (shnrt)+y; 

x = (short)-y; 

// Relacionales y lógicos : 

f(x > y); 

f (x .= y) ; 

f(x < y); 

104 Piensa en Java 

f (x <= y); 

f (x == y); 

f (x != y); 

! f (!x); 

! f(x && y); 

! f (x I I y); 

// Operadores de bit: 

x = (short) -y; 

x = (short) (x & y) ; 

x = (short) (x I y); 

x = (short) (x A y) ; 

x = (short) (x << 1) ; 

x = (short) (x >> 1) ; 

x = (short) (x >>> 1) ; 

// Asignación compuesta: 

x t= y; 

x -= y; 

x *= Y; 

x /= y; x Po- y; 

x <<= 1; 

x >>= 1; 

x >>>= 1; 

x &= y; 

x ^= y; 

x i= y; 

/ / Conversión: 

//! boolean b = (boolean)~; 

char c = (char)~; 

byte B = by te)^; 

int i = (int)x; 

long 1 = (1ong)x; 

float f = (f1oat)x; 

double d = (double) x; 

1 

void pruebaInt (int x, int y) { 

// Operadores aritméticos: 

X = x * y; 

x=x/y; 

x=x%y; 

x=x t y; 

X = X - y; 

x++; 

x--; 

x = +y; 

3: Controlar el flujo del programa 105 

x = -y; 

// Relacionales y lógicos: 

f(x > y); 

f(x >= y); 

f(x < y); 

f(x <= y); 

f(x == y); 

f(x != y); 

! f(!x); 

! f(x && y); 

! f(x ll y); 

// Operadores de bit: 

x = -y; 

X = x & y: 

x=x) y; 

X = x A y; 

x = x << 1; 

x = x >> 1; 

x = x >>> 1; 

// Asignación compuesta: 

x += y; 

x -= Y; 

x *= Y; 

x /= y; 

x %= y; 

x <<= 1; 

x >>= 1; 

x >>>= 1; 

x &= y; 

X A= Y; 

x I= y; 

// Conversión: 

//! boolean b = (boolean)~; 

char c = (char)~; 

byte B = by te)^; 

short S = (short)~; 

long 1 = (1ong)x; 

float f = (float) x; 

double d - (double) x; 

1 

void pruebalong (lorig x, loriy y) { 

// Operadores aritméticos: 

x=x*y; 

x=x/y; 

X = x % y; 

106 Piensa en Java 

x=x+y; 

X = x - y; 

x++; 

x--; 

x = +y; 

x = -y; 

// Relacionales y lógicos : 

f(x > y); 

f (x >= y) ; 

f(x < y); 

f (x <= y) ; 

f (x == y) ; 

f(x != y); 

! f (!x); 

/ f(x GG y); 

! f(x II y); 

// Operadores de bit: 

x = -y; 

x=x&y; 

x=x / y; 

X = x A y; 

x = x << 1; 

x = x >> 1; 

x = x >>> 1; 

// Asignación compuesta: 

x += y; x -= Y; x *= Y; 

x /= y; So- y; 

x <<= 1; 

x >>= 1; 

x >>>= 1; 

x &= y; 

X Y; 

x I= y; 

// Conversión: 

//! boolean b = (boolean)~; 

char c = (char)~; 

byte B = by te)^; 

short S = (shorL) x; 

int i = (int)x; 

float f = (f1oat)x; 

double d = (double)~; 

1 

3: Controlar el flujo del programa 107 

void pruebaFloat (f loat x, f loat y) { 

// Operadores aritméticos: 

X = x * y; 

x=x/y; 

X = x % y; 

x=x+y; 

X = x - y; 

x++; 

x--; 

x = +y; 

x = -y; 

/ / Relacionales y lógicos : 

f(x > y); 

f (x i= y); 

f(x < y); 

f (x <= y); 

f (x == y); 

f(x != y); 

! f (!x); 

! f(x && y); 

/ f(x 11 y); 

// Operadores de bit: 

//! x = -y; 

//! x = x & y; 

//! x = x 1 y; 

//! x = x " y; 

//! x = x << 1; 

//! x = x >> 1; 

//! x = x >>> 1; 

// Asignación compuesta: 

x += y; 

x -= y; 

x *= Y; 

x /= y; Po- y; 

//! x <<= 1; 

//! x >>= 1; 

//! x >>>= 1; 

//! x &= y; 

//! x ^= Y; 

//! x I= y; 

// Conversión: 

//! boolean b = (boolean)~; 

char c = (char)~; 

byte B = (byte) x; 

108 Piensa en Java 

short s = (shortlx; 

int i = (int)x; 

long 1 = (1ong)x; 

double d = (double)~; 

1 

void pruebaDouble (double x, double y) { 

// Operadores aritméticos: 

X = x * y; 

x=x/ y; 

X = x % y; 

x=x+y; 

X = x - y; 

xt+; 

x--; 

x = +y; 

x = -y; 

// Relacionales y lógicos: 

f(x > y); 

f (x >= y) ; 

f(x < y); 

f (x <= y) ; 

f (x == y) ; 

f (x != y); 

! f (!x); 

! f(x && y); 

! f(x ll y); 

// Operadores de bit: 

//! x = -y; 

//! x = x & y; 

//! x=x I y; 

//! x = x A y; 

//! x = x << 1; 

//! x = x >> 1; 

//! x = x >>> 1; 

// Asignación compuesta: 

x += y; 

x -= Y; x *= Y; 

x /= y; 

x %= y; 

//! x <<' 1; 

//! x >>= 1; 

//! x >>>= 1; 

//! x &= y; 

//! x ^= y; 

3: Controlar el flujo del programa 109 

//! x l= y; 

// Conversión: 

//! boolean b = (boolean) x; 

char c = (char)~; 

byte B = by te)^; 

short S = (short)~; 

int i = (int)x; 

long 1 = (long) x; 

float f = (f1oat)x; 

Fíjese que boolean es bastante limitado. Se le pueden asignar los valores true y false, y se puede 

comprobar su validez o falsedad, pero no se pueden sumar valores lógicos o llevar a cabo ningún 

otro tipo de operación sobre ellos. 

En char, byte y short se puede ver el efecto de promoción con los operadores aritméticos. Cada 

operación aritmética que se haga con estos tipos genera como resultado un int, que debe ser explícitamente convertido para volver al tipo original (una conversión reductora que podría implicar pérdida de información) para volver a ser asignado a ese tipo. Con los valores int, sin embargo, no es 

necesaria ninguna conversión, porque todo es ya un int. Aunque no hay que relajarse pensando que 

todo está ya a salvo. Si se multiplican dos valores de tipo int lo suficientemente grandes, se desbordará el resultado. Esto se demuestra en el siguiente ejemplo: 

//: c03:Desbordamiento.java 

// ;Sorpresa! Java permite desbordamientos. 

public class Desbordamiento { 

public static void main (String[] args) { 

int grande = Ox7fffffff; // Valor entero máximo 

visualizar ("grande = " + grande) ; 

int mayor = grande * 4; 

visualizar ("mayor = l' t mayor) ; 

static void visualizar (String S) { 

System.out .println (S) ; 

1 

1 ///:- 

La salida de esto es: 

grande = 2147483647 

mayor = -4 

y no se recibe ningún error ni advertencia proveniente del cornpilador, ni excepciones en tiempo de 

ejecución. Java es bueno, pero no tanto. 

110 Piensa en Java 

La asignaciones compuestas no requieren conversiones para char, byte o short, incluso aunque estén llevando a cabo promociones que tienen los mismos resultados que los operadores aritméticos 

directos. Por otro lado, la falta de conversión, definitivamente, simplifica el código. 

Se puede ver que, con la excepción de boolean, cualquier tipo primitivo puede convertirse a otro tipo 

primitivo. De nuevo, debemos ser conscientes del efecto de la conversión reductora cuando se hace 

una conversión a un tipo menor. Si no, se podría perder información sin saberlo durante la conversión. 

Control de ejecución 

Java utiliza todas las sentencias de control de ejecución de C, de forma que si se ha programado con 

C o C++, la mayoría de lo que se ha visto será familiar. La mayoría de los lenguajes procedurales tienen algún tipo de sentencia de control, y casi siempre hay solapamiento entre lenguajes. En Java, 

las palabras clave incluyen if-else, while, do-while, for, y una sentencia de selección denominada 

switch. Java, sin embargo, no soporta el siempre perjudicial goto (lo que podría seguir siendo la 

manera más expeditiva de solventar cierto tipo de problemas). Todavía se puede hacer un salto del 

estilo del "goto", pero es mucho más limitado que un goto típico. 

True y false 

Todas las sentencias condicionales utilizan la certeza o falsedad de una expresión de condición para 

determinar el cauce de ejecución. Un ejemplo de una expresión condicional es A == B. Ésta hace 

uso del operador condicional == para ver si el valor de A es equivalente al valor de B. La expresión 

devuelve true o false. Cualquiera de los operadores relacionales vistos anteriormente en este capítulo puede usarse para producir una sentencia condicional. Fíjese que Java no permite utilizar un número como un boolean, incluso aunque está permitido en C y C++ (donde todo lo distinto de cero 

es verdadero, y cero es falso). Si se quiere usar un valor que no sea lógico en una conducción lógica, como if(a), primero es necesario convertirlo a un valor boolean utilizando una expresión condicional, como if(a!=O). 

La sentencia if-else es probablemente la manera más básica de controlar el flujo de un programa. 

El else es opcional, por lo que puede usarse if de dos formas: 

if (expresión condicional) 

sentencia 

if (expresión condicional) 

sentencia 

else 

sentencia 

3: Controlar el flujo del programa 11 1 

La expresión condicional debe producir un resultado boolean. La sentencia equivale bien a una sentencia simple acabada en un punto y coma, o a una sentencia compuesta, que es un conjunto de sentencias simples encerradas entre llaves. Cada vez que se use la palabra sentencia, siempre implicará que ésta puede ser simple o compuesta. 

He aquí un método prueba( ) como ejemplo de if-else. Se trata de un método que indica si un número dicho en un acertijo es mayor, menor o equivalente al número solución: 

//: cO3: IfElse. java 

public class IfElse { 

static int prueba(int intento, int solucion) { 

int resultado = 0; 

if (intento > solucion) 

resultado = +l; 

else if (intento < solucion) 

resultado = -1; 

else 

resultado = 0; // Coincidir 

return resultado; 

1 

public static void main(String[] args) { 

System.out .println (prueba (10, 5) ) ; 

System. out .println (prueba (5, 10) ) ; 

System. out .println (prueba (5, 5) ) ; 

1 

1 ///:- 

Es frecuente alinear el cuerpo de una sentencia de control de flujo, de forma que el lector pueda determinar fácilmente dónde empieza y dónde acaba. 

return 

La palabra clave return tiene dos propósitos: especifica qué valor devolverá un método (si no tiene 

un valor de retorno void), y hace que el valor se devuelva inmediatamente. El método prueba( ) 

puede reescribirse para sacar ventaja de esto: 

//: c03:IfElseZ.java 

public class IfElse2 { 

static int prueba (int intento, int solucionar) { 

int resultado = 0; 

if (intento > solucionar) 

ret-iirn tl; 

else if (intento < solucionar) 

return -1; 

else 

return O; // Coincidir 

112 Piensa en Java 

} 

public static void main(String[l args) { 

System.out .println (prueba (10, 5) ) ; 

System.out .println (prueba (5, 10) ) ; 

System.out .println (prueba (5, 5) ) ; 

1 

1 ///:- 

No hay necesidad de else porque el método no continuará ejecutándose una vez que se ejecute el 

return. 

Iteración 

Las sentencias while, do-while y for son para el control de bucles, y en ocasiones se clasifican 

como sentencias de iteración. Se repite una sentencia hasta que la expresión Condicional controladora se evalúe a falsa. La forma de un bucle while es: 

while (Expresión-Condicional) 

sentencia 

La expresión condicional se evalúa al comienzo de cada interación del bucle, y de nuevo antes de 

cada iteración subsiguiente de la sentencia. 

He aquí un ejemplo sencillo que genera números aleatorios hasta que se dé una condición determinada: 

//: c03:PruebaWhile.java 

// Muestra el funcionamiento del bucle while. 

public class PruebaWhile { 

public static void main(String[] args) { 

double r = 0; 

while(r < 0.99d) { 

r = Math.random() ; 

System.out.println(r); 

1 

1 

1 ///:- 

Este ejemplo usa el método estático random( ) de la biblioteca Math, que genera un valor double 

entre O y 1. (Incluye el O, pero no el 1.) La expresión condicional para el while dice "siga haciendo 

este bucle hasta que el número sea 0,99 o mayor". Cada vez que se ejecute este programa, se logrará un listado de números de distinto tamaño. 

do-while 

La forma del do-while es 

3: Controlar el flujo del programa 113 

do 

sentencia 

while (Expresión condicional); 

La única diferencia entre while y do-while es que la sentencia del do-while se ejecuta siempre, al 

menos, una vez, incluso aunque la expresión se evalúe como falsa la primera vez. En un while, si la 

condicional es falsa la primera vez, la sentencia no se ejecuta nunca. En la práctica, do-while es menos común que while. 

for 

Un bucle for lleva a cabo la inicialización antes de la primera iteración. Después, lleva a cabo la comprobación condicional y, al final de cada iteración, hace algún tipo de "paso". La forma del bucle for 

es: 

for(inicia1ización; Expresión condicional; paso) 

sentencia 

Cualquiera de las expresiones inicialización, expresión condicional o paso puede estar vacía. Dicha 

expresión se evalúa antes de cada iteración, y en cuanto el resultado sea falso, la ejecución continuará en la línea siguiente a la sentencia for. Al final de cada iteración se ejecuta paso. 

Los bucles for suelen utilizarse para crear contadores: 

//: c03:ListaCaracteres.java 

// Muestra el funcionamiento del bucle "for" listando 

// todos los caracteres ASCII. 

public class Listacaracteres { 

public static void main (String[] arqs) { 

for( char c = O; c < 128; c++) 

if (C != 26 ) // Limpiar pantalla ANSI 

System.out.println( 

"valor: " + (int) c + 

'' caracter: " + c) ; 

Fíjese en que la variable c está definida en el punto en que se usa, dentro de la expresión de control del bucle for, en vez de al principio del bloque delimitado por la llave de apertura. El ámbito de 

c es la expresión controlada por el for. 

Los lenguajes procedurales tradicionales como C requieren que todas las variables se definan al 

principio de un bloque, de forma que cuando el compilador cree un bloque, pueda asignar espacio 

para esas variables. En Java y C++ es posible diseminar las declaraciones de variables a lo largo del 

bloque, definiéndolas en el momento en que son necesarias. Esto permite un estilo de codificación 

más natural y hace que el código sea más fácil de entender. 

114 Piensa en Java 

Se puede definir múltiples variables dentro de una sentencia for, pero deben ser del mismo tipo: 

for(int i = O, j =l; 

i < 10 && j i= 11; 

i++, j++) 

/* cuerpo del bucle for */ 

La definición int de la sentencia for cubre tanto a i como a j. La habilidad de definir variables en 

expresiones de control se limita al bucle for. No se puede utilizar este enfoque con cualquiera de 

las otras sentencias de selección o iteración. 

El o~erador coma 

Anteriormente en este capítulo, dije que el operador coma (no el separador coma, que se usa para separar definiciones y parámetros de funciones) sólo tiene un uso en Java: en la expresión de control de 

un bucle for. Tanto en la inicialización como en las porciones de "paso" de las expresiones de control, 

se tiene determinado número de sentencias separadas por comas, y estas sentencias se evaluarán secuencialmente. El fragmento de bloque previo utiliza dicha capacidad. He aquí otro ejemplo: 

//: c03:OperadorComa.java 

public class Operadorcoma { 

public static void main (String[] args) { 

for(int i = 1, J = i + 10; i < 5; 

i++, j = i*2) { 

System.out.println("i= " + i + " j= " + j); 

He aquí la salida: 

Se puede ver que tanto en la inicialización, como en las porciones de "paso" se evalúan las sentencias en orden secuencial. Además, la porción de inicialización puede tener cualquier número de definiciones de un tipo. 

break y continue 

Dentro del cuerpo de cualquier sentencia de iteración también se puede controlar el flujo del bucle 

utilizando break y continue. Break sale del bucle sin ejecutar el resto de las sentencias del bucle. 

Continue detiene la ejecución de la iteración actual y vuelve al principio del bucle para comenzar la 

siguiente iteración. 

Este programa muestra ejemplos de break y continue dentro de bucles for y while: 

3: Controlar el flujo del programa 115 

//: c03:BreakYContinue.java 

// Muestra el funcionamiento de las palabras clave break y continue. 

public class BreakYContinue { 

public static void main(String[] args) { 

for(int i = O; i < 100; itt) { 

if (i == 74) break; // Sale del bucle for 

if (i % 9 != 0) continue; // Siguiente iteración 

System-out .println (i) ; 

1 

int i = 0; 

// Un "bucle infinito": 

while (true) { 

itt; 

Asunto Símbolo Significado Página

Lógica ∼p no p 25

p ∧ q p y q 25

p ∨ q p o q 25

p ⊕ q o p XOR q p o q pero no tanto p como q 28

P ≡ Q P es lógicamente equivalente a Q 30

p → q si p entonces q 40

p ↔ q p si y sólo si q 45

∴ por lo tanto 51

Predicado P(x) en x 97

P(x) Q(x) cada elemento del conjunto de verdad para P(x) está en 104

el conjunto de verdad para Q(x)

P(x) ⇔ Q(x) P(x) y Q(x) tienen conjuntos de verdad idénticos 104

∀ para todos los 101

∃ existe 103





Aplicaciones de la lógica



NO-puerta 67



Puerta AND 67

Puerta OR 67

Puerta NAND 75

Puerta NOR 75



















Teoría de números y aplicaciones



| Golpe de sheffer 74

↓ Flecha de Peirce 74

n2 número escrito en notación binaria 78

n10 número escrito en notación decimal 78

n16 número escrito en notación hexadecimal 91

re | n d divide n 170

d/| n d no divide n 172

n div d el cociente entero de n dividido por d 181

n mod d el resto entero de n dividido por d 181

  x ] el piso de x 191

「x el techo de x 191

|x | el valor absoluto de x 187

mcd(a, b) el máximo común divisor de a y b 220

x := e x se le asigna el valor e 214











norte

ak la sumatoria de k es igual a m an de ak 230

k=m norte

ak el producto de k es igual a m an de ak 223

k=metro

¡norte! factorial 237

Conjunto a ∈ A a es un elemento de A 7

Teoría a ∈/ A a no es un elemento de A 7

{a1, a2,..., an} el conjunto con elementos a1, a2,..., an 7

{x∈D| P(x)} el conjunto de todos los x en D para los cuales P(x) es verdadero 8

R, R−, R+, Rnonneg los conjuntos de todos los números reales, reales negativos 7, 8

números, números reales positivos y números reales no negativos

Z, Z−, Z+, Znonneg los conjuntos de todos los números enteros, enteros negativos, 7, 8

enteros positivos y enteros no negativos

Q, Q−, Q+, Qnonneg los conjuntos de todos los números racionales, negativos 7, 8

números racionales, números racionales positivos y números racionales no negativos

N el conjunto de los números naturales 8

A ⊆ B A es un subconjunto de B 9

A /⊆ B A no es un subconjunto de B 9

A = B A es igual a B 339

A ∪ B A unión B 341

A ∩ B A intersección B 341

B − A la diferencia de B menos A 341

Ac el complemento de A 341

(x, y) par ordenado 11

(x1, x2,..., xn) ordenado n-tupla 346

A × B el producto cartesiano de A y B 12

A1 × A2 × ··· × An el producto cartesiano de A1, A2,..., An 347

∅ el conjunto vacío 361

P( A) el conjunto de potencia de A 346



























   n n elija r, el número de r combinaciones 566

bx b elevado a la potencia x 405, 406

F −1 la función inversa de F 411



R−1 la relación inversa de R 444



Continúa en la primera página de las guardas traseras.









MATEMÁTICAS DISCRETAS







MATEMÁTICAS DISCRETAS

CON APLICACIONES



CUARTA EDICIÓN









SUSANNA S. EPP

Universidad DePaul









































Australia · Brasil · Japón · Corea · México · Singapur · España · Reino Unido · Estados Unidos







































Esta es una versión electrónica del libro de texto impreso. Debido a restricciones de derechos electrónicos, es posible que se suprima parte del contenido de terceros. La revisión editorial ha considerado que cualquier contenido suprimido no representa materialmente

afectan la experiencia de aprendizaje en general. El editor se reserva el derecho de eliminar contenido de este título en cualquier momento si posteriores

las restricciones de derechos así lo requieren. Para obtener información valiosa sobre precios, ediciones anteriores, cambios en las ediciones actuales y formatos alternativos, visite para buscar por número de ISBN, autor, título o palabra clave materiales en sus áreas de interés.































































Copyright 2010 Cengage Aprendizaje. Reservados todos los derechos. No se puede copiar, escanear ni duplicar, total o parcialmente. Debido a los derechos electrónicos, es posible que algunos contenidos de terceros se supriman del libro electrónico y/o de los capítulos electrónicos. La revisión editorial ha considerado que cualquier contenido suprimido no afecta materialmente la experiencia de aprendizaje general. Cengage Learning se reserva el derecho de eliminar contenido adicional en cualquier momento si restricciones de derechos posteriores así lo requieren.











 







Foto de portada: Las piedras son objetos discretos colocados uno encima de otro como una cadena de razonamiento cuidadoso. Una persona que decide construir una torre así aspira a las alturas y disfruta jugando con un problema desafiante. La elección de las piedras requiere un sentido tanto científico como estético. Lograr que se equilibren requiere un esfuerzo paciente y una reflexión cuidadosa. Y la torre resultante es preciosa. ¡Una metáfora perfecta de las matemáticas discretas!





Matemáticas discretas con aplicaciones, cuarta edición

Susanna Epp



Editorial: Richard Stratton

Editor patrocinador principal: Molly Taylor Editor asociado: Daniel Seibert Asistente editorial: Shaylin Walsh

Editor asociado de medios: Andrew Coppola

Gerente sénior de marketing: Jennifer Pursley Jones

Gerente de Comunicaciones de Marketing: Mary Anne Payumo

Coordinadora de marketing: Erica O'Connell Gerente de proyectos de contenido: Alison Eigel Zade Directora de arte senior: Jill Ort

Compradora sénior de impresión: Diane Gibbons

Especialistas en adquisiciones adecuadas: Timothy Sisler y Don Schlotman

Servicio de producción: Servicios editoriales de Elm Street

Responsable de fotografía: Chris Althof, Bill Smith Group

Diseñador de portada: Hanh Luu

Imagen de portada: GettyImages.com (Colección: OJO Images, Fotógrafo: Martin Barraud)

Compositor: Integra Software Services Pvt.

. Limitado.



Ⓧc 2011, 2004, 1995 Brooks/Cole Cengage Aprendizaje

RESERVADOS TODOS LOS DERECHOS. Ninguna parte de este trabajo cubierto por los derechos de autor en este documento puede reproducirse, transmitirse, almacenarse o usarse de ninguna forma ni por ningún medio gráfico, electrónico o mecánico, incluidos, entre otros, fotocopiado, grabación, escaneo, digitalización, grabación, Web. distribución, redes de información o sistemas de almacenamiento y recuperación de información, excepto según lo permitido por la Sección 107 o 108 de la Ley de Derechos de Autor de los Estados Unidos de 1976, sin el permiso previo por escrito del editor.





Número de control de la Biblioteca del Congreso: 2010927831 Edición para estudiantes:

ISBN-13: 978-0-495-39132-6 ISBN-10: 0-495-39132-8



Brooks/Cole

20 Channel Center Street Boston, MA 02210

EE.UU



Cengage Learning es un proveedor líder de soluciones de aprendizaje personalizadas con oficinas en todo el mundo, incluidos Singapur, el Reino Unido, Australia, México, Brasil y Japón. Ubique su oficina local en: international.cengage.com/region.



Los productos de Cengage Learning están representados en Canadá por Nelson Education, Ltd.



Para conocer su curso y soluciones de aprendizaje, visite





Compra cualquiera de nuestros productos en la tienda de tu universidad local o en nuestra tienda en línea preferida





















Impreso en Canadá

1 2 3 4 5 6 7 14 13 12 11 10







































A Jayne y Ernesto

















CONTENIDO





Uso de variables en el discurso matemático; Introducción a las declaraciones universales, existenciales y condicionales



Las notaciones Set-Roster y Set-Builder; Subconjuntos; Productos cartesianos



Definición de una relación de un conjunto a otro; Diagrama de flechas de una relación; Definición de Función; Máquinas funcionales; Igualdad de funciones





Declaraciones; Declaraciones compuestas; Valores de Verdad; Evaluación de la veracidad de enunciados compuestos más generales; Equivalencia Lógica; Tautologías y Contradicciones; Resumen de equivalencias lógicas



Equivalencias lógicas que involucran ; Representación de Si-Entonces Como O; La negación de una declaración condicional; La contrapositiva de una declaración condicional; Lo contrario y lo inverso de una declaración condicional; Sólo Si y el Bicondicional; Condiciones Necesarias y Suficientes; Observaciones



Modus Ponens y Modus Tollens; Formas adicionales de argumentos válidos: reglas de inferencia; Falacias; Contradicciones y Argumentos Válidos; Resumen de reglas de inferencia



Cajas y Puertas Negras; La tabla de entradas/salidas de un circuito; La expresión booleana correspondiente a un circuito; El circuito correspondiente a una expresión booleana; Encontrar un circuito que corresponda a una tabla de entrada/salida determinada; Simplificación de circuitos combinacionales; Puertas NAND y NOR



Representación Binaria de Números; Suma y Resta Binaria; Circuitos para adición de computadoras; Los complementos a dos y la representación informática de

vi





Enteros Negativos; Representación de 8 bits de un número; Suma informática con números enteros negativos; Notación hexadecimal





El cuantificador universal: ; El cuantificador existencial: ; Lenguaje formal versus lenguaje informal; Declaraciones Condicionales Universales; Formas equivalentes de enunciados universales y existenciales; Cuantificación implícita; El mundo de Tarski



Negaciones de Declaraciones Cuantificadas; Negaciones de enunciados condicionales universales; La relación entre , , y ; Verdad vacía de las declaraciones universales; Variantes de enunciados condicionales universales; Condiciones necesarias y suficientes, sólo si



Traducir del lenguaje informal al formal; lenguaje ambiguo; Negaciones de declaraciones cuantificadas multiplicadamente; Orden de Cuantificadores; notación lógica formal; Prólogo



Modus Ponens Universal; Uso del Modus Ponens Universal en una Prueba; Modus Tollens Universal; Demostración de validez de argumentos con afirmaciones cuantificadas; Uso de diagramas para probar la validez; Crear formas adicionales de argumentación; Observación sobre los errores inversos e inversos







Definiciones; Demostración de declaraciones existenciales; Refutar afirmaciones universales mediante contraejemplos; Demostración de declaraciones universales; Instrucciones para redactar pruebas de enunciados universales; Variaciones entre Pruebas; Errores comunes; Cómo comenzar con las pruebas; Demostrar que una afirmación existencial es falsa; Conjetura, prueba y refutación



Más sobre generalizar a partir del particular genérico; Demostración de propiedades de números racionales; Derivando nuevas matemáticas de las antiguas



Demostración de propiedades de divisibilidad; Contraejemplos y Divisibilidad; El teorema de factorización única de números enteros









*-Equivalencia de Estados; k-Equivalencia de Estados; Encontrar las clases de equivalencia *; El autómata cociente; Construcción del autómata cociente; Autómatas equivalentes



























PREFACIO



Mi propósito al escribir este libro fue proporcionar un tratamiento claro y accesible de las matemáticas discretas para estudiantes con especialización o 

especialización en informática, matemáticas, educación matemática e ingeniería. El objetivo del libro es sentar las bases matemáticas para cursos de informática como estructuras de datos, algoritmos, teoría de bases de datos relacionales, teoría de autómatas y lenguajes formales, diseño de compiladores y criptografía, y para cursos de matemáticas como lineal y ab.

álgebra abstracta, combinatoria, probabilidad, lógica y teoría de conjuntos, y teoría de números. Al combinar la discusión sobre teoría y práctica, he tratado de mostrar que las matemáticas tienen aplicaciones atractivas e importantes, además de ser interesantes y hermosas por derecho propio.

El único requisito previo es tener una buena formación en álgebra; Los estudiantes pueden tomar el curso antes o después de un curso de cálculo. Las ediciones anteriores del libro han sido utilizadas con éxito por estudiantes de cientos de instituciones en América del Norte y del Sur, Europa, Medio Oriente, Asia y Australia.

Recomendaciones curriculares recientes del Institute for Electrical and Electronic Engineers Computer Society (IEEE-CS) y la Association for Computing Machinery (ACM) incluyen las matemáticas discretas como la mayor parte del “conocimiento básico” para los estudiantes de ciencias de la computación y afirman que los estudiantes deben tomar al menos un curso de un semestre sobre la materia como parte de sus estudios de primer año, prefiriéndose un curso de dos semestres cuando sea posible. Este libro incluye los temas recomendados por esas organizaciones y se puede utilizar eficazmente para un curso de uno o dos semestres.

Hubo un tiempo en que la mayoría de los temas de matemáticas discretas se enseñaban sólo a estudiantes universitarios de nivel superior. Descubrir cómo presentar estos temas de manera que puedan ser comprendidos por los estudiantes de primer y segundo año fue el desafío principal y más interesante al escribir este libro. La presentación se desarrolló durante un largo período de experimentación durante el cual mis alumnos fueron, en muchos sentidos, mis profesores. Sus preguntas, comentarios y trabajos escritos me mostraron qué conceptos y técnicas les causaban dificultades, y su reacción a mi exposición me mostró qué funcionó para desarrollar su comprensión y fomentar su interés. Muchos de los cambios en esta edición han sido el resultado de la interacción continua con los estudiantes.





Temas de un curso de matemáticas discretas

Las matemáticas discretas describen procesos que constan de una secuencia de pasos individuales. Esto contrasta con el cálculo, que describe procesos que cambian de manera continua. Mientras que las ideas del cálculo fueron fundamentales para la ciencia y la tecnología de la revolución industrial, las ideas de las matemáticas discretas son la base de la ciencia y la tecnología de la era de la informática. Los temas principales de un primer curso de matemáticas discretas son lógica y prueba, inducción y recursividad, estructuras discretas, combinatoria y probabilidad discreta, algoritmos y su análisis, y aplicaciones y modelado.



Lógica y demostración Probablemente el objetivo más importante de un primer curso de matemáticas discretas sea ayudar a los estudiantes a desarrollar la capacidad de pensar de forma abstracta. Esto significa aprender a utilizar formas de argumentación lógicamente válidas y evitar errores lógicos comunes, apreciar lo que significa razonar a partir de definiciones, saber cómo utilizar métodos directos e indirectos.



xiv





argumento para derivar nuevos resultados a partir de aquellos que ya se sabe que son verdaderos, y poder trabajar con representaciones simbólicas como si fueran objetos concretos.



Inducción y recursividad Un desarrollo apasionante de los últimos años ha sido el creciente aprecio por el poder y la belleza del “pensamiento recursivo”. Pensar recursivamente significa abordar un problema asumiendo que problemas similares de menor naturaleza ya han sido resueltos y descubriendo cómo juntar esas soluciones para resolver el problema mayor. Este tipo de pensamiento se utiliza ampliamente en el análisis de algoritmos, donde las relaciones de recurrencia que resultan del pensamiento recursivo a menudo dan lugar a fórmulas que se verifican mediante inducción matemática.



Estructuras discretas Las estructuras matemáticas discretas son estructuras abstractas que describen, categorizan y revelan las relaciones subyacentes entre objetos matemáticos discretos. Los que se estudian en este libro son los conjuntos de números enteros y racionales, conjuntos generales, álgebras booleanas, funciones, relaciones, gráficos y árboles, lenguajes formales y expresiones regulares, y autómatas de estados finitos.



Combinatoria y probabilidad discreta La combinatoria es la matemática de contar y organizar objetos, y la probabilidad es el estudio de las leyes relativas a la medición de eventos aleatorios o fortuitos. La probabilidad discreta se centra en situaciones que involucran conjuntos discretos de objetos, como encontrar la probabilidad de obtener una cierta cantidad de caras cuando se lanza una moneda imparcial una cierta cantidad de veces. Se necesita habilidad en el uso de la combinatoria y la probabilidad en casi todas las disciplinas donde se aplican las matemáticas, desde la economía hasta la biología, la informática, la química y la física y la gestión empresarial.



Algoritmos y su análisis La palabra algoritmo era en gran medida desconocida a mediados del siglo XX, pero ahora es una de las primeras palabras que se encuentran en el estudio de la informática. Para resolver un problema en una computadora, es necesario encontrar un algoritmo o una secuencia paso a paso de instrucciones que la computadora debe seguir. Diseñar un algoritmo requerido

Requiere una comprensión de las matemáticas subyacentes al problema a resolver. Determinar si un algoritmo es correcto o no requiere un uso sofisticado de la inducción matemática. Calcular la cantidad de tiempo o espacio de memoria que necesitará el algoritmo para compararlo con otros algoritmos que producen el mismo resultado requiere conocimientos de combinatoria, relaciones de recurrencia, funciones y O-, ▲- y

①-notaciones.



Aplicaciones y modelado Los temas matemáticos se comprenden mejor cuando se ven en una variedad de contextos y se utilizan para resolver problemas en una amplia gama de situaciones aplicadas. Una de las lecciones profundas de las matemáticas es que el mismo modelo matemático puede usarse para resolver problemas en situaciones que superficialmente parecen totalmente diferentes. El objetivo de este libro es mostrar a los estudiantes la extraordinaria utilidad práctica de algunas ideas matemáticas muy abstractas.



Características especiales de este libro

Razonamiento matemático La característica que más distingue a este libro de otros textos de matemáticas discretas es que enseña (explícitamente pero de una manera accesible a estudiantes universitarios de primer y segundo año) la lógica y el razonamiento tácitos que subyacen al pensamiento matemático. Durante muchos años impartí un curso intensivo e interactivo de transición a las matemáticas abstractas para estudiantes de matemáticas e informática. Esta experiencia me mostró que si bien es posible enseñar a la mayoría de los estudiantes a











xvi Prefacio



comprender y construir argumentos matemáticos sencillos, los obstáculos para hacerlo no pueden pasarse por alto a la ligera. Para tener éxito, un texto para un curso de este tipo debe abordar las dificultades de los estudiantes con la lógica y el lenguaje directamente y con cierta extensión. También debe incluir suficientes ejemplos y ejercicios concretos para permitir a los estudiantes desarrollar los modelos mentales necesarios para conceptualizar problemas más abstractos. El tratamiento de la lógica y la prueba en este libro combina sentido común y rigor de una manera que explica lo esencial, pero evita sobrecargar a los estudiantes con detalles formales.



Enfoque en espiral para el desarrollo de conceptos Varios conceptos de este libro aparecen en formas cada vez más sofisticadas en capítulos sucesivos para ayudar a los estudiantes a desarrollar la capacidad de abordar eficazmente niveles crecientes de abstracción. Por ejemplo, cuando los estudiantes encuentran las matemáticas relativamente avanzadas del pequeño teorema de Fermat en la Sección 8.4, ya se les ha introducido la lógica del discurso matemático en los Capítulos 1, 2 y 3, han aprendido los métodos básicos de demostración y los conceptos de mod. y div en el Capítulo 4, exploró mod y div como funciones en el Capítulo 7 y se familiarizó con las relaciones de equivalencia en las Secciones 8.2 y 8.3. Este enfoque incorpora una revisión útil y desarrolla la madurez matemática en etapas naturales.



Apoyo a los estudiantes Los estudiantes de colegios y universidades inevitablemente tienen que aprender mucho por sí mismos. Aunque a menudo resulta frustrante, aprender a aprender mediante el autoestudio es un paso crucial hacia el éxito final en una carrera profesional. Este libro tiene una serie de características para facilitar la transición de los estudiantes al aprendizaje independiente.

Ejemplos resueltos

El libro contiene más de 500 ejemplos resueltos, escritos en un formato de solución de problemas y adaptados en tipografía y dificultad a los ejercicios. Muchas soluciones para los problemas de prueba se desarrollan en dos etapas: primero una discusión sobre cómo se podría llegar a pensar en la prueba o refutación y luego un resumen de la solución, que se incluye en un recuadro. Este formato permite a los estudiantes leer el problema y pasar inmediatamente al resumen, si lo desean, y solo regresar a la discusión si tienen problemas para entender el resumen. El formato también ahorra tiempo a los estudiantes que releen el texto como preparación para un examen.

Notas marginales y preguntas para ponerse a prueba

En los márgenes de todo el libro se incluyen notas sobre temas de particular importancia y comentarios de advertencia para ayudar a los estudiantes a evitar errores comunes. Entre el texto y los ejercicios se encuentran preguntas diseñadas para centrar la atención en las ideas principales de cada sección. Por conveniencia, las preguntas utilizan un formato de completar espacios en blanco y las respuestas se encuentran inmediatamente después de los ejercicios.

Ejercicios

El libro contiene casi 2600 ejercicios. Los conjuntos al final de cada sección han sido diseñados para que estudiantes con antecedentes y niveles de habilidad muy diferentes encuentren algunos ejercicios que pueden estar seguros de realizar con éxito y también algunos ejercicios que los desafiarán.

Soluciones para ejercicios

Para proporcionar una retroalimentación adecuada a los estudiantes entre sesiones de clase, el Apéndice B contiene una gran cantidad de soluciones completas a los ejercicios. Se recomienda encarecidamente a los estudiantes que no consulten las soluciones hasta que hayan hecho todo lo posible para responder las preguntas por sí mismos. Sin embargo, una vez que lo hayan hecho, comparar sus respuestas con las dadas puede conducir a una comprensión significativamente mejor. Además, muchos problemas, incluidos algunos de los más difíciles

, tenga soluciones parciales o sugerencias para que los estudiantes puedan determinar si están en el camino correcto y hacer ajustes si es necesario.





También hay muchos ejercicios sin solución para ayudar a los estudiantes a aprender a resolver problemas matemáticos en un entorno realista.

Funciones de referencia

Muchos estudiantes me han escrito para decirme que el libro les ayudó a tener éxito en sus cursos avanzados. Uno incluso escribió que había usado tanto una edición que se había desmoronado, y de hecho salió y compró una copia de la siguiente edición, que seguía usando en un programa de maestría. Se incluyen figuras y tablas cuando hacerlo ayudaría a los lectores a una mejor comprensión. En la mayoría, se utiliza un segundo color para resaltar el significado. Mi razón fundamental para seleccionar enunciados de definiciones y teoremas, poner títulos a los ejercicios y dar los significados de los símbolos y una lista de fórmulas de referencia en las guardas es facilitar a los estudiantes el uso de este libro para su revisión en un curso actual y como referencia en otros posteriores.



Apoyo al instructor He recibido una gran cantidad de comentarios valiosos de instructores que han utilizado ediciones anteriores de este libro. Muchos aspectos del libro se han mejorado gracias a sus sugerencias. Además de los siguientes elementos, hay apoyo adicional para el instructor en el sitio web del libro, que se describe más adelante en el prefacio.

Ejercicios

La gran variedad de ejercicios en todos los niveles de dificultad permite a los instructores una gran libertad para adaptar un curso a las habilidades de sus estudiantes. Los ejercicios con soluciones al final del libro tienen números en azul, y aquellos cuyas soluciones se dan en un Manual de soluciones para estudiantes y una Guía de estudio por separado tienen números que son múltiplos de tres. Hay ejercicios de todo tipo representados en este libro que no tienen respuesta en ninguno de los lugares para permitir a los instructores asignar cualquier combinación que prefieran de ejercicios con y sin respuestas. El amplio número de ejercicios de todo tipo ofrece a los profesores una importante variedad de problemas para utilizar en tareas de revisión y exámenes. Se invita a los instructores a utilizar los numerosos ejercicios planteados como preguntas en lugar de en forma de “demostrar que” para estimular la discusión en clase sobre el papel de la prueba y el contraejemplo en la resolución de problemas.

Secciones flexibles

La mayoría de las secciones se dividen en subsecciones para que un instructor que tenga poco tiempo pueda optar por cubrir ciertas subsecciones solo y omitir el resto o dejarlas para que los estudiantes las estudien por su cuenta. La división en subsecciones también facilita a los instructores dividir las secciones si desean dedicar más de un día a ellas.

Presentación de métodos de prueba.

Es inevitable que las pruebas y refutaciones de este libro parezcan fáciles a los profesores. Sin embargo, a muchos estudiantes les resultan difíciles. Al mostrar a los estudiantes cómo descubrir y construir pruebas y refutaciones, he tratado de describir los tipos de enfoques que utilizan los matemáticos cuando enfrentan problemas desafiantes en su propia investigación.

Soluciones para instructores

Soluciones completas para instructores para todos los ejercicios están disponibles para cualquiera que imparta un curso de este libro a través del servicio Solution Builder de Cengage. Los instructores pueden registrarse para acceder en



Lo más destacado de la cuarta edición

Los cambios realizados para esta edición se basan en sugerencias de colegas y otros usuarios veteranos de ediciones anteriores, en interacciones continuas con mis alumnos y en desarrollos dentro de los campos en evolución de la informática y las matemáticas.







Reorganización

Un nuevo Capítulo 1 presenta a los estudiantes parte del lenguaje preciso que es la base de gran parte del pensamiento matemático: el lenguaje de variables, conjuntos, relaciones y funciones. En respuesta a las solicitudes de algunos instructores, el material básico ahora se agrupa en los capítulos 1 a 8, y el capítulo sobre recursividad se une al capítulo sobre inducción. Los capítulos 9 a 12 se colocaron juntos al final porque, aunque muchos instructores cubren uno o más de ellos, existe una diversidad considerable en sus opciones, y algunos de los temas de estos capítulos se incluyen en otros cursos.

Pedagogía mejorada

El número de ejercicios se ha incrementado a casi 2600. Se han añadido aproximadamente 300 ejercicios nuevos.

Se agregaron ejercicios para temas en los que los estudiantes parecían necesitar práctica adicional y se modificaron, según fue necesario, para abordar las dificultades de los estudiantes.

Se han incorporado respuestas completas adicionales en el Apéndice B para brindar a los estudiantes más ayuda en temas difíciles.

La exposición ha sido reexaminada en su totalidad y revisada cuando fue necesario.

Se ha ampliado la discusión sobre los antecedentes históricos y los resultados recientes y se ha aumentado el número de fotografías de matemáticos e informáticos cuyas contribuciones se analizan en el libro.

Lógica y teoría de conjuntos

Ahora se incluye la definición de argumento sólido y se aclara adicionalmente la diferencia entre un argumento válido y una conclusión verdadera.

Ejemplos y ejercicios



Se han agregado cuestiones sobre cuantificadores finales.

Se han incorporado definiciones para uniones e intersecciones infinitas.

Introducción a la prueba

Se han ampliado las instrucciones para redactar pruebas y la discusión de errores comunes.

Las descripciones de los métodos de prueba se han hecho más claras.

Los ejercicios han sido revisados y/o reubicados para promover el desarrollo de la comprensión de los estudiantes.

Inducción y recursividad

Se ha mejorado el formato para esquematizar demostraciones por inducción matemática.

Se han reorganizado los subapartados del apartado de secuencias.

Se han ampliado los conjuntos de ejercicios para las secciones sobre inducción matemática fuerte y el principio de buen ordenamiento y sobre definiciones recursivas.

Se ha prestado mayor atención a la inducción estructural.

Teoría de los números

Se ha ampliado una subsección sobre problemas abiertos en teoría de números e incluye una discusión adicional sobre descubrimientos matemáticos recientes en teoría de números.

Se ha simplificado la presentación en la sección de aritmética modular y criptografía.

Se ha aclarado la discusión sobre las pruebas de primalidad.





Combinatoria y probabilidad discreta

La discusión sobre el principio del casillero se ha trasladado a este capítulo.

Funciones

Hay una mayor cobertura de funciones de más de una variable y de funciones que actúan sobre conjuntos.

Teoría de grafos

Se ha actualizado la terminología sobre viajar en un gráfico.

Ahora se incluye el algoritmo de ruta más corta de Dijkstra.

Se agregaron ejercicios para presentar a los estudiantes la coloración de gráficos.



Sitio web complementario



Se ha desarrollado un sitio web para este libro que contiene información y materiales tanto para estudiantes como para profesores. Incluye:

descripciones y enlaces a muchos sitios en Internet con información accesible sobre temas matemáticos discretos,

enlaces a applets que ilustran o proporcionan práctica en los conceptos de matemáticas discretas,

ejemplos y ejercicios adicionales con soluciones,

Guías de revisión de los capítulos del libro. Una sección especial para instructores contiene:

sugerencias sobre cómo abordar el material de cada capítulo,

soluciones para todos los ejercicios no completamente resueltos en el Apéndice B,

ideas para proyectos y tareas de escritura,

Diapositivas de powerpoint,

hojas de repaso y ejercicios adicionales para pruebas y exámenes.



Manual de soluciones para estudiantes y guía de estudio

(ISBN-10: 0-495-82613-8; ISBN-13: 978-0-495-82613-2)

Al escribir este libro, me esforcé por brindar suficiente ayuda a los estudiantes a través de la exposición del texto, los ejemplos resueltos y las soluciones de los ejercicios, de modo que el libro en sí proporcionara todo lo que un estudiante necesitaría para dominar con éxito el material del curso. . Creo que los estudiantes que terminen el estudio de este libro con la capacidad de resolver, por sí solos, todos los ejercicios con soluciones completas del Apéndice B habrán desarrollado un excelente dominio de la materia. No obstante, me di cuenta de que algunos estudiantes querían tener la oportunidad de obtener materiales útiles adicionales. En respuesta, desarrollé un Manual de soluciones para estudiantes y una Guía de estudio, disponibles por separado de este libro, que contiene soluciones completas para cada ejercicio que no está completamente respondido en el Apéndice B y cuyo número es divisible por 3. La guía también incluye explicaciones alternativas para algunos de los conceptos y preguntas de repaso para cada capítulo.





Organización

Este libro se puede utilizar eficazmente para un curso de uno o dos semestres. Los capítulos contienen secciones principales, secciones que cubren material matemático opcional y secciones que cubren aplicaciones opcionales. Los instructores tienen la flexibilidad de elegir la combinación que mejor satisfaga las necesidades de sus alumnos. La siguiente tabla muestra una división de las secciones en categorías.





El siguiente diagrama de árbol muestra, aproximadamente, cómo dependen unos de otros los capítulos de este libro. Los capítulos sobre diferentes ramas del árbol son lo suficientemente independientes como para que los instructores necesiten hacer como máximo ajustes menores si se saltan capítulos pero siguen caminos a lo largo de las ramas del árbol.

En la mayoría de los casos, cubrir sólo las secciones centrales de los capítulos es una preparación adecuada para descender en el árbol.



∗La Sección 8.3 es necesaria para la Sección 12.3 pero no para las Secciones 12.1 y 12.2.





Expresiones de gratitud

Tengo una deuda de gratitud con muchas personas de la Universidad DePaul por su apoyo y aliento a lo largo de los años que trabajé en las ediciones de este libro. Varios de mis colegas utilizaron versiones anteriores y ediciones anteriores y proporcionaron muchas sugerencias excelentes para mejorar. Por esto, agradezco a Louis Aquila, J. Marshall Ash, Allan Berele, Jeffrey Bergen, William Chin, Barbara Cortzen, Constantine Georgakis, Sigrun Goes, Jerry Goldman, Lawrence Gluck, Leonid Krop, Carolyn Narasimhan, Walter Pranger, Eric Rieders, Ayse Sahin, Yuen-Fat Wong y, muy especialmente, Jeanne LaDuke. Los miles de estudiantes a quienes he enseñado matemáticas discretas han tenido una profunda influencia en la forma del libro. Al compartir conmigo sus pensamientos y procesos de pensamiento, me enseñaron cómo enseñarles mejor. Soy



muy agradecido por su ayuda. Debo a la administración de la Universidad DePaul, especialmente a mi decano, Charles Suchar, y a mis ex decanos, Michael Mezey y Richard Meister, unas palabras especiales de agradecimiento por considerar la escritura de este libro como un esfuerzo académico que vale la pena.

Mi agradecimiento a los revisores por sus valiosas sugerencias para esta edición del libro: David Addis, Texas Christian University; Rachel Esselstein, Universidad Estatal de California-Bahía de Monterrey; William Marion, Universidad de Valparaíso; Michael McClendon, Universidad de Oklahoma Central; y Steven Miller, Universidad de Brown. Por su ayuda con las ediciones anteriores del libro, agradezco a Itshak Borosh, Texas A & M University; Douglas M. Campbell, Universidad Brigham Young; David G. Cantor, Universidad de California en Los Ángeles; C. Patrick Collier, Universidad de Wisconsin-Oshkosh; kevan

H. Croteau, Universidad Francis Marion; Irinel Drogan, Universidad de Texas en Arlington; Pablo Echeverría, Camden County College; Henry A. Etlinger, Instituto de Tecnología de Rochester; Melvin J. Friske, Colegio Luterano de Wisconsin; William Gasarch, Universidad de Maryland; Ladnor Geissinger, Universidad de Carolina del Norte; Jerrold R. Griggs, Universidad de Carolina del Sur; Nancy Baxter Hastings, Dickinson College; Lillian Hupert, Universidad Loyola de Chicago; Joseph Kolibal, Universidad del Sur de Mississippi; Benny Lo, Universidad Tecnológica Internacional; George Luger, Universidad de Nuevo México; Leonard T. Malinowski, Colegio Comunitario de Finger Lakes; John F. Morrison, Universidad Estatal de Towson; Paul Pederson, Universidad de Denver; George Peck, Universidad Estatal de Arizona; Roxy Peck, Universidad Estatal Politécnica de California, San Luis Obispo; Dix Pettey, Universidad de Missouri; Anthony Ralston, Universidad Estatal de Nueva York en Buffalo; Norman Richert, Universidad de Houston-Clear Lake; John Roberts, Universidad de Louisville; y George Schultz, St. Petersburg Junior College, Clearwater. Un agradecimiento especial a John Carroll, Universidad Estatal de San Diego; Dr. Joseph S. Fulda; y portero

G. Webster, Universidad del Sur de Mississippi; Peter Williams, Universidad Estatal de California en San Bernardino; y a Jay Zimmerman, de la Universidad Towson, por su minuciosidad inusual y su aliento.

También me he beneficiado enormemente de las sugerencias de muchos profesores que generosamente me han ofrecido sus ideas para mejorar basadas en sus experiencias con ediciones anteriores del libro, especialmente Jonathan Goldstine, de la Universidad Estatal de Pensilvania; David Hecker, Universidad de St. Joseph; Edward Huff, Colegio Comunitario de Virginia del Norte; Robert Messer, Universidad Albion; Sophie Quigley, Universidad Ryerson; Piotr Rudnicki, Universidad de Alberta; Anwar Shiek, Diné College; Norton Starr, Universidad Amherst; y Eng Wee, Universidad Nacional de Singapur. La producción de la tercera edición recibió la valiosa ayuda de Christopher Novak, Universidad de Michigan, Dearborn, e Ian Crewe, Ascension Collegiate School. Para la tercera y cuarta edición estoy especialmente agradecido por las excelentes sugerencias de mejora hechas por Tom Jenkyns, de la Universidad de Brock, cuya asistencia durante todo el proceso de producción fue invaluable.

Debo muchas gracias al personal de Brooks/Cole, especialmente a mi editor, Dan Seibert, por sus atentos consejos y su tranquilizadora dirección del proceso de producción, y a mi











XXII Prefacio



a los editores anteriores, Stacy Green, Robert Pirtle, Barbara Holland y Heather Bennett, por su aliento y entusiasmo.

Cuanto mayor me hago, más me doy cuenta de la profunda deuda que tengo con mis propios profesores de matemáticas por moldear la forma en que percibo la materia. Mi primer agradecimiento debo ir a mi marido, Helmut Epp, quien, en una cita en la escuela secundaria (!), me presentó el poder y la belleza de los axiomas de campo y la visión de que las matemáticas son una materia con ideas, además de fórmulas y técnicas. . En mi educación formal, estoy muy agradecido a Daniel Zelinsky y Ky Fan de la Universidad Northwestern y a Izaak Wirszup, I. N. Herstein e Irving Kaplansky de la Universidad de Chicago, quienes, a su manera, me ayudaron a apreciar la elegancia. , rigor y entusiasmo de las matemáticas.

A mi familia le debo un agradecimiento sin medida. Estoy agradecido a mi madre, cuyo gran interés en el funcionamiento del intelecto humano me inició hace muchos años en el camino que finalmente me llevó a escribir este libro, y a mi difunto padre, cuya devoción por la palabra escrita ha sido una fuente constante de inspiración. Agradezco a mis hijos y nietos su afecto y su alegre aceptación de las exigencias que este libro ha impuesto a mi vida. Y, sobre todo, agradezco a mi esposo, quien durante muchos años me ha animado con su fe en el valor de este proyecto y me ha apoyado con su amor y sus sabios consejos.

Susana Epp





















Por eso, Oh estudiantes, estudian matemáticas y no construyen sin fundamentos. —Leonardo da Vinci (1452-1519)



El objetivo de este libro es presentarle una forma matemática de pensar que puede

Servirlo en una amplia variedad de situaciones. A menudo, cuando empiezas a trabajar en un problema matemático, es posible que sólo tengas una idea vaga de cómo proceder. Puede comenzar mirando ejemplos, haciendo dibujos, jugando con la notación, releyendo el problema para centrarse en más detalles, etc. Sin embargo, cuanto más se acerque a una solución, más cristalizará su pensamiento. Y cuanto más necesitas entender, más necesitas un lenguaje que exprese las ideas matemáticas de forma clara, precisa e inequívoca.

Este capítulo le presentará parte del lenguaje especial que constituye la base de gran parte del pensamiento matemático: el lenguaje de variables, conjuntos, relaciones y funciones. Piense en el capítulo como los ejercicios que haría antes de un evento deportivo importante. Su objetivo es calentar tus músculos mentales para que puedas dar lo mejor de ti.







A veces se piensa que una variable es un “John Doe” matemático porque puedes usarla como marcador de posición cuando quieres hablar sobre algo pero (1) imaginas que tiene uno o más valores pero no sabes cuáles son. son, o (2) desea que todo lo que diga al respecto sea igualmente cierto para todos los elementos de un conjunto determinado y, por lo tanto, no desea limitarse a considerar solo un valor particular y concreto para él. Para ilustrar el primer uso, considere preguntar

¿Existe un número con la siguiente propiedad: duplicarlo y sumarle 3 da el mismo resultado que elevarlo al cuadrado?

En esta oración puedes introducir una variable para reemplazar la palabra potencialmente ambigua “eso”: ¿Existe un número x con la propiedad de que 2x + 3 = x 2?

La ventaja de usar una variable es que te permite darle un nombre temporal a lo que

está buscando para poder realizar cálculos concretos con él para ayudar a descubrir sus posibles valores. Para enfatizar el papel de la variable como marcador de posición, podría escribir lo siguiente:

¿Existe un número Q con la propiedad de que 2 · Q + 3 = Q2?

El vacío del cuadro puede ayudarte a imaginar llenarlo con una variedad de valores diferentes, algunos de los cuales podrían igualar los dos lados y otros no.

1





Para ilustrar el segundo uso de variables, considere la afirmación:

No importa qué número se elija, si es mayor que 2, entonces su cuadrado es mayor que 4.

En este caso, introducir una variable para dar un nombre temporal al número (arbitrario) que podría elegir le permite mantener la generalidad de la declaración, y reemplazar todas las instancias de la palabra "eso" por el nombre de la variable garantiza que la posible ambigüedad se evita:

No importa qué número n se elija, si n es mayor que 2, entonces n2 es mayor que 4.





Ejemplo 1.1.1 Escribir oraciones usando variables

Utilice variables para reescribir las siguientes oraciones de manera más formal.

¿Existen números con la propiedad de que la suma de sus cuadrados es igual al cuadrado de su suma?

Dado cualquier número real, su cuadrado no es negativo.

Solución





Nota En el inciso (a) la respuesta es sí. Por ejemplo, a 1 y b 0 funcionarían. ¿Puedes pensar en otros números que también funcionarían?



¿Hay números a y b con la propiedad de que a2 + b2 = (a + b)2? O: ¿Existen números a y b tales que a2 + b2 = (a + b)2?

O: ¿Existen números a y b tales que a2 + b2 = (a + b)2?

Dado cualquier número real r, r 2 no es negativo.

O: Para cualquier número real r, r 2 ≥ 0.

O: Para todos los números reales r, r 2 ≥ 0. ■



Algunos tipos importantes de enunciados matemáticos

Tres de los tipos de oraciones más importantes en matemáticas son los enunciados universales, los enunciados condicionales y los enunciados existenciales:









En secciones posteriores definiremos cuidadosamente cada tipo de enunciado y los analizaremos todos en detalle. El objetivo aquí es que usted se dé cuenta de que las combinaciones de estas declaraciones se pueden expresar de diferentes maneras. Una forma utiliza el lenguaje común y corriente y otra expresa el enunciado utilizando una o más variables. Los ejercicios están diseñados para ayudarle a empezar a sentirse cómodo al traducir de un modo a otro.





Declaraciones condicionales universales

Los enunciados universales contienen alguna variación de las palabras “para todos” y los enunciados condicionales contienen versiones de las palabras “si-entonces”. Una declaración condicional universal es una declaración que es a la vez universal y condicional. Aquí hay un ejemplo:

Para todos los animales a, si a es un perro, entonces a es un mamífero.

Uno de los hechos más importantes sobre los enunciados condicionales universales es que se pueden reescribir de manera que parezcan puramente universales o puramente condicionales. Por ejemplo, la declaración anterior se puede reescribir de manera que haga explícita su naturaleza condicional pero implícita su naturaleza universal:

Si a es un perro, entonces a es un mamífero.

O: Si un animal es un perro, entonces el animal es un mamífero.

La declaración también puede expresarse de modo que haga explícita su naturaleza universal y implícita su naturaleza condicional:

Para todos los perros a, a es un mamífero.

O: Todos los perros son mamíferos.

El punto crucial es que la capacidad de traducir entre varias formas de expresión universal

Los enunciados condicionales múltiples son enormemente útiles para hacer matemáticas y muchas partes de la informática.



Ejemplo 1.1.2 Reescribir una declaración condicional universal

Complete los espacios en blanco para reescribir la siguiente afirmación:

Para todos los números reales x, si x es distinto de cero, entonces x 2 es positivo.

Si un número real es distinto de cero, entonces su cuadrado.





Nota Si introduce x en la primera parte de la oración, asegúrese de incluirla en la segunda parte de la oración.



































Nota Para que un número b sea un inverso aditivo para un número a significa que



Para todos los números reales distintos de cero x,.

Si x, entonces.

El cuadrado de cualquier número real distinto de cero es.

Todos los números reales distintos de cero tienen .

Solución

es positivo

x2 es positivo

es un número real distinto de cero; x2 es positivo

positivo

cuadrados positivos (o: cuadrados que son positivos) ■



Declaraciones existenciales universales

Un enunciado existencial universal es un enunciado que es universal porque su primera parte dice que cierta propiedad es verdadera para todos los objetos de un tipo determinado, y es existencial porque su segunda parte afirma la existencia de algo. Por ejemplo:



a + b = 0. Todo número real tiene un inverso aditivo.





En este enunciado, la propiedad “tiene un inverso aditivo” se aplica universalmente a todos los números reales. “Tiene un inverso aditivo” afirma la existencia de algo (un inverso aditivo) para cada número real. Sin embargo, la naturaleza del inverso aditivo depende del número real; diferentes números reales tienen diferentes inversos aditivos. Sabiendo que un inverso aditivo es un número real, puedes reescribir este enunciado de varias maneras, algunas menos formales y otras más formales∗:

Todos los números reales tienen inversos aditivos.

O Para todos los números reales r, existe un inverso aditivo para r.

O Para todos los números reales r, existe un número real s tal que s es un inverso aditivo de r.

Introducir nombres para las variables simplifica las referencias en una discusión posterior. Por ejemplo, después de la tercera versión de la afirmación podrías escribir: Cuando r es positivo, s es negativo, cuando r es negativo, s es positivo y cuando r es cero, s también es cero. Una de las razones más importantes para utilizar variables en matemáticas es que permite hacer referencia a cantidades sin ambigüedades a lo largo de un largo proceso matemático.

argumento, sin restringirle a considerar sólo valores específicos para ellos.



Ejemplo 1.1.3 Reescribir una declaración existencial universal

Completa los espacios en blanco para reescribir la siguiente afirmación: Cada olla tiene una tapa.

Todas las ollas.

Para todos los recipientes P, existe .

Para todas las ollas P, hay una tapa L tal que .

Solución

tener tapas

una tapa para P

L es una tapa para P ■



Declaraciones universales existenciales

Un enunciado universal existencial es un enunciado que es existencial porque su primera parte afirma que cierto objeto existe y es universal porque su segunda parte dice que el objeto satisface cierta propiedad para todas las cosas de cierto tipo. Por ejemplo:

Hay un número entero positivo que es menor o igual que todo número entero positivo:

Esta afirmación es verdadera porque el número uno es un número entero positivo y satisface la propiedad de ser menor o igual a todo número entero positivo. Podemos reescribir la declaración de varias maneras, algunas menos formales y otras más formales:

Algún número entero positivo es menor o igual que todo número entero positivo.

O hay un número entero positivo m que es menor o igual a todo número entero positivo.

O bien, existe un número entero positivo m tal que cada número entero positivo es mayor o igual que m.

O: existe un entero positivo m con la propiedad de que para todos los enteros positivos

norte, metro ≤ norte.



∗Se podría utilizar un condicional para ayudar a expresar esta afirmación, pero posponemos la complejidad adicional para un capítulo posterior.





Ejemplo 1.1.4 Reescribir una declaración universal existencial

Complete los espacios en blanco para reescribir la siguiente afirmación de tres maneras diferentes:

Hay una persona en mi clase que tiene al menos la misma edad que todos los de mi clase.

Algunos son al menos tan antiguos como .

Hay una persona p en mi clase tal que p es.

Hay una persona p en mi clase con la propiedad de que por cada persona q en mi clase,

p es .

Solución

persona de mi clase; cada persona en mi clase

al menos tan mayor como todos los de mi clase

al menos tan antiguo como q ■



Algunos de los conceptos matemáticos más importantes, como la definición del límite de una secuencia, sólo pueden definirse usando frases que sean universales, existenciales y condicionales, y requieren el uso de las tres frases “para todos”, “ lo hay” y “si-entonces”. Por ejemplo, si a1, a2, a3,... es una secuencia de números reales, diciendo que

el límite de an cuando n tiende a infinito es L

significa que

para todos los números reales positivos ε, existe un número entero N tal que

para todos los números enteros n, si n > N entonces −ε< an − L < ε.





Pruébate

Las respuestas a las preguntas de Pruébese usted mismo se encuentran al final de cada sección.



Un enunciado universal afirma que cierta propiedad es

para	.

Una declaración condicional afirma que si una cosa entonces otra cosa.



Dada una propiedad que puede o no b

Si es verdadero, un enunciado existencial afirma aquello para lo cual la propiedad es verdadera.





Conjunto de ejercicios 1.1

El Apéndice B contiene soluciones completas o parciales para todos los ejercicios con números azules. Cuando la solución no está completa, el número del ejercicio tiene una H al lado. Un ✶ junto al número de un ejercicio indica que el ejercicio es más desafiante de lo habitual. Tenga cuidado de no adquirir el hábito de buscar soluciones demasiado rápido. Haga todo lo posible para trabajar los ejercicios por su cuenta antes de comprobar sus respuestas. Consulte el Prefacio para obtener fuentes adicionales de ayuda y estudios adicionales.



En cada uno de 1 a 6, complete los espacios en blanco usando una variable o variables para reescribir la declaración dada.

¿Existe un número real cuyo cuadrado sea 1?

¿Existe un número real x tal que?

¿Existe algo tal que x 2 = −1?



¿Existe un número entero que tenga resto 2 cuando se divide entre 5 y resto 3 cuando se divide entre 6?

¿Existe un número entero n tal que n tenga?

¿Existe tal que si n se divide por 5 el resto sea 2 y si ?

Nota: Hay números enteros con esta propiedad. Puedes pensar en una?







Dados dos números reales cualesquiera, hay un número real en el medio.

Dados dos números reales cualesquiera a y b, existe un número real c tal que c es .

Para dos cualesquiera, tales que a < c < b.

Dado cualquier número real, hay un número real que es mayor.

Dado cualquier número real r, existe s tal que s es

  .

Para cualquiera , tal que s > r .

El recíproco de cualquier número real positivo es positivo.

Dado cualquier número real positivo r, el recíproco de.

Para cualquier número real r, si r es, entonces.

Si es un número real r, entonces.

La raíz cúbica de cualquier número real negativo es negativa.

Dado cualquier número real negativo s, la raíz cúbica de .

Para cualquier número real s, si s es , entonces .

Si un número real s, entonces.

Reescribe las siguientes afirmaciones de manera menos formal, sin utilizar variables. Determina, lo mejor que puedas, si las afirmaciones son verdaderas o falsas.

Hay números reales u y v con la propiedad de que

uv<uv.

Existe un número real x tal que x2 < x .

Para todos los números enteros positivos n, n2 ≥ n.

Para todos los números reales a y b, |a + b|≤ |a|+ |b|.

En cada uno de los ejercicios 8 a 13, complete los espacios en blanco para reescribir el enunciado dado.



Para todos los objetos J, si J es un cuadrado, entonces J tiene cuatro lados.

Todos los cuadrados.

Cada cuadrado.

Si un objeto es un cuadrado, entonces...



Si J, entonces J.

Para todos los cuadrados J , .

Para todas las ecuaciones E, si E es cuadrática, entonces E tiene como máximo dos soluciones reales.

Todas las ecuaciones cuadráticas.

Cada ecuación cuadrática.

Si una ecuación es cuadrática, entonces.

Si mi, entonces mi.

Para todas las ecuaciones cuadráticas E,.

Todo número real distinto de cero tiene un recíproco.

Todos los números reales distintos de cero.

Para todos los números reales distintos de cero r , existe para r .

Para todos los números reales distintos de cero r, existe un número real s

tal que.

Todo número positivo tiene una raíz cuadrada positiva.

Todos los números positivos.

Para cualquier número positivo e, existe para e.

Para todos los números positivos e, existe un número positivo r

tal que.



Hay un número real cuyo producto con cada número deja el número sin cambios.

Algunos tienen la propiedad de que es .

Existe un número real r tal que el producto de r .

Existe un número real r con la propiedad de que por cada número real s, .

Existe un número real cuyo producto por cada número real es igual a cero.

Algunos tienen la propiedad de que es .

Existe un número real a tal que el producto de a .

Existe un número real a con la propiedad de que por cada número real b, .







Respuestas para Ponte a prueba

verdadero; todos los elementos de un conjunto 2. es verdadero; también tiene que ser cierto 3. hay al menos una cosa







... cuando intentamos expresar en símbolos matemáticos una condición propuesta en palabras. Primero, debemos entender a fondo la condición. En segundo lugar, debemos estar familiarizados con las formas de expresión matemática. —George Polyá (1887–1985)



El uso de la palabra conjunto como término matemático formal fue introducido en 1879 por Georg Cantor (1845-1918). Para la mayoría de los propósitos matemáticos podemos pensar en un conjunto de manera intuitiva, como





Cantor lo hizo, simplemente como una colección de elementos. Por ejemplo, si C es el conjunto de todos los países que actualmente forman parte de las Naciones Unidas, entonces Estados Unidos es un elemento de C, y si I es el conjunto de todos los números enteros del 1 al 100, entonces el número 57 es un elemento de yo.









El axioma de extensión dice que un conjunto está completamente determinado por cuáles son sus elementos, no por el orden en que podrían enumerarse o el hecho de que algunos elementos puedan enumerarse más de una vez.





Ejemplo 1.2.1 Uso de la notación Set-Roster

Sean A 1, 2, 3, B 3, 1, 2 y C 1, 1, 2, 3, 3, 3. ¿Cuáles son los elementos de

¿A, B y C? ¿Cómo se relacionan A, B y C? b. ¿Es {0}= 0?

C. ¿Cuántos elementos hay en el conjunto {1, {1}}?

d. Para cada entero no negativo n, sea Un = {n, −n}. Encuentre U1, U2 y U0.



Solución

A, B y C tienen exactamente los mismos tres elementos: 1, 2 y 3. Por lo tanto, A, B y

C son simplemente diferentes formas de representar el mismo conjunto.

0 0 porque {0} es un conjunto con un elemento, concretamente 0, mientras que 0 es sólo el símbolo que representa el número zer

o.

El conjunto {1, {1}} tiene dos elementos: 1 y el conjunto cuyo único elemento es 1.

d. U1 = {1, −1}, U2 = {2, −2}, U0 = {0, −0}= {0, 0}= {0}.



Se hace referencia con tanta frecuencia a ciertos conjuntos de números que se les dan nombres simbólicos especiales. Estos se resumen en la tabla de la página siguiente.









Nota La Z es la primera letra de la palabra alemana para números enteros, Zahlen. Representa el conjunto de todos los números enteros y no debe usarse como abreviatura de

la palabra entero. La adición de un superíndice o las letras nonneg indica que solo se incluirán los elementos positivos, negativos o no negativos del conjunto, respectivamente. Así, R+ denota el conjunto de números reales positivos y Znonneg se refiere al conjunto de números enteros no negativos: 0, 1, 2, 3, 4, etc. Algunos autores se refieren al conjunto de números enteros no negativos como el conjunto de números naturales y lo denotan como N. Otros autores llaman números naturales sólo a los números enteros positivos. Para evitar confusiones, simplemente evitamos utilizar la frase números naturales en este libro.

El conjunto de números reales generalmente se representa como el conjunto de todos los puntos de una recta, como se muestra a continuación. El número 0 corresponde a un punto medio, llamado origen. Se marca una unidad de distancia y cada punto a la derecha del origen corresponde a un número real positivo que se encuentra calculando su distancia desde el origen. Cada punto a la izquierda del origen corresponde a un número real negativo, que se denota calculando su distancia desde el origen y poniendo un signo menos delante del número resultante. Por lo tanto, el conjunto de números reales se divide en tres partes: el conjunto de números reales positivos, el conjunto de números reales negativos y el número 0. Tenga en cuenta que 0 no es ni positivo ni negativo. Se dan etiquetas para algunos números reales correspondientes. a puntos en la línea que se muestra a continuación.



–3 –2 –1 0 1 2 3



– 5 – 3

2



–0,8 1 2

3



2.6 13

4























Nota Leemos el

llave izquierda como "el conjunto de todos" y la línea vertical como "tal que". Sin embargo, en todos los demás contextos matemáticos no utilizamos una línea vertical para indicar las palabras “tal que”; abreviamos “tal que” como “s. t.” o “s. eso.” o “·3·”.



La recta numérica real se llama continua porque se supone que no tiene agujeros. El conjunto de números enteros corresponde a una colección de puntos ubicados a intervalos fijos a lo largo de la recta de números reales. Por tanto, todo número entero es un número real y, como todos los números enteros están separados entre sí, el conjunto de números enteros se llama discreto. El nombre de matemáticas discretas proviene de la distinción entre objetos matemáticos continuos y discretos.

Otra forma de especificar un conjunto utiliza lo que se llama notación constructora de conjuntos.





Ocasionalmente escribiremos x P(x) sin ser específicos acerca de dónde proviene el elemento x. Resulta que el uso ilimitado de esta notación puede conducir a verdaderas contradicciones en la teoría de conjuntos. Analizaremos uno de ellos en la sección 6.4 y tendremos cuidado de utilizar esta notación simplemente por conveniencia en los casos en que el conjunto S pueda especificarse si fuera necesario.





Ejemplo 1.2.2 Uso de la notación del generador de conjuntos

Dado que R denota el conjunto de todos los números reales, Z el conjunto de todos los números enteros y Z+ el conjunto de todos los números enteros positivos, describe cada uno de los siguientes conjuntos.

a. {x ∈ R | −2 < x < 5}

b. {x ∈ Z | −2 < x < 5}

C. {x ∈ Z+ | −2 < x < 5}



Solución

x R 2 < x < 5 es el intervalo abierto de números reales (estrictamente) entre 2 y

5. Se muestra de la siguiente manera:



–3 –2 –1 0 1 2 3 4 5 6 7 8





{x ∈ Z | −2 < x < 5} es el conjunto de todos los números enteros (estrictamente) entre −2 y 5. Es igual al conjunto {−1, 0, 1, 2, 3, 4}.

Como todos los números enteros en Z+ son positivos, {x ∈ Z+| −2 < x < 5}= {1, 2, 3, 4}. ■



Subconjuntos

Una relación básica entre conjuntos es la de subconjunto.







De la definición de subconjunto se deduce que para que un conjunto A no sea subconjunto de un conjunto B significa que hay al menos un elemento de A que no es elemento de B. Simbólicamente:











Ejemplo 1.2.3 Subconjuntos

Sean A Z+, B n Z 0 n 100 y C 100, 200, 300, 400, 500. Evaluar

la verdad y falsedad de cada una de las siguientes afirmaciones.

B A

C es un subconjunto propio de A

C y B tienen al menos un elemento en común.

C ⊆ B mi. C ⊆ C

Solución

FALSO. El cero no es un número entero positivo. Por tanto, cero está en B pero cero no está en A, por lo que

B¢A.

Verdadero. Cada elemento en C es un entero positivo y, por tanto, está en A, pero hay elementos en A que no están en C. Por ejemplo, 1 está en A y no en C.

Verdadero. Por ejemplo, 100 está tanto en C como en B.

FALSO. Por ejemplo, 200 está en C pero no en B.

Verdadero. Cada elemento en C está en C . En general, la definición de subconjunto implica que todos los conjuntos son subconjuntos de sí mismos.





Ejemplo 1.2.4 Distinción entre ∈ y ⊆

¿Cuáles de las siguientes son afirmaciones verdaderas?

a. 2 ∈ {1, 2, 3} segundo. {2}∈ {1, 2, 3}c. 2 ⊆ {1, 2, 3}

d. {2}⊆ {1, 2, 3} e. {2}⊆ {{1}, {2}}f. {2}∈ {{1}, {2}}

Solución Sólo (a), (d) y (f) son verdaderas.

Para que (b) sea cierto, el conjunto 1, 2, 3 tendría que contener el elemento 2. Pero los únicos elementos de 1, 2, 3 son 1, 2 y 3, y 2 no es igual.

o 2 . Por tanto (b) es falso.

Para que (c) sea cierto, el número 2 tendría que ser un conjunto y cada elemento del conjunto 2 tendría que ser un elemento de 1, 2, 3. Este no es el caso, por lo que (c) es falso.

Para que (e) sea verdadero, cada elemento del conjunto que contenga sólo el número 2 tendría que ser un elemento del conjunto cuyos elementos son {1} y {2}. Pero 2 no es igual a ninguno de los dos.

{1} o {2}, por lo que (e) es falso. ■









Kazimierz Kuratowski (1896-1980)



Productos cartesianos

Con la introducción de la teoría de conjuntos de Georg Cantor a finales del siglo XIX, empezó a parecer posible dotar a las matemáticas de una base lógica firme desarrollando todas sus diversas ramas a partir únicamente de la teoría de conjuntos y la lógica. Un obstáculo importante fue cómo utilizar conjuntos para definir un par ordenado porque la definición de un conjunto no se ve afectada por el orden en que se enumeran sus elementos. Por ejemplo, a, b y b, a representan el mismo conjunto, mientras que en un par ordenado queremos poder indicar qué elemento viene primero.

En 1914, Norbert Wiener (1894-1964), un joven estadounidense que acababa de obtener su doctorado, logró avances cruciales. de Harvard y el matemático alemán Felix Hausdorff (1868-1942). Ambas dieron definiciones que mostraban que un par ordenado puede definirse como cierto tipo de conjunto, pero ambas definiciones eran algo incómodas. Finalmente, en 1921, el matemático polaco Kazimierz Kuratowski (1896-1980) publicó





la siguiente definición, que desde entonces se ha convertido en estándar. Dice que un par ordenado es un conjunto de la forma

{{a}, {a,b}}.

Este conjunto tiene elementos, a y a, b. Si a b, entonces los dos conjuntos son distintos y a está en ambos conjuntos mientras que b no. Esto nos permite distinguir entre a y b y decir que a es el primer elemento del par ordenado y b es el segundo elemento del par. Si a b, entonces podemos decir simplemente que a es tanto el primer como el segundo elemento del par. En este caso el conjunto que define el par ordenado se convierte en a , a, a , que es igual a a .

Sin embargo, sólo mucho después de que los pares ordenados se hubieran utilizado ampliamente en matemáticas, los matemáticos se dieron cuenta de que era posible definirlos completamente en términos de conjuntos y, en cualquier caso, la notación de conjuntos sería engorrosa de usar en forma regular. base. La notación habitual para pares ordenados se refiere a {{a}, {a, b}} más simplemente como (a, b).





Ejemplo 1.2.5 Pares ordenados

a. ¿Es (1, 2) = (2, 1)?

b. ¿Es 3, 5 = √9, 1?

C. ¿Cuál es el primer elemento de (1, 1)?

Solución

No. Por definición de igualdad de pares ordenados,

(1, 2) = (2.1) si, y sólo si, 1 = 2 y 2 = 1.

Pero 1 /= 2, por lo que los pares ordenados no son iguales.

Sí. Por definición de igualdad de pares ordenados,

  3, 5 = √9, 1 si, y sólo si, 3 = √9 y 5 = .



Como ambas ecuaciones son verdaderas, los pares ordenados son iguales.

En el par ordenado (1, 1), el primer y segundo elemento son ambos 1.









Ejemplo 1.2.6 Productos cartesianos

Sean A = {1, 2, 3} y B = {u, v}.

Encuentra A × B

Encuentra B × A

Encontrar B × B

¿Cuántos elementos hay en A × B, B × A y B × B?

Sea R el conjunto de todos los números reales. Describe R × R.

Solución

a. A × B = {(1, u), (2, u), (3, u), (1, v), (2, v), (3, v)}

b. B × A = {(u, 1), (u, 2), (u, 3), (v, 1), (v, 2), (v, 3)}

C. segundo × segundo = {(u, u), (u, v), (v, u), (v, v)}





Nota ¡Es por eso que tiene sentido llamar producto a un producto cartesiano!



d. A B tiene seis elementos. Tenga en cuenta que este es el número de elementos en A multiplicado por el número de elementos en B. B A tiene seis elementos, el número de elementos en B multiplicado por el número de elementos en A. B B tiene cuatro elementos, el número de elementos en B multiplicado por el número de elementos en B.

mi. R R es el conjunto de todos los pares ordenados (x, y) donde tanto x como y son números reales. Si se dibujan los ejes horizontal y vertical en un plano y se marca una unidad de longitud, entonces cada par ordenado en R R corresponde a un punto único en el plano, con el primer y segundo elemento del par indicando, respectivamente, los ejes horizontal y vertical. posiciones del punto. El término plano cartesiano se utiliza a menudo para referirse a un plano con este sistema de coordenadas, como se ilustra en la Figura 1.2.1.









Figura 1.2.1: Un plano cartesiano





Pruébate

Cuando los elementos de un conjunto se dan utilizando la notación de lista de conjuntos, el orden en que se enumeran.

El símbolo R denota .

El símbolo Z denota .

El símbolo Q denota .





La notación {x | Se lee P(x)} .

Para que un conjunto A sea un subconjunto de un conjunto B significa que,

  .

Dados los conjuntos A y B, el producto cartesiano A × B es .







Conjunto de ejercicios 1.2

¿Cuáles de los siguientes conjuntos son iguales?

A = {a, b, c, d} B = {d, e, a, c}

C = {d, b, a, c} D = {a, a, d, e, c, e}

Escribe con palabras cómo leer cada uno de los siguientes en voz alta.

a. {x∈R+ | 0 < x < 1}

{x ∈ R | x ≤ 0 o x ≥ 1}

{norte ∈ Z+| n es un factor de 6}





C. U = {r ∈ Z | 2 ≤ r ≤ −2}

V = {s ∈ Z | s > 2 o s < 3}

mi. W = {t ∈ Z | 1 < t < −3}

F. X = {tu ∈ Z | tu ≤ 4 o tu ≥ 1}

Sean A c, d, f, g, B f, j y C d, g. Responda cada una de las siguientes preguntas. Razona tus respuestas.

¿B ⊆ A? b. ¿Es C ⊆ A?



d. {norte ∈ Z | n es una f

actor de 6}

3. a. ¿Es 4 {4}?

b. ¿Cuántos elementos hay en el conjunto {3, 4, 3, 5}?

C. ¿Cuántos elementos hay en el conjunto {1, {1}, {1, {1}}}?

4. a. ¿Es 2 2?

b. ¿Cuántos elementos hay en el conjunto {2, 2, 2, 2}?

C. ¿Cuántos elementos hay en el conjunto {0, {0}}?

d. ¿Es {0}∈ {{0}, {1}}?

mi. ¿Es 0 ∈ {{0}, {1}}?







¿Es C ⊆ C ? d. ¿Es C un subconjunto adecuado de A? 9. a. ¿Es 3 ∈ {1, 2, 3}? b. ¿Es 1 ⊆ {1}?

C. ¿Es {2}∈ {1, 2}? d. ¿Es {3}∈ {1, {2}, {3}}?

mi. ¿Es 1 ∈ {1}? F. ¿Es {2}⊆ {1, {2}, {3}}?

gramo. ¿Es {1}⊆ {1, 2}? h. ¿Es 1 ∈ {{1}, 2}?

i. ¿Es {1}⊆ {1, {2}}? j. ¿Es {1}⊆ {1}?

10 a. ¿Es ((−2)2, −22) = (−22, (−2)2)?

b. ¿Es (5, −5) = (−5, 5)?

  







A = {0 1 2}



d. ¿Es −2, (−2)3 = 3, −8?



segundo = {x ∈ R | −1 ≤ x < 3} C = {x ∈ R | −1 < x < 3} D = {x ∈ Z | −1 < x < 3} mi = {x ∈ Z+ | −1 < x < 3}

H 6. Para cada número entero n, sea Tn = {n, n2}. ¿Cuántos elementos hay en cada uno de T2, T−3, T1 y T0? Justifica tus respuestas.

Utilice la notación de lista de conjuntos para indicar los elementos de cada uno de los siguientes conjuntos.

S = {norte ∈ Z | n = (−1)k, para algún número entero k}.

T = {metro ∈ Z | m = 1 + (−1)i, para algún número entero i}.



Sean A w, x, y, z y B a, b . Utilice la notación de lista de conjuntos para escribir cada uno de los siguientes conjuntos e indique la cantidad de elementos que hay en cada conjunto:

A × B b. B×A

C. A × A d. B×B

Sean S 2, 4, 6 y T 1, 3, 5. Utilice la notación de lista de conjuntos para escribir cada uno de los siguientes conjuntos e indique la cantidad de elementos que hay en cada conjunto:

S × Tb. T×S

C. S × S d. T×T







Respuestas para Ponte a prueba

1. no importa 2. el conjunto de todos los números reales 3. el conjunto de todos los números enteros 4. el conjunto de todos los números racionales 5. el conjunto de todos los x tales que P(x) 6. cada elemento en A es un elemento en B 7. el conjunto de todos los pares ordenados (a, b) donde a está en A y b está en B





Las matemáticas son un lenguaje. — Josías Willard Gibbs (1839-1903)



Hay muchos tipos de relaciones en el mundo. Por ejemplo, decimos que dos personas están relacionadas por sangre si comparten un antepasado común y que están relacionadas por matrimonio si una comparte un antepasado común con el cónyuge de la otra. También hablamos de la relación entre estudiantes y profesores, entre personas que trabajan para el mismo empleador y entre personas que comparten un origen étnico común.

De manera similar, los objetos de las matemáticas pueden estar relacionados de diversas maneras. Se puede decir que un conjunto A está relacionado con un conjunto B si A es un subconjunto de B, o si A no es un subconjunto de B, o si A y B tienen al menos un elemento en común. Se puede decir que un número x está relacionado con un número y si x < y, o si x es un factor de y, o si x 2 + y2 = 1. Dos identificadores en una computadora





Se puede decir que un programa está relacionado si tienen los mismos primeros ocho caracteres, o si se usa la misma ubicación de memoria para almacenar sus valores cuando se ejecuta el programa. ¡Y la lista podría seguir!

Sean A 0, 1, 2 y B 1, 2, 3 y digamos que un elemento x en A está relacionado con un elemento y en B si, y sólo si, x es menor que y. Usemos la notación xRy como abreviatura de la oración "x está relacionada con y". Entonces



Por otro lado, si la notación x R y representa la oración “x no está relacionada con y”, entonces



/R 1 desde 1 <

/R 1 desde 2 <

2 /R 2 desde 2 </



1,

1, y

2.



Recuerde que el producto cartesiano de A y B, A B, consta de todos los pares ordenados cuyo primer elemento está en A y cuyo segundo elemento está en B:

A × B = (x, y) | x ∈ A y y ∈ B}.

En este caso,

A × B = (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 1), (2, 2 ), (2, 3) .

Los elementos de algunos pares ordenados en A B están relacionados, mientras que los elementos de otros pares ordenados no lo están. Considere el conjunto de todos los pares ordenados en A B cuyos elementos están relacionados

(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3).

Observe que saber qué pares ordenados se encuentran en este conjunto equivale a saber qué elementos están relacionados con cuál. Por tanto, la relación misma puede considerarse como la totalidad de pares ordenados cuyos elementos están relacionados por la condición dada. La definición matemática formal de relación, basada en esta idea, fue introducida por el matemático y lógico estadounidense C. S. Peirce en el siglo XIX.





La notación de una relación R puede escribirse simbólicamente de la siguiente manera:

x R y significa que (x, y) ∈ R.

La notación x /R y significa que x no está relacionado con y por R:

x /R y significa que (x, y) ∈/ R.





Ejemplo 1.3.1 Una relación como subconjunto

Sean A = {1, 2} y B = {1, 2, 3} y defina una relación R de A a B de la siguiente manera: Dado cualquier (x, y) ∈ A × B,

(x, y) R significa que x − y es un número entero.

2

Indique explícitamente qué pares ordenados están en A × B y cuáles están en R.

¿Es 1 R 3? ¿Es 2 R 3? ¿Es 2 R 2?

¿Cuáles son el dominio y el codominio de R?

Solución

a. A B (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3). Para determinar explícitamente la composición de R, examine cada par ordenado en A B para ver si sus elementos satisfacen la condición definitoria de R.

(1, 1) ∈ R porque 1−1 = 0 = 0, que es un número entero.

(1, 2) ∈/ R porque 1−2 = −1 , que no es un número entero.

(1, 3) ∈ R porque 1−3 = −2 = −1, que es un número entero.

(2, 1) ∈/ R porque 2−1 = 1 ,

que no es un número entero.

(2, 2) ∈ R porque 2−2 = 0 = 0, que es un número entero.

(2, 3) ∈/ R porque 2−3 = −1 , que es un número entero.

2 2

De este modo

R = {(1, 1), (1, 3), (2, 2)}

b. Sí, 1 R 3 porque (1, 3) ∈ R. No, 2 /R 3 porque (2, 3) ∈/ R. Sí, 2 R 2 porque (2, 2) ∈ R.

C. El dominio de R es {1, 2} y el codominio es {1, 2, 3}. ■



Ejemplo 1.3.2 La relación circular

Defina una relación C de R a R de la siguiente manera: Para cualquier (x, y) ∈ R × R,

(x, y) ∈ C significa que x 2 + y2 = 1.

a. ¿Es (1, 0) ∈ C? ¿Es (0, 0) ∈ C? ¿Es − 1 , √3 ∈ C ? ¿Es −2 C 0? ¿Es 0 C (-1)? ¿Es 1 C 1?

b. ¿Cuáles son el dominio y el codominio de C?

C. Dibuja una gráfica para C trazando los puntos de C en el plano cartesiano.

Solución

a. Sí, (1, 0) ∈ C porque 12 + 02 = 1. No, (0, 0) ∈/ C porque 02 + 02 = 0 /= 1.

Sí, − 1 √3 ∈ C porque 1 2 √3 2 = 1 + 3 = 1.

No, −2 C/ 0 porque (−2)2 + 02 = 4 /= 1.

Sí, 0 C (−1) porque 02 + (−1)2 = 1.

No, 1 C/ 1 porque 12 + 12 = 2 /= 1.

b. El dominio y el codominio de C son ambos R, el conjunto de todos los números reales.





C.



















■



Diagrama de flechas de una relación

Supongamos que R es una relación de un conjunto A a un conjunto B. El diagrama de flechas para R se obtiene de la siguiente manera:

Representar los elementos de A como puntos en una región y los elementos de B como puntos en otra región.

Para cada x en A y y en B, dibuje una flecha de x a y si, y solo si, x está relacionado con y

por R. Simbólicamente:

Dibuja una flecha de x a y

si, y sólo si, x R y

si, y sólo si, (x, y) ∈ R.



Ejemplo 1.3.3 Diagramas de flechas de relaciones

Sean A = {1, 2, 3} y B = {1, 3, 5} y defina las relaciones S y T de A a B de la siguiente manera: Para todo (x, y) ∈ A × B,

(x, y) ∈ S significa que x < y S es una relación “menor que”.

T = {(2, 1), (2, 5)}.

Dibuja diagramas de flechas para S y T.

Solución

CALLE









Estas relaciones de ejemplo ilustran que es posible que varias flechas salgan del mismo elemento de A y apunten en diferentes direcciones. Además, es muy posible tener un elemento de A del que no salga una flecha. ■



Funciones

En la sección 1.2 mostramos que los pares ordenados se pueden definir en términos de conjuntos y definimos los productos cartesianos en términos de pares ordenados. En esta sección introdujimos las relaciones como subconjuntos de productos cartesianos. Así, ahora podemos definir funciones de una manera que dependa sólo del concepto de conjunto. Aunque esta definición no está obviamente relacionada con la forma en que normalmente trabajamos con funciones en matemáticas, es satisfactoria desde un punto de vista teórico.





y a los informáticos les gusta porque es especialmente adecuado para el manejo de funciones en un ordenador.







Las propiedades (1) y (2) se pueden expresar de manera menos formal como sigue: Una relación F de A a

B es una función si y sólo si:

Cada elemento de A es el primer elemento de un par ordenado de F.

No hay dos pares ordenados distintos en F que tengan el mismo primer elemento.

En la mayoría de las situaciones matemáticas pensamos que una función envía elementos de un conjunto, el dominio, a elementos de otro conjunto, el codominio. Debido a la definición de función, cada elemento del dominio corresponde a uno y sólo un elemento del codominio.

Más precisamente, si F es una función de un conjunto A a un conjunto B, entonces dado cualquier elemento x en A, la propiedad (1) de la definición de función garantiza que hay al menos un elemento de B que está relacionado con x por F y la propiedad (2) garantiza que existe como máximo uno de esos elementos. Esto permite dar un nombre especial al elemento que corresponde a x.







Ejemplo 1.3.4 Funciones y relaciones en conjuntos finitos

Sean A 2, 4, 6 y B 1, 3, 5. ¿Cuáles de las relaciones R, S y T definidas a continuación son funciones de A a B?

a. R = {(2, 5), (4, 1), (4, 3), (6, 5)}

b. Para todo (x, y) ∈ A × B, (x, y) ∈ S significa que y = x + 1.

C. T está definido por el diagrama de flechas.



A B





Solución

R no es una función porque no satisface la propiedad (2). Los pares ordenados (4, 1) y (4, 3) tienen el mismo primer elemento pero segundos elementos diferentes. Puedes ver esto gráficamente si dibujas el diagrama de flechas para R. Hay dos flechas que salen de 4: una apunta a 1 y la otra apunta a 3.



A R B





S no es una función porque no satisface la propiedad (1). No es cierto que cada elemento de A sea el primer elemento de un par ordenado en S. Por ejemplo, 6 A pero no existe y en B tal que y 6 1 7. También puedes ver esto gráficamente dibujando el diagrama de flechas. para s.



ASB











Nota En la parte (c),

T (4) T (6). Este

ilustra el hecho de que aunque ningún elemento del dominio de una función puede estar relacionado con más de un elemento del codominio, varios elementos del dominio pueden estar relacionados con el mismo elemento del codominio.







T es una función: Cada elemento de {2, 4, 6} está relacionado con algún elemento de {1, 3, 5} y ningún elemento de {2, 4, 6} está relacionado con más de un elemento de {1, 3, 5}. Cuando estas propiedades se expresan en términos del diagrama de flechas, se convierten en (1) hay una flecha que sale de cada elemento del dominio y (2) ningún elemento del dominio tiene más de una flecha que sale de él. Entonces puedes escribir

T (2) = 5, T (4) = 1 y T (6) = 1. ■





Ejemplo 1.3.5 Funciones y relaciones en conjuntos de números reales

En el ejemplo 1.3.2, la relación circular C se definió de la siguiente manera:



Para todo (x, y) ∈ R × R, (x, y) ∈ C significa que x 2 + y2 = 1.

¿Es C una función? Si es así, encuentre C(0) y C(1).

Defina una relación de R a R de la siguiente manera:



Para todo (x, y) ∈ R × R, (x, y) ∈ L significa que y = x − 1.

¿Es L una función? Si es así, encuentre L(0) y L(1).



Solución

La gráfica de C, que se muestra en la página siguiente, indica que C no satisface ninguna de las propiedades de la función. Para ver por qué C no satisface la propiedad (1), observe que hay muchos números reales x tales que (x, y) ∈/ C para cualquier y.











GRAMO











2

Por ejemplo, cuando x = 2, no existe un número real y, por lo que

x2 + y2 = 22 + y2 = 4 + y2 = 1

porque si lo hubiera, entonces tendría que ser cierto que

y2 = −3.

lo cual no es el caso de ningún número real y.

Para ver por qué C no satisface la propiedad (2), observe que para algunos valores de x hay dos valores distintos de y de modo que (x, y) ∈ C. Una forma de ver esto gráficamente es

observe que hay rectas verticales, como x = , que cortan la gráfica de C en dos

   1 √3 1 √3



L es una función. Para cada número real x, y x 1 es un número real, por lo que hay un número real y con (x, y) L. Además, si (x, y) L y (x, z) L, entonces y x 1 y z x 1, y entonces y z. En particular, L(0) 0 1 1 y L(1) 1 1 0.

También puede verificar estos resultados inspeccionando la gráfica de L, que se muestra a continuación. Tenga en cuenta que para cada número real x, la línea vertical que pasa por (x, 0) pasa por la gráfica de L exactamente una vez. Esto indica que todo número real x es el primer elemento de un par ordenado en L y también que no hay dos pares ordenados distintos en L que tengan el mismo primer elemento.

















■







Máquinas funcionales

Otra forma útil de pensar en una función es como una máquina. Supongamos que f es una función de X a Y y se da una entrada x de X. Imagine que f es una máquina que procesa x de cierta manera para producir la salida f (x). Esto se ilustra en la Figura 1.3.1 en la página siguiente.







X

Aporte









f(x) Salida

Figura 1.3.1





Ejemplo 1.3.6 Funciones definidas por fórmulas

La función de elevación al cuadrado f de R a R se define mediante la fórmula f (x) x 2 para todos los números reales x. Esto significa que no importa qué número real de entrada se sustituya por x, la salida de f será el cuadrado de ese número. Esta idea se puede representar escribiendo f (Q) Q2. En otras palabras, f envía cada número real x a x 2, o, simbólicamente,

f : x x 2. Tenga en cuenta que la variable x es una variable ficticia; cualquier otro símbolo podría reemplazar

siempre y cuando el reemplazo se realice en todos los lugares donde aparece la x.

La función sucesora g de Z a Z se define mediante la fórmula g(n) n 1. Por lo tanto, no importa qué entero se sustituya por n, la salida de g será ese número más uno: g(Q) Q 1. En En otras palabras, g envía cada número entero n a n 1, o, simbólicamente, g: n n 1.

Un ejemplo de función constante es la función h de Q a Z definida por la fórmula h(r) 2 para todos los números racionales r. Esta función envía cada número racional r a 2. En otras palabras, no importa cuál sea la entrada, la salida siempre es 2: h(Q) 2 o h: r 2.

Las funciones f, g y h están representadas por las máquinas de funciones en la Figura 1.3.2.





xr

















(a)





f(x) = x2









(b)





g(norte) = norte + 1









(C)





h(r) = 2



Figura 1.3.2 ■



Una función es una entidad por derecho propio. Puede pensarse como una determinada relación entre conjuntos o como una máquina de entrada/salida que funciona según una determinada regla. Ésta es la razón por la que una función generalmente se denota mediante un solo símbolo o una cadena de símbolos, como f, G, de log o sin.

Una relación es un subconjunto de un producto cartesiano y una función es un tipo especial de relación.

Específicamente, si f y g son funciones de un conjunto A a un conjunto B, entonces

f = {(x, y) ∈ A × B | y = f (x)} y g = {(x, y) ∈ A × B | y = g(x)}.

Resulta que







Ejemplo 1.3.7 Igualdad de funciones

Defina f : R → R y g: R → R mediante las siguientes fórmulas:

f (x) =√|x | para todo x ∈ R.





¿f = g?

Solución



g(x) =



x 2 para todo x ∈ R.



Sí. B√porque el valor absoluto de cualquier número real es igual a la raíz cuadrada de su cuadrado,





Pruébate



|x |= x 2 para todo x ∈ R. Por tanto f = g. ■



Dados los conjuntos A y B, una relación de A a B es .

Una función F de A a B es una relación de A a B que satisface las dos propiedades siguientes:

para cada elemento x de A, hay .



Serie de ejercicios 1.3

Sean A = {2, 3, 4} y B = {6, 8, 10} y defina una relación

R de A a B de la siguiente manera: Para todo (x, y) ∈ A × B,

y

(x, y) ∈ R significa que x es un número entero.

a. ¿Es 4R 6? ¿Es 4R 8? ¿Es (3, 8)R? ¿Es (2, 10)R?

Escribe R como un conjunto de pares ordenados.

Escribe el dominio y codominio de R.

Dibuja un diagrama de flechas para R.

Sea C = D = {−3, −2, −1, 1, 2, 3} y defina una relación S

de C a D de la siguiente manera: Para todo (x, y) ∈ C × D,

(x, y) ∈ S significa que x − y es un número entero. a. ¿Es 2 S 2? ¿Es 1S 1? ¿Es (3, 3)S? ¿Es (3, 3)S?

Escribe S como un conjunto de pares ordenados.

Escribe el dominio y codominio de S.

Dibuja un diagrama de flechas para S.



Sean E = {1, 2, 3} y F = {−2, −1, 0} y defina una relación T de E a F de la siguiente manera: Para todo (x, y) ∈ E × F,

(x, y) T significa que x − y es un número entero.

3



b. para todos los elementos x en A e y y z en B, si

entonces	.

Si F es una función de A a B y x es un elemento de A, entonces

F(x) es .









Escribe V como un conjunto de pares ordenados.

Escribe el dominio y codominio de V .

Dibuja un diagrama de flechas para V.

Defina una relación S de R a R de la siguiente manera: Para todo (x, y) ∈ R × R,

(x, y) ∈ S significa que x ≥ y.

a. ¿Es (2, 1)S? ¿Es (2, 2)S? ¿Es 2 S 3? ¿Es (1) S (2)?

b. Dibuja la gráfica de S en el plano cartesiano.

Defina una relación R de R a R de la siguiente manera: Para todo (x, y) ∈ R × R,

(x, y) ∈ R significa que y = x 2.

a. ¿Es (2, 4)R? ¿Es (4, 2)R? ¿Es (3)R 9? ¿Es 9R (3)?

b. Dibuja la gráfica de R en el plano cartesiano.

Sean A 4, 5, 6 y B 5, 6, 7 y defina las relaciones R, S y T de A a B de la siguiente manera:

Para todo (x, y) ∈ A × B,

(x, y) ∈ R significa que x ≥ y.

(x, y) S significa que x − y es un número entero.

2



a. ¿Es 3 T 0? ¿Es 1T (−1? ¿Es 2 −1 ∈ T? ¿Es 3 −2 ∈ T?



T = {(4, 7), (6, 5), (6, 7)}.





Escribe T como un conjunto de pares ordenados.

Escribe el dominio y codominio de T .

Dibuja un diagrama de flechas para T.

4. Sean G = {−2, 0, 2} y H = {4, 6, 8} y defina una relación

V de G a H de la siguiente manera: Para todo (x, y) ∈ G × H,

(x, y) V significa que x − y es un número entero.

4



b. Indique si alguna de las relaciones R, S y T son funciones.

Sean A 2, 4 y B 1, 3, 5 y defina las relaciones

U, V y W de A a B de la siguiente manera: Para todo (x, y)

∈ A × B,

(x, y) ∈ U significa que y − x > 2. (x, y) ∈ V significa que y − 1 = 2 .



a. ¿Es 2 V 6? ¿Es (−2)V (−6)? ¿Es (0, 6) ∈ V ? ¿Es (2, 4) ∈ V ? W = {(2, 5), (4, 1), (2, 3)}.







Dibuja diagramas de flechas para U, V y W.

Indique si alguna de las relaciones U, V y W son funciones.

a. Encuentra todas las relaciones de {0,1} a {1}.

b. Encuentre todas las funciones desde {0,1} hasta {1}.

C. ¿Qué fracción de las relaciones de {0,1} a {1} son funciones?

Encuentre cuatro relaciones de {a, b} a {x, y} que no sean funciones de {a, b} a {x, y}.

Defina una relación P de R+ a R de la siguiente manera: Para todos los números reales xey con x > 0,

(x, y) ∈ P significa que x = y2.

¿Es P una función? Explicar.

Defina una relación T de R a R de la siguiente manera: Para todos los números reales x e y,

(x, y) ∈ T significa que y2 − x 2 = 1.

¿Es T una función? Explicar.

Sean A = {−1, 0, 1} y B = {t, u, v, w}. Definir una función

F : A → B mediante el siguiente diagrama de flechas:



X Y







X Y







X Y







X Y



A B





a. Escribe el dominio y codominio de F .

b. Encuentre F(−1), F(0) y F(1).

Sean C = {1, 2, 3, 4} y D = {a, b, c, d}. Definir una función

G: C → D mediante el siguiente diagrama de flechas:



Sea f la función elevatoria definida en el ejemplo 1.3.6.

1



2

Sea g la función sucesora definida en el ejemplo 1.3.6. Encuentre g(−1000), g(0) y g(999).

Sea h la función constante definida en el ejemplo 1.3.6. Encuentre h − 12 , h 0 y h 9 .









a. Escribe el dominio y codominio de G.



Defina las funciones f y g de R a R mediante las siguientes fórmulas: Para todo x ∈ R,

2x 3 + 2x







b. Encuentre G(1), G(2), G(3) y G(4).

Sean X = {2, 4, 5} e Y = {1, 2, 4, 6}. ¿Cuál de los siguientes



f (x) = 2x y g(x) =

¿f = g? Explicar.



x2+1.



¿Los diagramas de flechas inferiores determinan funciones de X a Y?

X Y



20. Defina las funciones H y K de R a R mediante las siguientes fórmulas: Para todo x ∈ R,

H(x) = (x − 2)2 y K(x) = (x − 1)(x − 3) + 1.

¿H = K? Explicar.







Respuestas para Ponte a prueba

1. un subconjunto del producto cartesiano A × B 2. a. un elemento y de B tal que (x, y) ∈ F (es decir, tal que x está relacionado con y

por F ) b. (x, y) ∈ F y (x, z) ∈ F ; y = z 3. el único elemento de B que está relacionado con x por F

































Aristóteles

(384 a.C.-322 a.C.)



Los primeros grandes tratados de lógica fueron escritos por el filósofo griego Aristóteles. Eran una colección de reglas de razonamiento deductivo que pretendían servir de base para el estudio de cada rama del conocimiento. En el siglo XVII, el filósofo y matemático alemán Gottfried Leibniz concibió la idea de utilizar símbolos para mecanizar el proceso de razonamiento deductivo de la misma manera que la notación algebraica había mecanizado el proceso de razonamiento sobre números y sus relaciones. La idea de Leibniz fue realizada en el siglo XIX por los matemáticos ingleses George Boole y Augustus De Morgan, quienes fundaron el tema moderno de la lógica simbólica. Con las investigaciones que continúan hasta el día de hoy, la lógica simbólica ha proporcionado, entre otras cosas, la base teórica para muchas áreas de la informática, como el diseño de circuitos lógicos digitales (ver Secciones 2.4 y 2.5), la teoría de bases de datos relacionales (ver Sección 8.1), los autómatas. teoría y computabilidad (ver Sección 7.4 y Capítulo 12), e inteligencia artificial (ver Secciones 3.3, 10.1 y 10.5).







La lógica es una ciencia de las leyes necesarias del pensamiento, sin las cuales no tiene lugar ningún uso del entendimiento y de la razón. —Immanuel Kant, 1785

El concepto central de la lógica deductiva es el concepto de forma argumentativa. Un argumento es una secuencia de s.



Declaraciones destinadas a demostrar la verdad de una afirmación. La afirmación al final de la secuencia se llama conclusión y las afirmaciones anteriores se llaman premisas. Para tener confianza en la conclusión que se extrae de un argumento, debe estar seguro de que las premisas son aceptables por sí mismas o se derivan de otras afirmaciones que se sabe que son verdaderas.

En lógica, la forma de un argumento se distingue de su contenido. El análisis lógico no le ayudará a determinar el mérito intrínseco del contenido de un argumento, pero le ayudará a analizar la forma de un argumento para determinar si la verdad de la conclusión se deriva necesariamente de la verdad de las premisas. Por esta razón, a veces se define la lógica como la ciencia de la inferencia necesaria o la ciencia del razonamiento.

Consideremos, por ejemplo, los dos argumentos siguientes. Aunque su contenido es muy diferente, su forma lógica es la misma. Ambos argumentos son válidos en el sentido de que si sus premisas son verdaderas, entonces sus conclusiones también deben ser verdaderas. (En la Sección 2.3 aprenderá cómo probar si un argumento es válido).

Argumento 1 Si la sintaxis del programa es defectuosa o si la ejecución del programa resulta en una división por cero, entonces la computadora generará un mensaje de error. Por lo tanto, si la computadora no

23





no genera un mensaje de error, entonces la sintaxis del programa es correcta y la ejecución del programa no resulta en una división por cero.

Argumento 2 Si x es un número real tal que x < −2 o x > 2, entonces x 2 > 4. Por lo tanto, si

x 2 ≯ 4, entonces x ≮ −2 y x ≯ 2.

Para ilustrar la forma lógica de estos argumentos, usamos letras del alfabeto (como p, q y r) para representar las oraciones componentes y la expresión “no p” para referirnos a la oración “No es el caso que p .” Entonces la forma lógica común de ambos argumentos anteriores es la siguiente:

Si p o q, entonces r .

Por lo tanto, si no es r, entonces no es p y no es q.



Ejemplo 2.1.1 Identificación de la forma lógica

Complete los espacios en blanco a continuación para que el argumento (b) tenga la misma forma que el argumento (a). Luego represente la forma común de los argumentos usando letras para representar las oraciones componentes.

Si Jane se especializa en matemáticas o en ciencias de la computación, entonces Jane tomará Matemáticas 150.

Jane se especializa en informática. Por lo tanto, Jane tomará Matemáticas 150.

Si la lógica es fácil o (1), entonces (2). Estudiaré duro.

Por lo tanto, obtendré una A en este curso.

Solución

Estudiaré duro.

Obtendré una A en este curso.

Forma común: si p o q, entonces r. q.

Por lo tanto, r. ■



Declaraciones

La mayoría de las definiciones de lógica formal se han desarrollado de manera que concuerden con la lógica natural o intuitiva utilizada por personas que han sido educadas para pensar con claridad y utilizar el lenguaje con cuidado. Las diferencias que existen entre la lógica formal e intuitiva son necesarias para evitar la ambigüedad y obtener coherencia.

En cualquier teoría matemática, los nuevos términos se definen utilizando aquellos que ya se han definido previamente. Sin embargo, este proceso tiene que comenzar en alguna parte. Algunos términos iniciales necesariamente permanecen indefinidos. En lógica, las palabras oración, verdadero y falso son los términos iniciales indefinidos.





Por ejemplo, “Dos más dos son cuatro” y “Dos más dos son cinco” son ambas afirmaciones, la primera porque es verdadera y la segunda porque es falsa. En el otro





Por otro lado, la verdad o falsedad de “Él es un estudiante universitario” depende de la referencia del pronombre él. Para algunos valores de él la oración es verdadera; para otros es falso. Si la oración estuviera precedida por otras oraciones que dejaran clara la referencia del pronombre, entonces la oración sería una declaración. Sin embargo, considerada por sí sola, la oración no es ni verdadera ni falsa, por lo que no es una afirmación. Discutiremos formas de transformar oraciones de esta forma en enunciados en la Sección 3.1.

De manera similar, “x + y > 0” no es un enunciado porque para algunos valores de xey la oración es verdadera, mientras que para otros es falsa. Por ejemplo, si x = 1 e y = 2, la oración es verdadera; si x = −1 e y = 0, la oración es falsa.



Declaraciones compuestas

Ahora presentamos tres símbolos que se utilizan para construir expresiones lógicas más complicadas a partir de otras más simples. El símbolo ∼ denota no, ∧ denota y, y ∨ denota o. Dada una proposición p, la oración “∼p” se lee “no p” o “No es el caso que p” y se llama negación de p. En algunos lenguajes informáticos el símbolo 'se utiliza en

lugar de     . Dada otra proposición q, la oración “p q” se lee “p y q” y se

llamada conjunción de p y q. La oración "p q" se lee "p o q" y se llama disyunción de py q.

En expresiones que incluyen el símbolo además de o , el orden de las operaciones especifica quién se realiza primero. Por ejemplo, p q (p) q. En expresiones lógicas, como en expresiones algebraicas ordinarias, el orden de las operaciones se puede anular mediante el uso de paréntesis. Así ( p q ) representa la negación de la conjunción de py q. En esto, como en la mayoría de los tratamientos de la lógica, los símbolos y se consideran iguales en orden de operación.

ación, y una expresión como p q r se considera ambigua. Esta expresión debe escribirse como (p q) r o p (q r) para que tenga significado. Una variedad de palabras en inglés se traducen lógicamente como , o . Por ejemplo, la palabra pero se traduce igual cuando vincula dos cláusulas independientes, como en "Jim es alto pero no pesado". Generalmente, la palabra pero se usa en lugar de y cuando la parte de la oración que sigue es, de alguna manera, inesperada. Otro ejemplo involucra las palabras ni-ni. Cuando Shakespeare escribió: "Ni un prestatario ni un prestamista", quiso decir:

“No seas prestatario ni prestamista”. Entonces, si p y q son declaraciones, entonces







Ejemplo 2.1.2 Traducción del inglés a símbolos: pero y ni-ni

Escribe simbólicamente cada una de las siguientes oraciones, dejando h “Hace calor” y s “Hace sol”.

No hace calor pero hace sol.

No hace calor ni hace sol.

Solución

La oración dada equivale a “No hace calor y hace sol”, que puede escribirse simbólicamente como ∼h ∧ s.

Decir que no hace calor ni hace sol significa que no hace calor ni hace sol. Por lo tanto, la oración dada se puede escribir simbólicamente como ∼h ∧ ∼s. ■





La notación para desigualdades involucra declaraciones y y o. Por ejemplo, si x, a y b

son números reales particulares, entonces





Tenga en cuenta que la desigualdad 2 ≤ x ≤ 1 no se satisface con ningún número real porque 2 ≤ x ≤ 1 significa 2 ≤ x y x ≤ 1,

y esto es falso sin importar cuál sea el número x. Por cierto, el objetivo de especificar que x, a y b sean números reales particulares es garantizar que oraciones como “x < a” y “x ≥ b” sean verdaderas o falsas y, por tanto, que sean afirmaciones. .

Ejemplo 2.1.3 Y, O y Desigualdades

Supongamos que x es un número real particular. Sean p, q y r simbolizan “0 < x”, “x < 3” y “x = 3”, respectivamente. Escribe simbólicamente las siguientes desigualdades:

a. x ≤ 3b. 0 < x < 3c. 0 < x ≤ 3

Solución

a. q ∨ r segundo. pag ∧ q c. pag ∧ (q ∨ r) ■



Valores de verdad

En los ejemplos 2.1.2 y 2.1.3 construimos oraciones compuestas a partir de enunciados componentes y los términos not, and, and or. Sin embargo, si tales oraciones han de ser enunciados, deben tener valores de verdad bien definidos: deben ser verdaderas o falsas. Ahora definimos tales oraciones compuestas como enunciados especificando sus valores de verdad en términos de los enunciados que las componen.

La negación de un enunciado es un enunciado que expresa exactamente lo que significaría que el enunciado fuera falso.



Los valores de verdad de la negación se resumen en una tabla de verdad.

Tabla de verdad para ∼ p







En el lenguaje corriente, se entiende que la frase “Hace calor y hace sol” es verdadera cuando se satisfacen ambas condiciones: hacer calor y hacer sol. Si hace calor pero no hace sol, o hace sol pero no hace calor, o ni hace calor ni hace sol, se entiende que la frase es falsa. La definición formal de valores de verdad para un enunciado concuerda con esta comprensión general.







Los valores de verdad de la conjunción también se pueden resumir en una tabla de verdad. La tabla se obtiene considerando las cuatro posibles combinaciones de valores de verdad para p y q. Cada combinación se muestra en una fila de la tabla; el valor de verdad correspondiente para toda la declaración se coloca en la columna más a la derecha de esa fila. Tenga en cuenta que la única fila que contiene una T es la primera, ya que la única forma de que una declaración y sea verdadera es que ambas declaraciones componentes sean verdaderas.



Tabla de verdad para p ∧ q





Por cierto, el orden de los valores de verdad para p y q en la tabla anterior es TT, TF, FT, FF. No es absolutamente necesario escribir los valores de verdad en este orden, aunque es costumbre hacerlo. Usaremos este orden para todas las tablas de verdad que incluyan dos variables enunciativas. En el Ejemplo 2.1.5 mostraremos el orden estándar para tablas de verdad que involucran tres variables enunciativas.

En el caso de la disyunción (enunciados de la forma “p o q”), la lógica intuitiva ofrece dos interpretaciones alternativas. En el lenguaje ordinario o a veces se usa en un sentido exclusivo (p o q pero no ambos) y a veces en un sentido inclusivo (p o q o ambos). Un camarero que dice que puede tomar “café, té o leche” usa la palabra o en un sentido exclusivo: generalmente se requiere un pago adicional si desea más de una bebida. Por otro lado, un camarero que ofrece “nata o azúcar” utiliza la palabra o en un sentido inclusivo: tienes derecho tanto a la nata como al azúcar si deseas tenerlas.

Los matemáticos y lógicos evitan una posible ambigüedad sobre el significado de la palabra o al entender que significa el inclusivo "y/o". El símbolo proviene del vocablo latino vel, que significa o en su sentido inclusivo. Para expresar el o exclusivo, se utiliza la frase p o q pero no ambas.













Nota La afirmación “2 2” significa que 2 es

menos de 2 o 2 es igual a 2. Es cierto porque 2 = 2.



Aquí está la tabla de verdad para la disyunción:



Tabla de verdad para p ∨ q







Evaluación de la veracidad de enunciados compuestos más generales

Ahora que se han asignado valores de verdad a p, p q y p q, considere la cuestión de asignar

valores de verdad a expresiones más complicadas como p q, ( p q) ( p q) y ( p q) r . Estas expresiones se denominan formas enunciativas (o formas proposicionales). La estrecha relación entre las formas de los enunciados y las expresiones booleanas se analiza en la Sección 2.4.











Para calcular los valores de verdad de una forma de enunciado, siga reglas similares a las utilizadas para evaluar expresiones algebraicas. Para cada combinación de valores de verdad para las variables enunciativas, primero evalúe las expresiones dentro del paréntesis más interno, luego evalúe las expresiones dentro del siguiente conjunto de paréntesis más interno, y así sucesivamente hasta que tenga los valores de verdad para la expresión completa.





Ejemplo 2.1.4 Tabla de verdad para O exclusivo

Construya la tabla de verdad para la forma de enunciado ( p q) ( p q). Tenga en cuenta que cuando o se usa en su sentido exclusivo, la afirmación “poq” significa “poq pero no ambos” o “poq y no ambos p y q”, lo que se traduce en símbolos como (p ∨ q) ∧ ∼( p ∧ q). A veces se abrevia p ⊕ q o p XOR q.





Solución Configure columnas etiquetadas p, q, p q, p q, ( p q) y ( p q) ( p q). Complete las columnas p y q con todas las combinaciones lógicamente posibles de T y F. Luego use las tablas de verdad para y para completar las columnas p q y p q con los valores de verdad apropiados. Luego complete la columna (p q) tomando los opuestos de los valores de verdad para p q. Por ejemplo, la entrada para ( p q) en la primera fila es F porque en la primera fila el valor de verdad de p q es T. Finalmente, complete la columna ( p q) ( p q) considerando la tabla de verdad para an y declaración junto con los valores de verdad calculados para p q y (p q). Por ejemplo, la entrada de la primera fila es F porque la entrada para p q es T, la entrada para (p q) es F y una proposición y es falsa a menos que ambos componentes sean verdaderos. La entrada en la segunda fila es T porque ambos componentes son verdaderos en esta fila.

Tabla de verdad para O exclusivo: ( p ∨ q) ∧ ∼( p ∧ q)









■



Ejemplo 2.1.5 Tabla de verdad para (p ∧ q) ∨ ∼r

Construya una tabla de verdad para la forma de enunciado (p ∧ q) ∨ ∼r.

Solución Haga columnas con los encabezados p, q, r, p q, r y (p q) r. Ingrese las ocho combinaciones lógicamente posibles de valores de verdad para p, q y r en las tres columnas de la izquierda. Luego complete los valores de verdad para p q y para r . Complete la tabla considerando los valores de verdad para (p q) y para r y la definición de un enunciado o. Dado que una declaración o es falsa sólo cuando ambos componentes son falsos, las únicas filas en las que la entrada es F son la tercera, quinta y séptima porque esas son las únicas filas en las que las expresiones p q y r son ambas falsas. La entrada para todas las demás filas es T.























■





El punto esencial acerca de asignar valores de verdad a enunciados compuestos es que le permite (usando únicamente la lógica) juzgar la verdad de un enunciado compuesto sobre la base de su conocimiento de la verdad de sus partes componentes. La lógica no le ayuda a determinar la verdad o falsedad de las declaraciones que las componen. Más bien, la lógica ayuda a vincular estas piezas separadas de información en un todo coherente.





Equivalencia lógica

Las declaraciones

6 es mayor que 2 y 2 es menor que 6

Son dos maneras diferentes de decir lo mismo. ¿Por qué? Por la definición de las frases mayor que y menor que. Por el contrario, aunque las declaraciones

Los perros ladran y los gatos maúllan y (2) Los gatos maúllan y los perros ladran

También son dos formas diferentes de decir lo mismo, el motivo no tiene nada que ver con la deﬁnición de las palabras. Tiene que ver con la forma lógica de las declaraciones. Dos afirmaciones cualesquiera cuyas formas lógicas estén relacionadas de la misma manera que (1) y (2) serían ambas verdaderas o ambas falsas. Puede ver esto examinando la siguiente tabla de verdad, donde las variables enunciativas p y q se sustituyen por las declaraciones componentes “Los perros ladran” y “Los gatos maúllan”, respectivamente. La tabla muestra que para cada combinación de valores de verdad para p y q, p q es verdadero cuando, y sólo cuando, q p es verdadero. En tal caso, las formas de los enunciados se denominan lógicamente equivalentes y decimos que (1) y (2) son enunciados lógicamente equivalentes.



↑ ↑

p q y q p siempre tienen los mismos valores de verdad, por lo que son lógicamente equivalentes







Ejemplo 2.1.6 Propiedad doble negativa: ∼(∼ p) ≡ p

Construya una tabla de verdad para mostrar que la negación de la negación de un enunciado es lógicamente equivalente al enunciado, anotando la tabla con una oración explicativa.



Solución







↑ ↑

p y (p) siempre tienen los mismos valores de verdad, por lo que

son lógicamente equivalentes ■



Hay dos maneras de demostrar que las formas de enunciado P y Q no son lógicamente equivalentes. Como se indicó anteriormente, se debe utilizar una tabla de verdad para encontrar filas cuyos valores de verdad difieren. La otra manera es encontrar enunciados concretos para cada una de las dos formas, uno de los cuales sea verdadero y el otro falso. El siguiente ejemplo ilustra ambas formas.



Ejemplo 2.1.7 Mostrando no equivalencia

mostrar



en las formas de enunciado ∼( p ∧ q) y ∼p ∧ ∼q no son lógicamente equivalentes.

Solución

Este método utiliza una tabla de verdad anotada con una oración explicativa.



↑ ↑

(p q) y p q tienen diferentes valores de verdad en las filas 2 y 3, por lo que no son lógicamente equivalentes





Este método utiliza un ejemplo para mostrar que ( p q ) y p q no son lógicamente equivalentes. Sea p el enunciado “0 < 1” y sea q el enunciado “1 < 0”. Entonces

∼( p ∧ q) es “No es cierto que 0 < 1 y 1 < 0”, lo cual es cierto. Por otro lado,

∼p ∧ ∼q es “0 ≮ 1 y 1 ≮ 0”,

lo cual es falso. Este ejemplo muestra que hay afirmaciones concretas que puedes sustituir p y q para hacer que una de las afirmaciones sea verdadera y la otra falsa. Por lo tanto, las formas de los enunciados no son lógicamente equivalentes. ■





Ejemplo 2.1.8 Negaciones de Y y O: Leyes de De Morgan

Para que la afirmación “John es alto y Jim es pelirrojo” sea cierta, ambos componentes deben ser verdaderos. Entonces, para que una afirmación sea falsa, uno o ambos componentes deben ser falsos. Por tanto, la negación se puede escribir como "John no es alto o Jim no es pelirrojo". En general, la negación de la conjunción de dos enunciados es lógicamente equivalente a la disyunción de sus negaciones. Es decir, los enunciados de las formas (p q) y p q son lógicamente equivalentes. Verifique esto usando tablas de verdad.



Solución











↑ ↑

( p q ) y p q siempre tienen los mismos valores de verdad, por lo que son lógicamente equivalentes



Simbólicamente,



















Augusto de Morgan (1806–1871)



En los ejercicios al final de esta sección se le pedirá que muestre la ley análoga de que la negación de la disyunción de dos enunciados es lógicamente equivalente a la conjunción de sus negaciones:





■



Las dos equivalencias lógicas del ejemplo 2.1.8 se conocen como leyes de la lógica de De Morgan en honor a Augustus De Morgan, quien fue el primero en enunciarlas en términos matemáticos formales.









Ejemplo 2.1.9 Aplicación de las leyes de De Morgan

Escribe negaciones para cada una de las siguientes afirmaciones:

John mide 6 pies de alto y pesa al menos 200 libras.

El autobús llegó tarde o el reloj de Tom estaba atrasado.





Solución

John no mide 6 pies de alto ni pesa menos de 200 libras.

El autobús no llegó tarde y el reloj de Tom no atrasó.

Dado que el enunciado “ni p ni q” significa lo mismo que “p y q”, una respuesta alternativa para (b) es “Ni el autobús llegó tarde ni el reloj de Tom estuvo atrasado”. ■



Si x es un número real particular, decir que x no es menor que 2 (x ≮ 2) significa que x no se encuentra a la izquierda de 2 en la recta numérica. Esto equivale a decir que x = 2 o x se encuentra a la derecha de 2 en la recta numérica (x = 2 o x > 2). Por eso,



x ≮ 2 es equivalente a x ≥ 2.

Gráficamente,



–2 –1 0 1 2 3 4 5





Similarmente,





Ejemplo 2.1.10 Desigualdades y leyes de De Morgan

Usa las leyes de De Morgan para escribir la negación de −1 < x ≤ 4.

Solución La afirmación dada es equivalente a



−1 < x y x ≤ 4.

Según las leyes de De Morgan, la negación es





¡Precaución! La negación de −1 < x ≤ 4 no es

−1 ≮ x # 4. Tampoco lo es

−1 ≥ x > 4.







que es equivalente a



−1 ≮ x o x # 4,



−1 ≥ x o x > 4.





Gráficamente, si 1 x o x > 4, entonces x se encuentra en la región sombreada de la recta numérica, como se muestra a continuación.



–2 –1 0 1 2 3 4 5 6



■

Las leyes de De Morgan se utilizan con frecuencia al escribir programas de computadora. Por ejemplo, supongamos que desea que su programa borre todos los archivos modificados fuera de un cierto rango de fechas, digamos desde la fecha 1 hasta la fecha 2 inclusive. Usarías el hecho de que

∼(fecha1 ≤ fecha_modificación_archivo ≤ fecha2)





es equivalente a

(fecha_modificación_archivo < fecha1) o (fecha2 <fecha_modificación_archivo).





Ejemplo 2.1.11 Un ejemplo de precaución

Según las leyes de De Morgan, la negación de

p: Jim es alto y Jim es delgado

es ∼p: Jim no es alto o Jim no es delgado

porque la negación de una declaración y es la declaración o en la que se niegan los dos componentes.

Desafortunadamente, puede surgir un aspecto potencialmente confuso del idioma inglés cuando se aceptan negaciones de este tipo. Tenga en cuenta que el enunciado p se puede escribir de forma más compacta como

















¡Precaución! Aunque las leyes de la lógica son extremadamente útiles, deberían utilizarse como ayuda para el pensamiento, no como un sustituto mecánico del mismo.



p↔: Jim es alto y delgado.

Cuando está escrito así, otra forma de negarlo es



∼(p↔): Jim no es alto ni delgado.

Pero en esta forma la negación parece una declaración y. ¿No viola eso las leyes de De Morgan?

En realidad no se produce ninguna infracción. La razón es que en la lógica formal las palabras y y o

sólo se permiten entre declaraciones completas, no entre fragmentos de oraciones.

Una lección que se puede aprender de este ejemplo es que cuando se aplican las leyes de De Morgan, se deben tener enunciados completos a cada lado de cada y a cada lado de cada o.

■





Tautologías y contradicciones

Se ha dicho que todas las matemáticas se reducen a tautologías. Aunque esto es formalmente cierto, la mayoría de los matemáticos que trabajan piensan que su materia tiene sustancia además de forma. Sin embargo, una comprensión intuitiva de las tautologías lógicas básicas es parte del equipo de cualquiera que reaccione.



Ons con las matemáticas.





Según esta definición, la verdad de un enunciado tautológico y la falsedad de un enunciado contradictorio se deben a la estructura lógica de los enunciados mismos y son independientes de los significados de los enunciados.





Ejemplo 2.1.12 Tautologías y contradicciones

Demuestre que la forma de enunciado p p es una tautología y que la forma de enunciado p p

es una contradicción.

Solución





↑ ↑

todas las T, así que todas las F, así

p p es p p es un ■

una contradicción tautología



Ejemplo 2.1.13 Equivalencia lógica que involucra tautologías y contradicciones

Si t es una tautología y c es una contradicción, demuestre que p ∧ t ≡ p y p ∧ c ≡ c.

Solución





↑ ↑ ↑ ↑

misma verdad misma verdad

valores, entonces valores, entonces

p ∧ t ≡ p p ∧ c ≡ c ■

Resumen de equivalencias lógicas

El conocimiento de enunciados lógicamente equivalentes es muy útil para construir argumentos. A menudo sucede que es difícil ver cómo se sigue una conclusión de una forma de enunciado, mientras que es fácil ver cómo se sigue de una forma lógicamente equivalente del enunciado. En el teorema 2.1.1 se resumen varias equivalencias lógicas para referencia futura.







Las demostraciones de las leyes 4 y 6, las primeras partes de las leyes 1 y 5 y la segunda parte de la ley 9 ya se han dado como ejemplos en el texto. Las demostraciones de las otras partes del teorema se dejan como ejercicios. De hecho, se puede demostrar que las primeras cinco leyes del teorema 2.1.1 forman un núcleo del cual se pueden derivar las demás leyes. Las primeras cinco leyes son los axiomas de una estructura matemática conocida como álgebra booleana, que se analiza en la sección 6.4.

Las equivalencias del Teorema 2.1.1 son leyes generales de pensamiento que ocurren en todas las áreas del esfuerzo humano. También se pueden utilizar de manera formal para reescribir formas de declaraciones complicadas de manera más simple.



Ejemplo 2.1.14 Simplificación de formularios de declaración

Utilice el Teorema 2.1.1 para verificar la equivalencia lógica

∼(∼p ∧ q) ∧ ( p ∨ q) ≡ p.

Solución Utilice las leyes del Teorema 2.1.1 para reemplazar secciones del formulario de enunciado de la izquierda por expresiones lógicamente equivalentes. Cada vez que hace esto, obtiene una forma de declaración lógicamente equivalente. Continúe haciendo reemplazos hasta que obtenga el formulario de declaración a la derecha.



∼(∼p ∧ q) ∧ ( p ∨ q) ≡ (∼(∼p) ∨ ∼q) ∧ ( p ∨ q) por las leyes de De Morgan

≡ ( p ∨ ∼q) ∧ ( p ∨ q) por la doble ley negativa

≡ p ∨ (∼q ∧ q) por la ley distributiva

≡ p ∨ (q ∧ ∼q) por la ley conmutativa para ∧

≡ p ∨ c por la ley de negación

≡ p por la ley de identidad. ■

La habilidad para simplificar formas de enunciados es útil para construir programas de computadora lógicamente eficientes y para diseñar circuitos lógicos digitales.

Aunque las propiedades del Teorema 2.1.1 se pueden usar para demostrar la equivalencia lógica de dos formas de enunciado, no se pueden usar para demostrar que las formas de enunciado no son lógicamente equivalentes. Por otro lado, las tablas de verdad siempre se pueden utilizar para determinar tanto la equivalencia como la no equivalencia, y las tablas de verdad son fáciles de programar en una computadora. Sin embargo, cuando se utilizan tablas de verdad, verificar la equivalencia siempre requiere 2n pasos, donde n es el número de variables. A veces se puede ver rápidamente que dos formas de enunciado son equivalentes según el teorema 2.1.1, mientras que se necesitarían bastantes cálculos para mostrar su equivalencia usando tablas de verdad. Por ejemplo, de la ley asociativa se deduce inmediatamente que p (q r) (p q) r, mientras que una verificación de una tabla de verdad requiere construir una tabla con ocho filas.



Pruébate

Las respuestas a las preguntas de Pruébese usted mismo se encuentran al final de cada sección.



Una afirmación y es verdadera si, y sólo si, ambos componentes son verdaderos.

  .

Una declaración o es falsa si, y sólo si, ambos componentes son

  .

Dos formas de enunciado son lógicamente equivalentes si, y sólo si, siempre tienen .

Las leyes de De Morgan dicen (1) que la negación de un enunciado y es lógicamente equivalente al enunciado en el que



cada componente es , y (2) que la negación de un enunciado o es lógicamente equivalente al enunciado en el que cada componente es .

Una tautología es una afirmación que es siempre.

Una contradicción es una afirmación que es siempre.







Conjunto de ejercicios 2.1 *

En cada uno de los puntos 1 a 4, represente la forma común de cada argumento usando letras para representar las oraciones componentes y complete los espacios en blanco para que el argumento del inciso (b) tenga la misma forma lógica que el argumento del inciso (a).

a. Si todos los números enteros son racionales, entonces el número 1 es racional. Todos los números enteros son racionales.

Por tanto, el número 1 es racional.

b. Si todas las expresiones algebraicas se pueden escribir en notación de prefijo, entonces.

  .

Por lo tanto, (a 2b)(a2 b) se puede escribir en notación de prefijo.

a. Si todos los programas de computadora contienen errores, entonces este programa contiene un error.

Este programa no contiene ningún error.

Por tanto, no se da el caso de que todos los programas informáticos contengan errores.

b. Si entonces. 2 no es extraño.

Por lo tanto, no es cierto que todos los números primos sean impares.

a. Este número es par o este número es impar. Este número no es par.

Por tanto, este número es impar.

b. o la lógica es confusa. Mi mente no está disparada. Por lo tanto

, .

a. Si n es divisible por 6, entonces n es divisible por 3.

Si n es divisible por 3, entonces la suma de los dígitos de n es divisible por 3.

Por lo tanto, si n es divisible por 6, entonces la suma de los dígitos de n es divisible por 3.

(Supongamos que n es un número entero fijo particular.)

b. Si esta función lo es, entonces esta función es diferenciable.

Si esta función es entonces esta función es continua. Por lo tanto, si esta función es un polinomio, entonces esta función.

Indique cuáles de las siguientes oraciones son afirmaciones.

1.024 es el número más pequeño de cuatro dígitos que es un cuadrado perfecto.

Ella es estudiante de matemáticas.

C. 128 = 26 d. x = 26

Escriba las afirmaciones del 6 al 9 en forma simbólica usando los símbolos

, , y y las letras indicadas para representar declaraciones de componentes.

Seamos s “las acciones están aumentando” y i “las tasas de interés se mantienen estables”.







Las acciones están aumentando pero las tasas de interés se mantienen estables.

Ni las acciones están aumentando ni las tasas de interés se mantienen estables.

Juan es estudiante de matemáticas pero no de informática. (m “Juan se especializa en matemáticas”, c “Juan se especializa en ciencias de la computación”)

Sean h “Juan está sano”, w “Juan es rico” y s

"Juan es sabio".

Juan es sano y rico pero no sabio.

Juan no es rico pero es sano y sabio.

Juan no es ni sano, ni rico, ni sabio.

Juan no es rico ni sabio, pero está sano.

Juan es rico, pero no es a la vez sano y sabio.

O este polinomio tiene grado 2 o tiene grado 3, pero no ambos. (n “Este polinomio tiene grado 2”, k “Este polinomio tiene grado 3”)

Sea p la declaración “DATAENDFLAG está desactivada”, q la declaración “ERROR es igual a 0” y r la declaración “SUM es menor que 1000”. Expresa las siguientes oraciones en notación simbólica.

DATAENDFLAG está desactivado, ERROR es igual a 0 y SUM es inferior a 1000.

DATAENDFLAG está desactivado pero ERROR no es igual a 0.

DATAENDFLAG está desactivado; sin embargo, ERROR no es 0 o SUM es mayor o igual a 1000.

DATAENDFLAG está activado y ERROR es igual a 0 pero SUM es mayor o igual a 1000.

O DATAENDFLAG está activado o se da el caso de que ERROR sea igual a 0 y SUM sea menor que 1000.

En la siguiente oración, ¿se usa la palabra o en su sentido inclusivo o exclusivo? Un equipo gana los playoffs si gana dos juegos seguidos o un total de tres juegos.

Escribe tablas de verdad para los formularios de enunciados del 12 al 15.

12. ∼p ∧ q 13. ∼( p ∧ q) ∨ ( p ∨ q)

14. p ∧ (q ∧ r) 15. p ∧ (∼q ∨ r)

Determine si las formas de enunciado de 16 a 24 son lógicamente equivalentes. En cada caso, construye una tabla de verdad e incluye una oración que justifique tu respuesta. Tu oración debe demostrar que entiendes el significado de equivalencia lógica.

16. p ∨ ( p ∧ q) y p 17. ∼( p ∧ q) y ∼p ∧ ∼q

18. p ∨ t y t 19. p ∧ t y p

p ∧ c y p ∨ c

(p ∧ q) ∧ r y p ∧ (q ∧ r)





* Para ejercicios con números o letras azules, las soluciones se dan en el Apéndice B. El símbolo H indica que solo se da una pista o una solución parcial. El símbolo ✶ indica que un ejercicio es más desafiante de lo habitual.







22. p ∧ (q ∨ r) y (p ∧ q) ∨ (p ∧ r)

23. (p ∧ q) ∨ r y p ∧ (q ∨ r)

24. (p ∨ q) ∨ (p ∧ r) y (p ∨ q) ∧ r

Utilice las leyes de De Morgan para escribir negaciones para los enunciados de 25 a 31.

Hal estudia matemáticas y la hermana de Hal estudia ciencias de la computación.

Sam es cinturón naranja y Kate es cinturón rojo.

El conector está suelto o la máquina está desenchufada.

El dígito de las unidades de 467 es 4 o es 6.

Este programa de computadora tiene un error lógico en las primeras diez líneas o se está ejecutando con un conjunto de datos incompleto.

El dólar está en un máximo histórico y el mercado de valores está en un mínimo histórico.

El tren llega tarde o mi reloj está adelantado.



Suponga que x es un número real particular y utilice las leyes de De Morgan para escribir negaciones para los enunciados de 32-37.

32. −2 < x < 7 33. −10 < x < 2

34. x < 2 o x > 5 35. x ≤ −1 o x > 1

36. 1 > x ≥ −3 37. 0 > x ≥ −7

En 38 y 39, imagine que num_orders y num_instock son valores particulares, como los que podrían ocurrir durante la ejecución de un programa de computadora. Escribe negaciones para las siguientes afirmaciones.

38.



45. a. Bob tiene una doble especialización en matemáticas e informática y Ann tiene una especialización en matemáticas, pero Ann no tiene una doble especialización en matemáticas e informática.

b. No es el caso que tanto Bob como Ann tengan una doble especialización en matemáticas y ciencias de la computación, pero sí es cierto que Ann tiene una especialización en matemáticas y Bob tiene una doble especialización en matemáticas y ciencias de la computación.

✶ 46. En el ejemplo 2.1.4, el símbolo se introdujo para denotar exclusivo o, entonces p q ( p q) ( p q). Por tanto, la tabla de verdad para o exclusivo es la siguiente:





Encuentre formas de enunciados más simples que sean lógicamente equivalentes a p p y (p p) p.

¿Es (p q) r p (q r)? Justifica tu respuesta.

¿Es (p q) r (p r) (q r)? Justifica tu respuesta.

✶ 47. En lógica y en inglés estándar, una doble negativa equivale a una positiva. Hay un uso bastante común en inglés en el que un “doble positivo” equivale a un negativo. ¿Qué es? ¿Puedes pensar en otros?



En 48 y 49 siguientes, se deriva una equivalencia lógica del Teorema 2.1.1. Proporcione una razón para cada paso.

48. ( p ∧ ∼q) ∨ ( p ∧ q) ≡ p ∧ (∼q ∨q) por (a)





(num_pedidos > 100 y num_instock 500) o

número_instock < 200



≡ p ∧ (q ∨ ∼q)



por (b)



39. (núm_pedidos < 50 y núm_disponibilidad > 300) o (50 ≤ núm_pedidos < 75 y núm_disponibilidad > 500)

Utilice tablas de verdad para establecer cuáles de las formas de enunciado de 40 a 43 son tautologías y cuáles son contradicciones.

40. (p ∧ q) ∨ (∼p ∨ (p ∧ ∼q))

41. ( p ∧ ∼q) ∧ (∼p ∨ q)

42. ((∼p ∧ q) ∧ (q ∧ r)) ∧ ∼q



≡ p ∧ t por (c)

≡ p por (d)

Por lo tanto, ( p ∧ ∼q) ∨ ( p ∧ q) ≡ p.

49. ( p ∨ ∼q) ∧ (∼p ∨ ∼q)

≡ (∼q ∨ p) ∧ (∼q ∨ ∼p) por (a)

≡ ∼q ∨ (p ∧ ∼p) por (b)

≡ ∼q ∨ c por (c)

≡ ∼q por (d)



43. (∼p ∨ q) ∨ ( p ∧ ∼q)

En 44 y 45, determine si los enunciados en (a) y (b) son lógicamente equivalentes.

Supongamos que x es un número real particular.



x < 2 o no se da el caso de que 1 < x < 3.

x ≤ 1 o x < 2 o x ≥ 3.



Por lo tanto, ( p ∨ ∼q) ∧ (∼p ∨ ∼q) ≡ ∼q.

Utilice el teorema 2.1.1 para verificar las equivalencias lógicas en 50-54. Proporcione una razón para cada paso.

50. ( p ∧ ∼q) ∨ p ≡ p 51. p ∧ (∼q ∨ p) ≡ p

52. ∼( p ∨ ∼q) ∨ (∼p ∧ ∼q) ≡ ∼p

53. ∼((∼p ∧ q) ∨ (∼p ∧ ∼q)) ∨ ( p ∧ q) ≡ p

54. ( p ∧ (∼(∼p ∨ q))) ∨ ( p ∧ q) ≡ p





Respuestas para Ponte a prueba

1. verdadero 2. falso 3. los mismos valores de verdad 4. o; negado; y; negado 5. verdadero 6. falso





... el razonamiento hipotético implica la subordinación de lo real al ámbito de lo posible... — Jean Piaget, 1972



Cuando haces una inferencia o deducción lógica, razonas desde una hipótesis hasta una conclusión. Su objetivo es poder decir: "Si se sabe tal o cual cosa, entonces debe ser cierto algo".

Sean p y q declaraciones. Una oración de la forma “Si p entonces q” se denota simbólicamente por “p q”; p se llama hipótesis y q se llama conclusión. Por ejemplo, considere la siguiente afirmación:

Si 4.686 es divisible por 6, entonces 4.686 es divisible por 3.

c hipótesis I c conclusión I

Tal oración se llama condicional porque la verdad del enunciado q está condicionada a la verdad del enunciado p.

La notación p → q indica que → es un conectivo, como ∧ o ∨, que se puede usar para unir declaraciones para crear nuevas declaraciones. Por lo tanto, para definir p → q como un enunciado, debemos especificar los valores de verdad para p → q tal como especificamos los valores de verdad para p ∧ q y para p ∨ q. Como es el caso con los otros conectivos, la definición formal de valores de verdad para

→ (si-entonces) se basa en su significado intuitivo y cotidiano. Considere un ejemplo.

Supongamos que vas a una entrevista para un trabajo en una tienda y el dueño de la tienda te hace la siguiente promesa:

Si te presentas a trabajar el lunes por la mañana, conseguirás el trabajo.

¿En qué circunstancias está justificado decir que el propietario habló falsamente? Es decir, ¿bajo qué circunstancias la frase anterior es falsa? La respuesta es: te presentas a trabajar el lunes por la mañana y no consigues el trabajo.

Después de todo, la promesa del propietario sólo dice que obtendrá el trabajo si se cumple una determinada condición (presentarse a trabajar el lunes por la mañana); no dice nada sobre lo que sucederá si no se cumple la condición. Entonces, si no se cumple la condición, no se puede decir con justicia que la promesa es falsa, independientemente de si obtiene o no el trabajo.

El ejemplo anterior pretendía convencerle de que la única combinación de circunstancias en la que consideraría falsa una oración condicional ocurre cuando la hipótesis es verdadera y la conclusión es falsa. En todos los demás casos, no llamarías falsa la oración. Esto implica que la única fila de la tabla de verdad para p q que debe completarse con una F es la fila donde p es T y q es F. Ninguna otra fila debe contener una F. Pero cada fila de una tabla de verdad debe completarse con una T o una F. Por lo tanto, todas las demás filas de la tabla de verdad para p → q deben completarse con T.

Tabla de verdad para p → q











Un enunciado condicional que es verdadero en virtud del hecho de que su hipótesis es falsa a menudo se denomina vagamente verdadero o verdadero por defecto. Por lo tanto, la afirmación “Si te presentas a trabajar el lunes por la mañana, conseguirás el trabajo” es vagamente cierta si no te presentas a trabajar el lunes por la mañana. En general, cuando la parte "si" de un enunciado si-entonces es falsa, se dice que el enunciado en su conjunto es verdadero, independientemente de si la conclusión es verdadera o falsa.



Ejemplo 2.2.1 Una declaración condicional con una hipótesis falsa

Considere la declaración:

Si 0 = 1 entonces 1 = 2.

Por extraño que parezca, dado que la hipótesis de esta afirmación es falsa, la afirmación en su conjunto es verdadera. ■













Nota Por ejemplo, si

0 1, entonces, sumando 1 a ambos lados de la

ecuación, puedes deducir que 1 = 2.



El filósofo Willard Van Orman Quine desaconseja el uso de la frase "p implica q" para significar "p q" porque la palabra implica sugiere que q se puede deducir lógicamente de p y este no es a menudo el caso. No obstante, mucha gente utiliza la frase, probablemente porque es un reemplazo conveniente del símbolo. Y, por supuesto, en muchos casos se puede deducir una conclusión a partir de una hipótesis, incluso cuando la hipótesis sea falsa.

En expresiones que incluyen → así como otros operadores lógicos scomo ∧, ∨ y ∼,

el orden de las operaciones es que → se realiza al final. Por lo tanto, de acuerdo con la especificación del orden de las operaciones en la Sección 2.1, primero se realiza ∼, luego ∧ y ∨, y finalmente →.





Ejemplo 2.2.2 Tabla de verdad para p ∨ ∼q →∼ p

Construya una tabla de verdad para la forma de enunciado p ∨ ∼q →∼p.

Solución Según el orden de las operaciones dado anteriormente, las dos expresiones siguientes son equivalentes: p q p y ( p ( q)) ( p), y este orden gobierna la construcción de la tabla de verdad. Primero complete las cuatro combinaciones posibles de valores de verdad para pyq, y luego ingrese los valores de verdad para pyq usando la definición de negación. Luego complete la columna p q usando la definición de . Finalmente, complete la columna p q p usando la definición de . Las únicas filas en las que la hipótesis p q es verdadera y la conclusión p es falsa son la primera y la segunda fila. Entonces pones F en esas dos filas y T en las otras dos filas.



hipótesis de conclusión



∼Icp



˛∼q



p∨Ic∼q˛











■





Equivalencias lógicas que involucran →

Imagina que estás intentando resolver un problema que involucra tres enunciados: p, q y r. Supongamos que sabes que la verdad de r se sigue de la verdad de p y también que la verdad de r se sigue de la verdad de q. Entonces, no importa si p o q es el caso, la verdad de r debe seguirse. El método de análisis de división en casos se basa en esta idea.

Ejemplo 2.2.3 División en casos: demostrar que p ∨ q → r ≡ ( p → r) ∧ (q → r)

Utilice tablas de verdad para mostrar la equivalencia lógica de las formas de enunciado p ∨ q → r y

(p → r) ∧ (q → r). Anota la tabla con una frase explicativa.

Solución Primero complete las ocho combinaciones posibles de valores de verdad para p, q y r. Luego complete las columnas para p q, p r y q r usando las deﬁniciones de o y si-entonces. Por ejemplo, la columna p r tiene F en las filas segunda y cuarta porque estas son las filas en las que p es verdadero y q es falso. Luego complete la columna p q r usando la definición de si-entonces. Las filas en las que la hipótesis p q es verdadera y la conclusión r es falsa son la segunda, cuarta y sexta. Entonces las F van en estas filas y las T en todas las demás. La tabla completa muestra que p q r y (p r) (q r) tienen los mismos valores de verdad para cada combinación de valores de verdad de p, q y r. Por tanto, las dos formas de enunciado son lógicamente equivalentes.



↑ ↑

p q r y (p r) (q r)

tener siempre los mismos valores de verdad,

entonces son lógicamente equivalentes ■



Representación de Si-Entonces Como O

En el ejercicio 13(a), al final de esta sección, se le pide que utilice tablas de verdad para demostrar que

p → q ≡ ∼p ∨ q.

La equivalencia lógica de “si p entonces q” y “no p o q” se utiliza ocasionalmente en el habla cotidiana. Aquí hay un ejemplo.



Ejemplo 2.2.4 Aplicación de la Equivalencia entre ∼ p ∨ q y p → q

Reescribe la siguiente declaración en forma si-entonces.

O llegas al trabajo a tiempo o te despiden.



Solución Sea ∼p





Llegas a trabajar a tiempo.





y q ser

Estás despedido.

Entonces el enunciado dado es ∼p ∨ q. También p es

No llegas a trabajar a tiempo.

Entonces la versión equivalente si-entonces, p → q, es

Si no llegas a tiempo al trabajo, te despiden. ■



La negación de una declaración condicional

Por definición, p q es falsa si, y sólo si, su hipótesis, p, es verdadera y su conclusión,

q, es falsa. Resulta que



Esto se puede reformular simbólicamente de la siguiente manera:



También puedes obtener este resultado partiendo de la equivalencia lógica p → q ≡∼

pag ∨ q. Tome la negación de ambos lados para obtener

∼( p → q) ≡ ∼(∼p ∨ q)

≡ ∼(∼p) ∧ (∼q) por las leyes de De Morgan

≡ p ∧ ∼q por la ley del doble negativo.

Otra forma más de derivar este resultado es construir tablas de verdad para (p q) y para p q y comprobar que tienen los mismos valores de verdad. (Ver ejercicio 13(b) al final de esta sección.)



Ejemplo 2.2.5 Negaciones de declaraciones si-entonces

Escribe negaciones para cada una de las siguientes afirmaciones:

Si mi coche está en el taller de reparación, entonces no puedo ir a clase.

Si Sara vive en Atenas, entonces vive en Grecia.

Solución

Mi coche está en el taller y puedo llegar a clase.

Sara vive en Atenas y no vive en Grecia. (Sara podría vivir en Atenas,



¡Precaución! Recuerde que la negación de un enunciado si-entonces no comienza con la palabra si.



Georgia; Atenas, Ohio; o Atenas, Wisconsin.) ■



Es tentador escribir la negación de un enunciado si-entonces como otro enunciado si-entonces.

¡Por favor resista esa tentación!





La contrapositiva de una declaración condicional

Una de las leyes más fundamentales de la lógica es la equivalencia entre un enunciado condicional y su contrapositivo.







El hecho es que



Se le solicita que establezca esta equivalencia en el ejercicio 26 al final de esta sección.







Ejemplo 2.2.6 Escribir el contrapositivo

Escribe cada uno de los siguientes enunciados en su forma contrapositiva equivalente:

Si Howard puede cruzar el lago nadando, entonces Howard podrá nadar hasta la isla.

Si hoy es Pascua, mañana es lunes.

Solución

Si Howard no puede nadar hasta la isla,entonces Howard no puede cruzar el lago nadando.

Si mañana no es lunes, entonces hoy no es Semana Santa. ■



Cuando intentas resolver ciertos problemas, puedes encontrar que es más fácil trabajar con la forma contrapositiva de un enunciado condicional que con el enunciado original. Reemplazar una afirmación por su contrapositivo puede darle un empujón adicional que le ayude a avanzar en su búsqueda de una solución. Esta equivalencia lógica es también la base de una de las leyes de deducción más importantes, el modus tollens (que se explicará en la sección 2.3), y del método de prueba contrapositivo (que se explicará en la sección 4.6).





Lo contrario y lo inverso de una declaración condicional

El hecho de que un enunciado condicional y su contrapositivo sean lógicamente equivalentes es muy importante y tiene una amplia aplicación. Otras dos variantes de un enunciado condicional no son lógicamente equivalentes al enunciado.









Ejemplo 2.2.7 Escribir el inverso y el inverso

Escribe el inverso y el inverso de cada una de las siguientes afirmaciones:

Si Howard puede cruzar el lago nadando, entonces Howard podrá nadar hasta la isla.

Si hoy es Pascua, mañana es lunes.

Solución

Inversa: si Howard puede nadar hasta la isla, entonces Howard puede cruzar el lago nadando.

Inversa: si Howard no puede cruzar el lago nadando, entonces Howard no puede nadar hasta la isla.

Recíprocamente: Si mañana es lunes, entonces hoy es Semana Santa.

Inversa: si hoy no es Semana Santa, mañana no es lunes. ■





¡Precaución! Mucha gente cree que si un enunciado condicional es verdadero, entonces su inverso y su inverso también deben ser verdaderos. ¡Esto no es correcto!



Tenga en cuenta que si bien la afirmación “Si hoy es Pascua, mañana es lunes” siempre es cierta, tanto su recíproco como su inverso son falsos todos los domingos excepto Pascua.













En los ejercicios 24, 25 y 27 al final de esta sección, se le pedirá que utilice tablas de verdad para verificar las afirmaciones del cuadro anterior. Tenga en cuenta que la verdad del enunciado 3 también se deriva de la observación de que el inverso de un enunciado condicional es el contrapositivo de su inverso.



Sólo si y el bicondicional

Decir “p sólo si q” significa que p puede tener lugar sólo si q también tiene lugar. Es decir, si q no ocurre, entonces p no puede ocurrir. Otra forma de decir esto es que si p ocurre, entonces q también debe ocurrir (por la equivalencia lógica entre un enunciado y su contrapositivo).











Ejemplo 2.2.8 Conversión sólo si a si-entonces

Reescribe el siguiente enunciado en forma si-entonces de dos maneras, una de las cuales es contrapositiva de la otra.

John romperá el récord mundial de carrera de una milla sólo si corre la milla en menos de cuatro minutos.

Solución Versión 1: Si John no corre la milla en menos de cuatro minutos, entonces no batirá el récord mundial.

Versión 2: Si John rompe el récord mundial, habrá corrido la milla en menos de cuatro minutos. ■





¡Precaución! "p sólo si q" no significa "p si q".



Tenga en cuenta que es posible que "p sólo si q" sea verdadero en algún momento en que "p si q" sea falso. Por ejemplo, decir que John batirá el récord mundial sólo si corre la milla en menos de cuatro minutos no significa que John romperá el récord mundial si corre la milla en menos de cuatro minutos. Su tiempo podría ser inferior a cuatro minutos, pero aún así no sería lo suficientemente rápido como para batir el récord.









El bicondicional tiene la siguiente tabla de verdad:



Tabla de verdad para p ↔ q



El orden de las operaciones es igual a . Al igual que con y, la única forma de indicar la precedencia entre ellos es utilizar paréntesis. La jerarquía completa de operaciones para los cinco operadores lógicos se encuentra en la página siguiente.









Según las definiciones separadas de si y sólo si, decir “p si, y sólo si, q” debería significar lo mismo que decir “p si q” y “p sólo si q”. La siguiente tabla de verdad anotada muestra que este es el caso:

Tabla de verdad que muestra que p ↔ q ≡ ( p → q) ∧ (q → p)



↑ ↑

p q y (p q) (q p) siempre tienen los mismos valores de verdad, por lo que son lógicamente equivalentes





Ejemplo 2.2.9 Si y sólo si

Reescribe el siguiente enunciado como una conjunción de dos enunciados si-entonces:

Este programa de computadora es correcto si, y sólo si, produce respuestas correctas para todos los conjuntos posibles de datos de entrada.

Solución Si este programa es correcto, entonces produce las respuestas correctas para todos los conjuntos posibles de datos de entrada; y si este programa produce las respuestas correctas para todos los conjuntos posibles de datos de entrada, entonces es correcto. ■



Condiciones necesarias y suficientes

Las frases condición necesaria y condición suficiente, tal como se usan en inglés formal, corresponden exactamente a sus definiciones en lógica.





En otras palabras, decir “r es una condición suficiente para s” significa que la ocurrencia de r es suficiente para garantizar la ocurrencia de s. Por otro lado, decir “r es una condición necesaria para s” significa que si r no ocurre, entonces s tampoco puede ocurrir:





La aparición de r es necesaria para obtener la aparición de s. Tenga en cuenta que debido a la equivalencia entre un enunciado y su contrapositivo,



Como consecuencia,





Ejemplo 2.2.10 Interpretación de C necesaria y suficiente condiciones

Considere la afirmación "Si John es elegible para votar, entonces tiene al menos 18 años". La veracidad de la condición “Juan es elegible para votar” es suficiente para asegurar la veracidad de la condición “Juan tiene al menos 18 años”. Además, la condición “John tiene al menos 18 años” es necesaria para que la condición “John sea elegible para votar” sea verdadera. Si John tuviera menos de 18 años, no tendría derecho a votar. ■



Ejemplo 2.2.11 Conversión de una condición suficiente a la forma Si-Entonces

Reescribe el siguiente enunciado en la forma “Si A entonces B”:

El nacimiento de Pia en suelo estadounidense es condición suficiente para que ella sea ciudadana estadounidense.

Solución Si Pia nació en suelo estadounidense, entonces es ciudadana estadounidense. ■



Ejemplo 2.2.12 Conversión de una condición necesaria a la forma Si-Entonces

Utilice el contrapositivo para reescribir el siguiente enunciado de dos maneras:

Que George cumpla 35 años es una condición necesaria para ser presidente de los Estados Unidos.

Solución Versión 1: Si George no ha cumplido 35 años, entonces no puede ser presidente de los Estados Unidos.

Versión 2: Si George puede ser presidente de los Estados Unidos, entonces habrá cumplido 35 años. ■





Observaciones

En lógica, no es necesario que una hipótesis y una conclusión tengan temas relacionados. En el habla ordinaria nunca decimos cosas como “Si las computadoras son máquinas, entonces Babe Ruth era un jugador de béisbol” o “Si 2 2 5, entonces Mickey Mouse es el presidente de los Estados Unidos”. Formulamos una oración como “Si p entonces q” sólo si hay alguna

conexión de contenido entre p y q.

En lógica, sin embargo, las dos partes de un enunciado condicional no necesitan tener significados relacionados. ¿La razón? Si existiera tal requisito, ¿quién lo haría cumplir? Lo que una persona percibe como dos cláusulas no relacionadas pueden parecerlo para otra persona. Tendría que haber un árbitro central para verificar cada oración condicional antes de que alguien pudiera usarla, para asegurarse de que sus cláusulas estuvieran en la relación adecuada. ¡Esto no es práctico, por decir lo menos!





Así, una afirmación como “si las computadoras son máquinas, entonces Babe Ruth era un jugador de béisbol” está permitida, e incluso se la considera verdadera porque tanto su hipótesis como su conclusión son verdaderas. De manera similar, la afirmación “Si 2 2 5, entonces Mickey Mouse es presidente de los Estados Unidos” está permitida y se considera verdadera porque su hipótesis es falsa, aunque hacerlo pueda parecer ridículo.

En matemáticas sucede a menudo que una definición cuidadosamente formulada que cubre con éxito las situaciones para las que fue pensada principalmente, luego se ve satisfecha por algunos casos extremos que el formulador no tenía en mente. Pero esas son las rupturas, y es importante adquirir el hábito de explorar plenamente las definiciones para buscar y comprender todos sus casos, incluso los inusuales.

En el lenguaje informal, los condicionales simples se utilizan a menudo para referirse a bicondicionales.

El enunciado formal “p si, y sólo si, q” rara vez se utiliza en el lenguaje corriente. Con frecuencia, cuando la gente intenta utilizar el bicondicional, omiten el y sólo si o el si y. Es decir, dicen "p si q" o "p sólo si q" cuando en realidad quieren decir "p si, y sólo si, q". Por ejemplo, considere la afirmación "Recibirás postre si, y sólo si, cenas". Lógicamente, esto equivale a la conjunción de las dos afirmaciones siguientes.

Declaración 1: Si cenas, recibirás postre.

Declaración 2: Recibirás postre solo si cenas. o

Si no cenas, no recibirás postre.

Ahora bien, ¿cuántos padres en la historia del mundo han dicho a sus hijos: “Recibirás postre si, y sólo si, cenas”? ¡No muchos! La mayoría dice: “Si cenas, recibirás postre” (estos adoptan el enfoque positivo: enfatizan la recompensa) o “Recibirás postre sólo si cenas” (estos adoptan el enfoque negativo: enfatizan la recompensa). castigo). Sin embargo, los padres que prometen la recompensa tienen la intención de sugerir también el castigo, y aquellos que amenazan con el castigo ciertamente darán la recompensa si se la merecen. Ambos grupos de padres esperan que sus declaraciones condicionales sean interpretadas como bicondicionales.

Dado que a menudo interpretamos (correctamente) los enunciados condicionales como bicondicionales, no es sorprendente que lleguemos a creer (erróneamente) que los enunciados condicionales siempre son lógicamente equivalentes a sus inversos y conversos. Sin embargo, en entornos formales las declaraciones deben tener interpretaciones inequívocas. Las declaraciones si-entonces a veces no pueden significar "si-entonces" y otras veces significan "si y sólo si". Cuando se utiliza el lenguaje en matemáticas, ciencias u otras situaciones donde la precisión es importante, es esencial interpretar los enunciados si-entonces de acuerdo con la definición formal y no confundirlos con sus inversos e inversos.









Pruébate

Un enunciado si-entonces es falso si, y sólo si, la hipótesis es

  y la conclusión es.

La negación de “si p entonces q” es.

Lo contrario de “si p entonces q” es.

El contrapositivo o f “si p entonces q” es .

El inverso de “si p entonces q” es.







Un enunciado condicional y su contrapositivo son.

Una declaración condicional y su recíproca no lo son.

“R es una condición suficiente para S” significa “si entonces”.

“R es una condición necesaria para S” significa “si entonces

  .”

"R sólo si S" significa "si entonces".







Conjunto de ejercicios 2.2

Reescribe las afirmaciones del 1 al 4 en forma si-entonces.

Este bucle se repetirá exactamente N veces si no contiene una parada o un acceso.

Llego a tiempo al trabajo si tomo el autobús de las 8:05.

Quédate quieto o dispararé.

Arregla mi techo o no pagaré el alquiler.

Construya tablas de verdad para las formas de enunciado de 5–11.

5. ∼p ∨ q → ∼q 6. (p ∨ q) ∨ (∼p ∧ q) → q

7. p ∧ ∼q → r 8. ∼p ∨ q → r

9. p ∧ ∼r ↔ q ∨ r 10. (p → r) ↔ (q → r)

11. ( p → (q → r)) ↔ (( p ∧ q) → r)

Utilice la equivalencia lógica establecida en el ejemplo 2.2.3, p q r ( p r) (q r), para reescribir el siguiente enunciado. (Supongamos que x representa un número real fijo.)

Si x > 2 o x < −2, entonces x 2 > 4.

Utilice tablas de verdad para verificar las siguientes equivalencias lógicas. Incluye algunas palabras de explicación con tus respuestas.

a. p → q ≡ ∼p ∨ q segundo. ∼( p → q) ≡ p ∧ ∼q.

H 14. a. Demuestre que las siguientes formas de enunciado son todas lógicamente equivalentes.

p → q ∨ r, p ∧ ∼q → r, y p ∧ ∼r → q

b. Utilice las equivalencias lógicas establecidas en el inciso (a) para reescribir la siguiente oración de dos maneras diferentes. (Supongamos que n representa un número entero fijo.)

Si n es primo, entonces n es impar o n es 2.



Determine si las siguientes formas de enunciado son lógicamente equivalentes:

p → (q → r) y (p → q) → r

En 16 y 17, escribe cada una de las dos afirmaciones en forma simbólica y determina si son lógicamente equivalentes. Incluya una tabla de verdad y algunas palabras de explicación.

Si pagó el precio completo, no lo compró en Crown Books. No lo compraste en Crown Books o pagaste el precio completo.

Si 2 es factor de n y 3 es factor de n, entonces 6 es factor de n. 2 no es un factor de n o 3 no es un factor de n o 6 es un factor de n.

Escriba cada una de las siguientes tres afirmaciones en forma simbólica y determine qué pares son lógicamente equivalentes. Incluya tablas de verdad y algunas palabras de explicación.











Si camina como pato y habla como pato, entonces es pato.

O no camina como un pato o no habla como un pato, o es un pato.

Si no camina como un pato y no habla como un pato, entonces no es un pato.

¿Verdadero o falso? La negación de “Si Sue es la madre de Luiz, entonces Ali es su prima” es “Si Sue es la madre de Luiz, entonces Ali no es su prima”.

Escribe negaciones para cada una de las siguientes afirmaciones. (Supongamos que todas las variables representan cantidades o entidades fijas, según corresponda.)

Si P es un cuadrado, entonces P es un rectángulo.

Si hoy es Nochevieja, mañana es enero.

Si la expansión decimal de r es terminante, entonces r es racional.

Si n es primo, entonces n es impar o n es 2.

Si x no es negativo, entonces x es positivo o x es 0.

Si Tom es el padre de Ann, entonces Jim es su tío y Sue es su tía.

Si n es divisible por 6, entonces n es divisible por 2 y n es divisible por 3.

Supongamos que p y q son enunciados de modo que p q es falso. Encuentre los valores de verdad de cada uno de los siguientes:

∼p → q b. pag ∨ q c. q → pag

H 22. Escribe contrapositivos para los enunciados del ejercicio 20.

H 23. Escribe el inverso y el inverso para cada enunciado del ejercicio 20.

Utilice tablas de verdad para establecer la verdad de cada afirmación de 24–27.

Un enunciado condicional no es lógicamente equivalente a su inverso.

Un enunciado condicional no es lógicamente equivalente a su inverso.

Un enunciado condicional y su contrapositivo son lógicamente equivalentes entre sí.

El inverso y el inverso de un enunciado condicional son lógicamente equivalentes entre sí.

H 28. “¿Quieres decir que crees que puedes encontrar la respuesta?” dijo la Liebre de Marzo.

“Exactamente”, dijo Alicia.

"Entonces deberías decir lo que quieres decir", continuó la Liebre de Marzo.

“Sí”, respondió Alice apresuradamente; "Al menos... al menos quiero decir lo que digo... eso es lo mismo, ¿sabes?"







“¡No es ni un poco lo mismo!” dijo el Sombrerero. "¡Vaya, también podrías decir que 'veo lo que como' es lo mismo que 'como lo que veo'!"

—de “A Mad Tea-Party” en Alicia en el país de las maravillas,

por Lewis Carroll

El Sombrerero tiene razón. "Digo lo que quiero decir" no es lo mismo que "digo lo que digo". Reescribe cada una de estas dos oraciones en forma si-entonces y explica la relación lógica entre ellas. (Se hace referencia a este ejercicio en la introducción del Capítulo 4.)

Si las formas de enunciado P y Q son lógicamente equivalentes, entonces P Q es una tautología. Por el contrario, si P Q es una tautología, entonces P y Q son lógicamente equivalentes. Úselo para convertir cada una de las equivalencias lógicas de 29 a 31 en una tautología. Luego use una tabla de verdad para verificar cada tautología.

29. p → (q ∨ r) ≡ (p ∧ ∼q) → r

30. p ∧ (q ∨ r) ≡ ( p ∧ q) ∨ ( p ∧ r)

31. p → (q → r) ≡ (p ∧ q) → r

Reescribe cada uno de los enunciados en 32 y 33 como una conjunción de dos enunciados si-entonces.

Esta ecuación cuadrática tiene dos raíces reales distintas si, y sólo si su discriminante es mayor que cero.

Este número entero es par si, y sólo si, es igual al doble de algún número entero.

Reescribe los enunciados en 34 y 35 en forma si-entonces de dos maneras, una de las cuales es contrapositiva de la otra.

Los Cachorros ganarán el banderín sólo si ganan el partido de mañana.

A Sam sólo se le permitirá subir al barco de carreras de Signe si es un marinero experto.

Teniendo una visión a largo plazo de tu educación, vas a Prestige Corporation y preguntas qué deberías hacer en la universidad para que te contraten cuando te gradúes. El director de personal responde que solo lo contratarán si se especializa en matemáticas o informática, obtiene un promedio de B o mejor y estudia contabilidad. De hecho, te especializas en matemáticas, obtienes un promedio de B+ y estudias contabilidad. Usted regresa a Prestige Corporation, hace una solicitud formal y es rechazado. ¿Le mintió el director de personal?

Algunos lenguajes de programación usan declaraciones de la forma "r a menos que sn" para significar que mientras s no suceda, entonces r sucederá. Más formalmente:





En 37–39, reescribe los enunciados en forma si-entonces.

El pago se hará el día cinco a menos que se conceda una nueva audiencia.



Ann irá a menos que llueva.

Esta puerta no se abrirá a menos que se ingrese un código de seguridad.



Reescribe los enunciados en 40 y 41 en forma si-entonces.

Tomar el autobús de las 8:05 es condición suficiente para llegar a tiempo al trabajo.

Tener dos ángulos de 45° es condición suficiente para que este triángulo sea rectángulo.

Utilice el contrapositivo para reescribir los enunciados de 42 y 43 en forma si-entonces de dos maneras.

Ser divisible por 3 es condición necesaria para que este número sea divisible por 9.

Hacer los deberes con regularidad es una condición necesaria para que Jim apruebe la asignatura.

Tenga en cuenta que “una condición suficiente para s es r” significa que r es una condición suficiente para s y que “una condición necesaria para s es r” significa que r es una condición necesaria para s. Reescribe los enunciados en 44 y 45 en forma si-entonces.

Una condición suficiente para que el equipo de Jon gane el campeonato es que gane el resto de sus juegos.

Una condición necesaria para que este programa informático sea correcto es que no produzca mensajes de error durante la traducción.

"Si el compuesto X está hirviendo, entonces su temperatura debe ser de al menos 150°C". Suponiendo que esta afirmación es cierta, ¿cuál de las siguientes afirmaciones también debe ser cierta?

Si la temperatura del compuesto X es al menos 150 ◦C, entonces el compuesto X está en ebullición.

Si la temperatura del compuesto X es inferior a 150 ◦ C,

entonces el compuesto X no está hirviendo.

El compuesto X hervirá sólo si su temperatura es de al menos 150 ◦ C.

Si el compuesto X no hierve, entonces su temperatura es menor

de 150 ◦C.

Una condición necesaria para que el compuesto X hierva es que su temperatura sea de al menos 150°C.

Una condición suficiente para que el compuesto X hierva es que su

La temperatura debe ser de al menos 150 ◦ C.

En 47–50 (a), use las equivalencias lógicas p → q ≡∼p ∨ q y p ↔ q ≡ (∼p ∨ q) ∧ (∼q ∨ p) para reescribir las formas de enunciado dadas sin usar el símbolo → o ↔ , y (b) use la equivalencia lógica p ∨ q ≡∼(∼p∧ ∼q) para reescribir cada forma de enunciado usando solo ∧ y ∼.

47. p ∧ ∼q → r 48. p ∨ ∼q → r ∨ q

49. (p → r) ↔ (q → r)

50. ( p → (q → r)) ↔ (( p ∧ q) → r)

Dada cualquier forma de enunciado, ¿es posible encontrar una forma lógicamente equivalente que utilice sólo y ? Justifica tu respuesta.







Respuestas para Ponte a prueba

verdadero; falso 2. p∧ ∼q 3. si q entonces p 4. si ∼q entonces ∼p 5. si ∼p entonces ∼q 6. lógicamente equivalente 7. lógicamente equivalente 8. R; S9.S; R 10. R; S







“Por el contrario”, continuó Tweedledee, “si fuera así, podría ser; y si así fuera, así sería; pero como no lo es, no lo es. Eso es lógico”. — Lewis Carroll, A través del espejo

En matemáticas y lógica, un argumento no es una disputa. Es una secuencia de afirmaciones que terminan en una conclusión. En esta sección mostramos cómo determinar si un argumento es válido, es decir, si la conclusión se sigue necesariamente de las afirmaciones anteriores. Mostraremos que esta determinación depende sólo de la forma de un argumento, no de su contenido.

En la sección 2.1 se demostró que la forma lógica de un argumento puede abstraerse de su contenido. Por ejemplo, el argumento

Si Sócrates es un hombre, entonces Sócrates es mortal. Sócrates es un hombre.

∴ Sócrates es mortal.

tiene la forma abstracta

Si p entonces q p

∴q

Al considerar la forma abstracta de un argumento, piense en p y q como variables que pueden sustituirse por enunciados. Una forma de argumento se considera válida si, y sólo si, siempre que se sustituyen enunciados que hacen que todas las premisas sean verdaderas, la conclusión también es verdadera.





El hecho crucial acerca de un argumento válido es que la verdad de su conclusión se sigue necesaria o ineludiblemente o sólo por forma lógica de la verdad de sus premisas. Es imposible tener un argumento válido con premisas verdaderas y una conclusión falsa. Cuando un argumento es válido y sus premisas son verdaderas, se dice que la verdad de la conclusión se infiere o deduce de la verdad de las premisas. Si una conclusión "no es necesariamente así", entonces no es una deducción válida.











Desarrollamos la capacidad de pensar de forma abstracta. Esto significa aprender a utilizar formas de argumentación lógicamente válidas y evitar errores lógicos comunes, apreciar lo que significa razonar a partir de definiciones, saber cómo utilizar métodos directos e indirectos.



xiv





argumento para derivar nuevos resultados a partir de aquellos que ya se sabe que son verdaderos, y poder trabajar con representaciones simbólicas como si fueran objetos concretos.



Inducción y recursividad Un desarrollo apasionante de los últimos años ha sido el creciente aprecio por el poder y la belleza del “pensamiento recursivo”. Pensar recursivamente significa abordar un problema asumiendo que problemas similares de menor naturaleza ya han sido resueltos y descubriendo cómo juntar esas soluciones para resolver el problema mayor. Este tipo de pensamiento se utiliza ampliamente en el análisis de algoritmos, donde las relaciones de recurrencia que resultan del pensamiento recursivo a menudo dan lugar a fórmulas que se verifican mediante inducción matemática.



Estructuras discretas Las estructuras matemáticas discretas son estructuras abstractas que describen, categorizan y revelan las relaciones subyacentes entre objetos matemáticos discretos. Los que se estudian en este libro son los conjuntos de números enteros y racionales, conjuntos generales, álgebras booleanas, funciones, relaciones, gráficos y árboles, lenguajes formales y expresiones regulares, y autómatas de estados finitos.



Combinatoria y probabilidad discreta La combinatoria es la matemática de contar y organizar objetos, y la probabilidad es el estudio de las leyes relativas a la medición de eventos aleatorios o fortuitos. La probabilidad discreta se centra en situaciones que involucran conjuntos discretos de objetos, como encontrar la probabilidad de obtener una cierta cantidad de caras cuando se lanza una moneda imparcial una cierta cantidad de veces. Se necesita habilidad en el uso de la combinatoria y la probabilidad en casi todas las disciplinas donde se aplican las matemáticas, desde la economía hasta la biología, la informática, la química y la física y la gestión empresarial.



Algoritmos y su análisis La palabra algoritmo era en gran medida desconocida a mediados del siglo XX, pero ahora es una de las primeras palabras que se encuentran en el estudio de la informática. Para resolver un problema en una computadora, es necesario encontrar un algoritmo o una secuencia paso a paso de instrucciones que la computadora debe seguir. Diseñar un algoritmo requiere una comprensión de las matemáticas subyacentes al problema a resolver. Determinar si un algoritmo es correcto o no requiere un uso sofisticado de la inducción matemática. Calcular la cantidad de tiempo o espacio de memoria que necesitará el algoritmo para compararlo con otros algoritmos que producen el mismo resultado requiere conocimientos de combinatoria, relaciones de recurrencia, funciones y O-, ▲- y

①-notaciones.



Aplicaciones y modelado Los temas matemáticos se comprenden mejor cuando se ven en una variedad de contextos y se utilizan para resolver problemas en una amplia gama de situaciones aplicadas. Una de las lecciones profundas de las matemáticas es que el mismo modelo matemático puede usarse para resolver problemas en situaciones que superficialmente parecen totalmente diferentes. El objetivo de este libro es mostrar a los estudiantes la extraordinaria utilidad práctica de algunas ideas matemáticas muy abstractas.



Características especiales de este libro

Razonamiento matemático La característica que más distingue a este libro de otros textos de matemáticas discretas es que enseña (explícitamente pero de una manera accesible a estudiantes universitarios de primer y segundo año) la lógica y el razonamiento tácitos que subyacen al pensamiento matemático. Durante muchos años impartí un curso intensivo e interactivo de transición a las matemáticas abstractas para estudiantes de matemáticas e informática. Esta experiencia me mostró que si bien es posible enseñar a la mayoría de los estudiantes a











xvi Prefacio

relaciones de lencia en las Secciones 8.2 y 8.3. Este enfoque incorpora una revisión útil y desarrolla la madurez matemática en etapas naturales.



Apoyo a los estudiantes Los estudiantes de colegios y universidades inevitablemente tienen que aprender mucho por sí mismos. Aunque a menudo resulta frustrante, aprender a aprender mediante el autoestudio es un paso crucial hacia el éxito final en una carrera profesional. Este libro tiene una serie de características para facilitar la transición de los estudiantes al aprendizaje independiente.

Ejemplos resueltos

El libro contiene más de 500 ejemplos resueltos, escritos en un formato de solución de problemas y adaptados en tipografía y dificultad a los ejercicios. Muchas soluciones para los problemas de prueba se desarrollan en dos etapas: primero una discusión sobre cómo se podría llegar a pensar en la prueba o refutación y luego un resumen de la solución, que se incluye en un recuadro. Este formato permite a los estudiantes leer el problema y pasar inmediatamente al resumen, si lo desean, y solo regresar a la discusión si tienen problemas para entender el resumen. El formato también ahorra tiempo a los estudiantes que releen el texto como preparación para un examen.

Notas marginales y preguntas para ponerse a prueba

En los márgenes de todo el libro se incluyen notas sobre temas de particular importancia y comentarios de advertencia para ayudar a los estudiantes a evitar errores comunes. Entre el texto y los ejercicios se encuentran preguntas diseñadas para centrar la atención en las ideas principales de cada sección. Por conveniencia, las preguntas utilizan un formato de completar espacios en blanco y las respuestas se encuentran inmediatamente después de los ejercicios.

Ejercicios

El libro contiene casi 2600 ejercicios. Los conjuntos al final de cada sección han sido diseñados para que estudiantes con antecedentes y niveles de habilidad muy diferentes encuentren algunos ejercicios que pueden estar seguros de realizar con éxito y también algunos ejercicios que los desafiarán.

Soluciones para ejercicios

Para proporcionar una retroalimentación adecuada a los estudiantes entre sesiones de clase, el Apéndice B contiene una gran cantidad de soluciones completas a los ejercicios. Se recomienda encarecidamente a los estudiantes que no consulten las soluciones hasta que hayan hecho todo lo posible para responder las preguntas por sí mismos. Sin embargo, una vez que lo hayan hecho, comparar sus respuestas con las dadas puede conducir a una comprensión significativamente mejor. Además, muchos problemas, incluidos algunos de los más desafiantes, tienen soluciones parciales o sugerencias para que los estudiantes puedan determinar si están en el camino correcto y hacer ajustes si es necesario.





También hay muchos ejercicios sin solución para ayudar a los estudiantes a aprender a resolver problemas matemáticos en un entorno realista.

Funciones de referencia

Muchos estudiantes me han escrito para decirme que el libro les ayudó a tener éxito en sus cursos avanzados. Uno incluso escribió que había usado tanto una edición que se había desmoronado, y de hecho salió y compró una copia de la siguiente edición, que seguía usando en un programa de maestría. Se incluyen figuras y tablas cuando hacerlo ayudaría a los lectores a una mejor comprensión. En la mayoría, se utiliza un segundo color para resaltar el significado. Mi razón fundamental para seleccionar enunciados de definiciones y teoremas, poner títulos a los ejercicios y dar los significados de los símbolos y una lista de fórmulas de referencia en las guardas es facilitar a los estudiantes el uso de este libro para su revisión en un curso actual y como referencia en otros posteriores.



Apoyo al instructor He recibido una gran cantidad de comentarios valiosos de instructores que han utilizado ediciones anteriores de este libro. Muchos aspectos del libro se han mejorado gracias a sus sugerencias. Además de los siguientes elementos, hay apoyo adicional para el instructor en el sitio web del libro, que se describe más adelante en el prefacio.

Ejercicios

La gran variedad de ejercicios en todos los niveles de dificultad permite a los instructores una gran libertad para adaptar un curso a las habilidades de sus estudiantes. Los ejercicios con soluciones al final del libro tienen números en azul, y aquellos cuyas soluciones se dan en un Manual de soluciones para estudiantes y una Guía de estudio por separado tienen números que son múltiplos de tres. Hay ejercicios de todo tipo representados en este libro que no tienen respuesta en ninguno de los lugares para permitir a los instructores asignar cualquier combinación que prefieran de ejercicios con y sin respuestas. El amplio número de ejercicios de todo tipo ofrece a los profesores una importante variedad de problemas para utilizar en tareas de revisión y exámenes. Se invita a los instructores a utilizar los numerosos ejercicios planteados como preguntas en lugar de en forma de “demostrar que” para estimular la discusión en clase sobre el papel de la prueba y el contraejemplo en la resolución de problemas.

Secciones flexibles

La mayoría de las secciones se dividen en subsecciones para que un instructor que tenga poco tiempo pueda optar por cubrir ciertas subsecciones solo y omitir el resto o dejarlas para que los estudiantes las estudien por su cuenta. La división en subsecciones también facilita a los instructores dividir las secciones si desean dedicar más de un día a ellas.

comprender y construir argumentos matemáticos sencillos, los obstáculos para hacerlo no pueden pasarse por alto a la ligera. Para tener éxito, un texto para un curso de este tipo debe abordar las dificultades de los estudiantes con la lógica y el lenguaje directamente y con cierta extensión. También debe incluir suficientes ejemplos y ejercicios concretos para permitir a los estudiantes desarrollar los modelos mentales necesarios para conceptualizar problemas más abstractos. El tratamiento de la lógica y la prueba en este libro combina sentido común y rigor de una manera que explica lo esencial, pero evita sobrecargar a los estudiantes con detalles formales.



Enfoque en espiral para el desarrollo de conceptos Varios conceptos de este libro aparecen en formas cada vez más sofisticadas en capítulos sucesivos para ayudar a los estudiantes a desarrollar la capacidad de abordar eficazmente niveles crecientes de abstracción. Por ejemplo, cuando los estudiantes encuentran las matemáticas relativamente avanzadas del pequeño teorema de Fermat en la Sección 8.4, ya se les ha introducido la lógica del discurso matemático en los Capítulos 1, 2 y 3, han aprendido los métodos básicos de demostración y los conceptos de mod. y div en el Capítulo 4, exploré mod y div como funciones en el Capítulo 7 y me familiaricé con equiva

Examen

relaciones de lencia en las Secciones 8.2 y 8.3. Este enfoque incorpora una revisión útil y desarrolla la madurez matemática en etapas naturales.



Apoyo a los estudiantes Los estudiantes de colegios y universidades inevitablemente tienen que aprender mucho por sí mismos. Aunque a menudo resulta frustrante, aprender a aprender mediante el autoestudio es un paso crucial hacia el éxito final en una carrera profesional. Este libro tiene una serie de características para facilitar la transición de los estudiantes al aprendizaje independiente.

Ejemplos resueltos

El libro contiene más de 500 ejemplos resueltos, escritos en un formato de solución de problemas y adaptados en tipografía y dificultad a los ejercicios. Muchas soluciones para los problemas de prueba se desarrollan en dos etapas: primero una discusión sobre cómo se podría llegar a pensar en la prueba o refutación y luego un resumen de la solución, que se incluye en un recuadro. Este formato permite a los estudiantes leer el problema y pasar inmediatamente al resumen, si lo desean, y solo regresar a la discusión si tienen problemas para entender el resumen. El formato también ahorra tiempo a los estudiantes que releen el texto como preparación para un examen.

Notas marginales y preguntas para ponerse a prueba

En los márgenes de todo el libro se incluyen notas sobre temas de particular importancia y comentarios de advertencia para ayudar a los estudiantes a evitar errores comunes. Entre el texto y los ejercicios se encuentran preguntas diseñadas para centrar la atención en las ideas principales de cada sección. Por conveniencia, las preguntas utilizan un formato de completar espacios en blanco y las respuestas se encuentran inmediatamente después de los ejercicios.

Ejercicios

El libro contiene casi 2600 ejercicios. Los conjuntos al final de cada sección han sido diseñados para que estudiantes con antecedentes y niveles de habilidad muy diferentes encuentren algunos ejercicios que pueden estar seguros de realizar con éxito y también algunos ejercicios que los desafiarán.

Soluciones para ejercicios

Para proporcionar una retroalimentación adecuada a los estudiantes entre sesiones de clase, el Apéndice B contiene una gran cantidad de soluciones completas a los ejercicios. Se recomienda encarecidamente a los estudiantes que no consulten las soluciones hasta que hayan hecho todo lo posible para responder las preguntas por sí mismos. Sin embargo, una vez que lo hayan hecho, comparar sus respuestas con las dadas puede conducir a una comprensión significativamente mejor. Además, muchos problemas, incluidos algunos de los más desafiantes, tienen soluciones parciales o sugerencias para que los estudiantes puedan determinar si están en el camino correcto y hacer ajustes si es necesario.





También hay muchos ejercicios sin solución para ayudar a los estudiantes a aprender a resolver problemas matemáticos en un entorno realista.

Funciones de referencia

Muchos estudiantes me han escrito para decirme que el libro les ayudó a tener éxito en sus cursos avanzados. Uno incluso escribió que había usado tanto una edición que se había desmoronado, y de hecho salió y compró una copia de la siguiente edición, que seguía usando en un programa de maestría. Se incluyen figuras y tablas cuando hacerlo ayudaría a los lectores a una mejor comprensión. En la mayoría, se utiliza un segundo color para resaltar el significado. Mi razón fundamental para seleccionar enunciados de definiciones y teoremas, poner títulos a los ejercicios y dar los significados de los símbolos y una lista de fórmulas de referencia en las guardas es facilitar a los estudiantes el uso de este libro para su revisión en un curso actual y como referencia en otros posteriores.



Apoyo al instructor He recibido una gran cantidad de comentarios valiosos de instructores que han utilizado ediciones anteriores de este libro. Muchos aspectos del libro se han mejorado gracias a sus sugerencias. Además de los siguientes elementos, hay apoyo adicional para el instructor en el sitio web del libro, que se describe más adelante en el prefacio.

Ejercicios

La gran variedad de ejercicios en todos los niveles de dificultad permite a los instructores una gran libertad para adaptar un curso a las habilidades de sus estudiantes. Los ejercicios con soluciones al final del libro tienen números en azul, y aquellos cuyas soluciones se dan en un Manual de soluciones para estudiantes y una Guía de estudio por separado tienen números que son múltiplos de tres. Hay ejercicios de todo tipo representados en este libro que no tienen respuesta en ninguno de los lugares para permitir a los instructores asignar cualquier combinación que prefieran de ejercicios con y sin respuestas. El amplio número de ejercicios de todo tipo ofrece a los profesores una importante variedad de problemas para utilizar en tareas de revisión y exámenes. Se invita a los instructores a utilizar los numerosos ejercicios planteados como preguntas en lugar de en forma de “demostrar que” para estimular la discusión en clase sobre el papel de la prueba y el contraejemplo en la resolución de problemas.

Secciones flexibles

La mayoría de las secciones se dividen en subsecciones para que un instructor que tenga poco tiempo pueda optar por cubrir ciertas subsecciones solo y omitir el resto o dejarlas para que los estudiantes las estudien por su cuenta. La división en subsecciones también facilita a los instructores dividir las secciones si desean dedicar más de un día a ellas.



.

Presentación de métodos de prueba.

Es inevitable que las pruebas y refutaciones de este libro parezcan fáciles a los profesores. Sin embargo, a muchos estudiantes les resultan difíciles. Al mostrar a los estudiantes cómo descubrir y construir pruebas y refutaciones, he tratado de describir los tipos de enfoques que utilizan los matemáticos cuando enfrentan problemas desafiantes en su propia investigación.

Soluciones para instructores

Soluciones completas para instructores para todos los ejercicios están disponibles para cualquiera que imparta un curso de este libro a través del servicio Solution Builder de Cengage. Los instructores pueden registrarse para acceder en



Lo más destacado de la cuarta edición

Los cambios realizados para esta edición se basan en sugerencias de colegas y otros usuarios veteranos de ediciones anteriores, en interacciones continuas con mis alumnos y en desarrollos dentro de los campos en evolución de la informática y las matemáticas.







Reorganización

Un nuevo Capítulo 1 presenta a los estudiantes parte del lenguaje preciso que es la base de gran parte del pensamiento matemático: el lenguaje de variables, conjuntos, relaciones y funciones. En respuesta a las solicitudes de algunos instructores, el material básico ahora se agrupa en los capítulos 1 a 8, y el capítulo sobre recursividad se une al capítulo sobre inducción. Los capítulos 9 a 12 se colocaron juntos al final porque, aunque muchos instructores cubren uno o más de ellos, existe una diversidad considerable en sus opciones, y algunos de los temas de estos capítulos se incluyen en otros cursos.

Pedagogía mejorada

El número de ejercicios se ha incrementado a casi 2600. Se han añadido aproximadamente 300 ejercicios nuevos.

Se agregaron ejercicios para temas en los que los estudiantes parecían necesitar práctica adicional y se modificaron, según fue necesario, para abordar las dificultades de los estudiantes.

Se han incorporado respuestas completas adicionales en el Apéndice B para brindar a los estudiantes más ayuda en temas difíciles.

La exposición ha sido reexaminada en su totalidad y revisada cuando fue necesario.

Se ha ampliado la discusión sobre los antecedentes históricos y los resultados recientes y se ha aumentado el número de fotografías de matemáticos e informáticos cuyas contribuciones se analizan en el libro.

Lógica y teoría de conjuntos

Ahora se incluye la definición de argumento sólido y se aclara adicionalmente la diferencia entre un argumento válido y una conclusión verdadera.

Se han agregado ejemplos y ejercicios sobre el seguimiento de cuantificadores.

Se han incorporado definiciones para uniones e intersecciones infinitas.

Introducción a la prueba

Se han ampliado las instrucciones para redactar pruebas y la discusión de errores comunes.

Las descripciones de los métodos de prueba se han hecho más claras.

Los ejercicios han sido revisados y/o reubicados para promover el desarrollo de la comprensión de los estudiantes.

Inducción y recursividad

Se ha mejorado el formato para esquematizar demostraciones por inducción matemática.

Se han reorganizado los subapartados del apartado de secuencias.

Se han ampliado los conjuntos de ejercicios para las secciones sobre inducción matemática fuerte y el principio de buen ordenamiento y sobre definiciones recursivas.

Se ha prestado mayor atención a la inducción estructural.

Teoría de los números

Se ha ampliado una subsección sobre problemas abiertos en teoría de números e incluye una discusión adicional sobre descubrimientos matemáticos recientes en teoría de números.

Se ha simplificado la presentación en la sección de aritmética modular y criptografía.

Se ha aclarado la discusión sobre las pruebas de primalidad.





Combinatoria y probabilidad discreta

La discusión sobre el principio del casillero se ha trasladado a este capítulo.

Funciones

Hay una mayor cobertura de funciones de más de una variable y de funciones que actúan sobre conjuntos.

Teoría de grafos

Se ha actualizado la terminología sobre viajar en un gráfico.

Ahora se incluye el algoritmo de ruta más corta de Dijkstra.

Se agregaron ejercicios para presentar a los estudiantes la coloración de gráficos.



Sitio web complementario



Se ha desarrollado un sitio web para este libro que contiene información y materiales tanto para estudiantes como para profesores. Incluye:

descripciones y enlaces a muchos sitios en Internet con información accesible sobre temas matemáticos discretos,

enlaces a applets que ilustran o proporcionan práctica en los conceptos de matemáticas discretas,

ejemplos y ejercicios adicionales con soluciones,

Guías de revisión de los capítulos del libro. Una sección especial para instructores contiene:

sugerencias sobre cómo abordar el material de cada capítulo,

soluciones para todos los ejercicios no completamente resueltos en el Apéndice B,

ideas para proyectos y tareas de escritura,

Diapositivas de powerpoint,

hojas de repaso y ejercicios adicionales para pruebas y exámenes.



Manual de soluciones para estudiantes y guía de estudio

(ISBN-10: 0-495-82613-8; ISBN-13: 978-0-495-82613-2)

Al escribir este libro, me esforcé por brindar suficiente ayuda a los estudiantes a través de la exposición del texto, los ejemplos resueltos y las soluciones de los ejercicios, de modo que el libro en sí proporcionara todo lo que un estudiante necesitaría para dominar con éxito el material del curso. . Creo que los estudiantes que terminan la s



estudio de este libro con la capacidad de resolver, por sí solos, todos los ejercicios con soluciones completas del Apéndice B habrán desarrollado un excelente dominio de la materia. No obstante, me di cuenta de que algunos estudiantes querían tener la oportunidad de obtener materiales útiles adicionales. En respuesta, desarrollé un Manual de soluciones para estudiantes y una Guía de estudio, disponibles por separado de este libro, que contiene soluciones completas para cada ejercicio que no está completamente respondido en el Apéndice B y cuyo número es divisible por 3. La guía también incluye explicaciones alternativas para algunos de los conceptos y preguntas de repaso para cada capítulo.





Organización

Este libro se puede utilizar eficazmente para un curso de uno o dos semestres. Los capítulos contienen secciones principales, secciones que cubren material matemático opcional y secciones que cubren aplicaciones opcionales. Los instructores tienen la flexibilidad de elegir la combinación que mejor satisfaga las necesidades de sus alumnos. La siguiente tabla muestra una división de las secciones en categorías.





El siguiente diagrama de árbol muestra, aproximadamente, cómo dependen unos de otros los capítulos de este libro. Los capítulos sobre diferentes ramas del árbol son lo suficientemente independientes como para que los instructores necesiten hacer como máximo ajustes menores si se saltan capítulos pero siguen caminos a lo largo de las ramas del árbol.

En la mayoría de los casos, cubrir sólo las secciones centrales de los capítulos es una preparación adecuada para descender en el árbol.



∗La Sección 8.3 es necesaria para la Sección 12.3 pero no para las Secciones 12.1 y 12.2.





Expresiones de gratitud

Tengo una deuda de gratitud con muchas personas de la Universidad DePaul por su apoyo y aliento a lo largo de los años que trabajé en las ediciones de este libro. Varios de mis colegas utilizaron versiones anteriores y ediciones anteriores y proporcionaron muchas sugerencias excelentes para mejorar. Por esto, agradezco a Louis Aquila, J. Marshall Ash, Allan Berele, Jeffrey Bergen, William Chin, Barbara Cortzen, Constantine Georgakis, Sigrun Goes, Jerry Goldman, Lawrence Gluck, Leonid Krop, Carolyn Narasimhan, Walter Pranger, Eric Rieders, Ayse Sahin, Yuen-Fat Wong y, muy especialmente, Jeanne LaDuke. Los miles de estudiantes a quienes he enseñado matemáticas discretas han tenido una profunda influencia en la forma del libro. Al compartir conmigo sus pensamientos y procesos de pensamiento, me enseñaron cómo enseñarles mejor. Estoy muy agradecido por su ayuda. Debo a la administración de la Universidad DePaul, especialmente a mi decano, Charles Suchar, y a mis ex decanos, Michael Mezey y Richard Meister, unas palabras especiales de agradecimiento por considerar la escritura de este libro como un esfuerzo académico que vale la pena.

Mi agradecimiento a los revisores por sus valiosas sugerencias para esta edición del libro: David Addis, Texas Christian University; Rachel Esselstein, Universidad Estatal de California-Bahía de Monterrey; William Marion, Universidad de Valparaíso; Michael McClendon, Universidad de Oklahoma Central; y Steven Miller, Universidad de Brown. Por su ayuda con las ediciones anteriores del libro, agradezco a Itshak Borosh, Texas A & M University; Douglas M. Campbell, Universidad Brigham Young; David G. Cantor, Universidad de California en Los Ángeles; C. Patrick Collier, Universidad de Wisconsin-Oshkosh; kevan

H. Croteau, Universidad Francis Marion; Irinel Drogan, Universidad de Texas en Arlington; Pablo Echeverría, Camden County College; Henry A. Etlinger, Instituto de Tecnología de Rochester; Melvin J. Friske, Colegio Luterano de Wisconsin; William Gasarch, Universidad de Maryland; Ladnor Geissinger, Universidad de Carolina del Norte; Jerrold R. Griggs, Universidad de Carolina del Sur; Nancy Baxter Hastings, Dickinson College; Lillian Hupert, Universidad Loyola de Chicago; Joseph Kolibal, Universidad del Sur de Mississippi; Benny Lo, Universidad Tecnológica Internacional; George Luger, Universidad de Nuevo México; Leonard T. Malinowski, Colegio Comunitario de Finger Lakes; John F. Morrison, Universidad Estatal de Towson; Paul Pederson, Universidad de Denver; George Peck, Universidad Estatal de Arizona; Roxy Peck, Universidad Estatal Politécnica de California, San Luis Obispo; Dix Pettey, Universidad de Missouri; Anthony Ralston, Universidad Estatal de Nueva York en Buffalo; Norman Richert, Universidad de Houston-Clear Lake; John Roberts, Universidad de Louisville; y George Schultz, St. Petersburg Junior College, Clearwater. Un agradecimiento especial a John Carroll, Universidad Estatal de San Diego; Dr. Joseph S. Fulda; y portero

G. Webster, Universidad del Sur de Mississippi; Peter Williams, Universidad Estatal de California en San Bernardino; y a Jay Zimmerman, de la Universidad Towson, por su minuciosidad inusual y su aliento.

También me he beneficiado enormemente de las sugerencias de muchos profesores que generosamente me han ofrecido sus ideas para mejorar basadas en sus experiencias con ediciones anteriores del libro, especialmente Jonathan Goldstine, de la Universidad Estatal de Pensilvania; David Hecker, Universidad de St. Joseph; Edward Huff, Colegio Comunitario de Virginia del Norte; Robert Messer, Universidad Albion; Sophie Quigley, Ryerson ONU

universidad; Piotr Rudnicki, Universidad de Alberta; Anwar Shiek, Diné College; Norton Starr, Universidad Amherst; y Eng Wee, Universidad Nacional de Singapur. La producción de la tercera edición recibió la valiosa ayuda de Christopher Novak, Universidad de Michigan, Dearborn, e Ian Crewe, Ascension Collegiate School. Para la tercera y cuarta edición estoy especialmente agradecido por las excelentes sugerencias de mejora hechas por Tom Jenkyns, de la Universidad de Brock, cuya asistencia durante todo el proceso de producción fue invaluable.

Debo muchas gracias al personal de Brooks/Cole, especialmente a mi editor, Dan Seibert, por sus atentos consejos y su tranquilizadora dirección del proceso de producción, y a mi











XXII Prefacio



a los editores anteriores, Stacy Green, Robert Pirtle, Barbara Holland y Heather Bennett, por su aliento y entusiasmo.

Cuanto mayor me hago, más me doy cuenta de la profunda deuda que tengo con mis propios profesores de matemáticas por moldear la forma en que percibo la materia. Mi primer agradecimiento debo ir a mi marido, Helmut Epp, quien, en una cita en la escuela secundaria (!), me presentó el poder y la belleza de los axiomas de campo y la visión de que las matemáticas son una materia con ideas, además de fórmulas y técnicas. . En mi educación formal, estoy muy agradecido a Daniel Zelinsky y Ky Fan de la Universidad Northwestern y a Izaak Wirszup, I. N. Herstein e Irving Kaplansky de la Universidad de Chicago, quienes, a su manera, me ayudaron a apreciar la elegancia. , rigor y entusiasmo de las matemáticas.

A mi familia le debo un agradecimiento sin medida. Estoy agradecido a mi madre, cuyo gran interés en el funcionamiento del intelecto humano me inició hace muchos años en el camino que finalmente me llevó a escribir este libro, y a mi difunto padre, cuya devoción por la palabra escrita ha sido una fuente constante de inspiración. Agradezco a mis hijos y nietos su afecto y su alegre aceptación de las exigencias que este libro ha impuesto a mi vida. Y, sobre todo, agradezco a mi esposo, quien durante muchos años me ha animado con su fe en el valor de este proyecto y me ha apoyado con su amor y sus sabios consejos.

Susana Epp





















Por eso, Oh estudiantes, estudian matemáticas y no construyen sin fundamentos. —Leonardo da Vinci (1452-1519)



El objetivo de este libro es presentarle una forma de pensar matemática que puede resultarle útil en una amplia variedad de situaciones. A menudo, cuando empiezas a trabajar en un problema matemático, es posible que sólo tengas una idea vaga de cómo proceder. Puede comenzar mirando ejemplos, haciendo dibujos, jugando con la notación, releyendo el problema para centrarse en más detalles, etc. Sin embargo, cuanto más se acerque a una solución, más cristalizará su pensamiento. Y cuanto más necesitas entender, más necesitas un lenguaje que exprese las ideas matemáticas de forma clara, precisa e inequívoca.

Este capítulo le presentará parte del lenguaje especial que constituye la base de gran parte del pensamiento matemático: el lenguaje de variables, conjuntos, relaciones y funciones. Piense en el capítulo como los ejercicios que haría antes de un evento deportivo importante. Su objetivo es calentar tus músculos mentales para que puedas dar lo mejor de ti.







A veces se piensa que una variable es un “John Doe” matemático porque puedes usarla como marcador de posición cuando quieres hablar sobre algo pero (1) imaginas que tiene uno o más valores pero no sabes cuáles son. son, o (2) desea que todo lo que diga al respecto sea igualmente cierto para todos los elementos de un conjunto determinado y, por lo tanto, no desea limitarse a considerar solo un valor particular y concreto para él. Para ilustrar el primer uso, considere preguntar

¿Existe un número con la siguiente propiedad: duplicarlo y sumarle 3 da el mismo resultado que elevarlo al cuadrado?

En esta oración puedes introducir una variable para reemplazar la palabra potencialmente ambigua “eso”: ¿Existe un número x con la propiedad de que 2x + 3 = x 2?

La ventaja de usar una variable es que te permite darle un nombre temporal a lo que

está buscando para poder realizar cálculos concretos con él para ayudar a descubrir sus posibles valores. Para enfatizar el papel de la variable como marcador de posición, podría escribir lo siguiente:

¿Existe un número Q con la propiedad de que 2 · Q +Reescribe los enunciados en 40 y 41 en forma si-entonces.

Tomar el autobús de las 8:05 es condición suficiente para llegar a tiempo al trabajo.

Tener dos ángulos de 45° es condición suficiente para que este triángulo sea rectángulo.

Utilice el contrapositivo para reescribir los enunciados de 42 y 43 en forma si-entonces de dos maneras.

Ser divisible por 3 es condición necesaria para que este número sea divisible por 9.

Hacer los deberes con regularidad es una condición necesaria para que Jim apruebe la asignatura.

Tenga en cuenta que “una condición suficiente para s es r” significa que r es una condición suficiente para s y que “una condición necesaria para s es r” significa que r es una condición necesaria para s. Reescribe los enunciados en 44 y 45 en forma si-entonces.

Una condición suficiente para que el equipo de Jon gane el campeonato es que gane el resto de sus juegos.

Una condición necesaria para que este programa informático sea correcto es que no produzca mensajes de error durante la traducción.

"Si el compuesto X está hirviendo, entonces su temperatura debe ser de al menos 150°C". Suponiendo que esta afirmación es cierta, ¿cuál de las siguientes afirmaciones también debe ser cierta?

Si la temperatura del compuesto X es al menos 150 ◦C, entonces el compuesto X está en ebullición.

Si la temperatura del compuesto X es inferior a 150 ◦ C,

entonces el compuesto X no está hirviendo.

El compuesto X hervirá sólo si su temperatura es de al menos 150 ◦ C.

Si el compuesto X no hierve, entonces su temperatura es menor

de 150 ◦C.

Una condición necesaria para que el compuesto X hierva es que su temperatura sea de al menos 150°C.

Una condición suficiente para que el compuesto X hierva es que su

La temperatura debe ser de al menos 150 ◦ C.

En 47–50 (a), use las equivalencias lógicas p → q ≡∼p ∨ q y p ↔ q ≡ (∼p ∨ q) ∧ (∼q ∨ p) para reescribir las formas de enunciado dadas sin usar el símbolo → o ↔ , y (b) use la equivalencia lógica p ∨ q ≡∼(∼p∧ ∼q) para reescribir cada forma de enunciado usando solo ∧ y ∼.

47. p ∧ ∼q → r 48. p ∨ ∼q → r ∨ q

49. (p → r) ↔ (q → r)

50. ( p → (q → r)) ↔ (( p ∧ q) → r)

Dada cualquier forma de enunciado, ¿es posible encontrar una forma lógicamente equivalente que utilice sólo y ? Justifica tu respuesta.







Respuestas para Ponte a prueba

verdadero; falso 2. p∧ ∼q 3. si q entonces p 4. si ∼q entonces ∼p 5. si ∼p entonces ∼q 6. lógicamente equivalente 7. lógicamente equivalente 8. R; S9.S; R 10. R; S







“Por el contrario”, continuó Tweedledee, “si fuera así, podría ser; y si así fuera, así sería; pero como no lo es, no lo es. Eso es lógico”. — Lewis Carroll, A través del espejo

En matemáticas y lógica, un argumento no es una disputa. Es una secuencia de afirmaciones que terminan en una conclusión. En esta sección mostramos cómo determinar si un argumento es válido, es decir, si la conclusión se sigue necesariamente de las afirmaciones anteriores. Mostraremos que esta determinación depende sólo de la forma de un argumento, no de su contenido.

En la sección 2.1 se demostró que la forma lógica de un argumento puede abstraerse de su contenido. Por ejemplo, el argumento

Si Sócrates es un hombre, entonces Sócrates es mortal. Sócrates es un hombre.

∴ Sócrates es mortal.

tiene la forma abstracta

Si p entonces q p

∴q

Al considerar la forma abstracta de un argumento, piense en p y q como variables que pueden sustituirse por enunciados. Una forma de argumento se considera válida si, y sólo si, siempre que se sustituyen enunciados que hacen que todas las premisas sean verdaderas, la conclusión también es verdadera.





El hecho crucial acerca de un argumento válido es que la verdad de su conclusión se sigue necesaria o ineludiblemente o sólo por forma lógica de la verdad de sus premisas. Es imposible tener un argumento válido con premisas verdaderas y una conclusión falsa. Cuando un argumento es válido y sus premisas son verdaderas, se dice que la verdad de la conclusión se infiere o deduce de la verdad de las premisas. Si una conclusión "no es necesariamente así", entonces no es una deducción válida.













Ejemplo 2.3.1 Determinación de validez o invalidez

Determine si la siguiente forma de argumento es válida o inválida dibujando una tabla de verdad, indicando qué columnas representan las premisas y cuáles representan la conclusión, y anotando la tabla con una oración explicativa. Cuando completa la tabla, sólo necesita indicar los valores de verdad de la conclusión en las filas donde todas las premisas son verdaderas (las filas críticas) porque los valores de verdad de la conclusión en las otras filas son irrelevantes para la validez o invalidez. del argumento.

p → q ∨ ∼r q → p ∧ r

∴ pag → r

Solución La tabla de verdad muestra que aunque hay varias situaciones en las que las premisas y la conclusión son todas verdaderas (filas 1, 7 y 8), hay una situación (fila 4) en la que las premisas son verdaderas y la conclusión es falsa. .





instalaciones





pqrqpr



conclusión







Esta fila muestra que un argumento de esta forma puede tener premisas verdaderas y una conclusión falsa. Por tanto, esta forma de argumento es inválida.







■





Modus Ponens y Modus Tollens

Una forma argumentativa que consta de dos premisas y una conclusión se llama silogismo. La primera y segunda premisas se denominan premisa mayor y premisa menor, respectivamente.





La forma más famosadel silogismo en lógica se llama modus ponens. Tiene la siguiente forma:

Si p entonces q. pag

∴q

He aquí un argumento de esta forma:

Si la suma de los dígitos de 371,487 es divisible por 3, entonces 371,487 es divisible por 3.

La suma de los dígitos de 371,487 es divisible por 3.

∴ 371,487 es divisible por 3.

El término modus ponens en latín significa “método de afirmar” (la conclusión es una afirmación). Mucho antes de que vieras tu primera tabla de verdad, sin duda ya estabas convencido por argumentos de esta forma. Sin embargo, es instructivo demostrar que el modus ponens es una forma válida de argumento, aunque sólo sea para confirmar la concordancia entre la definición formal de validez y el concepto intuitivo. Para ello, construimos una tabla de verdad para las premisas y la conclusión.



conclusión de las premisas





←− fila crítica









La primera fila es la única en la que ambas premisas son verdaderas y la conclusión de esa fila también es verdadera. Por tanto, la forma del argumento es válida.

Consideremos ahora otra forma de argumento válida llamada modus tollens. Tiene la siguiente forma:











A continuación se muestra un ejemplo de modus tollens:



Si p entonces q.

∼ q

∴ ∼pag



Si Zeus es humano, entonces Zeus es mortal. Zeus no es mortal.

∴ Zeus no es humano.

Una explicación intuitiva de la validez del modus tollens utiliza la prueba por contradicción.

Dice así:

Suponer

Si Zeus es humano, entonces Zeus es mortal; y

Zeus no es mortal.

¿Debe Zeus ser necesariamente no humano? ¡Sí!





Porque, si Zeus fuera humano, entonces por (1) sería mortal. Pero por (2) él no es mortal.

Por tanto, Zeus no puede ser humano.

Modus tollens en latín significa "método de negar" (la conclusión es una negación). Se puede demostrar que la validez del modus tollens se deriva del modus ponens junto con el hecho de que un enunciado condicional es lógicamente equivalente a su contrapositivo. O puede establecerse formalmente mediante el uso de una tabla de verdad. (Ver ejercicio 13.)

Estudios realizados por psicólogos cognitivos han demostrado que, aunque casi el 100% de los estudiantes universitarios tienen una comprensión sólida e intuitiva del modus ponens, menos del 60% son capaces de aplicar el modus tollens correctamente.∗ Sin embargo, en el razonamiento matemático, el modus tollens se utiliza casi con tanta frecuencia como modus ponens. Por tanto, es importante estudiar detenidamente la forma del modus tollens para aprender a utilizarlo de forma eficaz.



Ejemplo 2.3.2 Reconocimiento de Modus Ponens y Modus Tollens

Utilice modus ponens o modus tollens para completar los espacios en blanco de los siguientes argumentos para que se conviertan en inferencias válidas.

Si hay más palomas que casilleros, entonces al menos dos palomas se posan en el mismo hoyo.

Hay más palomas que casilleros.

∴.

Si 870,232 es divisible por 6, entonces es divisible por 3. 870,232 no es divisible por 3.

∴.

Solución

Al menos dos palomas se posan en el mismo hoyo. por modus ponens

870.232 no es divisible por 6. por modus tollens ■



Formas adicionales de argumentos válidos: reglas de inferencia

Una regla de inferencia es una forma de argumento que es válida. Por tanto, tanto el modus ponens como el modus tollens son reglas de inferencia. Los siguientes son ejemplos adicionales de reglas de inferencia que se utilizan con frecuencia en el razonamiento deductivo.





Ejemplo 2.3.3 Generalización

Las siguientes formas de argumento son válidas:

pag

∴ p ∨ q









q

∴ p ∨ q



Estas formas de argumento se utilizan para hacer generalizaciones. Por ejemplo, según el primero, si p es verdadero, entonces, de manera más general, “poq” es verdadero para cualquier otro enunciado q. Como ejemplo, suponga que le asignan la tarea de contar a los estudiantes de último año de su escuela. Preguntas en qué clase está Anton y te dicen que es un estudiante de tercer año.





∗Psicología cognitiva y sus implicaciones, 3d ed. por John R. Anderson (Nueva York: Freeman, 1990), págs.





Razonas de la siguiente manera:

Anton es un junior.

∴ (más generalmente) Anton es un junior o Anton es un senior.

Sabiendo que estudiante de último año significa junior o senior, agregas a Anton a tu lista. ■





Ejemplo 2.3.4 Especialización

Las siguientes formas de argumento son válidas:

∴ p ∧ q





∴ p ∧ q



Estas formas de argumento se utilizan para especializarse. Al clasificar objetos según alguna propiedad, a menudo se sabe mucho más sobre ellos que si tienen o no esa propiedad. Cuando esto sucede, descarta información superflua mientras se concentra en la propiedad particular de interés.

Por ejemplo, suponga que está buscando una persona que conozca algoritmos gráficos para trabajar con usted en un proyecto. Descubres que Ana conoce tanto el análisis numérico como los algoritmos gráficos. Razonas de la siguiente manera:

Ana sabe análisis numérico y Ana conoce algoritmos gráficos.

∴ (en particular) Ana conoce algoritmos de grafos.

En consecuencia, la invitas a trabajar contigo en tu proyecto. ■



Tanto la generalización como la especialización se utilizan con frecuencia en matemáticas para adaptar hechos que se ajusten a hipótesis de teoremas conocidos con el fin de sacar conclusiones adicionales. La eliminación, la transitividad y la prueba por división en casos también son herramientas ampliamente utilizadas.



Ejemplo 2.3.5 Eliminación

Las siguientes formas de argumento son válidas:



pag ∨ q

∴ ∼ q



pag ∨ q

∴ ∼pag



Estas formas de argumento dicen que cuando sólo tienes dos posibilidades y no puedesSi se descarta uno, el otro debe ser el caso. Por ejemplo, supongamos que sabes que para un número particular x,

x − 3 = 0 o x + 2 = 0.

Si también sabes que x no es negativo, entonces x /= −2, entonces

x+2/= 0.

Por eliminación, se puede concluir que

∴ x − 3 = 0. ■



Ejemplo 2.3.6 Transitividad

La siguiente forma de argumento es válida:







p → q q → r

∴ pag → r





Muchos argumentos en matemáticas contienen cadenas de enunciados si-entonces. Del hecho de que un enunciado implica un segundo y el segundo implica un tercero, se puede concluir que el primer enunciado implica el tercero. Aquí hay un ejemplo:

Si 18.486 es divisible por 18, entonces 18.486 es divisible por 9.

Si 18,486 es divisible por 9, entonces la suma de los dígitos de 18,486 es divisible por 9.

∴ Si 18,486 es divisible por 18, entonces la suma de los dígitos de 18,486 es divisible por 9.





Ejemplo 2.3.7 Prueba por división en casos

La siguiente forma de argumento es válida:



■







p ∨ q p → r q → r

∴r



A menudo sucede que sabes que una cosa u otra es verdad. Si se puede demostrar que en cualquier caso se sigue una determinada conclusión, entonces esta conclusión también debe ser cierta. Por ejemplo, supongamos que sabes que x es un número real particular distinto de cero. La propiedad de tricotomía de los números reales dice que cualquier número es positivo, negativo o cero. Así (por eliminación) sabes que x es positivo o x es negativo. Puedes deducir que x 2 > 0 argumentando de la siguiente manera:

x es positivo o x es negativo. Si x es positivo, entonces x 2 > 0. Si x es negativo, entonces x 2 > 0.

∴ x 2 > 0. ■

Las reglas de inferencia válida se utilizan constantemente en la resolución de problemas. He aquí un ejemplo de la vida cotidiana.



Ejemplo 2.3.8 Aplicación: una deducción más compleja

Estás a punto de salir para la escuela por la mañana y descubres que no tienes tus gafas. Sabes que las siguientes afirmaciones son ciertas:

Si estoy leyendo el periódico en la cocina, mis vasos están sobre la mesa de la cocina.

Si mis vasos están en la mesa de la cocina, entonces los vi en el desayuno.

No vi mis gafas en el desayuno.

Estaba leyendo el periódico en la sala o estaba leyendo el periódico en la cocina.

Si estoy leyendo el periódico en la sala de estar, mis vasos están sobre la mesa de café.

¿Dónde están las gafas?

Solución Sea RK = Estaba leyendo el periódico en la cocina.

GK = Mis vasos están sobre la mesa de la cocina.

SB = Vi mis lentes en el desayuno.

RL = Estaba leyendo el periódico en la sala.

GC = Mis vasos están sobre la mesa de café.





A continuación se muestra una secuencia de pasos que puede seguir para llegar a la respuesta, junto con las reglas de inferencia que le permiten sacar la conclusión de cada paso:

RK → GK por (a)

GK → SB por (d)

∴ RK → SB por transitividad

RK → SB por la conclusión de (1)

∼SB por (c)

∴ ∼RK por modus tollens

RL ∨ RK por (d)

∼RK por la conclusión de (2)

∴ RL por eliminación

RL → GC por (e)

RL por la conclusión de (3)

∴ GC por modus ponens



Así los vasos están sobre la mesa de café. ■



Falacias

Una falacia es un error de razonamiento que resulta en un argumento inválido. Tres falacias comunes son el uso de premisas ambiguas y el tratamiento de ellas como si fueran inequívocas, el razonamiento circular (suponiendo lo que se va a demostrar sin haberlo derivado de las premisas) y el salto a una conclusión (sin fundamentos adecuados). En esta sección analizamos otras dos falacias, llamadas error inverso y error inverso, que dan lugar a argumentos que superficialmente se parecen a aquellos que son válidos por modus ponens y modus tollens pero que, de hecho, no son válidos.

Como en ejemplos anteriores, puede demostrar que un argumento no es válido construyendo una tabla de verdad para la forma del argumento y encontrando al menos una fila crítica en la que todas las premisas sean verdaderas pero la conclusión sea falsa. Otra forma es encontrar un argumento de la misma forma con premisas verdaderas y una conclusión falsa.





Ejemplo 2.3.9 Error de conversación

Demuestre que el siguiente argumento no es válido:

Si Zeke es un tramposo, entonces Zeke se sienta en la última fila. Zeke se sienta en la última fila.

∴ Zeke es un tramposo.

Solución Muchas personas reconocen intuitivamente la invalidez del argumento anterior y razonan algo como esto: La primera premisa da información sobre Zeke si se sabe que es un tramposo. No da ninguna información sobre él si aún no se sabe que es un tramposo. Ciertamente se puede imaginar a una persona que no es un tramposo pero que se sienta en el





fila de atrás. Entonces, si el nombre de esa persona se sustituye por Zeke, la primera premisa es verdadera por defecto y la segunda premisa también es verdadera pero la conclusión es falsa.

La forma general del argumento anterior es la siguiente:

p → q q

∴p

En el ejercicio 12(a), al final de esta sección, se le pide que utilice una tabla de verdad para demostrar que esta forma de argumento no es válida. ■



La falacia que subyace a esta forma de argumento inválida se llama error inverso porque la conclusión del argumento se seguiría de las premisas si la premisa p q fuera reemplazada por su inverso. Sin embargo, tal sustitución no está permitida porque un enunciado condicional no es lógicamente equivalente a su recíproco. ConversarEl error también se conoce como falacia de afirmar el consecuente.

Otro error común en el razonamiento se llama error inverso.



Ejemplo 2.3.10 Error inverso

Considere el siguiente argumento:

Si las tasas de interés suben, los precios del mercado de valores bajarán. Las tasas de interés no están subiendo.

∴ Los precios del mercado de valores no bajarán.

Tenga en cuenta que este argumento tiene la siguiente forma:

pag → q

∼pag

∴ ∼ q





¡Precaución! En lógica, las palabras verdadero y válido tienen significados muy diferentes. Un argumento válido puede tener una conclusión falsa y un argumento inválido puede tener una conclusión verdadera.



Se le pide que proporcione una verificación en una tabla de verdad de la invalidez de esta forma de argumento en el ejercicio 12(b) al final de esta sección.

La falacia que subyace a esta forma inválida del argumento se llama error inverso porque la conclusión del argumento se seguiría de las premisas si la premisa p q fuera reemplazada por su inverso. Sin embargo, tal sustitución no está permitida porque un enunciado condicional no es lógicamente equivalente a su inverso. El error inverso también se conoce como falacia de negar el antecedente. ■





A veces la gente junta las ideas de validez y verdad. Si un argumento parece válido, aceptan la conclusión como verdadera. Y si un argumento parece sospechoso (en realidad, una expresión del argot que significa inválido), piensan que la conclusión debe ser falsa. ¡Esto no es correcto!



Ejemplo 2.3.11 Un argumento válido con una premisa falsa y una conclusión falsa

El siguiente argumento es válido por modus ponens. Pero su premisa principal es falsa, al igual que su conclusión.

Si John Lennon era una estrella de rock, entonces John Lennon era pelirrojo. John Lennon era una estrella de rock.

∴ John Lennon tenía el pelo rojo. ■





Ejemplo 2.3.12 Un argumento inválido con premisas verdaderas y una conclusión verdadera

El siguiente argumento no es válido por el error inverso, pero tiene una conclusión verdadera.

Si Nueva York es una ciudad grande, entonces Nueva York tiene edificios altos. Nueva York tiene edificios altos.

∴ Nueva York es una gran ciudad. ■





Lo importante a tener en cuenta es que la validez es una propiedad de las formas de los argumentos: si un argumento es válido, también lo serán todos los demás argumentos que tengan la misma forma. De manera similar, si un argumento no es válido, también lo será cualquier otro argumento que tenga la misma forma. Lo que caracteriza a un argumento válido es que ningún argumento cuya forma sea válida puede tener todas las premisas verdaderas y una conclusión falsa. Para cada argumento válido, hay argumentos de esa forma con todas las premisas verdaderas y una conclusión verdadera, con al menos una premisa falsa y una conclusión verdadera, y con al menos una premisa falsa y una conclusión falsa. Por otro lado, para cada argumento inválido, hay argumentos de esa forma con cada combinación de valores de verdad para las premisas y la conclusión, incluidas todas las premisas verdaderas y una conclusión falsa. La conclusión es que sólo podemos estar seguros de que la conclusión de un argumento es verdadera cuando sabemos que el argumento es sólido, es decir, cuando sabemos que el argumento es válido y que tiene todas las premisas verdaderas.



Contradicciones y argumentos válidos

El concepto de contradicción lógica se puede utilizar para hacer inferencias mediante una técnica de razonamiento llamada regla de contradicción. Supongamos que p es algún enunciado cuya verdad desea deducir.





Ejemplo 2.3.13 Regla de contradicción

Demuestre que la siguiente forma de argumento es válida:

∼p → c, donde c es una contradicción

∴p

Solución Construya una tabla de verdad para la premisa y la conclusión de este argumento.

conclusión de las premisas

Sólo hay una fila crítica en la que la premisa es verdadera, y en esta fila la conclusión también es verdadera. De ahí esta forma

del argumento es válido. ■





La regla de la contradicción es el corazón lógico del método de prueba por contradicción. Una ligera variación también proporciona la base para resolver muchos acertijos lógicos eliminando respuestas contradictorias: si una suposición conduce a una contradicción, entonces esa suposición debe ser falsa.





Ejemplo 2.3.14 Caballeros y bribones

El lógico Raymond Smullyan describe una isla que contiene dos tipos de personas: caballeros que siempre dicen la verdad y bribones que siempre mienten.∗ Visitas la isla y se te acercan dos nativos que te hablan de la siguiente manera:

A dice: B es un caballero.

B dice: A y yo somos de tipo opuesto.

¿Qué son A y B?











Raymond Smullyan (nacido en 1919)



Las soluciones A y B son ambas pícaras. Para ver esto, razone de la siguiente manera: supongamos que A es un caballo.

∴ Lo que dice A es cierto. por definición de caballero

∴ B también es caballo. Eso es lo que dijo A.

∴ Lo que dice B es cierto. por definición de caballero

∴ A y B son de tipos opuestos. Eso es lo que dijo B.

∴ Hemos llegado a la siguiente contradicción: A y B

Ambos son caballos y A y B son de tipo opuesto.

∴ La suposición es falsa. por la regla de contradicción

∴ A no es un caballero. negación de suposición

∴ A es un bribón. por eliminación: Se da que todos los habitantes

son caballeros o bribones, por lo que como A no es un

caballero, A es un bribón.



∴ Lo que dice A es falso.

∴ B no es un caballero.

∴ B también es un bribón. por eliminación

Este razonamiento muestra que si el problema tiene alguna solución, entonces A y B deben ser ambos bribones. Es concebible, sin embargo, que el problema no tenga solución. El planteamiento del problema podría ser inherentemente contradictorio. Sin embargo, si analizamos la solución, veremos que resulta que tanto A como B son bribones. ■



Resumen de reglas de inferencia

La tabla 2.3.1 resume algunas de las reglas de inferencia más importantes.







∗Raymond Smullyan ha escrito una encantadora serie de libros caprichosos pero profundos de acertijos lógicos que comienzan con ¿Cuál es el nombre de este libro? (Englewood Cliffs, Nueva Jersey: Prentice-Hall, 1978). Otras buenas fuentes de acertijos lógicos son los excelentes libros de Martin Gardner, como Aha! Perspicacia y ¡Ajá! Gotcha (Nueva York: W. H. Freeman, 1978, 1982).





Tabla 2.3.1 Formas de argumentos válidos







Pruébate

Para que un argumento sea válido significa que todo argumento de la misma forma cuyas premisas tengan una conclusión.

Que un argumento sea inválido significa que hay un argumento de la misma forma cuyas premisas y cuya conclusión.



Conjunto de ejercicios 2.3

Utilice modus ponens o modus tollens para completar los espacios en blanco en los argumentos del 1 al 5 a fin de producir inferencias válidas.

Si √2 es racional, entonces √2 = a/b para algunos números enteros a







Para que un argumento sea sólido significa que lo es y sus premisas. En este caso podemos estar seguros de que su conclusión.













Si no estuvieran seguros de la dirección, habrían llamado por teléfono.

  .

∴ Estaban seguros de la dirección.



y B.

No es cierto que



√2 = a/b para algunos números enteros a y b.



Utilice tablas de verdad para determinar si las formas de argumento del 6 al 11 son válidas. Indique qué columnas representan las premisas y



∴.

Si 1 0,99999... es menor que todo número real positivo, entonces es igual a cero.

  .



que representan la conclusión e incluyen una oración que explica cómo la tabla de verdad respalda su respuesta. Su explicación debe demostrar que comprende lo que significa que una forma de argumento sea válida o inválida.



∴ El número 1 − 0,99999... es igual a cero.

Si la lógica es fácil, entonces soy el tío de un mono. No soy el tío de un mono.

∴.

Si esta figura es un cuadrilátero, entonces la suma de sus ángulos interiores es 360◦.

La suma de los ángulos interiores de esta figura no es 360◦.

∴.



p → q q → p

∴ p ∨ q



8. p q

p q

pr

∴r



7.pag

p q

q r

∴r

9. p ∧ q → ∼r p ∨ ∼q

∼q → pag

∴ ∼r







p → r q → r

∴ p ∨ q → r



p → q ∨ r

∼q ∨ ∼r

∴ ∼p ∨ ∼r



26. Si voy al cine, no terminaré mi tarea. Si no termino mi tarea, no me irá bien en el

mañana examen.



Utilice tablas de verdad para demostrar que las siguientes formas de argumento no son válidas.



∴ Si voy al cine, mañana no me irá bien en el examen.



pqq

∴p

(error inverso)



pqp

∴q

(error inverso)



27. Si este número es mayor que 2, entonces su cuadrado es mayor que 4.

Este número no es mayor que 2.

∴ El cuadrado de este número no es mayor que 4.





Utilice tablas de verdad para demostrar que las formas de argumento a las que se hace referencia en 13 a 21 son válidas. Indique qué columnas representan las premisas y cuáles representan la conclusión, e incluya una oración que explique cómo la tabla de verdad respalda su respuesta. Su explicación debe demostrar que comprende lo que significa que una forma de argumento sea válida.

Modo de peaje:

pag → q

∼ q

∴ ∼pag

14. Ejemplo 2.3.3(a) 15. Ejemplo 2.3.3(b)

16. Ejemplo 2.3.4(a) 17. Ejemplo 2.3.4(b)

18. Ejemplo 2.3.5(a) 19. Ejemplo 2.3.5(b)

20. Ejemplo 2.3.6 21. Ejemplo 2.3.7

Use símbolos para escribir la forma lógica de cada argumento en 22 y 23, y luego use una tabla de verdad para probar la validez del argumento. Indique qué columnas representan las premisas y cuáles representan la conclusión, e incluya algunas palabras explicativas que demuestren que comprende el significado de validez.

Si Tom no está en el equipo A, entonces Hua está en el equipo B. Si Hua no está en el equipo B, entonces Tom está en el equipo A.

∴ Tom no está en el equipo A o Hua no está en el equipo B.

Oleg se especializa en matemáticas o Oleg se especializa en economía.

Si Oleg se especializa en matemáticas, entonces se requiere que Oleg tome Matemáticas 362.

∴ Oleg es estudiante de economía o Oleg no está obligado a

toma Matemáticas 362.

Algunos de los argumentos de 24 a 32 son válidos, mientras que otros exhiben el error inverso o inverso. Usa símbolos para escribir la forma lógica de cada argumento. Si el argumento es válido, identifique la regla de inferencia que garantiza su validez. En caso contrario, indique si se comete el error inverso o inverso.

Si Jules resolvió este problema correctamente, entonces Jules obtuvo la respuesta 2.

Jules obtuvo la respuesta 2.

∴ Jules resolvió este problema correctamente.

Este número real es racional o es irracional. Este número real no es racional.

∴ Este número real es irracional.



Si hay tantos números racionales como irracionales, entonces el conjunto de todos los números irracionales es infinito.

El conjunto de todos los números irracionales es infinito.

∴ Hay tantos números racionales como irracionales.

Si al menos uno de estos dos números es divisible por 6, entonces el producto de estos dos números es divisible por 6. Ninguno de estos dos números es divisible por 6.

∴ El producto de estos dos números ino es divisible por 6.

Si este programa de computadora es correcto, entonces produce el resultado correcto cuando se ejecuta con los datos de prueba que me dio mi maestro.

Este programa de computadora produce el resultado correcto cuando se ejecuta con los datos de prueba que me dio mi maestro.

∴ Este programa informático es correcto.

Sandra sabe Java y Sandra sabe C++.

∴ Sandra sabe C++.

Si me dan el aguinaldo me compro un estéreo. Si vendo mi moto, me compraré un estéreo.

∴ Si recibo aguinaldo o vendo mi moto, entonces

Compraré un estéreo.

Dé un ejemplo (que no sea el ejemplo 2.3.11) de un argumento válido con una conclusión falsa.

Dé un ejemplo (que no sea el Ejemplo 2.3.12) de un argumento no válido con una conclusión verdadera.

Explique con sus propias palabras qué distingue una forma de argumento válida de una inválida.

Dada la siguiente información sobre un programa de computadora, encuentre el error en el programa.

Hay una variable no declarada o hay un error de sintaxis en las primeras cinco líneas.

Si hay un error de sintaxis en las primeras cinco líneas, entonces falta un punto y coma o el nombre de una variable está mal escrito.

No falta ningún punto y coma.

No hay ningún nombre de variable mal escrito.







En el fondo de un viejo armario descubres una nota firmada por un pirata famoso por su extraño sentido del humor y su amor por los acertijos lógicos. En la nota escribió que había escondido un tesoro en algún lugar de la propiedad. Enumeró cinco afirmaciones verdaderas (a-e a continuación) y desafió al lector a usarlas para descubrir la ubicación del tesoro.

Si esta casa está al lado de un lago, entonces el tesoro no está en la cocina.

Si el árbol del jardín delantero es un olmo, entonces el tesoro es

en la cocina.

Esta casa está al lado de un lago.

El árbol del jardín delantero es un olmo o el tesoro está enterrado bajo el asta de la bandera.

Si el árbol del patio trasero es un roble, entonces el tesoro es

en el garaje.

¿Dónde está escondido el tesoro?



Estás visitando la isla descrita en el Ejemplo 2.3.14 y tienes los siguientes encuentros con nativos.

Dos nativos A y B se dirigen a usted de la siguiente manera:

A dice: Ambos somos caballeros.

B dice: A es un bribón. ¿Qué son A y B?

Otros dos nativos C y D se acercan a ti pero solo C

habla.

C dice: Ambos somos bribones. ¿Qué son C y D?

Luego te encuentras con los nativos E y F.

E dice: F es un bribón.

F dice: E es un bribón.



Si el cocinero estaba en la cocina en el momento del asesinato, entonces el mayordomo mató a Lord Hazelton con una dosis fatal de estricnina.

Si Lady Hazelton estaba en el comedor en el momento del asesinato, entonces el chófer mató a Lord Hazelton.

Si la cocinera no estaba en la cocina en el momento del asesinato, entonces Sara no estaba en el comedor cuando se cometió el asesinato.

Si Sara estaba en el comedor en el momento en que se cometió el asesinato, entonces el camarero mató a Lord Hazelton.

¿Es posible que el detective deduzca la identidad del asesino a partir de estos hechos? Si es así, ¿quién asesinó a Lord Hazelton? (Supongamos que solo hubo una causa de muerte).

Sharky, un líder del inframundo, fue asesinado por uno de su propio grupo de cuatro secuaces. El detective Sharp entrevistó a los hombres y determinó que todos mentían excepto uno. Dedujo quién mató a Sharky basándose en las siguientes declaraciones:

Socko: Lefty mató a Sharky.

Grasas: Los músculos no mataron a Sharky.

Lefty: Muscles estaba jugando a los dados con Socko cuando Sharky fue derribado.

Músculos: Lefty no mató a Sharky. ¿Quién mató a Sharky?



En 41-44 se dan un conjunto de premisas y una conclusión. Utilice las formas de argumento válidas enumeradas en la tabla 2.3.1 para deducir la conclusión a partir de las premisas, dando una razón para cada paso como en el ejemplo 2.3.8. Suponga que todas las variables son variables de declaración.



¿Cuántos bribones hay?

H d. Finalmente, te encuentras con un grupo de seis nativos, U, V, W, X, Y y Z, que te hablan de la siguiente manera:

U dice: Ninguno de nosotros es un caballero.

V dice: Al menos tres de nosotros somos caballeros. W dice: Como máximo tres de nosotros somos caballeros. X dice: Exactamente cinco de nosotros somos caballeros.

Y dice: Exactamente dos de nosotros somos caballeros.

Z dice: Exactamente uno de nosotros es un caballero. ¿Cuáles son caballeros y cuáles son bribones?



a. ∼p ∨ q → r

s∨∼q

∼t

pag → t

mi. ∼p ∧ r → ∼s

F. ∴ ∼ q

43. a. ∼p → r ∧ ∼s

t → s



a. pag ∨ q

q → r

p ∧ s → t

∼r

∼q → u ∧ s

∴t

a. pag → q

b. r ∨ s



El famoso detective Percule Hoirot fue llamado para resolver un desconcertante misterio de asesinato. Determinó los siguientes hechos:

Lord Hazelton, el hombre asesinado, murió de un golpe en la cabeza con un candelabro de latón.

O Lady Hazelton o una doncella, Sara, estaban en el comedor.

habitación en el momento del asesinato.



Respuestas para Ponte a prueba

1. son todas ciertas; verdadero 2. son todos verdaderos; es falso 3. válido; son todas ciertas; es verdad



tu →∼p

∼w

tu ∨ w

∴ ∼t



∼s →∼t

∼q ∨ s

∼s

∼p ∧ r → u

w∨t

∴ tu ∧ w







¡Solo conéctate! - EM Forster, Howards End



A finales de la década de 1930, un joven MIT. El estudiante de posgrado llamado Claude Shannon notó una analogía entre las operaciones de los dispositivos de conmutación, como los circuitos de conmutación telefónica, y las operaciones de los conectivos lógicos. Usó esta analogía con sorprendente éxito para resolver problemas de diseño de circuitos y escribió sus resultados en h. Es una tesis de maestría, que se publicó en 1938.

El dibujo de la Figura 2.4.1(a) muestra la apariencia de las dos posiciones de un interruptor simple. Cuando el interruptor está cerrado, la corriente puede fluir de un terminal al otro; cuando está abierto, la corriente no puede fluir. Imagine que dicho interruptor es parte del circuito que se muestra en la Figura 2.4.1(b). La bombilla se enciende si, y sólo si, fluye corriente a través de ella. Y esto sucede si, y sólo si, el interruptor está cerrado.











Claude Shannon (1916-2001)











Abrir cerrado

(a)















Figura 2.4.1















(b)



El símbolo indica una batería y el símbolo



denota una bombilla.





Consideremos ahora los circuitos más complicados de las figuras 2.4.2(a) y 2.4.2(b).



Conmutadores “en serie” Conmutadores “en paralelo”

(b)

Figura 2.4.2



En el circuito de la figura 2.4.2(a) fluye corriente y la bombilla se enciende si, y sólo si, ambos interruptores P y Q están cerrados. Se dice que los interruptores de este circuito están en serie. En el circuito de la figura 2.4.2(b) fluye corriente y la bombilla se enciende si, y sólo si, al menos uno de los interruptores P o Q está cerrado. Se dice que los interruptores de este circuito están en paralelo. Todos los comportamientos posibles de estos circuitos se describen en la Tabla 2.4.1.

Tabla 2.4.1

Conmutadores en serie (b) Conmutadores en paralelo







Observe que si las palabras cerrado y encendido se reemplazan por T y abierto y apagado se reemplazan por F, la Tabla 2.4.1(a) se convierte en la tabla de verdad para y y la Tabla 2.4.1(b) se convierte en la tabla de verdad para o. En consecuencia, se dice que el circuito de conmutación de la Figura 2.4.2(a) corresponde a la expresión lógica P Q, y que el de la Figura 2.4.2(b) corresponde a P Q.

Los circuitos más complicados corresponden a expresiones lógicas más complicadas. Esta correspondencia se ha utilizado ampliamente en el diseño y estudio de circuitos.

En las décadas de 1940 y 1950, los interruptores fueron reemplazados por dispositivos electrónicos, y los estados físicos de cerrado y abierto correspondían a estados electrónicos como voltajes altos y bajos. La nueva tecnología electrónica condujo al desarrollo de sistemas digitales modernos, como computadoras electrónicas, sistemas electrónicos de conmutación telefónica, controles de semáforos, calculadoras electrónicas y los mecanismos de control utilizados en cientos de otros tipos de equipos electrónicos. Los componentes electrónicos básicos de un sistema digital se denominan circuitos lógicos digitales. La palabra lógica indica el importante papel de la lógica en el diseño de dichos circuitos, y la palabra digital indica que los circuitos procesan señales discretas o separadas en lugar de señales continuas.













El Intel 4004, presentado en 1971, se considera generalmente como el primer microprocesador o unidad central de procesamiento (CPU) comercialmente viable contenido en un chip del tamaño aproximado de una uña. Constaba de 2.300 transistores y podía ejecutar 70.000 instrucciones por segundo, esencialmente la misma potencia de cálculo que la primera computadora electrónica, la ENIAC, construida en 1946, que ocupaba una habitación entera. Los microprocesadores modernos constan de varias CPU en un chip, contienen cerca de mil millones de transistores y muchos cientos de millones de circuitos lógicos y pueden calcular cientos de millones de instrucciones por segundo.













John W. Tukey (1915-2000)



Los ingenieros eléctricos continúan utilizando el lenguaje de la lógica cuando se refieren a los valores de las señales producidas por un interruptor electrónico como "verdaderos" o "falso". Pero generalmente utilizan los símbolos 1 y 0 en lugar de T y F para indicar estos valores. Los símbolos 0 y 1 se llaman bits, abreviatura de dígitos binarios. Esta terminología fue introducida en 1946 por el estadístico John Tukey.



Cajas y puertas negras

Las combinaciones de bits de señal (1 y 0) se pueden transformar en otras combinaciones de bits de señal (1 y 0) mediante varios circuitos. Porque una variedad de diferentes





Aunque se utilizan tecnologías en la construcción de circuitos, los ingenieros informáticos y los diseñadores de sistemas digitales encuentran útil pensar en ciertos circuitos básicos como cajas negras. El interior de una caja negra contiene la implementación detallada del circuito y a menudo se ignora mientras la atención se centra en la relación entre las señales de entrada y salida.



Entrada P



señales Q

R



Señal de salida









El funcionamiento de una caja negra se especifica completamente construyendo una tabla de entrada/salida que enumere todas sus posibles señales de entrada junto con sus correspondientes señales de salida. Por ejemplo, el cuadro negro que se muestra arriba tiene tres señales de entrada. Dado que cada una de estas señales puede tomar el valor 1 o 0, existen ocho combinaciones posibles de señales de entrada. Una posible correspondencia de las señales de entrada y salida es la siguiente:







Una tabla de entrada/salida









La tercera fila, por ejemplo, indica que para las entradas P 1, Q 0 y R 1, la salida

S es 0.

Un método eficaz para diseñar circuitos más complicados es construirlos conectando circuitos de caja negra menos complicados. Tres de estos circuitos se conocen como puertas NOT, AND y OR.

Una puerta NOT (o inversor) es un circuito con una señal de entrada y una señal de salida. Si el La señal de entrada es 1, la señal de salida es 0. Por el contrario, si la señal de entrada es 0, entonces la señal de salida es 1. Una puerta AND es un circuito con dos señales de entrada y una señal de salida. Si ambas señales de entrada son 1, entonces la señal de salida es 1. De lo contrario, la señal de salida es 0. Una puerta OR también tiene dos señales de entrada y una señal de salida. Si ambas señales de entrada son 0, entonces la señal de salida es 0. De lo contrario, la señal de salida es 1.

Las acciones de las puertas NOT, AND y OR se resumen en la Figura 2.4.3, donde P y Q representan señales de entrada y R representa la señal de salida. Debería quedar claro en la Figura 2.4.3 que las acciones de las puertas NOT, AND y OR sobre las señales corresponden exactamente a las de los conectivos lógicos , y on, si el símbolo 1 se identifica con T y el El símbolo 0 se identifica con F.

Las puertas se pueden combinar en circuitos de diversas formas. Si las reglas mostradas en el

Si se siguen las instrucciones de la página siguiente, el resultado es un circuito combinacional, cuya salida en cualquier momento está determinada enteramente por su entrada en ese momento, sin tener en cuenta las entradas anteriores.

























Figura 2.4.3



Reglas para un circuito combinacional

Nunca combine dos cables de entrada. 2.4.1

Un único cable de entrada se puede dividir parcialmente y utilizar como entrada.

para dos puertas separadas. 2.4.2

Se puede utilizar un cable de salida como entrada. 2.4.3

Ninguna salida de una puerta puede eventualmente retroalimentar esa puerta. 2.4.4

La regla (2.4.4) se infringe en circuitos más complejos, llamados circuitos secuenciales, cuya salida en un momento dado depende tanto de la entrada en ese momento como también de entradas anteriores. Estos circuitos se analizan en la Sección 12.2.



La tabla de entradas/salidas de un circuito

Si se le proporciona un conjunto de señales de entrada para un circuito, puede encontrar su salida rastreando el circuito puerta por puerta.





Ejemplo 2.4.1 Determinación de la salida para una entrada dada

Indique la salida de los circuitos que se muestran a continuación para las señales de entrada dadas.



Señales de entrada: P = 0 y Q = 1

PAG

R



q



Señales de entrada: P = 1, Q = 0, R = 1

P Q

S

R

Solución

Muévase de izquierda a derecha a través del diagrama, rastreando la acción de cada puerta en las señales de entrada. La puerta NOT cambia P 0 a 1, por lo que ambas entradas a la puerta AND son 1; por lo tanto, la salida R es 1. Esto se ilustra anotando el diagrama como se muestra a continuación.





P 1 R

q



La salida de la puerta OR es 1 ya que una de las señales de entrada, P, es 1. La puerta NOT cambia este 1 en un 0, por lo que las dos entradas a la puerta AND son 0 y R 1. Por lo tanto, la salida S es 0. La traza se muestra a continuación.



PAG

q

S

R

■

Para construir la tabla completa de entrada/salida de un circuito, recorra el circuito para encontrar las señales de salida correspondientes para cada combinación posible de señales de entrada.



Ejemplo 2.4.2 Construcción de la tabla de entradas/salidas de un circuito

Construya la tabla de entradas/salidas para el siguiente circuito.



PAG

R



q













George Boole (1815–1864)







Nota Estrictamente hablando, sólo expresiones significativas como

( p q ) ( p r ) y

( ( p q ) r ) se permiten como booleanos, no sin sentido como

p q((rs q . Usamos la recursividad para dar una definición cuidadosa de las expresiones booleanas en la Sección 5.9.



Solución Enumere las cuatro combinaciones posibles de señales de entrada y encuentre la salida para cada una rastreando el circuito.

















■







La expresión booleana correspondiente a un circuito

En lógica, variables como p, q y r representan declaraciones, y una declaración puede tener uno de solo dos valores de verdad: T (verdadero) o F (falso). Una forma de enunciado es una expresión, como p (q r), compuesta de variables enunciativas y conectivos lógicos.

Como se señaló anteriormente, uno de los fundadores de la lógica simbólica fue el matemático inglés George Boole. En su honor, cualquier variable, como una variable de declaración o una señal de entrada, que puede tomar uno de sólo dos valores se llama variable booleana. Una expresión compuesta de variables booleanas y los conectivos , y se llama expresión booleana.

Dado un circuito que consta de puertas NOT, AND y OR combinadas, se puede obtener una expresión booleana correspondiente rastreando las acciones de las puertas sobre las variables de entrada.





Ejemplo 2.4.3 Encontrar una expresión booleana para un circuito

Encuentre las expresiones booleanas que corresponden a los circuitos que se muestran a continuación. Un punto indica una soldadura de dos cables; Se supone que los cables que se cruzan sin un punto no se tocan.



PAG

q



R







Solución



(b)



Trace el circuito de izquierda a derecha, indicando simbólicamente la salida de cada puerta, como se muestra a continuación.



PAG

Q (P ∨ Q) ∧ ~(P ∧ Q)







La expresión final obtenida, ( P Q) ( P Q), es la expresión para o exclusivo: P o Q pero no ambos.





La expresión booleana correspondiente al circuito es (P Q) R, como se muestra a continuación.





P P ∧ Q

Q~R



R



   (P∧Q)∧~R





■



Observe que la salida del circuito que se muestra en el ejemplo 2.4.3(b) es 1 para exactamente una combinación de entradas (P 1, Q 1 y R 0) y es 0 para todas las demás combinaciones de entradas. Por esta razón, se puede decir que el circuito "reconoce" una combinación particular de entradas. La columna de salida de la tabla de entrada/salida tiene un 1 exactamente en una fila y 0 en todas las demás filas.





Tabla de entrada/salida para un reconocedor





El circuito correspondiente a una expresión booleana

Los ejemplos anteriores mostraron cómo encontrar una expresión booleana correspondiente a un circuito. El siguiente ejemplo muestra cómo construir un circuito correspondiente a una expresión booleana.



Ejemplo 2.4.4 Construcción de circuitos para expresiones booleanas

Construya circuitos para las siguientes expresiones booleanas.

a. (∼P ∧ Q) ∨ ∼Q b. ((P ∧ Q) ∧ (R ∧ S)) ∧ T

Solución

Escriba las variables de entrada en una columna en el lado izquierdo del diagrama. Luego ve desde el lado derecho del diagrama hacia la izquierda, trabajando desde la parte más externa de la expresión hasta la parte más interna. Dado que la última operación ejecutada al evaluar (∼P ∧ Q) ∨ ∼Q es ∨, coloque una puerta OR en el extremo derecho del diagrama. Una entrada a esta puerta es ∼P ∧ Q, así que dibuje una puerta AND a la izquierda de la puerta OR y muestre su





salida que entra por la puerta OR. Dado que una entrada a la puerta AND es P, dibuje una línea desde P hasta una puerta NOT y desde allí hasta la puerta AND. Dado que la otra entrada a la puerta AND es Q, dibuje una línea desde Q directamente a la puerta AND. La otra entrada a la puerta OR es Q, así que dibuje una línea desde Q hasta una puerta NOT y desde la puerta NOT hasta la puerta OR. El circuito que obtienes se muestra a continuación.



P Q







Para comenzar a construir este circuito, coloque una puerta Y en el extremo derecho entre (( P Q) (R S)) y T. A la izquierda de esto coloque la puerta AND correspondiente a entre P Q y R S. A la izquierda de esto coloque las puertas AND correspondientes a entre P y Q y entre R y S. El circuito es se muestra en la Figura 2.4.4.



P Q R S T

Figura 2.4.4 ■





Del Teorema 2.1.1 se deduce que todas las formas de agregar paréntesis a

P ∧ Q ∧ R ∧ S ∧ T son lógicamente equivalentes. Así, por ejemplo,

(( P ∧ Q) ∧ (R ∧ S)) ∧ T ≡ ( P ∧ (Q ∧ R)) ∧ (S ∧ T ).

También se deduce que el circuito de la Figura 2.4.5, que corresponde a ( P ∧ (Q ∧ R)) ∧ (S ∧ T ), tiene la misma tabla de entradas/salidas que el circuito de la Figura 2.4.4, que corresponde a (( P ∧ Q) ∧ (R ∧ S)) ∧ T .



P Q R S T

Figura 2.4.5



Cada uno de los circuitos de las Figuras 2.4.4 y 2.4.5 es, por lo tanto, una implementación de la expresión P Q R S T. Un circuito de este tipo se denomina puerta AND de entradas múltiples y está representado por el diagrama que se muestra en la Figura 2.4.6. Las puertas OR de múltiples entradas se construyen de manera similar.





PQR

CALLE

Figura 2.4.6





Encontrar un circuito que corresponda a una tabla de entrada/salida determinada

Hasta este punto, hemos analizado cómo construir la tabla de entrada/salida para un circuito, cómo encontrar la expresión booleana correspondiente a un circuito dado y cómo construir el circuito correspondiente a una expresión booleana dada. Ahora abordamos la cuestión de cómo diseñar un circuito (o encontrar una expresión booleana) correspondiente a una tabla de entrada/salida dada. La forma de hacerlo es juntar varios reconocedores en paralelo.

Ejemplo 2.4.5 Diseño de un circuito para una tabla de entrada/salida determinada

Diseñe un circuito para la siguiente tabla de entradas/salidas:



Solución Primero construya una expresión booleana con esta tabla como tabla de verdad. Para hacer esto, identifique cada fila cuyo resultado sea 1; en este caso, la primera, tercera y cuarta filas. Para cada una de esas filas, construya una expresión y que produzca un 1 (o verdadero) para la combinación exacta de valores de entrada para esa fila y un 0 (o falso) para todas las demás combinaciones de valores de entrada. Por ejemplo, la expresión para la primera fila es P Q R porque P Q R es 1 si P 1 y Q 1 y R 1, y es 0 para todos los demás valores de P, Q y R. La expresión para la tercera fila es P Q R porque P Q R es 1 si P 1 y Q 0 y R 1, y es 0 para todos los demás valores de P, Q y R. De manera similar, la expresión para la cuarta fila es P Q R.

Ahora cualquier expresión booleana con la tabla dada como tabla de verdad tiene el valor 1 en el caso P Q R 1, o en el caso P Q R 1, o en el caso P Q R 1, y en ningún otro caso. De ello se deduce que una expresión booleana con la tabla de verdad dada es

( P ∧ Q ∧ R) ∨ ( P ∧ ∼Q ∧ R) ∨ ( P ∧ ∼Q ∧ ∼R). 2.4.5

El circuito correspondiente a esta expresión tiene el diagrama que se muestra en la Figura 2.4.7. Observe que la expresión (2.4.5) es una disyunción de términos que son en sí mismos conjunciones en las que aparecen uno de P o P, uno de Q o Q y uno de R o R. Se dice que tales expresiones están en forma normal disyuntiva o en forma de suma de productos.





PQR





























Figura 2.4.7 ■

Simplificación de circuitos combinacionales

Considere los dos circuitos combinacionales que se muestran en la Figura 2.4.8.



PAG



q

R







(a)



PAG

R

q



Figura 2.4.8



Si recorre el circuito (a), encontrará que su tabla de entrada/salida es





que es la misma que la tabla de entradas/salidas para el circuito (b). Así, estos dos circuitos hacen el mismo trabajo en el sentido de que transforman las mismas combinaciones de señales de entrada.



 

en las mismas señales de salida. Sin embargo, el circuito (b) es más simple que el circuito (a) porque contiene Hay muchas menos puertas lógicas. Por tanto, como parte de un circuito integrado, ocuparía menos espacio y requeriría menos energía.





Dado que las formas de enunciados lógicamente equivalentes tienen tablas de verdad idénticas, se puede determinar que dos circuitos son equivalentes encontrando las expresiones booleanas correspondientes a los circuitos y demostrando que estas expresiones, consideradas como formas de enunciados, son lógicamente equivalentes. El ejemplo 2.4.6 muestra cómo funciona este procedimiento para los circuitos (a) y (b) de la figura 2.4.8.



Ejemplo 2.4.6 Demostración de que dos circuitos son equivalentes

Encuentre las expresiones booleanas para cada circuito en la Figura 2.4.8. Utilice el teorema 2.1.1 para demostrar que estas expresiones son lógicamente equivalentes cuando se consideran formas de enunciado.

Solución Las expresiones booleanas que corresponden a los circuitos (a) y (b) son

(( P ∧ ∼Q) ∨ ( P ∧ Q)) ∧ Q y P ∧ Q, respectivamente. Por el teorema 2.1.1,

(( P ∧ ∼Q) ∨ ( P ∧ Q)) ∧ Q

≡ ( P ∧ (∼Q ∨ Q)) ∧ Q por la ley distributiva

≡ ( P ∧ (Q ∨ ∼Q)) ∧ Q por la ley conmutativa para ∨

≡ ( P ∧ t) ∧ Q por la ley de negación

≡ P ∧ Q por la ley de identidad.

De ello se deduce que las tablas de verdad para (( P Q) ( P Q)) Q y P Q son las mismas. Por lo tanto, las tablas de entrada/salida para los circuitos correspondientes a estas expresiones también son las mismas y, por tanto, los circuitos son equivalentes. ■



En general, se puede simplificar un circuito combinacional encontrando la expresión booleana correspondiente, usando las propiedades enumeradas en el teorema 2.1.1 para encontrar una expresión booleana que sea más corta y lógicamente equivalente (cuando ambas se consideran formas de enunciado). y construir el circuito correspondiente a esta expresión booleana más corta.









HM Sheffer (1882-1964)



Puertas NAND y NOR

Otra forma de simplificar un circuito es encontrar un circuito equivalente que utilice el menor número de tipos diferentes de puertas lógicas. Dos puertas no introducidas anteriormente son particularmente útiles para esto: las puertas NAND y las puertas NOR. Una puerta NAND es una puerta única que actúa como una puerta AND seguida de una puerta NOT. Una puerta NOR actúa como una puerta O seguida de una puerta NOT. Así, la señal de salida de una puerta NAND es 0 cuando, y sólo cuando, ambas señales de entrada son 1, y la señal de salida de una puerta NOR es 1 cuando, y sólo cuando, ambas señales de entrada son 0. Los símbolos lógicos correspondientes a estas puertas están (para NAND) y (para NOR), donde se llama trazo de Sheffer (en honor a H. M. Sheffer, 1882–1964) y se llama flecha de Peirce (en honor a C. S. Peirce, 1839–1914; consulte la página 101). De este modo



P | Q ≡ ∼( P ∧ Q) y P ↓ Q ≡ ∼( P ∨ Q).





La siguiente tabla resume las acciones de las puertas NAND y NOR.



Se puede demostrar que cualquier expresión booleana equivale a una escrita enteramente con trazos de Sheffer o enteramente con flechas de Peirce. Por lo tanto, cualquier circuito lógico digital es equivalente a uno que utiliza sólo puertas NAND o sólo puertas NOR. El ejemplo 2.4.7 desarrolla parte de la derivación de este resultado; el resto se deja para los ejercicios.



Ejemplo 2.4.7 Reescribir expresiones usando el trazo de Sheffer

Utilice el teorema 2.1.1 y la definición del trazo de Sheffer para demostrar que

a. ∼P≡P| P y b. P ∨ Q ≡ (P | P) | (Q|Q).

Solución

∼P ≡ ∼( P ∧ P) por la ley idempotente para ∧

≡ PAG | P por definición de |.

P ∨ Q ≡ ∼(∼( P ∨ Q)) por la doble ley negativa

≡ ∼(∼P ∧ ∼Q) por las leyes de De Morgan

≡ ∼(( P | P) ∧ (Q | Q)) por la parte (a)

≡ (P | P) | (Q | Q) por definición de |. ■





Pruébate

La tabla de entradas/salidas para un circuito lógico digital es una tabla que muestra.

La expresión booleana que corresponde a un circuito lógico digital es.

Un reconocedor es un circuito lógico digital que.







Dos circuitos lógicos digitales son equivalentes si, y sólo si,

Una puerta NAND se construye colocando una puerta inmediatamente después de otra.

Una puerta NOR se construye colocando una puerta inmediatamente después de otra.







Conjunto de ejercicios 2.4

Proporcione las señales de salida para los circuitos del 1 al 4 si las señales de entrada son las indicadas.

PAG







18.



R



q





señales de entrada: P = 1 y Q = 1

PAG

QR









señales de entrada: P = 1 y Q = 0

PAG



QS



R

señales de entrada: P = 1, Q = 0, R = 0

PAG

QS





R

señales de entrada: P = 0, Q = 0, R = 0

En 5-8, escriba una tabla de entradas/salidas para el circuito en el ejercicio al que se hace referencia.

Ejercicio 1 6. Ejercicio 2

7. Ejercicio 3 8. Ejercicio 4



En 9-12, encuentre la expresión booleana que corresponde al circuito en el ejercicio al que se hace referencia.

9. Ejercicio 1 10. Ejercicio 2

Ejercicio 3 12. Ejercicio 4



Construya circuitos para las expresiones booleanas del 13 al 17.

13. ∼P ∨ Q 14. ∼(P ∨ Q)

15. P ∨ (∼P ∧ ∼Q) 16. (P ∧ Q) ∨ ∼R

17. (P ∧ ∼Q) ∨ (∼P ∧ R)

Para cada una de las tablas de 18 a 21, construya (a) una expresión booleana que tenga la tabla dada como tabla de verdad y (b) un circuito que tenga la tabla dada como tabla de entrada/salida.















19.

























20.

























21.







Diseñe un circuito para tomar las señales de entrada P, Q y R y emitir un 1 si, y sólo si, P y Q tienen el mismo valor y Q y R tienen valores opuestos.

Diseñe un circuito para tomar las señales de entrada P, Q y R y emitir un 1 si, y sólo si, las tres P, Q y R tienen el mismo valor.

Las luces en un salón de clases están cont.accionado por dos interruptores: uno en la parte trasera y otro en la parte delantera de la habitación. Al mover cualquiera de los interruptores a la posición opuesta, las luces se apagan si están encendidas y se encienden si están apagadas. Suponga que las luces se han instalado de modo que cuando ambos interruptores estén en la posición hacia abajo, las luces estén apagadas. Diseñar un circuito para controlar los interruptores.

Un sistema de alarma tiene tres paneles de control diferentes en tres ubicaciones diferentes. Para habilitar el sistema, los interruptores en al menos dos de los paneles deben estar en la posición de encendido. Si hay menos de dos en la posición de encendido, el sistema está desactivado. Diseñar un circuito para controlar los interruptores.

Utilice las propiedades enumeradas en el teorema 2.1.1 para demostrar que cada par de circuitos de 26 a 29 tiene la misma tabla de entrada/salida. (Encuentre las expresiones booleanas para los circuitos y demuestre que son lógicamente equivalentes cuando se consideran formas de enunciado).



a. PAG

q



b. P Q



b. P Q





29. a. PAG

q



















b. P Q



Para los circuitos correspondientes a las expresiones booleanas en 30 y 31 hay un circuito equivalente con como máximo dos puertas lógicas. Encuentra tal circuito.

30. (P ∧ Q) ∨ (∼P ∧ Q) ∨ (∼P ∧ ∼Q)

31. (∼P ∧ ∼Q) ∨ (∼P ∧ Q) ∨ (P ∧ ∼Q)

La expresión booleana para el circuito del ejemplo 2.4.5 es

( P ∧ Q ∧ R) ∨ ( P ∧ ∼Q ∧ R) ∨ ( P ∧ ∼Q ∧ ∼R)

(una forma normal disyuntiva). Encuentre un circuito con como máximo tres puertas lógicas que sea equivalente a este circuito.

a. Demuestre que para el trazo de Sheffer |,



a. PAG



NO









Y









NO





Y



PAG ∧ Q ≡ (PAG | Q) | (P | Q).

b. Utilice los resultados del Ejemplo 2.4.7 y la parte (a) anterior para



q



b. P Q



a. PAG



escribe P ∧ (∼Q ∨ R) usando solo trazos de Sheffer.

Demuestre que las siguientes equivalencias lógicas son válidas para la flecha de Peirce ↓, donde P ↓ Q ≡ ∼( P ∨ Q).

a. ∼P ≡P ↓P

b. PAG ∨ Q ≡ ( PAG ↓ Q) ↓ ( PAG ↓ Q)

C. P ∧ Q ≡ ( P ↓ P) ↓ (Q ↓ Q)



H d. Escribe P → Q usando únicamente las flechas de Peirce.

P e. Escribe P ↔ Q usando únicamente las flechas de Peirce.





Respuestas para Ponte a prueba

1. la(s) señal(es) de salida que corresponden a todas las combinaciones posibles de señales de entrada al circuito 2. una expresión booleana que representa las señales de entrada como variables e indica las acciones sucesivas de las puertas lógicas sobre las señales de entrada 3. salidas a 1 para exactamente una combinación particular de señales de entrada y salidas 0 para todas las demás combinaciones 4. tienen la misma tabla de entrada/salida 5. NO; Y 6. NO; O







Contar en binario es como contar en decimal si eres todo pulgares. - Glaser y Camino



En la escuela primaria, aprendiste el significado de la notación decimal: que para interpretar una cadena de dígitos decimales como un número, multiplicas mentalmente cada dígito por su valor posicional. Por ejemplo, 5049 tiene un 5 en el lugar de las millares, un 0 en el lugar de las centenas, un 4 en el lugar de las decenas y un 9 en el lugar de las unidades. De este modo

5.049 = 5 · (1.000) + 0 · (100) + 4 · (10) + 9 · (1).

Usando notación exponencial, esta ecuación se puede reescribir como

5.049 = 5 · 103 + 0 · 102 + 4 · 101 + 9 · 100.

De manera más general, la notación decimal se basa en el hecho de que cualquier número entero positivo puede escribirse únicamente como una suma de productos de la forma

d·10n,

donde cada n es un número entero no negativo y cada d es uno de los dígitos decimales 0, 1, 2, 3, 4, 5, 6, 7, 8 o 9. La palabra decimal proviene de la raíz latina deci, que significa "diez". .” La notación decimal (o base 10) expresa un número como una cadena de dígitos en la que la posición de cada dígito indica la potencia de 10 por la que se multiplica. La posición más a la derecha es el lugar de las unidades (o el lugar 100), a la izquierda está el lugar de las decenas (o el lugar 101), a la izquierda está el lugar de las centenas (o el lugar 102), y así sucesivamente, como ilustrado a continuación.





Representación binaria de números

No hay nada sagrado en el número 10; Usamos 10 como base para nuestro sistema numérico habitual porque resulta que tenemos diez dedos. De hecho, cualquier número entero mayor que 1 puede servir como base para un sistema numérico. En informática, la notación de base 2, o notación binaria, es de especial importancia porque las señales utilizadas en la electrónica moderna siempre están en uno de dos estados. (La raíz latina bi significa "dos").

En la Sección 5.4, mostramos que cualquier número entero se puede representar de forma única como una suma de productos de la forma

d·2n,

donde cada n es un número entero y cada d es uno de los dígitos binarios (o bits) 0 o 1. Por ejemplo,





27 = 16 + 8 + 2 + 1

= 1 · 24 + 1 · 23 + 0 · 22 + 1 · 21 + 1 · 20.

En notación binaria, como en notación decimal, escribimos solo los dígitos binarios y no las potencias de la base. Entonces, en notación binaria,





1 · 24 + 1



· 23+0



· 22+1



· 21+1



· 20





2710 = 1 1 0 1 1 2



donde los subíndices indican la base, ya sea 10 o 2, en la que está escrito el número. Los lugares en notación binaria corresponden a las diversas potencias de 2. La posición más a la derecha es el lugar de las unidades (o el lugar 20), a la izquierda está el lugar de los dos (o el lugar 21), a la izquierda de ese está el lugar de cuatro (o lugar de 22), y así sucesivamente, como se ilustra a continuación.





Al igual que en la notación decimal, se pueden agregar o eliminar ceros a la izquierda según se desee. Por ejemplo,

00310 = 310 = 1 · 21 + 1 · 20 = 112 = 0112.



Ejemplo 2.5.1 Binario Notación para números enteros del 1 al 9

Derive la notación binaria para los números enteros del 1 al 9.

Solución 110 = 1 · 20 = 12

210 = 1 · 21 + 0 · 20 = 102

310 = 1 · 21 + 1 · 20 = 112

410 = 1 · 22 + 0 · 21 + 0 · 20 = 1002

510 = 1 · 22 + 0 · 21 + 1 · 20 = 1012

610 = 1 · 22 + 1 · 21 + 0 · 20 = 1102

710 = 1 · 22 + 1 · 21 + 1 · 20 = 1112

810 = 1 · 23 + 0 · 22 + 0 · 21 + 0 · 20 = 10002

910 = 1 · 23 + 0 · 22 + 0 · 21 + 1 · 20 = 10012 ■

Una lista de potencias de 2 es útil para realizar conversiones de binario a decimal y de decimal a binario. Ver Tabla 2.5.1.



Tabla 2.5.1 Potencias de 2







Ejemplo 2.5.2 Conversión de un número binario a decimal

Representa 1101012 en notación decimal.

Solución 1101012 = 1 · 25 + 1 · 24 + 0 · 23 + 1 · 22 + 0 · 21 + 1 · 20

= 32 + 16 + 4 + 1

= 5310

Alternativamente, se puede utilizar el siguiente esquema.







1 1 0



1 0 12

  → 1 · 1 = 1



  → 0 · 2 = 0

  → 1 · 4 = 4

  → 0 · 8 = 0

  → 1 · 16 = 16

  → 1 · 32 = 32

5310 ■

Ejemplo 2.5.3 Conversión de un número decimal a binario

Representa 209 en notación binaria.

Solución Utilice la tabla 2.5.1 para escribir 209 como una suma de potencias de 2, comenzando con la potencia más alta de 2 que es menor que 209 y continuando con potencias más bajas.

Como 209 está entre 128 y 256, la potencia más alta de 2 que es menor que 209 es 128.

Por eso

20910 = 128 + un número menor.

Ahora 209 128 81, y 81 está entre 64 y 128, por lo que la potencia más alta de 2 es

menos de 81 es 64. Por lo tanto

20910 = 128 + 64 + un número menor.

Continuando de esta manera se obtiene 20910 = 128 + 64 + 16 + 1

= 1 · 27 + 1 · 26 + 0 · 25 + 1 · 24 + 0 · 23 + 0 · 22 + 0 · 21 + 1 · 20.

Por cada potencia de 2 que se presenta en la suma, hay un 1 en la posición correspondiente del número binario. Por cada potencia de 2 que falta en la suma, hay un 0 en la posición correspondiente del número binario. De este modo

20910 = 110100012 ■













¡Precaución! No lea 102 como “diez”; es el número dos. Lea 102 como "uno oh base dos".



En la Sección 5.1 se analiza otro procedimiento para convertir de notación decimal a binaria.



Suma y resta binaria

Los métodos computacionales de la aritmética binaria son análogos a los de la aritmética decimal. En aritmética binaria el número 2 (102 en notación binaria) juega un papel similar al del número 10 en aritmética decimal.





Ejemplo 2.5.4 Suma en notación binaria

Suma 11012 y 1112 usando notación binaria.

Solución Debido a que 210 102 y 110 12, la traducción de 110 110 210 a notación binaria es

12

+ 12

102

De ello se deduce que la suma de dos unos da como resultado un acarreo de 1 cuando se utiliza la notación binaria. Sumar tres unos también da como resultado un acarreo de 1 desde 310 112 (“uno uno en base dos”).

12

+ 12

+ 12

112

Por tanto, la suma se puede realizar de la siguiente manera:

1 1 1 ← llevar fila

1 1 0 12

+ 1 1 12

1 0 1 0 02 ■





Ejemplo 2.5.5 Resta en notación binaria

Resta 10112 de 110002 usando notación binaria.

Solución En la resta decimal, el hecho de que 1010 110 910 se utiliza para tomar prestado en varias columnas. Por ejemplo, considere lo siguiente:

9 9

1 1 ← fila prestada

1 0 0 010

— 5 810

9 4 210

En la resta binaria también puede ser necesario tomar prestado en más de una columna.

Pero cuando tomas prestado un 12 de 102, lo que queda es 12.

102

— 12

12

Así, la resta se puede realizar de la siguiente manera:



0 1 1

1 1 1 ← fila prestada

1 1 0 0 02

— 1 0 1 12

1 1 0 12 ■





Circuitos para adición de computadoras

Considere la cuestión de diseñar un circuito para producir la suma de dos dígitos binarios P.

y Q. Tanto P como Q pueden ser 0 o 1. Y se conocen los siguientes hechos:

12 + 12 = 102,

12 + 02 = 12 = 012,

02 + 12 = 12 = 012,

02 + 02 = 02 = 002.

De ello se deduce que el circuito a diseñar debe tener dos salidas: una para el dígito binario izquierdo (esto se llama acarreo) y otra para el dígito binario derecho (esto se llama suma). La salida de acarreo es 1 si tanto P como Q son 1; en caso contrario es 0. Por lo tanto, el acarreo se puede producir usando el circuito de puerta AND que corresponde a la expresión booleana P Q. La suma de salida es 1 si P o Q, pero no ambos, es 1. Por lo tanto, la suma se puede producir usando un circuito que corresponde a la expresión booleana para exclusivo o: ( P Q) ( P Q). (Véase el Ejemplo 2.4.3(a).) Por lo tanto, se puede construir un circuito para sumar dos dígitos binarios P y Q como en la Figura 2.5.1. Este circuito se llama medio sumador.



MEDIA SUMADORA

Tabla de entrada/salida del circuito





PAG

Q suma



Llevar



Figura 2.5.1 Circuito para sumar P + Q, donde P y Q son dígitos binarios

Consideremos ahora la cuestión de cómo construir un circuito para sumar dos enteros binarios, cada uno con más de un dígito. Debido a que la suma de dos dígitos binarios puede resultar en un acarreo a la siguiente columna a la izquierda, puede ser necesario agregar tres dígitos binarios en ciertos puntos. En el siguiente ejemplo, la suma de la columna de la derecha es la suma de dos dígitos binarios y, debido al acarreo, la suma de la columna de la izquierda es la suma de tres dígitos binarios.

1 ← llevar fila

1 12

+ 1 12

1 1 02

Por lo tanto, para construir un circuito que sume números binarios de varios dígitos, es necesario Es necesario incorporar un circuito que calcule la suma de tres dígitos binarios. Un circuito de este tipo se llama sumador completo. Considere una suma general de tres dígitos binarios P, Q y R que da como resultado un acarreo (o dígito más a la izquierda) C y una suma (o dígito más a la derecha) S.

PAG

+Q

+R

CS

El funcionamiento del sumador completo se basa en el hecho de que la suma es una operación binaria: sólo se pueden sumar dos números a la vez. Por lo tanto, primero se suma P a Q y luego





El resultado se suma a R. Por ejemplo, considere la siguiente suma:



12 12 + 02 = 012 ⎫⎬ 1 + 1









= 10







+ 02

+ 2

102

El proceso ilustrado aquí se puede dividir en pasos que utilizan circuitos de medio sumador. Paso 1: Suma P y Q usando un medio sumador para obtener un número binario con dos dígitos.

PAG

+ Q C1 S1



Paso 2: Suma R a la suma C1 S1 de P y Q.

C1 S1

+R

Para ello proceda de la siguiente manera:

Paso 2a: Suma R a S1 usando un medio sumador para obtener el número de dos dígitos C2 S.

T1

+ R C2 S

Entonces S es el dígito más a la derecha de la suma total de P, Q y R.

Paso 2b: Determine el dígito más a la izquierda, C, de la suma total de la siguiente manera: Primero, observe que es imposible que C1 y C2 sean unos. Porque si C1 1, entonces P y Q son ambos 1, por lo que S1 0. En consecuencia, la suma de S1 y R da un número binario C2 S1 donde C2 0. A continuación observe que C será un 1 en el caso de que la suma de P y Q da un acarreo de 1 o en el caso de que la suma de S1 (el dígito más a la derecha de P Q) y R da un acarreo de 1. En otras palabras, C 1 si, y sólo si, C1 1 o C2 1. De ello se deduce que el circuito que se muestra en la Figura 2.5.2 calculará la suma de tres dígitos binarios.



sumador completo

Tabla de entrada/salida del circuito



PAG

S



q







RT













Figura 2.5.2 Circuito para sumar P + Q + R, donde P, Q y R son dígitos binarios





Se pueden usar dos sumadores completos y un medio sumador juntos para construir un circuito que sumará dos números binarios de tres dígitos PQR y STU para obtener la suma WXY Z. Esto se ilustra en la Figura 2.5.3. Un circuito de este tipo se llama sumador paralelo. Se pueden construir sumadores paralelos para sumar números binarios de cualquier longitud finita.



S1 = Z



Ud.



S2 = Y

QT



S3 = X

PAG

C3 = W

Figura 2.5.3 Un sumador paralelo para sumar P Q R y STU para obtener WXY Z



Los complementos a dos y la representación informática de números enteros negativos

Normalmente, se utiliza un número fijo de bits para representar números enteros en una computadora, y estos son necesarios para representar números enteros negativos y no negativos. A veces, un bit concreto, normalmente el situado más a la izquierda, se utiliza como indicador de signo, y los bits restantes se consideran el valor absoluto del número en notación binaria. El problema con este enfoque es que los procedimientos para sumar los números resultantes son algo complicados y la representación de 0 no es única. Un enfoque más común, que utiliza complementos a dos, permite sumar números enteros con bastante facilidad y da como resultado una representación única para 0. El complemento a dos de un número entero relativo a una longitud de bits fija se define de la siguiente manera:





Las longitudes de bits de 16 y 32 son las más utilizadas en la práctica. Sin embargo, debido a que los principios son los mismos para todas las longitudes de bits, utilizamos una longitud de bits de 8 para simplificar esta discusión. Por ejemplo, porque

(28 − 27)10 = (256 − 27)10 = 22910 = (128 + 64 + 32 + 4 + 1)10 = 111001012,

el complemento a dos de 8 bits de 27 es 111001012.

Resulta que existe una forma conveniente de calcular los complementos a dos que implica menos aritmética que la aplicación directa de la definición. Para una representación de 8 bits, se basa en tres hechos:













Por ejemplo, por (2) y (3), con a = 27,



−

Los 0 y 1 se intercambian







28 - 1



27





(28 − 1) − 27 2.5.1





y así en notación binaria la diferencia (28 − 1) − 27 es 111001002. Pero por (1) con a = 27, 28 − 27 = [(28 − 1) − 27]+ 1, y así si sumamos 1 a (2.5.1), obtenemos la representación binaria de 8 bits de 28 − 27, que es el complemento a dos de 8 bits de 27:



(28-1)-27



+





En general,







1



28 - 27









Ejemplo 2.5.6 Encontrar el complemento a dos

Encuentre el complemento a dos de 19 de 8 bits.

Solución Escriba la representación binaria de 8 bits para 19, cambie todos los 0 por 1 y todos los 1 por 0 y sume 1.



1910 = (16 + 2 + 1)10 = 000100112

Para comprobar este resultado, tenga en cuenta que



voltear los bits



11101100



−−−−→



11101101



111011012 = (128 + 64 + 32 + 8 + 4 + 1)10 = 23710 = (256 − 19)10

= (28 - 19)10,

que es el complemento a dos de 19. ■







Observa eso porque





28 − (28 − un) = un



el complemento a dos del complemento a dos de un número es el número mismo y, por lo tanto,





Ejemplo 2.5.7 Encontrar un número con complemento a dos dado

¿Cuál es la representación decimal del número entero en complemento a dos 10101001?

Solución



101010012



voltear los bits



01010110

−−−−→





010101112 = (64 + 16 + 4 + 2 + 1)10 = 8710



Para comprobar este resultado, tenga en cuenta que el número dado es

101010012 = (128 + 32 + 8 + 1)10 = 16910 = (256 − 87)10 = (28 − 87)10,

que es el complemento a dos de 87. ■

Representación de 8 bits de un número

Consideremos ahora el complemento a dos de un número entero n que satisface la desigualdad ty 1 sustantivo, masculino—

128. Entonces







y



1 n 128 porque multiplicar por 1 es inverso

la dirección de la desigualdad





28 − 1 ≥ 28 − n ≥ 28 − 128 sumando 28 a todas las partes de la desigualdad.



Pero 28 − 128 = 256 − 128 = 128 = 27. Por tanto

27 ≤ complemento a dos de n < 28.

De ello se deduce que el complemento a dos de 8 bits de un número entero del 1 al 128 tiene un bit inicial de 1. Tenga en cuenta también que la representación ordinaria de 8 bits de un número entero del 0 al 127 tiene un bit inicial de 0. En consecuencia, ocho bits se puede utilizar para representar enteros negativos y no negativos representando cada entero no negativo hasta 127 usando notación binaria ordinaria de 8 bits y representando cada entero negativo desde −1 hasta −128 como complemento a dos de su valor absoluto. Es decir, para cualquier número entero a desde −128 hasta 127,







Las representaciones se ilustran en la Tabla 2.5.2.



Tabla 2.5.2







Suma informática con números enteros negativos

A continuación se muestra un ejemplo de cómo los complementos a dos permiten que los circuitos de suma realicen restas. Supongamos que desea calcular 72 54. Primero tenga en cuenta que esto es lo mismo que 72

(54), y las representaciones binarias de 8 bits de 72 y 54 son 01001000 y 11001010, respectivamente. Entonces, si sumas las representaciones binarias de 8 bits para ambos números, obtienes

0 1 0 0 1 0 0 0

+ 1 1 0 0 1 0 1 0

1 0 0 0 1 0 0 1 0

Y si truncas el 1 inicial, obtienes 00010010. Esta es la representación binaria de 8 bits para 18, ¡que es la respuesta correcta!

La siguiente descripción explica cómo utilizar este método para sumar dos números enteros cualesquiera entre −128 y 127. Se generaliza fácilmente para aplicarlo a representaciones de 16 y 32 bits para sumar números enteros entre aproximadamente −2.000.000.000 y 2.000.000.000.







Para ver por qué este resultado es cierto, considere cuatro casos: (1) ambos números enteros no son negativos,

un número entero no negativo y el otro es negativo y el valor absoluto del entero no negativo es menor que el del negativo, (3) un número entero no negativo y el otro es negativo y el valor absoluto del entero negativo es menor que o igual al del no negativo, y (4) ambos números enteros son negativos.



Caso 1 (ambos enteros no negativos): este caso es fácil porque si dos enteros no negativos de 0 a 127 se escriben en sus representaciones de 8 bits y si su suma también está en el rango de 0 a 127, entonces la representación de 8 bits de su suma tiene un 0 inicial y, por lo tanto, se interpreta correctamente como un entero no negativo. El siguiente ejemplo ilustra lo que sucede cuando se suman 38 y 69.



38

+

69



107



Los casos (2) y (3) implican sumar un número entero negativo y uno no negativo. Para ser concretos, supongamos que el entero no negativo sea a y el entero negativo −b y supongamos que tanto a como −b están en el rango de −128 a 127. La observación crucial es que sumar las representaciones de 8 bits de a y −b es equivalente a la informática

a + (28 - segundo)

porque la representación de 8 bits de −b es la representación binaria de 28 − b.

Caso 2 (a es no negativo y −b es negativo y |a| < |b|): En este caso, observe que a = |a| < |b|= by

a + (28 − b) = 28 − (b − a),

y la representación binaria de este número es la representación de 8 bits de (b a)

un (b). Debemos tener cuidado de comprobar que 28 (b a) está entre 27 y 28. Pero es

porque

27 = 28 − 27 ≤ 28 − (b − a) < 28 ya que 0 < b − a ≤ b ≤ 128 = 27.

Por lo tanto, en caso |a| < |b|, sumando las representaciones de 8 bits de a y −b se obtiene la representación de 8 bits de a + (−b).

Ejemplo 2.5.8 Calcular a + (−b) Donde 0 ≤ a < b ≤ 128

Utilice representaciones de 8 bits para calcular 39 + (−89).

Solución

Paso 1: Cambie de representaciones decimales a 8 bits usando el complemento a dos para representar 89.

Dado que 3910 (32 4 2 1)10 1001112, la representación de 8 bits de 39 es 00100111. Ahora la representación de 8 bits de 89 es el complemento a dos de

89. Esto se obtiene de la siguiente manera:



8910 = (64 + 16 + 8 + 1)10 = 010110012



voltear los bits

10100110





−−−−→





10100111





Entonces, la representación de 8 bits de −89 es 10100111.

Paso 2: agregue las representaciones de 8 bits en notación binaria y trunque el 1 en la posición 28, si la hay:



+





No hay 1 en la posición 28 para truncar →



Paso 3: Encuentra el equivalente decimal del resultado. Dado que su bit inicial es 1, este número es la representación de 8 bits de un entero negativo.



11001110



voltear los bits



00110001



−−−−→



00110010

↔ −(32 + 16 + 2)10 = −5010





Tenga en cuenta que, dado que 39 − 89 = −50, este procedimiento da la respuesta correcta. ■

Caso 3 (a es no negativo y −b es negativo y |b| ≤ |a|): En este caso, observe que b = |b|≤ |a|= a y

a + (28 - b) = 28 + (a - b).

También

28 ≤ 28 + (a − b) < 28 + 27 porque 0 ≤ a − b ≤ a < 128 = 27.

Entonces, la representación binaria de a (28 b) 28 (a b) tiene un 1 inicial en la novena (28.ª) posición. Este 1 inicial suele denominarse “desbordamiento” porque no cabe en el formato entero de 8 bits. Ahora restar 28 de 28 (a b) equivale a truncar el 1 inicial en la posición 28 de la representación binaria del número. Pero [a + (28 − b)] − 28 = 28 + (a − b) − 28 = a − b = a + (−b).

Por lo tanto, en el caso |a|≥ |b|, sumar las representaciones de 8 bits de a y −b y truncar el 1 inicial (que seguramente estará presente) da la representación de 8 bits de a + (−b).

Ejemplo 2.5.9 Calcular a + (−b) Donde 1 ≤ b ≤ a ≤ 127

Utilice representaciones de 8 bits para calcular 39 + (−25).

Solución

Paso 1: Cambie de representaciones decimales a 8 bits usando el complemento a dos para representar 25.

Como en el ejemplo 2.5.8, la representación de 8 bits de 39 es 00100111. Ahora la representación de 8 bits de 25 es el complemento a dos de 25, que se obtiene de la siguiente manera:



2510 = (16 + 8 + 1)10 = 000110012



voltear los bits

11100110





−−−−→





11100111



Entonces, la representación de 8 bits de −25 es 11100111.

Paso 2: agregue las representaciones de 8 bits en notación binaria y trunque el 1 en la posición 28, si la hay:





+





Truncar→ 1



Paso 3: Encuentra el equivalente decimal del resultado:

000011102 = (8 + 4 + 2)10 = 1410.

Como 39 − 25 = 14, esta es la respuesta correcta. ■



Caso 4 (ambos enteros son negativos): este caso implica sumar dos enteros negativos en el rango −1 a −128 cuya suma también está en este rango. Para ser específico, considere la suma (−a) + (−b) donde a, b y a + b están todos en el rango de 1 a 128. En este caso, las representaciones de 8 bits de −a y −b son las representaciones de 8 bits de 28 − a y 28 − b.

Entonces, si se suman las representaciones de 8 bits de −a y −b, el resultado es

(28 − a) + (28 − b) = [28 − (a + b)] + 28.

Recuerde que truncar un 1 inicial en la novena (28.ª) posición de un número binario equivale a restar 28. Entonces, cuando se trunca el 1 inicial de la representación de 8 bits de (28 − a) + (28 − b) , el resultado es 28 − (a + b), que es la representación de 8 bits de −(a + b) = (−a) + (−b). (En el ejercicio 37 se le pide que demuestre que la suma (28 − a) + (28 − b) tiene un 1 inicial en la novena (28.ª) posición.)



Ejemplo 2.5.10 Calcular (−a) + (−b) Donde 1 ≤ a, b ≤ 128 y 1 ≤ a + b ≤ 128

Utilice representaciones de 8 bits para calcular (−89) + (−25).

Solución

Paso 1: Cambie de representaciones decimales a 8 bits usando los complementos a dos para representar 89 y 25.

Las representaciones de 8 bits de 89 y 25 se mostraron en los Ejemplos 2.5.8 y

2.5.9 serán 10100111 y 11100111, respectivamente.

Paso 2: agregue las representaciones de 8 bits en notación binaria y trunque el 1 en la posición 28, si la hay:



+





Truncar→ 1



Paso 3: Encuentra el equivalente decimal del resultado. Debido a que su bit inicial es 1, este número es la representación de 8 bits de un entero negativo.



10001110



voltear los bits



01110001



−−−−→



011100102



↔ −(64 + 32 + 16 + 2)10 = −11410

Dado que (−89) + (−25) = −114, esa es la respuesta correcta. ■





Notación hexadecimal

Ahora debería ser obvio que los números escritos en notación binaria ocupan mucho más espacio que los números escritos en notación decimal. Sin embargo, muchos aspectos del funcionamiento de una computadora se pueden analizar mejor utilizando números binarios. La notación hexadecimal es incluso más compacta que la notación decimal, y es mucho más fácil convertir entre notación hexadecimal y binaria que entre notación binaria y decimal. La palabra hexadecimal proviene de la raíz griega hex-, que significa "seis", y de la raíz latina deci-, que significa "diez". Por lo tanto, hexadecimal se refiere a "dieciséis" y la notación hexadecimal también se denomina notación de base 16. La notación hexadecimal se basa en el hecho de que cualquier número entero se puede expresar de forma única como una suma de números de la forma

d·16n,

donde cada n es un número entero no negativo y cada d es uno de los números enteros del 0 al 15. Para evitar ambigüedades, cada dígito hexadecimal debe representarse mediante un solo símbolo. Los números enteros del 10 al 15 están representados por los símbolos A, B, C, D, E y F. Los dieciséis dígitos hexadecimales se muestran en la Tabla 2.5.3, junto con sus equivalentes decimales y, para referencia futura, sus números de 4 bits. equivalentes binarios.



Tabla 2.5.3







Ejemplo 2.5.11 Conversión de notación hexadecimal a decimal

Convierta 3CF16 a notación decimal.

Solución Aquí se puede utilizar un esquema similar al presentado en el ejemplo 2.5.2.







316 C16 F16



310 1210 1510

  →15 · 1 = 15

  →12 · 16 = 192

→ 3 256 768

97510



Entonces 3CF16 = 97510. ■

Ahora considere cómo convertir de notación hexadecimal a binaria. En el siguiente ejemplo, los números se reescriben usando potencias de 2 y se aplican las leyes de los exponentes. El resultado sugiere un procedimiento general.



C16 516 016 A16



1210 510 010 1010

  → 10 · 160 = (23 + 2) · 1 = 23 + 2 ya que 10 = 23 + 2

  → 0 · 161 = 0 · 24 = 0 ya que 161 = 24

  → 5 · 162 = (22 + 1) · 28 = 210 + 28 ya que 5 = 22 + 1, 162 = (24)2 = 28 y 22 · 28 = 210

→ 12 · 163 = (23 + 22) · 212 = 215 + 214 ya que 12 = 23 + 22, 162 = (24)3 = 212,

23 · 212 = 215 y 22 · 212 = 214

Pero

(215 + 214) + (210 + 28) + 0 + (23 + 2)

1100 0000 0000 00002 0101 0000 00002 por las reglas de escritura

numeros binarios.



+ 0000 00002 + 10102

Entonces

C50A16 = 1c1˛0 0I 0c1˛0 1I c00˛0 0I 10102











por las reglas para agregar





El procedimiento ilustrado en este ejemplo puede ser general.[a + (28 − b)] − 28 = 28 + (a − b) − 28 = a − b = a + (−b).

Por lo tanto, en el caso |a|≥ |b|, sumar las representaciones de 8 bits de a y −b y truncar el 1 inicial (que seguramente estará presente) da la representación de 8 bits de a + (−b).

Ejemplo 2.5.9 Calcular a + (−b) Donde 1 ≤ b ≤ a ≤ 127

Utilice representaciones de 8 bits para calcular 39 + (−25).

Solución

Paso 1: Cambie de representaciones decimales a 8 bits usando el complemento a dos para representar 25.

Como en el ejemplo 2.5.8, la representación de 8 bits de 39 es 00100111. Ahora la representación de 8 bits de 25 es el complemento a dos de 25, que se obtiene de la siguiente manera:



2510 = (16 + 8 + 1)10 = 000110012



voltear los bits

11100110





−−−−→





11100111



Entonces, la representación de 8 bits de −25 es 11100111.

Paso 2: agregue las representaciones de 8 bits en notación binaria y trunque el 1 en la posición 28, si la hay:





+





Truncar→ 1



Paso 3: Encuentra el equivalente decimal del resultado:

000011102 = (8 + 4 + 2)10 = 1410.

Como 39 − 25 = 14, esta es la respuesta correcta. ■



Caso 4 (ambos enteros son negativos): este caso implica sumar dos enteros negativos en el rango −1 a −128 cuya suma también está en este rango. Para ser específico, considere la suma (−a) + (−b) donde a, b y a + b están todos en el rango de 1 a 128. En este caso, las representaciones de 8 bits de −a y −b son las representaciones de 8 bits de 28 − a y 28 − b.

Entonces, si se suman las representaciones de 8 bits de −a y −b, el resultado es

(28 − a) + (28 − b) = [28 − (a + b)] + 28.

Recuerde que truncar un 1 inicial en la novena (28.ª) posición de un número binario equivale a restar 28. Entonces, cuando se trunca el 1 inicial de la representación de 8 bits de (28 − a) + (28 − b) , el resultado es 28 − (a + b), que es la representación de 8 bits de −(a + b) = (−a) + (−b). (En el ejercicio 37 se le pide que demuestre que la suma (28 − a) + (28 − b) tiene un 1 inicial en la novena (28.ª) posición.)



Ejemplo 2.5.10 Calcular (−a) + (−b) Donde 1 ≤ a, b ≤ 128 y 1 ≤ a + b ≤ 128

Utilice representaciones de 8 bits para calcular (−89) + (−25).

Solución

Paso 1: Cambie de representaciones decimales a 8 bits usando los complementos a dos para representar 89 y 25.

Las representaciones de 8 bits de 89 y 25 se mostraron en los Ejemplos 2.5.8 y

2.5.9 serán 10100111 y 11100111, respectivamente.

Paso 2: agregue las representaciones de 8 bits en notación binaria y trunque el 1 en la posición 28, si la hay:



+





Truncar→ 1



Paso 3: Encuentra el equivalente decimal del resultado. Debido a que su bit inicial es 1, este número es la representación de 8 bits de un entero negativo.



10001110



voltear los bits



01110001



−−−−→



011100102



↔ −(64 + 32 + 16 + 2)10 = −11410

Dado que (−89) + (−25) = −114, esa es la respuesta correcta. ■





Notación hexadecimal

Ahora debería ser obvio que los números escritos en notación binaria ocupan mucho más espacio que los números escritos en notación decimal. Sin embargo, muchos aspectos del funcionamiento de una computadora se pueden analizar mejor utilizando números binarios. La notación hexadecimal es incluso más compacta que la notación decimal, y es mucho más fácil convertir entre notación hexadecimal y binaria que entre notación binaria y decimal. La palabra hexadecimal proviene de la raíz griega hex-, que significa "seis", y de la raíz latina deci-, que significa "diez". Por lo tanto, hexadecimal se refiere a "dieciséis" y la notación hexadecimal también se denomina notación de base 16. La notación hexadecimal se basa en el hecho de que cualquier número entero se puede expresar de forma única como una suma de números de la forma

d·16n,

donde cada n es un número entero no negativo y cada d es uno de los números enteros del 0 al 15. Para evitar ambigüedades, cada dígito hexadecimal debe representarse mediante un solo símbolo. Los números enteros del 10 al 15 están representados por los símbolos A, B, C, D, E y F. Los dieciséis dígitos hexadecimales se muestran en la Tabla 2.5.3, junto con sus equivalentes decimales y, para referencia futura, sus números de 4 bits. equivalentes binarios.



Tabla 2.5.3







Ejemplo 2.5.11 Conversión de notación hexadecimal a decimal

Convierta 3CF16 a notación decimal.

Solución Aquí se puede utilizar un esquema similar al presentado en el ejemplo 2.5.2.







316 C16 F16



310 1210 1510

  →15 · 1 = 15

  →12 · 16 = 192

→ 3 256 768

97510



Entonces 3CF16 = 97510. ■

Ahora considere cómo convertir de notación hexadecimal a binaria. En el siguiente ejemplo, los números se reescriben usando potencias de 2 y se aplican las leyes de los exponentes. El resultado sugiere un procedimiento general.



C16 516 016 A16



1210 510 010 1010

  → 10 · 160 = (23 + 2) · 1 = 23 + 2 ya que 10 = 23 + 2

  → 0 · 161 = 0 · 24 = 0 ya que 161 = 24

  → 5 · 162 = (22 + 1) · 28 = 210 + 28 ya que 5 = 22 + 1, 162 = (24)2 = 28 y 22 · 28 = 210

→ 12 · 163 = (23 + 22) · 212 = 215 + 214 ya que 12 = 23 + 22, 162 = (24)3 = 212,

23 · 212 = 215 y 22 · 212 = 214

Pero

(215 + 214) + (210 + 28) + 0 + (23 + 2)

1100 0000 0000 00002 0101 0000 00002 por las reglas de escritura

numeros binarios.



+ 0000 00002 + 10102

Entonces

C50A16 = 1c1˛0 0I 0c1˛0 1I c00˛0 0I 10102











por las reglas para agregar





El procedimiento ilustrado en este ejemplo puede ser general. izado. De hecho, la siguiente secuencia de pasos siempre dará la respuesta correcta:







Ejemplo 2.5.12 Conversión de notación hexadecimal a binaria

Convierta B09F16 a notación binaria.

Solución B16 1110 10112, 016 010 00002, 916 910 10012 y F16 1510

11112. En consecuencia,

B 0 9 F



1011 0000 1001 1111

y la respuesta es 10110000100111112. ■



Para convertir números enteros escritos en notación binaria a notación hexadecimal, invierta los pasos del procedimiento anterior.





Ejemplo 2.5.13 Conversión de notación binaria a hexadecimal

Convierta 1001101101010012 a notación hexadecimal.

Solución Primero, agrupe los dígitos binarios en conjuntos de cuatro, trabajando de derecha a izquierda y agregando ceros a la izquierda si es necesario.

0100 1101 1010 1001.

Convierte cada grupo de cuatro dígitos binarios en un dígito hexadecimal.

0100 1101 1010 1001



4D A 9

Luego yuxtaponga los dígitos hexadecimales.

4DA916 ■



Ejemplo 2.5.14 Lectura de un volcado de memoria

La unidad de memoria direccionable más pequeña en la mayoría de las computadoras es un byte u ocho bits. En algunas operaciones de depuración se realiza un volcado del contenido de la memoria; es decir, el contenido de cada ubicación de memoria se muestra o imprime en orden. Para ahorrar espacio y hacer que la salida sea más agradable a la vista, se proporcionan las versiones hexadecimales del contenido de la memoria, en lugar de las versiones binarias. Supongamos, por ejemplo, que un segmento del volcado de memoria se parece a

A3 BB 59 2E.

¿Cuál es el contenido real de las cuatro ubicaciones de memoria?





Solución A316 = 101000112

BB16 = 101110112

5916 = 010110012

2E16 = 001011102 ■







Pruébate

Representar un número entero no negativo en notación binaria significa escribirlo como una suma de productos de la forma, donde.

Para sumar números enteros en notación binaria, se utilizan los hechos de que 12 + 12 = y 12 + 12 + 12 =.

Para restar números enteros en notación binaria, usas los hechos de que 102 − 12 = y 112 − 12 = .

Un medio sumador es un circuito lógico digital que

  , y un sumador completo es un circuito lógico digital que .

El complemento a dos de 8 bits de un entero positivo a

es	.







Para encontrar el complemento a dos de 8 bits de un entero positivo a

es decir, como máximo 255, usted, y.

Si a es un número entero con −128 ≤ a ≤ 127, la representación de 8 bits de a es si a ≥ 0 y es si a < 0.

Para sumar dos números enteros en el rango de 128 a 127 cuya suma también esté en el rango de 128 a 127, usted, ,

  , y	.

Representar un número entero no negativo en notación hexadecimal significa escribirlo como una suma de productos de la forma, donde.

Para convertir un número entero no negativo de notación hexadecimal a binaria, usted y .





Conjunto de ejercicios 2.5



S













Realice la aritmética de 13 a 20 usando notación binaria.



22. Sume 111111112 + 12 y convierta el resultado a nota decimal.



13. 10112

+ 1012

15. 1011012

+ 111012

17. 101002

— 11012

19. 1011012

— 100112



14. 10012

+ 10112

16. 1101110112

+ 10010110102

18. 110102

— 11012

20. 10101002

— 101112



ción, para verificar que 111111112 = (28 − 1)10.

Encuentre los complementos a dos de 8 bits para los números enteros del 23 al 26.

23. 23 24. 67 25. 4 26. 115



Encuentre las representaciones decimales de los números enteros con las representaciones de 8 bits dadas en 27–30.

27. 11010011 28. 10011001

29. 11110010 30. 10111010



21. Dé las señales de salida S y T para el circuito en la columna de la derecha si las señales de entrada P, Q y R son las especificadas. Tenga en cuenta que este no es el circuito para un sumador completo.

a. P = 1, Q = 1, R = 1



Utilice representaciones de 8 bits para calcular las sumas de 31 a 36.

31. 57 + (-118) 32. 62 + (-18)

33. (-6) + (-73) 34. 89 + (-55)



b. P = 0, Q = 1, R = 0



35. (-15 + -46



36. 123 + −94



C. P = 1, Q = 0, R = 1



) ( ) ( )







✶ 37. Demuestre que si a, b y a b son números enteros en el rango de 1 a 128, entonces

(28 − a) + (28 − b) = (28 − (a + b)) + 28 ≥ 28 + 27.

Explique por qué se deduce que si se calcula la representación binaria de 8 bits de la suma de los negativos de dos números en el rango dado, el resultado es un número negativo.

Convierta los números enteros del 38 al 40 de notación hexadecimal a decimal.

38. A2BC16 39. E0D16 40. 39EB16

Convierta los números enteros del 41 al 43 de notación hexadecimal a binaria.



46. 110010010111002

Notación octal: además de binaria y hexadecimal, los informáticos también utilizan la notación octal (base 8) para representar números. La notación octal se basa en el hecho de que cualquier número entero se puede representar de forma única como una suma de números de la forma d 8n, donde cada n es un número entero no negativo y cada d es uno de los números enteros del 0 al 7. Así, por ejemplo, 50738 5 83 0 82 7 81 3 80 261910.

Convierta 615028 a notación decimal.

Convierta 207638 a notación decimal.

Describa métodos para convertir números enteros de notación octal a binaria y viceversa que sean similares a los métodos utilizados en los Ejemplos 2.5.12 y 2.5.13 para



41. 1C0ABE16



42. B53DF816



43. 4ADF8316



yendo y viniendo de notación hexadecimal a binaria. Dé ejemplos que muestren que estos métodos resultan



Convierta los números enteros del 44 al 46 de notación binaria a hexadecimal.

44. 001011102 45. 10110111110001012



en respuestas correctas.







Respuestas para Ponte a prueba

1. d 2n d 0 o d 1, y n es un entero no negativo er 2. 102 112 3. 12 102

genera la suma de dos dígitos binarios cualesquiera; genera la suma de tres dígitos binarios cualesquiera

28 a 6. escribe la representación binaria de 8 bits de a; voltea los bits; sumar 1 en notación binaria

la representación binaria de 8 bits de a; la representación binaria de 8 bits de 28 a

convertir ambos números enteros a sus representaciones binarias de 8 bits; sumar los resultados usando notación binaria; truncar cualquier 1 inicial; convertir de nuevo a forma decimal

d 16n d 0, 1, 2,... 9, A, B, C, D, E, F y n es un número entero no negativo

escriba cada dígito hexadecimal en notación binaria de 4 bits; yuxtaponer los resultados























En el capítulo 2 analizamos el análisis lógico de enunciados compuestos, aquellos formados por enunciados simples unidos por los conectivos , , , y . Este análisis arroja luz sobre muchos aspectos del razonamiento humano, pero no puede utilizarse para determinar la validez en la mayoría de las situaciones matemáticas y cotidianas. Por ejemplo, el argumento

Todos los hombres son mortales. Sócrates es un hombre.

∴ Sócrates es mortal.

se percibe intuitivamente como correcto. Sin embargo, su validez no puede derivarse utilizando los métodos descritos en la Sección 2.3. Para determinar la validez en ejemplos como este, es necesario separar los enunciados en partes de la misma manera que se separan las oraciones declarativas en sujetos y predicados. Y es necesario analizar y comprender el papel especial que juegan las palabras que denotan cantidades como “todos” o “algunos”. El análisis simbólico de predicados y enunciados cuantificados se denomina cálculo de predicados. El análisis simbólico de enunciados compuestos ordinarios (como se describe en las secciones 2.1 a 2.3) se denomina cálculo de enunciados (o cálculo proposicional).





... no fue hasta los últimos años que se dio cuenta de cuán fundamentales son algunos para la naturaleza misma de las matemáticas. - AN Whitehead (1861-1947)



Como se señaló en la Sección 2.1, la oración “Él es un estudiante universitario” no es una afirmación porque puede ser verdadera o falsa según el valor del pronombre él. De manera similar, la oración “x y es mayor que 0” no es un enunciado porque su valor de verdad depende de los valores de las variables x e y.

En gramática, la palabra predicado se refiere a la parte de una oración que brinda información sobre el sujeto. En la oración "James es un estudiante en Bedford College", la palabra James es el sujeto y la frase es un estudiante en Bedford College es el predicado. El predicado es la parte de la oración de la que se ha eliminado el sujeto.

En lógica, los predicados se pueden obtener eliminando algunos o todos los sustantivos de un enunciado. Por ejemplo, digamos que P significa "es un estudiante en Bedford College" y Q significa "es un estudiante en". Entonces tanto P como Q son símbolos de predicados. Las oraciones “x es un estudiante en Bedford College” y “x es un estudiante en y” se simbolizan como P(x) y Q(x, y) respectivamente, donde x e y son variables predicadas que toman valores en forma apropiada. comió conjuntos. Cuando se sustituyen valores concretos en lugar de variables predicadas, se produce una declaración. Por simplicidad, definimos un predicado como un símbolo de predicado junto con variables de predicado adecuadas. En algunos otros tratamientos de la lógica, estos objetos se denominan funciones proposicionales u oraciones abiertas.

96









Ejemplo 3.1.1 Encontrar valores de verdad de un predicado

Sea P(x) el predicado “x 2 > x ” con dominio el conjunto R de todos los números reales. Escribir

P(2), P( 1 ) y P(− 1 ), e indique cuáles de estas afirmaciones son verdaderas y cuáles son



2 2

FALSO.

Solución P(2): 22 > 2, o 4 > 2. Verdadero.

P 1 : 1 2 > 1 , o 1 > 1 . FALSO.

PAG - 1 : - 1 2 > - 1 , o 1 > - 1 . Verdadero. ■



Cuando un elemento en el dominio de la variable de un predicado de una variable se sustituye por la variable, el enunciado resultante es verdadero o falso. El conjunto de todos los elementos que hacen que el predicado sea verdadero se llama conjunto de verdad del predicado.







Nota Recuerde que leemos estos símbolos como “el conjunto de todos los x en D tales que P(x)”.



Ejemplo 3.1.2 Encontrar el conjunto de verdad de un predicado

Sea Q(n) el predicado "n es factor de 8". Encuentre el conjunto de verdad de Q(n) si

el dominio de n es el conjunto Z+ de todos los números enteros positivos

el dominio de n es el conjunto Z de todos los números enteros.

Solución

El conjunto de verdad es 1, 2, 4, 8 porque estos son exactamente los números enteros positivos que dividen a 8 de manera uniforme.

El conjunto de verdad es {1, 2, 4, 8, −1, −2, −4, −8} porque los enteros negativos −1, −2, −4 y −8 también se dividen en 8 sin dejar resto. ■

El cuantificador universal: ∀

Una forma segura de convertir predicados en declaraciones es asignar valores específicos a todas sus variables. Por ejemplo, si x representa el número 35, la oración “x es (uniforme) divisible por 5” es un enunciado verdadero ya que 35 5 7. Otra forma de obtener enunciados a partir de predicados es sumar cuantificadores. Los cuantificadores son palabras que se refieren a cantidades como “algunos” o “todos” y dicen para cuántos elementos un predicado dado es verdadero. El concepto formal de cuantificador fue introducido en la lógica simbólica a finales del siglo XIX por











Charles Sanders Peirce (1839-1914)



Nota Piense en “para todos” cuando vea el



el filósofo, lógico e ingeniero estadounidense Charles Sanders Peirce y, de forma independiente, el lógico alemán Gottlob Frege.

El símbolo denota “para todos” y se llama cuantificador universal. Por ejemplo, otra forma de expresar la frase “Todos los seres humanos son mortales” es escribir

∀ el ser humano x, x es mortal.

Cuando se introduce el símbolo x en la frase “seres humanos x”, se supone que debemos pensar en x como un objeto individual, pero genérico, con todas las propiedades compartidas por cada ser humano pero ninguna otra propiedad. Por lo tanto, debería decir "x es mortal" en lugar de "x es mortal". En otras palabras, utilice el verbo “es” en singular en lugar del verbo en plural “son” cuando describa la propiedad que satisface x. Si dejamos que H sea el conjunto de todos los seres humanos, entonces podemos simbolizar el enunciado más formalmente escribiendo

∀x ∈ H, x es mortal,

que se lee como “Para todo x en el conjunto de todos los seres humanos, x es mortal”.



símbolo ∀. El dominio de la variable predicada generalmente se indica entre el símbolo y el nombre de la variable (como en seres humanos x ) o inmediatamente después del nombre de la variable (como en x H ). Algunas otras expresiones que se pueden usar en lugar de para todos son para cada, para arbitrario, para cualquiera, para cada uno y dado cualquiera. En una oración como “números reales x e y, x y y x”, se entiende que el símbolo se refiere tanto a x como a y.∗

Las oraciones que se cuantifican universalmente se definen como enunciados dándoles la

valores de verdad especificados en la siguiente definición:















Gottlob Frege (1848-1925)



Ejemplo 3.1.3 Verdad y falsedad de enunciados universales

Sea D = {1, 2, 3, 4, 5} y considere el enunciado

∀x ∈ D, x 2 ≥ x.

Demuestre que esta afirmación es cierta.

Considere la declaración

∀x ∈ R, x 2 ≥ x.

Encuentre un contraejemplo para demostrar que esta afirmación es falsa.

Solución

Compruebe que “x 2 ≥ x ” sea cierto para cada individuo x en D.

12 ≥ 1, 22 ≥ 2, 32 ≥ 3, 42 ≥ 4, 52 ≥ 5.

Por tanto, “∀x ∈ D, x 2 ≥ x ” es cierto.



∗Las versiones más formales de lógica simbólica requerirían escribir una ∀ separada para cada variable: “∀x ∈ R(∀y ∈ R(x + y = y + x))”.





Contraejemplo: tome x = 1. Entonces x está en R (ya que 1 es un número real) y

2 2

   1 2 1 1

Por tanto “∀x ∈ R, x 2 ≥ x ” es falso. ■

La técnica utilizada para demostrar la verdad del enunciado universal en el ejemplo 3.1.3(a) se llama método de agotamiento. Consiste en mostrar la verdad del predicado por separado para cada elemento individual del dominio. (¡La idea es agotar las posibilidades antes de agotarte a ti mismo!) En teoría, este método puede usarse siempre que el dominio de la variable predicada sea finito. En los últimos años, la prevalencia de las computadoras digitales ha aumentado considerablemente la conveniencia de utilizar el método de agotamiento. Los sistemas informáticos expertos, o sistemas basados en el conocimiento, utilizan este método para llegar a respuestas a muchas de las preguntas que se les plantean. Sin embargo, como la mayoría de los conjuntos matemáticos son infinitos, el método de agotamiento rara vez se puede utilizar para derivar resultados matemáticos generales.



El cuantificador existencial: ∃

El símbolo denota “existe” y se llama cuantificador existencial. Por ejemplo, la oración "Hay un estudiante en Matemáticas 140" se puede escribir como

∃ una persona p tal que p es un estudiante en Matemáticas 140,





Nota Piense en “existe” cuando vea el



o, más formalmente,





∃ p ∈ P tal que p es un estudiante en Matemáticas 140,



símbolo ∃. donde P es el conjunto de todas las personas. El dominio de la variable predicada generalmente se indica entre el símbolo y el nombre de la variable o inmediatamente después del nombre de la variable. Las palabras tales que se insertan justo antes del predicado. Algunas otras expresiones que se pueden usar en lugar de existe son hay un, podemos encontrar un, hay al menos uno, para algunos y para al menos uno. En una oración como “enteros m y n tales que m n m n”, se entiende que el símbolo se refiere tanto a m como a n.∗

Las oraciones que se cuantifican existencialmente se definen como enunciados dándoles los valores de verdad especificados en la siguiente definición.





Ejemplo 3.1.4 Verdad y falsedad de afirmaciones existenciales

Considere la declaración

∃m ∈ Z+ tal que m2 = m.

Demuestre que esta afirmación es cierta.







∗En versiones más formales de lógica simbólica, las palabras que no están escritas (aunque se entienden) y se usa un símbolo ∃ separado para cada variable: “∃m ∈ Z(∃n ∈ Z(m + n = m · n)).”





Sea E = {5, 6, 7, 8} y considere el enunciado

∃m ∈ E tal que m2 = m.

Demuestre que esta afirmación es falsa.

Solución

Observe que 12 = 1. Por tanto, “m2 = m” es cierto para al menos un número entero m. Por lo tanto “∃m ∈ Z

tal que m2 = m” es verdadera.

Tenga en cuenta que m2 = m no es cierto para ningún número entero m del 5 al 8:

52 = 25 /= 5, 62 = 36 /= 6, 72 = 49 /= 7, 82 = 64 /= 8.

Por tanto, “∃m ∈ E tal que m2 = m” es falso. ■



Lenguaje formal versus informal

Es importante poder traducir del lenguaje formal al informal cuando intentas entender conceptos matemáticos que son nuevos para ti. Es igualmente importante poder traducir de información Lenguaje normal a formal al pensar en un problema complicado.



Ejemplo 3.1.5 Traducción del lenguaje formal al informal

Reescribe las siguientes declaraciones formales en una variedad de formas equivalentes pero más informales. No utilice el símbolo ∀ o ∃.

a. ∀x ∈ R, x 2 ≥ 0.

b. ∀x ∈ R, x 2 /= −1.

∃m ∈ Z+tal que m2 = m.

Solución





Nota El sustantivo singular se utiliza para referirse al dominio cuando el

símbolo se traduce como

cada, cualquiera o cada uno.













Nota En inglés común, la afirmación del inciso c) podría considerarse verdadera sólo si hay al menos dos números enteros positivos iguales a sus propios cuadrados. En matemáticas, entendemos que las dos últimas afirmaciones del inciso (c) significan lo mismo.



Todos los números reales tienen cuadrados no negativos.

O: Todo número real tiene un cuadrado no negativo. O: Cualquier número real tiene un cuadrado no negativo. O: El cuadrado de cada número real no es negativo.



Todos los números reales tienen cuadrados que no son iguales a 1.

O: Ningún número real tiene cuadrados iguales a 1.

(Las palabras none are o no... are son equivalentes a las palabras all not are.)



Existe un número entero positivo cuyo cuadrado es igual a sí mismo.

O: podemos encontrar al menos un número entero positivo igual a su propio cuadrado.

O: algún número entero positivo es igual a su propio cuadrado.

O: Algunos números enteros positivos son iguales a sus propios cuadrados. ■





Otra forma de reformular informalmente afirmaciones universales y existenciales es colocar la cuantificación al final de la oración. Por ejemplo, en lugar de decir "Para cualquier número real x, x 2 no es negativo", podrías decir "x 2 no es negativo para cualquier número real x". En tal caso se dice que el cuantificador “sigue” al resto de la oración.





Ejemplo 3.1.6 Cuantificadores finales

Reescribe las siguientes afirmaciones de modo que el cuantificador siga al resto de la oración.

Para cualquier número entero n, 2n es par.

Existe al menos un número real x tal que x 2 ≤ 0.

Solución

2n es par para cualquier número entero n.

x 2 ≤ 0 para algún número real x .

O: x 2 ≤ 0 para al menos un número real x . ■

Ejemplo 3.1.7 Traducción del lenguaje informal al formal

Reescribe formalmente cada una de las siguientes afirmaciones. Utilice cuantificadores y variables.

Todos los triángulos tienen tres lados.

Ningún perro tiene alas.

Algunos programas están estructurados.

Solución

∀ triángulos t, t tiene tres lados.

O: ∀t ∈ T, t tiene tres lados (donde T es el conjunto de todos los triángulos).

∀ perros d, no tiene alas d.

O: ∀d ∈ D, d no tiene alas (donde D es el conjunto de todos los perros).

∃ un programa p tal que p esté estructurado.

O: ∃ p ∈ P tal que p esté estructurado (donde P es el conjunto de todos los programas). ■

Declaraciones condicionales universales

Se puede argumentar razonablemente que la forma más importante de enunciado en matemáticas es el enunciado condicional universal:

∀x, si P(x) entonces Q(x).

La familiaridad con declaraciones de esta forma es esencial si quieres aprender a hablar matemáticas.



Ejemplo 3.1.8 Escribir enunciados condicionales universales de manera informal

Vuelva a escribir el siguiente enunciado de manera informal, sin cuantificadores ni variables.

∀x ∈ R, si x > 2 entonces x 2 > 4.

Solución Si un número real es mayor que 2 entonces su cuadrado es mayor que 4.

O: Siempre que un número real es mayor que 2, su cuadrado es mayor que 4.

O: El cuadrado de cualquier número real mayor que 2 es mayor que 4.

O: Los cuadrados de todos los números reales mayores que 2 son mayores que 4. ■



Ejemplo 3.1.9 Escribir formalmente enunciados condicionales universales

Reescribe cada una de las siguientes afirmaciones en la forma

∀, si entonces.

Si un número real es un número entero, entonces es un número racional.





Todos los bytes tienen ocho bits.

Ningún camión de bomberos es verde.

Solución

∀ números reales x , si x es un número entero, entonces x es un número racional.

O: ∀x ∈ R, si x ∈ Z entonces x ∈ Q.

∀x, si x es un byte, entonces x tiene ocho bits.

∀x, si x es un camión de bomberos, entonces x no es verde.

Es común, como en (b) y (c) anteriores, omitir la identificación explícita del dominio de las variables predicadas en enunciados condicionales universales. ■



Una reflexión cuidadosa sobre el significado de los enunciados condicionales universales conduce a otro nivel de comprensión de por qué la tabla de verdad para un enunciado si-entonces debe definirse tal como está. Consideremos nuevamente la afirmación

∀ números reales x, si x > 2 entonces x 2 > 4.

Tu experiencia e intuición te dicen que esta afirmación es cierta. Pero eso significa que

Si x > 2 entonces x 2 > 4

debe ser cierto para cada número real x . En consecuencia, debe ser cierta incluso para valores de x que hacen que su hipótesis “x > 2” sea falsa. En particular, ambas declaraciones

Si 1 > 2 entonces 12 > 4 y si − 3 > 2 entonces (−3)2 > 4

debe ser verdad. En ambos casos la hipótesis es falsa, pero en el primer caso la conclusión “12 > 4” es falsa y en el segundo caso la conclusión “(3)2 > 4” es verdadera. Por lo tanto, independientemente de si su conclusión es verdadera o falsa, un enunciado si-entonces con una hipótesis falsa debe ser verdadero.

Tenga en cuenta también que la definición de argumento válido es una declaración condicional universal:

combinaciones de valores de verdad para los enunciados componentes, si todas las premisas son verdaderas, entonces la conclusión también es verdadera.





Formas equivalentes de universal y existencia l Declaraciones

Observe que las dos afirmaciones “números reales x, si x es un número entero entonces x es racional” y “números enteros x, x es racional” significan lo mismo. Ambos tienen traducciones informales: "Todos los números enteros son racionales". De hecho, una declaración de la forma

∀x ∈ U, si P(x) entonces Q(x)

siempre se puede reescribir en la forma

∀x ∈ D,Q(x)

reduciendo U para que sea el dominio D que consta de todos los valores de la variable x que hacen

P(x) verdadero. Por el contrario, una declaración de la forma

∀x ∈ D,Q(x)



se puede reescribir como





∀x, si x está en D entonces Q(x).





Ejemplo 3.1.10 Formas equivalentes para declaraciones universales

Reescribe la siguiente afirmación en las dos formas “∀x, si entonces” y “∀ x,”,: Todos los cuadrados son rectángulos.

Solución ∀x, si x es un cuadrado entonces x es un rectángulo.

∀ cuadrados x, x es un rectángulo. ■

De manera similar, un enunciado de la forma “∃x tal que p(x) y Q(x)” se puede reescribir como “∃xε D tal que Q(x)”, donde D es el conjunto de todos los x para los cuales P( x) es cierto.



Ejemplo 3.1.11 Formas equivalentes para declaraciones existenciales

Un número primo es un número entero mayor que 1 cuyos únicos factores enteros positivos son él mismo y 1. Considere la afirmación "Hay un número entero que es a la vez primo e par". Sea Prime(n) “n es primo” y Even(n) sea “n es par”. Utilice la notación Prime(n) y Even(n) para reescribir esta declaración en las dos formas siguientes:

∃n tal que ∧ .

∃ n tal que .

Solución

∃n tal que Prime(n) ∧ Even(n).

Dos respuestas: ∃ un número primo n tal que Par(n).

∃ un número par n tal que Prime(n). ■



Cuantificación implícita

Considere la declaración

Si un número es entero, entonces es un número racional.

Como se mostró anteriormente, esta declaración es equivalente a una declaración universal. Sin embargo, no contiene la palabra reveladora todos o todos o cualquiera o cada uno. La única pista para indicar su cuantificación universal proviene de la presencia del artículo indefinido a. Éste es un ejemplo de cuantificación universal implícita.

La cuantificación existencial también puede ser implícita. Por ejemplo, el enunciado “El número 24 se puede escribir como la suma de dos números enteros pares” se puede expresar formalmente como “enteros pares m y n tales que 24 m n”.

La escritura matemática contiene muchos ejemplos de enunciados implícitamente cuantificados. Algunas ocurren, como en el primer ejemplo anterior, mediante la presencia de la palabra a o an. Otros ocurren en casos en que el contexto general de una oración proporciona parte de su significado. Por ejemplo, en un curso de álgebra en el que la letra x siempre se usa para indicar un número real, el predicado

Si x > 2 entonces se interpreta que x 2 > 4 significa lo mismo que la afirmación

∀ números reales x, si x > 2 entonces x 2 > 4.

Los matemáticos suelen utilizar una doble flecha para indicar simbólicamente la cuantificación implícita.

Por ejemplo, podrían expresar la afirmación anterior como

x > 2 ⇒ x 2 > 4.











Ejemplo 3.1.12 Usando ⇒ y ⇔

Dejar





Q(n) sea “n es un factor de 8”, R(n) sea “n es un factor de 4”, S(n) sea “n < 5 y n /= 3”,



y supongamos que el dominio de n es Z+, el conjunto de los números enteros positivos. Utilice los símbolos y para indicar relaciones verdaderas entre Q(n), R(n) y S(n).

Solución

Como se señaló en el Ejemplo 3.1.2, el conjunto de verdad de Q(n) es {1, 2, 4, 8} cuando el dominio de n es Z+. Por un razonamiento similar, el conjunto de verdad de R(n) es {1, 2, 4}. Por tanto, es cierto que cada elemento en el conjunto de verdad de R(n) está en el conjunto de verdad de Q(n), o, equivalentemente, ∀n en Z+, R(n) → Q(n). Entonces R(n) ⇒ Q(n), o, equivalentemente

n es un factor de 4 ⇒ n es un factor de 8.

El conjunto de verdad de S(n) es {1, 2, 4}, que es idéntico al conjunto de verdad de R(n), o, de manera equivalente, ∀n en Z+, R(n) ↔ S(n) . Entonces R(n) ⇔ S(n), o, de manera equivalente,

n es un factor de 4 ⇔ n < 5 y n /= 3.

Además, dado que cada elemento del conjunto de verdad de S(n) está en el conjunto de verdad de Q(n), o, equivalentemente, ∀n en Z+, S(n) → Q(n), entonces S(n) ⇒ Q(n), o, equivalentemente,

n < 5 y n /= 3 ⇒ n es un factor de 8. ■

Algunas cuestiones de cuantificación pueden ser bastante sutiles. Por ejemplo, un texto de matemáticas podría contener lo siguiente:

a. (x + 1)2 = x 2 + 2x + 1. b. Resuelve 3x − 4 = 5.

Aunque ni (a) ni (b) contienen cuantificación explícita, se supone que el lector debe comprender que x en (a) se cuantifica universalmente, mientras que x en (b) se cuantifica existencialmente. Cuando la cuantificación se hace explícita, (a) y (b) se vuelven

∀ números reales x, (x + 1)2 = x 2 + 2x + 1.

Demuestre (hallando un valor) que ∃ es un número real x tal que 3x − 4 = 5.

La cuantificación de una afirmación, ya sea universal o existencial, determina de manera crucial cómo se puede aplicar la afirmación y qué método se debe utilizar para establecer su verdad. Por lo tanto, es importante estar alerta a la presencia de cuantificadores ocultos cuando se leen matemáticas para poder interpretar los enunciados de una manera lógicamente correcta.





El mundo de Tarski

Tarski's World es un programa informático desarrollado por los científicos de la información Jon Barwise y John Etchemendy para ayudar a enseñar los principios de la lógica. Se describe en su libro The Language of First-Order Logic, que viene acompañado de un CD-Rom que contiene el programa Tarski's World, que lleva el nombre del gran lógico. Alfred Tarski.





Ejemplo 3.1.13 Investigando el mundo de Tarski

El programa de Tarski's World proporciona imágenes de bloques de varios tamaños, formas y colores, que están ubicados en una cuadrícula. En la Figura 3.1.1 se muestra una imagen de una disposición de objetos en un mundo Tarski bidimensional. La configuración se puede describir usando operadores lógicos y, para la versión bidimensional, notaciones como Triangle(x), que significa "x es un triángulo", Blue(y), que significa "y es azul", y RightOf(x, y), que significa "x está a la derecha de y (pero posiblemente en una fila diferente)". A los objetos individuales se les pueden dar nombres como a, b o c.





Alfred Tarski (1902-1983)







Figura 3.1.1



Determine la verdad o falsedad de cada una de las siguientes afirmaciones. El dominio para todas las variables es el conjunto de objetos en el mundo Tarski que se muestra arriba.

∀t , Triángulo(t ) → Azul(t ).

∀x , Azul(x) → Triángulo(x).

∃y tal que Square(y) ∧ RightOf(d, y).

∃z tal que Square(z) ∧ Gray(z).

Solución

Esta afirmación es cierta: todos los triángulos son azules.

Esta afirmación es falsa. Como contraejemplo, observe que e es azul y no es un triángulo.

Esta afirmación es cierta porque e y h son cuadrados y d está a su derecha.

Esta afirmación es falsa: todos los cuadrados son azules o negros. ■





Pruébate

Las respuestas a las preguntas de Pruébese usted mismo se encuentran al final de cada sección.



Si P(x) es un predicado con dominio D, el conjunto de verdad de P(x)

se denota. Leemos estos símbolos en voz alta como .

Algunas formas de expresar el símbolo ∀ en palabras son.

Algunas formas de expresar el símbolo ∃ en palabras son.

Serie de ejercicios 3.1*

Una colección de animales consta de siete perros marrones, dos perros negros, seis gatos grises, diez gatos negros, cinco pájaros azules, seis pájaros amarillos y un pájaro negro. Determine cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas.

Hay un animal en la casa de fieras que es rojo.

Cada animal de la colección de animales es un ave o un mamífero.

Todos los animales de la colección son marrones, grises o negros.

Hay un animal en la casa de fieras que no es ni gato ni perro.

Ningún animal en la colección es azul.

En la casa de fieras hay un perro, un gato y un pájaro que tienen el mismo color.

Indique cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas. Justifica tus respuestas lo mejor que puedas.

Todo número entero es un número real.

0 es un número real positivo.

Para todos los números reales r, r es un número real negativo.

Todo número real es un número entero.

Sea P(x) el predicado “x > 1/x”.

a. Escriba P(2), P( 1 ), P( 1), P( 1 ) y P( 8), y

Indique cuáles de estas afirmaciones son verdaderas y cuáles falsas.

b. Encuentre el conjunto de verdad de P(x) si el dominio de x es R, el conjunto

de todos los números reales.

C. Si el dominio es el conjunto R+ de todos los números reales positivos, ¿cuál es el conjunto de verdad de P(x)?

Sea Q(n) el predicado “n2 30”.

Escriba Q(2), Q( 2), Q(7) y Q( 7), e indique cuáles de estas afirmaciones son verdaderas y cuáles son falsas.

Encuentre el conjunto de verdad de Q(n) si el dominio de n es Z, el conjunto de todos los números enteros.

Si el dominio es el conjunto Z+ de todos los enteros positivos, ¿qué

Cuál es el conjunto de verdad de Q(n)?

Sea Q(x, y) el predicado “Si x < y entonces x 2 < y2” siendo el dominio para x e y el conjunto R de números reales.

Explique por qué Q(x, y) es falsa si x 2 e y 1.

Dé valores diferentes de aquellos del inciso (a) para los cuales

Q(x, y) es falso.

Explique por qué Q(x, y) es verdadera si x 3 e y 8.

Dé valores diferentes de aquellos del inciso (c) para los cuales

Q(x, y) es cierto.



Un enunciado de la forma x D, Q(x) es verdadero si, y sólo si, Q(x) es para .

Un enunciado de la forma x D tal que Q(x) es verdadero si, y sólo si, Q(x) es para .







Sea R(m, n) el predicado “Si m es un factor de n2, entonces m es un factor de n”, siendo el dominio tanto para m como para n el conjunto Z de números enteros.

Explique por qué R(m, n) es falso si m 25 y n 10.

Dé valores diferentes de aquellos del inciso (a) para los cuales

R(m, n) es falso.

Explique por qué R(m, n) es verdadera si m 5 y n 10.

Dé valores diferentes de aquellos del inciso (c) para los cuales

R(metro, norte) es cierto.

Encuentre el conjunto de verdad de cada predicado.

predicado: 6/d es un número entero, dominio: Z

predicado: 6/d es un número entero, dominio: Z+

predicado: 1 ≤ x 2 ≤ 4, dominio: R

predicado: 1 ≤ x 2 ≤ 4, dominio: Z

Sea B(x) “10 < x < 10”. Encuentre el conjunto de verdad de B(x) para cada uno de los siguientes dominios.

Zb. Z+c. El conjunto de todos los números pares.

Encuentre contraejemplos para demostrar que las afirmaciones de 9 a 12 son falsas.

9. ∀x ∈ R, x > 1/x .

∀a ∈ Z, (a − 1)/a no es un número entero.

∀ enteros positivos m y n, m · n ≥ m + n.

∀ números reales x e y, √x + y = √x + √y.

Considere la siguiente afirmación:

∀ jugadores de baloncesto x, x es alto.

¿Cuál de las siguientes son formas equivalentes de expresar esta afirmación?

Todo jugador de baloncesto es alto.

Entre todos los jugadores de baloncesto, algunos son altos.

Algunas de las personas altas son jugadores de baloncesto.

Cualquiera que sea alto es jugador de baloncesto.

Todas las personas que son jugadores de baloncesto son altas.

Cualquiera que sea jugador de baloncesto es una persona alta.





∗Para ejercicios con números o letras azules, las soluciones se dan en el Apéndice B. El símbolo H indica que solo un Se da una pista o una solución parcial. El símbolo ✶ indica que un ejercicio es más desafiante de lo habitual.







Considere la siguiente afirmación:

∃x ∈ R tal que x 2 = 2.

¿Cuál de las siguientes son formas equivalentes de expresar esta afirmación?

El cuadrado de cada número real es 2.

Algunos números reales tienen el cuadrado 2.

El número x tiene al cuadrado 2, para algún número real x.

Si x es un número real, entonces x 2 2.

Algún número real tiene el cuadrado 2.

Existe al menos un número real cuyo cuadrado es 2.

H 15. Reescribe las siguientes afirmaciones informalmente en al menos dos maneras diferentes sin usar variables ni cuantificadores.

∀ rectángulos x, x es un cuadrilátero.

∃ un conjunto A tal que A tiene 16 subconjuntos.

Reescribe cada una de las siguientes afirmaciones en la forma "x",

Todos los dinosaurios están extintos.

Todo número real es positivo, negativo o cero.

Ningún número irracional es entero.

Ningún lógico es holgazán.

El número 2.147.581.953 no es igual al cuadrado de ningún número entero.

El número 1 no es igual al cuadrado de ningún número real.

Reescribe cada uno de los siguientes en la forma "x tal que"

Algunos ejercicios tienen respuestas.

Algunos números reales son racionales.

Sea D el conjunto de todos los estudiantes de su escuela, y sea M(s) “s es un estudiante de matemáticas”, sea C(s) “s es un estudiante de informática” y sea E(s) be “s es un estudiante de ingeniería”. Exprese cada una de las siguientes afirmaciones utilizando cuantificadores, variables y los predicados M(s), C(s) y E(s).



H 20. Vuelva a escribir la siguiente afirmación de manera informal, al menos de dos maneras diferentes, sin utilizar variables ni el símbolo ni las palabras “para todos”.

números reales x, si x es positivo, entonces la raíz cuadrada de x es positiva.

Reescribe las siguientes afirmaciones de modo que el cuantificador siga al resto de la oración.

Para cualquier gráfico G, el grado total de G es par.

Para cualquier triángulo isósceles T, los ángulos base de T son iguales.

Existe un número primo p tal que p es par.

Existe una función continua f tal que f no es diferenciable.

Reescribe cada una de las siguientes afirmaciones en la forma "x, si entonces".

Todos los programas Java tienen al menos 5 líneas.

Cualquier argumento válido con premisas verdaderas tiene una conclusión verdadera.

Reescribe cada una de las siguientes afirmaciones en las dos formas “x, si entonces” y “x”, (sin un si-entonces).

Todos los triángulos equiláteros son isósceles.

Todo estudiante de informática necesita aprender estructuras de datos.

Reescribe las siguientes afirmaciones en las dos formas "x tal que" y "x tal que y".

Algunos sombrereros están enojados. b. Algunas preguntas son fáciles.

El enunciado “El cuadrado de cualquier número racional es racional” puede reescribirse formalmente como “Para todo número racional x, x 2 es racional” o como “Para todo x, si x es racional, entonces x 2 es racional”. Reescribe cada una de las siguientes afirmaciones en las dos formas “∀ x ” y “∀x , si , entonces



Hay un estudiante de ingeniería que se especializa en matemáticas. ” o en las dos formas “∀ x e y”,



Todo estudiante de informática es un estudiante de ingeniería.

Ningún estudiante de informática es estudiante de ingeniería.

Algunos estudiantes de informática también se especializan en matemáticas.

Algunos estudiantes de informática son estudiantes de ingeniería y otros no.

19. Considere la siguiente afirmación:

∀ enteros n, si n2 es par entonces n es par.

¿Cuál de las siguientes son formas equivalentes de expresar esta afirmación?



y “x e y, si, entonces”.

El recíproco de cualquier fracción distinta de cero es una fracción.

La derivada de cualquier función polinómica es una función polinómica.

La suma de los ángulos de cualquier triángulo es 180◦.

El negativo de cualquier número irracional es irracional.

La suma de dos números enteros pares cualesquiera es par.

El producto de dos fracciones cualesquiera es una fracción.

Considere la afirmación "Todos los números enteros son números racionales, pero algunos números racionales no son números enteros".

Escriba esta afirmación en la forma “∀x, si entonces



Todos los números enteros tienen cuadrados pares y son pares. , pero ∃ x tal que .”



Dado cualquier número entero cuyo cuadrado sea par, ese número entero es par en sí mismo.

Para todos los números enteros, hay algunos cuyo cuadrado es par.

Cualquier número entero con un cuadrado par es par.

Si el cuadrado de un número entero es par, entonces ese número entero es par.

Todos los números pares tienen cuadrados pares.



Sea Ratl(x) “x es un número racional” e Int(x) sea “x es un número entero”. Escriba formalmente el enunciado dado usando solo los símbolos Ratl(x), Int(x), ∀, ∃, ∧, ∨, ∼ y →.

Consulte la imagen del mundo de Tarski que se muestra en el ejemplo.

3.1.13. Sea Arriba(x, y) significa que x está encima de y (pero posiblemente en una columna diferente). Determinar la verdad o la falsedad.







de cada una de las siguientes afirmaciones. Razona tus respuestas.

∀u, Círculo(u) → Gris(u).

∀u, Gray(u) → Círculo(u).

∃y tal que Cuadrado(y) ∧ Arriba(y, d).

∃z tal que Triángulo(z) ∧ Arriba( f, z).

En 28–30, reescribe cada enunciado sin usar cuantificadores ni variables. Indique cuáles son verdaderas y cuáles falsas y justifique sus respuestas lo mejor que pueda.

Sea el dominio de x el conjunto D de objetos discutidos en los cursos de matemáticas, y sea Real(x) “x es un número real”, Pos(x) sea “x es un número real positivo”, Neg(x ) sea “x es un número real negativo” e Int(x ) sea “x es un número entero”.

Pos(0)

∀x , Real(x) ∧ Neg(x) → Pos(−x).

∀x , Int(x) → Real(x).

∃x tal que Real(x) ∧ ∼Int(x).

Sea el dominio de x el conjunto de figuras geométricas en el plano, y sea Square(x) “x es un cuadrado” y Rect(x) sea “x es un rectángulo”.

∃x tal que Rect(x) ∧ Square(x).

∃x tal que Rect(x) ∧ ∼Square(x).

∀x , Cuadrado(x) → Rect(x).

Sea el dominio de x el conjunto Z de números enteros, y sea Impar(x) “x es impar”, Prime(x) sea “x es primo” y Cuadrado(x) sea



"x es un cuadrado perfecto". (Se dice que un número entero n es un cuadrado perfecto si, y sólo si, es igual al cuadrado de algún número entero. Por ejemplo, 25 es un cuadrado perfecto porque 25 = 52.)

∃x tal que Prime(x) ∧ ∼Impar(x).

∀x, Primo(x) → ∼Cuadrado(x).

∃x tal que Impar(x) ∧ Cuadrado(x).

H 31. En cualquier texto de matemáticas o informática que no sea este libro, encuentre un ejemplo de un enunciado que sea universal pero que esté implícitamente cuantificado. Copie el enunciado tal como aparece y reescríbalo haciendo explícita la cuantificación. Proporcione una cita completa para su ejemplo, incluyendo título, autor, editorial, año y número de página.

Sea R el dominio de la variable predicada x. ¿Cuáles de las siguientes son verdaderas y cuáles son falsas? Da ejemplos contrarios a las afirmaciones que son falsas.

a. x > 2 ⇒ x > 1

b. x > 2 ⇒ x 2 > 4

C. x2 > 4 ⇒ x > 2

d. x2 > 4 ⇔ |x | > 2

Sea R el dominio de las variables predicadas a, b, cy d. ¿Cuáles de las siguientes son verdaderas y cuáles son falsas? Da contraejemplos de las afirmaciones que son falsas.

a > 0 y b > 0 ⇒ ab > 0

a < 0 y b < 0 ⇒ ab < 0

ab = 0 ⇒ a = 0 o b = 0

a < b y c < d ⇒ ac < bd









Respuestas para Ponte a prueba

1. xD P(x) ; el conjunto de todos los x en D tal que P(x) 2. Posibles respuestas: para todos, para cada, para cualquiera, para cada, para arbitrario, dado cualquiera 3. Posibles respuestas: existe, existe, existe al menos uno, para algunos, para al menos uno, podemos encontrar un 4. verdadero; cada x en D (Respuestas alternativas: todas las x en D; cada x en D) 5. verdadero; al menos una x en D (Respuesta alternativa: alguna x en D)









PIEDRA DE TOQUE: Párate los dos ahora: acariciaos la barbilla y jurad por vuestras barbas que soy un bribón.

CELIA: Por nuestras barbas, si las tuviéramos, eres tú.

PIEDRA DE TOQUE: Por mi picardía, si la tuve, entonces lo fui; pero si juras por lo que no es, no perjuras. - William Shakespeare, como quieras





Esta sección continúa la discusión de predicados y enunciados cuantificados iniciada en la Sección 3.1. Contiene las reglas para negar declaraciones cuantificadas; una exploración de la relación entre , , y ; una introducción al concepto de verdad vacía de los enunciados universales; ejemplos de variantes de enunciados condicionales universales; y una extensión del significado de necesario, suficiente y sólo si a declaraciones cuantificadas.





Negaciones de declaraciones cuantificadas

Considere la afirmación "Todos los matemáticos usan gafas". Mucha gente diría que su negación es “Ningún matemático usa gafas”, pero si incluso un matemático no usa gafas, entonces la afirmación generalizada de que todos los matemáticos usan gafas es falsa. Por tanto, una negación correcta es: "Hay al menos un matemático que no usa gafas".

La forma general de la negación de un enunciado universal se deriva inmediatamente de las definiciones de negación y de los valores de verdad de los enunciados universales y existenciales.







De este modo

La negación de un enunciado universal (“todos son”) es lógicamente equivalente a un enunciado existencial (“algunos no son” o “hay al menos uno que no lo es”).

Tenga en cuenta que cuando hablamos de equivalencia lógica para enunciados cuantificados, queremos decir que los enunciados siempre tienen valores de verdad idénticos sin importar qué predicados se sustituyan por los símbolos de predicado y sin importar qué conjuntos se utilicen para los dominios de las variables de predicado.

Consideremos ahora la afirmación “Algunos copos de nieve son iguales”. ¿Cuál es su negación? Que esta afirmación sea falsa significa que ningún copo de nieve es igual a otro. En otras palabras, “Ningún copo de nieve es igual” o “Todos los copos de nieve son diferentes”.

La forma general de la negación de un enunciado existencial se deriva inmediatamente de las definiciones de negación y de los valores de verdad de los enunciados existenciales y universales.







De este modo







La negación de una afirmación existencial (“algunos son”) es lógicamente equivalente a una afirmación universal (“ninguno es” o “no todos son”).





Ejemplo 3.2.1 Negar declaraciones cuantificadas

Escriba negaciones formales para las siguientes afirmaciones:

∀ primos p, p es impar.

∃ un triángulo T tal que la suma de los ángulos de T es igual a 200◦.

Solución

Al aplicar la regla para la negación de una declaración ∀, puedes ver que la respuesta es

∃ un primo p tal que p no es impar.

Al aplicar la regla para la negación de una declaración ∃, puedes ver que la respuesta es

∀ triángulos T, la suma de los ángulos de T no es igual a 200◦. ■

Es necesario tener especial cuidado para evitar errores al escribir negaciones de declaraciones que se dan de manera informal. Una forma de evitar errores es t o reescribe el enunciado formalmente y toma la negación usando la regla formal.

Ejemplo 3.2.2 Más negaciones

Reescribe formalmente la siguiente declaración. Luego escribe negaciones formales e informales.

Ningún político es honesto.

Solución Versión formal: ∀ políticos x, x no es honesto.

Negación formal: ∃ un político x tal que x es honesto.

Negación informal: algunos políticos son honestos. ■

Otra forma de evitar errores al aceptar negaciones de afirmaciones dadas en lenguaje informal es preguntarse: “¿Qué significaría exactamente que la afirmación dada fuera falsa? ¿Qué afirmación, de ser verdadera, equivaldría a decir que la afirmación dada es falsa?

Ejemplo 3.2.3 Aún más negaciones

Escriba negaciones informales para las siguientes afirmaciones:

Todos los programas de computadora son finitos.

Algunos piratas informáticos tienen más de 40 años.

El número 1.357 es divisible por algún número entero entre 1 y 37.

Solución

¿Qué significaría exactamente que esta afirmación fuera falsa? La declaración afirma que todos los programas de computadora satisfacen una determinada propiedad. Entonces, para que sea falso, tendría que haber al menos un programa informático que no satisfaga la propiedad. Así la respuesta es

Hay un programa de computadora que no es finito.

O: algunos programas de computadora son infinitos.

Esta afirmación equivale a decir que existe al menos un hacker informático con una determinada propiedad. Entonces, para que sea falso, ni un solo pirata informático puede tener esa propiedad. Así, la negación es

Ningún pirata informático tiene más de 40 años.

O: Todos los piratas informáticos tienen 40 años o menos.







Nota ¿Qué es verdadero: la afirmación del inciso (c) o su negación? ¿Es 1357 divisible por algún número entero entre 1 y 37? ¿O 1357 no es divisible por ningún número entero entre 1 y 37?



Esta afirmación tiene un cuantificador final. Escrito formalmente se convierte en:

∃ un número entero n entre 1 y 37 tal que 1357 es divisible por n.

Su negación es por tanto

∀ números enteros n entre 1 y 37; 1.357 no es divisible por n.

Una versión informal de la negación es

El número 1.357 no es divisible por ningún número entero entre 1 y 37. ■











¡Precaución! Simplemente insertar la palabra para no negar una afirmación cuantificada puede dar como resultado una afirmación que sea ambigua.



Se pueden construir negaciones informales de muchos enunciados universales simplemente insertando la palabra no o las palabras no en un lugar apropiado. Sin embargo, las afirmaciones resultantes pueden ser ambiguas. Por ejemplo, una posible negación de "Todos los matemáticos usan anteojos" es "Todos los matemáticos no usan anteojos". El problema es que esta frase tiene dos significados. Con el acento verbal adecuado en la palabra no, podría interpretarse como la negación lógica. (¡Qué! ¿Dices que todos los matemáticos usan gafas? ¡Tonterías! No todos los matemáticos usan gafas.) Por otro lado, expresado en un tono de voz plano (¡inténtalo!), significaría que todos los matemáticos no usan gafas; es decir, ni un solo matemático usa gafas. Esta es una afirmación mucho más fuerte que la negación lógica: implica la negación pero no es equivalente a ella.



Negaciones de enunciados condicionales universales

Las negaciones de enunciados condicionales universales son de especial importancia en matemáticas. La forma de tales negaciones puede deducirse de hechos ya establecidos.

Por definición de la negación de a para todo enunciado,

∼(∀x, P(x) → Q(x)) ≡ ∃x tal que ∼( P(x) → Q(x)). 3.2.1

Pero la negación de un enunciado si-entonces es lógicamente equivalente a un enunciado y. Más precisamente,



∼( P(x) → Q(x)) ≡ P(x) ∧ ∼Q(x). 3.2.2

Sustituyendo (3.2.2) en (3.2.1) se obtiene

∼(∀x, P(x) → Q(x)) ≡ ∃x tal que ( P(x)∧ ∼Q(x)).

Escrito de manera menos simbólica, esto se convierte en





Ejemplo 3.2.4 Negar declaraciones condicionales universales

Escriba una negación formal para el enunciado (a) y una negación informal para el enunciado (b).

∀ personas p, si p es rubio entonces p tiene ojos azules.

Si un programa de computadora tiene más de 100.000 líneas, entonces contiene un error.

Solución

∃ una persona p tal que p es rubia yp no tiene ojos azules.

Existe al menos un programa informático que tiene más de 100.000 líneas y no contiene ningún error. ■





La relación entre ∀, ∃, ∧ y ∨

La negación de una declaración para todos es una declaración de que existe, y la negación de una declaración de que existe es una declaración para todos. Estos hechos son análogos a las leyes de De Morgan, que establecen que la negación de un enunciado y es un enunciado o y que la negación de un enunciado o es un enunciado y. Esta similitud no es casual. En cierto sentido, los enunciados universales son generalizaciones de enunciados, y los enunciados existenciales son generalizaciones de enunciados.

Si Q(x) es un predicado y el dominio D de x es el conjunto x1, x2,..., xn, entonces los enunciados

∀x ∈ D,Q(x)

y Q(x1) ∧ Q(x2) ∧ ··· ∧ Q(xn)

son lógicamente equivalentes. Por ejemplo, sea Q(x) “x · x = x” y supongamos D = {0, 1}.



∀x ∈ D,Q(x)

se puede reescribir como ∀ dígitos binarios x, x · x = x.

Esto es equivalente a

0 · 0 = 0 y 1 · 1 = 1, que se pueden reescribir en símbolos como

Q(0) ∧ Q(1).

De manera similar, si Q(x) es un predi cate y D = {x1, x2,..., xn}, entonces las declaraciones

∃x ∈ D tal que Q(x)

y Q(x1) ∨ Q(x2) ∨ ··· ∨ Q(xn)

son lógicamente equivalentes. Por ejemplo, sea Q(x) “x + x = x” y supongamos D = {0, 1}.



∃x ∈ D tal que Q(x)

se puede reescribir como ∃ un dígito binario x tal que x + x = x.

Esto es equivalente a

0 + 0 = 0 o 1 + 1 = 1,

que se puede reescribir en símbolos como

Q(0) ∨ Q(1).

Verdad vacía de las declaraciones universales

Supongamos que hay un cuenco sobre una mesa y al lado del cuenco hay un montón de cinco bolas azules y cinco grises, cualquiera de las cuales puede colocarse en el cuenco. Si se colocan tres bolas azules y una gris en el tazón, como se muestra en la Figura 3.2.1(a), la afirmación “Todas las bolas en el tazón son azules” sería falsa (dado que una de las bolas en el tazón es gris).

Ahora supongamos que no se coloca ninguna bola en el recipiente, como se muestra en la Figura 3.2.1(b).

Considere la declaración

Todas las bolas del cuenco son azules.

¿Es esta declaración verdadera o falsa? Un enunciado es falso si y sólo si su negación es verdadera. Y su negación es

Existe una bola en el cuenco que no es azul.





Pero la única forma en que esta negación puede ser cierta es que realmente haya una bola que no sea azul en el cuenco. ¡Y no lo hay! Por tanto, la negación es falsa y, por tanto, el enunciado es verdadero "por defecto".

(b)

Figura 3.2.1

En general, una declaración de la forma

∀x en D, si P(x) entonces Q(x)

se llama vagamente verdadero o verdadero por defecto si, y sólo si, P(x) es falso para cada x en D. Por cierto, en el lenguaje ordinario las palabras en general significan que algo es usualmente, pero no siempre, lo mismo. caso. (En general, tomo el autobús a casa, pero hoy caminé). En matemáticas, las palabras en general se usan de manera bastante diferente. Cuando ocurren justo después de la discusión de un ejemplo particular (como en el párrafo anterior), son una señal de que lo que sigue es una generalización de algún aspecto del ejemplo que siempre es cierto.

Variantes de declaraciones condicionales universales

Recuerde de la Sección 2.2 que un enunciado condicional tiene un contrapositivo, un inverso y un inverso. Las definiciones de estos términos pueden extenderse a enunciados condicionales universales.



Ejemplo 3.2.5 Contrapositivo, inverso e inverso de una declaración condicional universal

Escriba un contrapositivo, inverso e inverso formal e informal para el siguiente enunciado:

Si un número real es mayor que 2, entonces su cuadrado es mayor que 4.

Solución La versión formal de esta afirmación es x R, si x > 2 entonces x 2 > 4.

Contrapositivo: x R, si x 2 4 entonces x 2.

O: Si el cuadrado de un número real es menor o igual a 4, entonces el número es menor o igual a 2.

Inversa: x R, si x 2 > 4 entonces x > 2.

O: Si el cuadrado de un número real es mayor que 4, entonces el número es mayor que 2.

Inversa: x R, si x 2 entonces x 2 4.

O: Si un número real es menor o igual a 2, entonces el cuadrado del número es menor o igual a 4.

Tenga en cuenta que al resolver este ejemplo, hemos utilizado la equivalencia de “x ≯ a” y “x ≤ a” para todos los números reales x y a. (Consulte la página 33.) ■





En la sección 2.2 mostramos que un enunciado condicional es lógicamente equivalente a su contrapositivo y que no es lógicamente equivalente ni a su inverso ni a su inverso. La siguiente discusión muestra que estos hechos se generalizan al caso de enunciados condicionales universales y sus contrapositivos, inversos e inversos.

Sean P(x) y Q(x) cualesquiera predicados, sea D el dominio de x y considere el enunciado







y su contrapositivo



∀x ∈ D, si P(x) entonces Q(x)



∀x ∈ D, si ∼Q(x) entonces ∼P(x).



Cualquier x particular en D que haga que “si P(x) entonces Q(x)” sea verdadero también hace que “si Q(x) entonces P(x)” sea verdadero (por la equivalencia lógica entre p q y q p). De ello se deduce que la oración “Si P(x) entonces Q(x)” es verdadera para todo x en D si, y sólo si, la oración “Si

Q(x) entonces P(x)” es cierto para todo x en D.

Así escribimos lo siguiente y decimos que un enunciado condicional universal es lógicamente equivalente a su contrapositivo:



En el ejemplo 3.2.5 notamos que la declaración

∀x ∈ R, si x > 2 entonces x 2 > 4

tiene el inverso ∀x ∈ R, si x 2 > 4 entonces x > 2.

Observe que el enunciado es verdadero mientras que su recíproco es falso (ya que, por ejemplo, (3)2 9 > 4 pero 3 ≯ 2). Esto muestra que un enunciado condicional universal puede tener un valor de verdad diferente al de su inverso. Por tanto, un enunciado condicional universal no es lógicamente equivalente a su inverso. Esto está escrito en símbolos de la siguiente manera:



En los ejercicios al final de esta sección, se le pedirá que demuestre de manera similar que un enunciado condicional universal no es lógicamente equivalente a su inverso.





Condiciones necesarias y suficientes, sólo si

Las definiciones de necesario, suficiente y sólo si también pueden extenderse para aplicarse a enunciados condicionales universales.









Ejemplo 3.2.6 Condiciones necesarias y suficientes

Reescribe las siguientes afirmaciones como afirmaciones condicionales cuantificadas. No utilice la palabra necesario o suficiente.

La cuadratura es una condición suficiente para la rectangularidad.

Tener al menos 35 años es condición necesaria para ser g Presidente de los Estados Unidos.

Solución

Una versión formal de la declaración es

∀x, si x es un cuadrado, entonces x es un rectángulo.

O, en lenguaje informal:

Si una figura es un cuadrado, entonces es un rectángulo.

Usando lenguaje formal, podrías escribir la respuesta como

∀ personas x, si x es menor de 35 años, entonces x

No puede ser Presidente de los Estados Unidos.

O, por la equivalencia entre un enunciado y su contrapositivo:

gente x, si x es presidente de los Estados Unidos,

entonces x tiene al menos 35 años. ■

Ejemplo 3.2.7 Sólo si

Reescribe lo siguiente como un enunciado condicional universal:

Un producto de dos números es 0 sólo si uno de los números es 0.

Solución Usando un lenguaje informal, podrías escribir la respuesta como

Si ninguno de dos números es 0, entonces el producto de los números no es 0.

O, por la equivalencia entre un enunciado y su contrapositivo,

Si el producto de dos números es 0, entonces uno de los números es 0. ■





Pruébate

Una negación para "Todos R tienen la propiedad S" es "Existe R

eso	."

Una negación para "Algunos R tienen la propiedad S" es "".

Una negación para "Para todo x, si x tiene la propiedad P, entonces x tiene la propiedad Q" es "".



Conjunto de ejercicios 3.2

¿Cuál de las siguientes es una negación de “Todos los estudiantes de matemáticas discretas son atléticos”? Más de una respuesta puede ser correcta.

Hay un estudiante de matemáticas discreto que no es atlético.

Ninguno de los estudiantes de matemáticas discretas es deportista.







Lo contrario de "Para todo x, si x tiene la propiedad P, entonces x tiene la propiedad Q" es "".

La contrapositiva de “Para todo x, si x tiene la propiedad P entonces x

tiene la propiedad Q” es “ .”

El inverso de "Para todo x, si x tiene la propiedad P, entonces x tiene la propiedad Q" es "".





Hay una persona atlética que es un estudiante discreto de matemáticas.

Ningún estudiante de matemáticas discretas es atlético.

Algunos estudiantes de matemáticas discretas no son deportistas.

Ninguna persona atlética es estudiante de matemáticas discreta.







¿Cuál de las siguientes es una negación de "Todos los perros son leales"? Más de una respuesta puede ser correcta.

a. Todos los perros son desleales. b. Ningún perro es leal.

C. Algunos perros son desleales. d. Algunos perros son leales.

Hay un animal desleal que no es un perro.

Hay un perro que es desleal.

Ningún animal que no sea perro es leal.

Algunos animales que no son perros son leales.

Escriba una negación formal para cada una de las siguientes afirmaciones:



Negación propuesta: el producto de cualquier número irracional

y cualquier número racional es racional.

Declaración: Para todos los números enteros n, si n2 es par, entonces n es

incluso.

Negación propuesta: Para todos los números enteros n, si n2 es par, entonces n es

ni siquiera.

Declaración: Para todos los números reales x1 y x2, si

x2 = x2 entonces x1 = x2.

Negación propuesta: Para todos los números reales x1 y x2, si

x 2 = x 2 entonces x1 /= x2.



∀ pez x, x tiene branquias. 1 2



Las computadoras c, c tienen una CPU.

una película m tal que m dura más de 6 horas.

una banda b tal que b ha ganado al menos 10 premios Grammy.

Escribe una negación informal para cada una de las siguientes afirmaciones. Tenga cuidado de evitar negaciones que sean ambiguas.

Todos los perros son amigables.

Toda la gente está feliz.

Algunas sospechas se confirmaron.

Algunas estimaciones son precisas.

Escribe una negación para cada una de las siguientes afirmaciones.

Cualquier argumento válido tiene una conclusión verdadera.

Todo número real es positivo, negativo o cero.

Escribe una negación para cada una de las siguientes afirmaciones.

Los conjuntos A y B no tienen puntos en común.

Las ciudades P y Q no están conectadas por ninguna carretera en el mapa.

El lenguaje informal es en realidad más complejo que el lenguaje formal. Por ejemplo, la frase "No hay pedidos de la tienda A para el artículo B" contiene las palabras que sí hay. ¿Es la afirmación existencial? Escriba una negación informal para el enunciado y luego escriba el enunciado formalmente usando cuantificadores y variables.

Considere la afirmación "No existen soluciones simples para los problemas de la vida". Escriba una negación informal para el enunciado y luego escriba el enunciado formalmente usando cuantificadores y variables.

Escribe una negación para cada afirmación de 9 y 10.

∀ números reales x , si x > 3 entonces x2 > 9.

programas de computadora P, si P se compila sin mensajes de error, entonces P es correcto.

En cada uno de los ejercicios 11 a 14, determine si la negación propuesta es correcta. Si no es así, escribe una negación correcta.

Declaración: La suma de dos números irracionales cualesquiera es irracional.

Negación propuesta: la suma de dos números irracionales cualesquiera

es racional.

Declaración: El producto de cualquier número irracional.

y cualquier número racional es irracional.



15. Sea D 48, 14, 8, 0, 1, 3, 16, 23, 26, 32, 36.

Determina cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas. Proporcione contraejemplos para aquellas afirmaciones que sean falsas.

x D, si x es impar entonces x > 0.

x D, si x es menor que 0 entonces x es par.

x D, si x es par entonces x 0.

x D, si el dígito de las unidades de x es 2, entonces el dígito de las decenas es 3 o 4.

x D, si el dígito de las unidades de x es 6, entonces el dígito de las decenas es 1 o 2.

En 16–23, escribe una negación para cada afirmación.

∀ números reales x , si x 2 ≥ 1 entonces x > 0.

∀ enteros d, si 6/d es un número entero entonces d = 3.

18. ∀x ∈ R, si x(x + 1)> 0 entonces x > 0 o x < −1.

∀n ∈ Z, si n es primo entonces n es impar o norte = 2.

∀ enteros a, b y c, si a − b es par y b − c es par, entonces a − c es par.

números enteros n, si n es divisible por 6, entonces n es divisible por 2 y n es divisible por 3.

Si el cuadrado de un número entero es impar, entonces el número entero es impar.

Si una función es diferenciable entonces es continua.

Vuelva a escribir los enunciados de cada par en forma si-entonces e indique la relación lógica entre ellos.

Todos los niños de la familia de Tom son mujeres. Todas las mujeres de la familia de Tom son niñas.

Todos los números enteros mayores que 5 y que terminan en 1, 3, 7 o 9 son primos.

Todos los números enteros mayores que 5 y que son primos terminan en 1, 3, 7 o 9.

Cada una de las siguientes afirmaciones es cierta. En cada caso, escriba lo contrario del enunciado y dé un contraejemplo que demuestre que lo contrario es falso.

Si n es cualquier número primo mayor que 2, entonces

n 1 es par.

Si m es un número entero impar, entonces 2m es par.

Si dos círculos se cortan exactamente en dos puntos, entonces no tienen un centro común.







En 26–33, para cada afirmación en el ejercicio al que se hace referencia, escriba lo inverso, lo inverso y lo contrapositivo. Indique lo mejor que pueda cuáles de los enunciados, su inverso, su inverso y su contrapositivo son verdaderos y cuáles son falsos. Da un contraejemplo para cada uno que sea falso.

Ejercicio 16 27. Ejercicio 17

28. Ejercicio 18 29. Ejercicio 19

30. Ejercicio 20 31. Ejercicio 21

32. Ejercicio 22 33. Ejercicio 23

Escribe el contrapositivo de cada una de las siguientes afirmaciones.

Si n es primo, entonces √n no es divisible por ningún número primo.

número entero mayor que 1.)

Si A y B no tienen ningún elemento en común, entonces son disjuntos. (Supongamos que A y B son conjuntos fijos.)

Dé un ejemplo para demostrar que un enunciado condicional universal no es lógicamente equivalente a su inverso.

✶ 36. Si P(x) es un predicado y el dominio de x es el conjunto de todos los números reales, sea R “ x Z, P(x)”, sea S “ x Q, P(x)”, y sea T “x R, P(x)”.

Encuentre una definición para P(x) (pero no use “x Z”) de manera que R sea verdadera y tanto S como T sean falsas.

Encuentre una definición para P(x) (pero no use “x Q”) de manera que tanto R como S sean verdaderos y T sea falso.

Considere la siguiente secuencia de dígitos: 0204. Una persona afirma que todos los unos de la secuencia están a la izquierda de todos los ceros de la secuencia. ¿Es esto cierto? Justifica tu respuesta. (Pista: escriba la afirmación formalmente y escriba una negación formal. ¿La negación es verdadera o falsa?)

¿Verdadero o falso? Todas las apariciones de la letra u en Matemáticas Discretas están en minúsculas. Justifica tu respuesta.

Reescribe cada enunciado de 39 a 42 en forma si-entonces.

Obtener una calificación de C en este curso es condición suficiente para que cuente para la graduación.



Respuestas para Ponte a prueba



Ser divisible por 8 es condición suficiente para ser divisible por 4.

Llegar a tiempo todos los días es una condición necesaria para mantener este trabajo.

Aprobar un examen completo es una condición necesaria para obtener una maestría.

Utilice los hechos de que la negación de un enunciado es un enunciado y que la negación de un enunciado si-entonces es un enunciado y para reescribir cada uno de los enunciados 43 a 46 sin utilizar la palabra necesario o suficiente.

Ser divisible por 8 no es condición necesaria para ser divisible por 4.

Tener grandes ingresos no es una condición necesaria para que una persona sea feliz.

Tener grandes ingresos no es condición suficiente para que una persona sea feliz.

Ser un polinomio no es condición suficiente para que una función tenga una raíz real.

Los informáticos Richard Conway y David Gries escribieron una vez:

La ausencia de mensajes de error durante la traducción de un programa informático es sólo una condición necesaria y

no es una condición suficiente para una corrección [del programa] razonable.

Reescribe esta declaración sin usar las palabras necesarias.

o suficiente.

Un folleto del club de viajeros frecuentes dice: "Puede seleccionar entre las aerolíneas sólo si ofrecen la misma tarifa más baja". Suponiendo que “sólo si” tiene un significado formal y lógico, ¿garantiza esta afirmación que si dos compañías aéreas ofrecen la misma tarifa más baja, el cliente será libre de elegir entre ellas? Explicar.



algunas (respuestas alternativas: al menos una; una); no tiene la propiedad S. 2. Ningún R tiene la propiedad S. 3. Hay un x tal que x tiene la propiedad P y x no tiene la propiedad Q. 4. Para todo x, si x tiene la propiedad Q entonces x tiene la propiedad P 5. Para todo x, si x no tiene la propiedad Q, entonces x no tiene la propiedad P. 6. Para todo x, si x no tiene la propiedad P, entonces x no tiene la propiedad Q.





No basta con tener buena mente. Lo principal es usarlo bien. - René Descartes



Imagine que está visitando una fábrica que fabrica microchips para computadoras. La guía de fábrica te dice,

Hay una persona supervisando cada detalle del proceso de producción.





Tenga en cuenta que esta afirmación contiene versiones informales tanto del cuantificador existencial que existe como del cuantificador universal cada. ¿Cuál de las siguientes describe mejor su significado?

Hay una sola persona que supervisa todos los detalles del proceso productivo.

Para cualquier particular En un detalle de producción, hay una persona que supervisa ese detalle, pero puede haber diferentes supervisores para diferentes detalles.

Da la casualidad de que cualquiera de las interpretaciones podría ser lo que quiso decir la guía. (¡Vuelva a leer la oración para asegurarse de que está de acuerdo!) Tomada en sí misma, su afirmación es genuinamente ambigua, aunque otras cosas que pudo haber dicho (el contexto de su afirmación) podrían haberla aclarado. En nuestra vida cotidiana, nos enfrentamos a este tipo de ambigüedad todo el tiempo. Normalmente el contexto ayuda a resolverlo, pero a veces simplemente nos malinterpretamos.

En cambio, en matemáticas, lógica formal e informática es esencial que todos interpretemos los enunciados exactamente de la misma manera. Por ejemplo, la etapa inicial del desarrollo de software generalmente implica una discusión cuidadosa entre un analista programador y un cliente para convertir descripciones vagas de lo que el cliente quiere en especificaciones de programa inequívocas que el cliente y el programador puedan acordar mutuamente.

Debido a que muchas declaraciones técnicas importantes contienen ambos y , se ha desarrollado una convención para interpretarlas de manera uniforme. Cuando un enunciado contiene más de un cuantificador, imaginamos que las acciones sugeridas por los cuantificadores se realizan en el orden en que ocurren los cuantificadores. Por ejemplo, considere una declaración de la forma

∀x en el conjunto D, ∃y en el conjunto E tal que xey satisfacen la propiedad P(x, y).

Para demostrar que tal afirmación es cierta, debe poder afrontar el siguiente desafío:

Imaginemos que a alguien se le permite elegir cualquier elemento del conjunto.

D, e imagina que la persona te regala ese elemento. Llámalo x.

El desafío para usted es encontrar un elemento y en E de modo que la x de la persona y su

y, en conjunto, satisfacen la propiedad P(x, y).

Tenga en cuenta que como no tiene que especificar y hasta que la otra persona haya especificado x, puede encontrar un valor diferente de y para cada x diferente que le den.

Ejemplo 3.3.1 Verdad de una afirmación ∀∃ en un mundo Tarski

Considere el mundo Tarski que se muestra en la Figura 3.3.1.



Figura 3.3.1

Demuestre que la siguiente afirmación es cierta en este mundo:

Para todos los triángulos x, existe un cuadrado y tal que xey tienen el mismo color.





Solución El enunciado dice que no importa qué triángulo te dé alguien, podrás encontrar un cuadrado del mismo color. Sólo hay tres triángulos, d, f e i. La siguiente tabla muestra que para cada uno de estos triángulos se puede encontrar un cuadrado del mismo color.









■

Ahora considere una declaración que contiene tanto ∀ como ∃, donde ∃ viene antes de ∀:

∃ una x en D tal que ∀y en E, xey satisfacen la propiedad P(x, y).

Para demostrar que una afirmación de esta forma es verdadera:

Debes encontrar un solo elemento (llámalo x ) en D con la siguiente propiedad:

Una vez que haya encontrado su x , alguien puede elegir cualquier elemento de E . La persona te desafía dándote ese elemento. Llámalo y.

Su trabajo es demostrar que su x junto con la y de la persona satisfacen la propiedad P(x, y).

Tenga en cuenta que su x tiene que funcionar para cualquier y que la persona le proporcione; no se le permite cambiar su x una vez que la haya especificado inicialmente.



Ejemplo 3.3.2 Verdad de una afirmación ∃∀ en un mundo Tarski

Consideremos nuevamente el mundo Tarski en la Figura 3.3.1. Demuestre que la siguiente afirmación es verdadera: Hay un triángulo x tal que para todos los círculos y, x está a la derecha de y.

Solución El enunciado dice que puedes encontrar un triángulo que está a la derecha de todos los círculos. En realidad, d o i funcionarían para los tres círculos, a, b y c, como puede ver en la siguiente tabla.











■

A continuación se muestra un resumen de la convención para interpretar declaraciones con dos cuantificadores diferentes:







Ejemplo 3.3.3 Interpretación de declaraciones cuantificadas multiplicadas*

La línea de una cafetería universitaria tiene cuatro estaciones: ensaladas, platos principales, postres y bebidas. La estación de ensaladas ofrece la opción de ensalada verde o macedonia de frutas; la estación de platos principales ofrece espaguetis o pescado; la estación de postres ofrece tarta o pastel; y la estación de bebidas ofrece leche, refrescos o café. Tres estudiantes, Uta, Tim y Yuen, pasan por la fila y toman las siguientes decisiones:

Estas opciones se ilustran en la Figura 3.3.2.



Ensaladas





uta





Timo





Yuen





Platos principales





Postres





Bebidas









Figura 3.3.2



Escriba cada una de las siguientes afirmaciones de manera informal y encuentre su valor de verdad.

∃ un ítem I tal que ∀ estudiantes S, S eligieron I .

∃ un estudiante S tal que ∀ elementos I, S eligió I.

∃ un estudiante S tal que ∀ estaciones Z, ∃ un elemento I en Z tal que S eligió I .

∀ estudiantes S y ∀ estaciones Z, ∃ un elemento I en Z tal que S eligió I.

Solución



Hay un elemento que fue elegido por cada estudiante. Esto es cierto; cada estudiante eligió pastel.

Hay un estudiante que eligió todos los artículos disponibles. Esto es falso; ningún estudiante eligió los nueve ítems.

Hay un estudiante que eligió al menos un elemento de cada estación. Esto es cierto; Tanto Uta como Tim eligieron al menos un elemento de cada estación.

Cada estudiante eligió al menos un elemento de cada estación. Esto es falso; Yuen no eligió ensalada. ■







∗El término “multiplicar-cuantificado” se pronuncia MUL-ti-plee QUAN-ti-ﬁdo. Un enunciado con cuantificación múltiple es un enunciado que contiene más de un cuantificador.





Traducir del lenguaje informal al formal

La mayoría de los problemas se plantean en un lenguaje informal, pero resolverlos a menudo requiere traducirlos a términos más formales.



Ejemplo 3.3.4 Traducción de declaraciones cuantificadas múltiples del lenguaje informal al formal

El recíproco de un número real a es un número real b tal que ab 1. Las dos afirmaciones siguientes son verdaderas. Reescríbalos formalmente usando cuantificadores y variables:

Todo número real distinto de cero tiene un recíproco.

Hay un número real sin recíproco. El número 0 no tiene recíproco.

Solución

∀ números reales distintos de cero u, ∃ un número real v tal que uv = 1.

∃ un número real c tal que ∀ números reales d, cd /= 1. ■



Ejemplo 3.3.5 Hay un entero positivo más pequeño

Recuerde que todo número entero es un número real y que los números reales son de tres tipos: positivos, negativos y cero (el cero no es ni positivo ni negativo). Considere la afirmación "Existe un número entero positivo más pequeño". Escribe esta declaración formalmente usando ambos símbolos.

∃ y ∀.

Solución Decir que hay un entero positivo más pequeño significa que hay un entero positivo m con la propiedad de que no importa qué entero positivo n una persona pueda elegir, m será menor o igual que n:

∃ un entero positivo m tal que ∀ enteros positivos n, m ≤ n.

Tenga en cuenta que esta afirmación es cierta porque 1 es un número entero positivo que es menor o igual que todo número entero positivo.







–5 –4 –3









enteros positivos





–2 –1 0 1 2 3 4 5

■





Ejemplo 3.3.6 No existe el número real positivo más pequeño

Imagine cualquier número real positivo x en la recta numérica real. Estos números corresponden a todos los puntos a la derecha de 0. Observe que no importa cuán pequeño sea x, el número x/2 será positivo y menor que x .∗

–2 –1 0 x 1 2

X

2

∗Esto se puede deducir de las propiedades de los números reales dadas en el Apéndice A. Como x es positivo, 0 < x . Suma x a ambos lados para obtener x < 2x . Entonces 0 < x < 2x . Ahora multiplica todas las partes de la desigualdad por el número positivo 1/2. Esto no cambia la dirección de la desigualdad, por lo que 0 < x/2 < x .





Por tanto, la siguiente afirmación es verdadera: "No existe un número real positivo más pequeño". Escribe esta declaración formalmente usando ambos símbolos ∀ y ∃.

Solución ∀ números reales positivos x, ∃ un número real positivo y tal que y < x. ■

Ejemplo 3.3.7 Definición de límite de una secuencia

La definición de límite de una sucesión, estudiada en cálculo, utiliza tanto cuantificadores como y también si-entonces. Decimos que el límite de la secuencia an cuando n tiende al infinito es igual a L y escribimos



Lim

n→∞



un = L



si, y sólo si, los valores de an se acercan arbitrariamente a L a medida que n crece cada vez más sin límite. Más precisamente, esto significa que dado cualquier número positivo ε, podemos encontrar un número entero N tal que siempre que n sea mayor que N, el número an se encuentre entre L − ε y L + ε en la recta numérica.

L – ε L L + ε







Simbólicamente:



an debe estar aquí cuando n > N





∀ε>0, ∃ un número entero N tal que ∀ enteros n,

si n > N entonces L − ε< an < L + ε.



Considerando la complejidad lógica de esta definición, no sorprende que a muchos estudiantes les resulte difícil entenderla. ■

Lenguaje ambiguo

El dibujo de la Figura 3.3.3 es un famoso ejemplo de ambigüedad visual. Cuando lo mires un rato, probablemente verás la silueta de una mujer joven con un sombrero grande o una mujer mayor con una nariz grande. Cualquiera que sea la imagen que primero te venga a la mente,



Figura 3.3.3





Intente ver cómo se puede interpretar el dibujo de otra manera. (Pista: la boca de la anciana es el collar de la joven).

Una vez que la mayoría de las personas ven una de las imágenes, les resulta difícil percibir la otra. Lo mismo ocurre con el lenguaje ambiguo. Una vez que interpretaste la oración al comienzo de esta sección de una manera, puede que te haya resultado difícil ver que se podía entender de otra manera. Quizás tuvo dificultades a pesar de que se le explicaron los dos posibles significados, así como muchas personas tienen dificultades para ver la segunda interpretación.

tación para el dibujo incluso cuando se les dice qué buscar.

Aunque las declaraciones escritas de manera informal pueden estar abiertas a múltiples interpretaciones, no podemos determinar su verdad o falsedad sin interpretarlas de una forma u otra. Por lo tanto, tenemos que utilizar el contexto para intentar determinar su significado lo mejor que podamos.







Negaciones de declaraciones cuantificadas multiplicadamente

Puede utilizar las mismas reglas para negar enunciados cuantificados múltiples que utilizó para negar enunciados cuantificados más simples. Recordar que

∼(∀x en D, P(x)) ≡ ∃x en D tal que ∼P(x).





y





∼(∃x en D tal que P(x)) ≡ ∀x en D, ∼P(x).





Aplicamos estas leyes para encontrar



∼(∀x en D, ∃y en E tal que P(x, y))

moviéndose en etapas de izquierda a derecha a lo largo de la oración.



Primera versión de la negación: ∃x en D tal que ∼(∃y en E tal que P(x, y)). Versión final de la negación: ∃x en D tal que ∀y en E, ∼P(x, y).

De manera similar, para encontrar









tenemos



∼(∃x en D tal que ∀y en E, P(x, y)),



Primera versión de la negación: ∀x en D, ∼(∀y en E, P(x, y)).

Versión final de la negación: ∀x en D, ∃y en E tal que ∼P(x, y).





Estos hechos se pueden resumir de la siguiente manera:











Ejemplo 3.3.8 Enunciados negadores en un mundo Tarski

Consulte el mundo Tarski de la Figura 3.3.1, que se reproduce aquí como referencia.





Escribe una negación para cada una de las siguientes afirmaciones y determina cuál es verdadera, la afirmación dada o su negación.

Para todos los cuadrados x, existe un círculo y tal que xey tienen el mismo color.

Hay un triángulo x tal que para todos los cuadrados y, x está a la derecha de y.

Solución

Primera versión de la negación: un cuadrado x tal que (un círculo y tal

que x e y tienen el mismo color).

Versión final de la negación: un cuadrado x tal que rodea a y, x e y

no tienen el mismo color.

La negación es cierta. El cuadrado e es negro y ningún círculo es negro, por lo que hay un cuadrado que no tiene el mismo color que ningún círculo.

Primera versión de la negación: triángulos x, (cuadrados y, x es a la

derecha de y).

Versión final de la negación: triángulos x, un cuadrado y tal que x es

no a la derecha de y.

La negación es verdadera porque no importa qué triángulo se elija, no está a la derecha del cuadrado g (o del cuadrado j). ■



Orden de cuantificadores

Considere las siguientes dos afirmaciones:

∀ personas x, ∃ una persona y tal que x ama a y.

∃ una persona y tal que ∀ la gente x, x ama a y.

Tenga en cuenta que, excepto por el orden de los cuantificadores, estas afirmaciones son idénticas. Sin embargo, el primero significa que, dada cualquier persona, es posible encontrar a alguien a quien esa persona ama, mientras que el segundo significa que hay un individuo asombroso que es amado por todas las personas. (¡Vuelva a leer las afirmaciones cuidadosamente para verificar estas interpretaciones!) Las dos oraciones ilustran una propiedad extremadamente importante acerca de las afirmaciones cuantificadas múltiples:











¡Precaución! Si un enunciado contiene dos cuantificadores diferentes, invertir su orden puede cambiar el valor de verdad del enunciado a su opuesto.







Sin embargo, es interesante que si un cuantificador sigue inmediatamente a otro cuantificador del mismo tipo, entonces el orden de los cuantificadores no afecta el significado. Considere la propiedad conmutativa de la suma de números reales, por ejemplo:

∀ números reales x y ∀ números reales y, x + y = y + x.

Esto significa lo mismo que

∀ números reales y y ∀ números reales x, x + y = y + x.

Por tanto, la propiedad se puede expresar más brevemente como

∀ números reales x e y, x + y = y + x.





Ejemplo 3.3.9 Orden de cuantificadores en un mundo Tarski

Mire nuevamente el mundo Tarski de la Figura 3.3.1. ¿Tienen las siguientes dos afirmaciones el mismo valor de verdad?

Por cada cuadrado x existe un triángulo y tal que xey tienen colores diferentes.

Existe un triángulo y tal que para cada cuadrado x, xey tienen colores diferentes.

El enunciado de solución (a) dice que si alguien te da uno de los cuadrados del mundo de Tarski, puedes encontrar un triángulo que tiene un color diferente. Esto es cierto. Si alguien te da el cuadrado g o h (que son grises), puedes usar el triángulo d (que es negro); si alguien te da el cuadrado e (que es negro), puedes usar el triángulo f o el triángulo i (ambos grises); y si alguien te da el cuadrado j (que es azul), puedes usar el triángulo d (que es negro) o el triángulo f o i (ambos grises).

El enunciado (b) dice que hay un triángulo particular en el mundo de Tarski que tiene un color diferente al de cada uno de los cuadrados del mundo. Esto es falso. Dos de los triángulos son grises, pero no pueden usarse para mostrar la verdad de la afirmación porque el mundo Tarski contiene cuadrados grises. El único otro triángulo es negro, pero tampoco se puede utilizar porque hay un cuadrado negro en el mundo de Tarski.

Por tanto, una de las afirmaciones es verdadera y la otra es falsa, por lo que tienen valores de verdad opuestos. ■





Notación lógica formal

En algunas áreas de la informática, los enunciados lógicos se expresan en notación puramente simbólica. La notación implica el uso de predicados para describir todas las propiedades de las variables y omitir palabras como eso en declaraciones existenciales. (Cuando intentas descubrir el significado de una estadística formal (Sin embargo, es útil pensar las palabras de tal manera que cada vez sean apropiadas para usted). El formalismo también depende de los siguientes hechos:

“∀x en D, P(x)” se puede escribir como “∀x(x en D → P(x))”, y

“∃x en D tal que P(x)” se puede escribir como “∃x(x en D ∧ P(x))”. Ilustramos el uso de estos hechos en el Ejemplo 3.3.10.





Ejemplo 3.3.10 Formalización de declaraciones en un mundo Tarski

Consideremos una vez más el mundo Tarski de la Figura 3.3.1:





Sean Triángulo(x), Círculo(x) y Cuadrado(x) significan “x es un triángulo”, “x es un círculo” y “x es un cuadrado”; dejemos que Azul(x), Gris(x) y Negro(x) signifiquen “x es azul”, “x es gris” y “x es negro”; deje que RightOf(x, y), Above(x, y) y SameColorAs(x, y) signifiquen "x está a la derecha de y", "x está encima de y" y "x tiene el mismo color que y". ; y use la notación x y para denotar el predicado “x es igual a y”. Sea el dominio común D de todas las variables el conjunto de todos los objetos del mundo Tarski. Utilice notación lógica formal para escribir cada una de las siguientes afirmaciones y escriba una negación formal para cada afirmación.

Para todos los círculos x, x está por encima de f.

Existe un cuadrado x tal que x es negro.

Para todos los círculos x, existe un cuadrado y tal que xey tienen el mismo color.

Hay un cuadrado x tal que para todos los triángulos y, x está a la derecha de y.

Solución

Declaración: ∀x (Círculo(x) → Arriba(x, f )).

Negación: ∼(∀x(Círculo(x) → Arriba(x, f )))

≡ ∃x ∼ (Círculo(x) → Arriba(x, f ))

por la ley para negar una declaración ∀

x(Círculo(x) Arriba(x, f ))

por la ley de negar un enunciado si-entonces

Declaración: ∃x (Cuadrado(x) ∧ Negro(x)).

Negación: ∼(∃x(Cuadrado(x) ∧ Negro(x)))

≡ ∀x ∼ (Cuadrado(x) ∧ Negro(x))

por la ley para negar una declaración ∃

x( Cuadrado(x) Negro(x))

por la ley de De Morgan

Declaración: ∀x (Círculo(x) → ∃y(Cuadrado(y) ∧ MismoColor(x, y))). Negación: ∼(∀x(Círculo(x) → ∃y(Cuadrado(y) ∧ MismoColor(x, y))))

≡ ∃x ∼ (Círculo(x) → ∃y(Cuadrado(y) ∧ MismoColor(x, y)))

por la ley para negar una declaración ∀

x(Círculo(x) ( y(Cuadrado(y) Mismo color(x, y))))

por la ley para negar una declaración si-entonces





≡ ∃x(Círculo(x) ∧ ∀y(∼(Cuadrado(y) ∧ MismoColor(x, y))))

por la ley para negar una declaración ∃

x(Círculo(x) y( Cuadrado(y) Mismo color(x, y)))

por la ley de De Morgan

Declaración: ∃x (Cuadrado(x) ∧ ∀y(Triángulo(y) → RightOf(x, y))). Negación: ∼(∃x (Cuadrado(x) ∧ ∀y(Triángulo(y) → RightOf(x, y))))

≡ ∀x ∼ (Cuadrado(x) ∧ ∀y(Triángulo(x) → RightOf(x, y)))

por la ley para negar una declaración ∃

x( Cuadrado(x) ( y(Triángulo(y) DerechaDe(x, y))))

por la ley de De Morgan

≡ ∀x(∼Cuadrado(x) ∨ ∃y(∼(Triángulo(y) → RightOf(x, y))))

por la ley para negar una declaración ∀

x( Cuadrado(x) y(Triángulo(y) DerechaDe(x, y)))

por la ley para negar una declaración si-entonces

■



La desventaja de la notación totalmente formal es que, debido a que es compleja y algo alejada de la comprensión intuitiva, cuando la utilizamos podemos cometer errores que pasan desapercibidos. La ventaja, sin embargo, es que las operaciones, como por ejemplo las negaciones, pueden hacerse completamente mecánicas y programarse en una computadora. Además, cuando nos sentimos cómodos con las manipulaciones formales, podemos usarlas para verificar nuestra intuición, y luego podemos usar nuestra intuición para verificar nuestras manipulaciones formales. La notación lógica formal se utiliza en ramas de la informática como la inteligencia artificial, la verificación de programas y la teoría de autómatas y los lenguajes formales.

En conjunto, los símbolos de cuantificadores, variables, predicados y conectivos lógicos constituyen lo que se conoce como el lenguaje de la lógica de primer orden. Aunque este idioma es más simple en muchos aspectos que el idioma que usamos todos los días, aprenderlo requiere el mismo tipo de práctica que se necesita para adquirir cualquier idioma extranjero.



Prólogo

El lenguaje de programación Prolog (abreviatura de programación en lógica) fue desarrollado en Francia en la década de 1970 por A. Colmerauer y P. Roussel para ayudar a los programadores que trabajan en el campo de la inteligencia artificial. Un programa Prolog simple consta de un conjunto de declaraciones que describen alguna situación junto con preguntas sobre la situación. Integradas en el lenguaje están las técnicas de búsqueda e inferencia necesarias para responder las preguntas derivando las respuestas de las afirmaciones dadas. Esto libera al programador de la necesidad de escribir programas separados para responder cada tipo de pregunta. El ejemplo 3.3.11 ofrece un ejemplo muy sencillo de un programa Prolog.



Ejemplo 3.3.11 Un programa de prólogo

Considere la siguiente imagen, que muestra bloques de colores apilados sobre una mesa.





= bloque gris



= bloque azul 1



= bloque azul 2



= bloque azul 3



= bloque blanco 1



= bloque blanco 2









Nota Las diferentes implementaciones de Prolog siguen diferentes convenciones sobre cómo representar nombres de constantes, variables y predicados y formas de preguntas y respuestas.

Las convenciones utilizadas aquí son similares a las de Edinburgh Prolog.



Las siguientes son declaraciones en Prolog que describen esta imagen y plantean dos preguntas al respecto.

está arriba (g, b1) color (g, gris) color (b3, azul) está arriba (b1, w1) color (b1, azul) color (w1, blanco) está arriba (w2, b2) color (b2, azul) color ( w2, blanco)

está arriba (b2, b3) está arriba (X, Z) si está arriba (X, Y) y isab sobre(Y, Z)

?color(b1, azul) ?isarriba(X, w1)

Las declaraciones "isarriba(g, b1)" y "color(g, gris)" deben interpretarse como "g está por encima de b1" y "g es de color gris". La afirmación “está arriba(X, Z) si está arriba(X, Y) y está arriba(Y, Z)” debe interpretarse como “Para todo X, Y y Z, si X está arriba de Y e Y está arriba de Z, entonces X está por encima de Z”. La declaración del programa.

?color(b1, azul)

Es una pregunta que pregunta si el bloque b1 es de color azul. Prolog responde a esto escribiendo

Sí.



La declaración

?está arriba(X, w1)

































Pruébate



es una pregunta que pregunta para qué bloques X el predicado "X está por encima de w1" es verdadero. Prolog responde dando una lista de todos esos bloques. En este caso, la respuesta es

X = b1, X = g.

Tenga en cuenta que Prolog puede encontrar la solución X = b1 simplemente buscando en el conjunto original de hechos dados. Sin embargo, Prolog debe inferir la solución X = g a partir de las siguientes afirmaciones:

está arriba (g, b1),

está arriba (b1, w1),

está arriba (X, Z) si está arriba (X, Y) y está arriba (Y, Z).

Escribe las respuestas que daría Prolog si se añadieran las siguientes preguntas al programa anterior.

a. ?está arriba(b2, w1) b. ?color(w1, X) c. ?color(X, azul)

Solución

La pregunta significa "¿Está b2 por encima de w1?"; Por tanto, la respuesta es no."

La pregunta significa "¿Para qué colores X es verdadero el predicado 'w1 es de color X'?"; entonces la respuesta es “X = blanco”.

La pregunta significa "¿Para qué bloques es verdadero el predicado 'X es de color azul'?"; entonces la respuesta es “X = b1”, “X = b2” y “X = b3”. ■



Para establecer la verdad de un enunciado de la forma “x en D, y en E tal que P(x, y)”, imaginas que alguien te ha dado un elemento x de D pero que



Para establecer la verdad de un enunciado de la forma “x en D tal que y en E, P(x, y)”, es necesario encontrar que, sin importar lo que una persona pueda decirte posteriormente,



no tenemos control sobre cuál es ese elemento. Entonces serás sincero.

Necesita encontrar con la propiedad que x la persona.



le dio junto con el que posteriormente encontró satisfacer.



Considere la afirmación "x, y tal que P(x, y), una propiedad que involucra xey, es verdadera". Una negación de esta afirmación es "."







Considere el enunciado “x tal que y, P(x, y), una propiedad que involucra a x e y, es verdadera”. Una negación de esta afirmación es "."

Supongamos que P(x, y) es alguna propiedad que involucra a x e y, y supongamos el enunciado “∀x en D, ∃y en E tal que P(x, y)”



Conjunto de ejercicios 3.3

Sea C el conjunto de ciudades del mundo, sea N el conjunto de naciones del mundo y sea P(c, n) “c es la ciudad capital de n”. Determine los valores de verdad de las siguientes afirmaciones.

a. P (Tokio, Japón) b. P(Atenas, Egipto)

C. P (París, Francia) d. P(Miami, Brasil)

Sea G(x, y) “x 2 > y”. Indique cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas.

a.



es verdad. Entonces el enunciado “x en D tal que y en E, P(x, y)”

a. es verdad. b. Es falso. C. puede ser cierto o puede ser falso.











Sea S el conjunto de estudiantes de su escuela, sea M el conjunto de películas que se han estrenado alguna vez y sea V (s, m) “el estudiante s ha visto la película m”. Reescribe cada una de las siguientes afirmaciones sin utilizar el símbolo , el símbolo o las variables.

∃s ∈ S tal que V (s, Casablanca).

∀s ∈ S, V (s, Guerra de las Galaxias).

∀s ∈ S, ∃m ∈ M tal que V (s, m).

∃m ∈ M tal que ∀s ∈ S, V (s, m).



GRAMO(2, 3)



b. G(1, 1)



∃s ∈ S, ∃t ∈ S y ∃m ∈ M tales que s /= t y



  



La siguiente afirmación es verdadera: “∀ números x distintos de cero, ∃ un número real y tal que xy = 1”. Para cada x dada a continuación, encuentre una y para que el predicado “xy = 1” sea verdadero.

a. x = 2 b. x = −1c. x = 3/4

La siguiente afirmación es verdadera: “números reales x, un entero n tal que n > x”.∗ Para cada x dada a continuación, encuentre una n para que el predicado “n > x” sea verdadero.

a. x = 15,83b. x = 108 c. x = 101010

Las afirmaciones de los ejercicios 5 a 8 se refieren al mundo Tarski dado en el ejemplo 3.3.1. Explica por qué cada una es cierta.

Para todo círculo x existe un cuadrado y tal que xey tienen el mismo color.

Para todos los cuadrados x hay un círculo y tal que xey tienen diferentes colores y y está por encima de x.

Hay un triángulo x tal que para todos los cuadrados y, x está por encima de y.

Hay un triángulo x tal que para todos los círculos y, y está por encima de x.

Sea DE 2, 1, 0, 1, 2. Explique por qué las siguientes afirmaciones son verdaderas.

∀x en D, ∃y en E tal que x + y = 0.

∃x en D tal que ∀y en E, x + y = y.

Este ejercicio se refiere al Ejemplo 3.3.3. Determina si cada una de las siguientes afirmaciones es verdadera o falsa.

estudiantes S, un postre D tal que S eligió D.

estudiantes S, una ensalada T tal que S eligió T .

un postre D tal que los estudiantes S, S eligieron D.

una bebida B tal que los estudiantes D, D eligieron B.

un ítem I tal que los estudiantes S, S no eligieron I.

una estación Z tal que los estudiantes S, un elemento I tal que S elija I de Z.



V (s, m) → V (t, m).

Sea DE 2, 1, 0, 1, 2. Escribe negaciones para cada una de las siguientes afirmaciones y determina cuál es verdadera, la afirmación dada o su negación.

∀x en D, ∃y en E tal que x + y = 1.

∃x en D tal que ∀y en E, x + y = −y.

∀x en D, ∃y en E tal th en xy ≥ y.

∃x en D tal que ∀y en E , x ≤ y.

En cada uno de los ejercicios 13 a 19, (a) reescribe el enunciado en inglés sin usar el símbolo o las variables y expresando tu respuesta de la manera más simple posible, y (b) escribe una negación para el enunciado.

∀ colorea C, ∃ un animal A tal que A tiene color C .

∃ un libro b tal que ∀ personas p, p ha leído b.

∀ enteros impares n, ∃ un número entero k tal que n = 2k + 1.

∃ un número real u tal que ∀ números reales v, uv = v.

∀r ∈ Q, ∃ enteros a y b tales que r = a/b.

∀x ∈ R, ∃ un número real y tal que x + y = 0.

∃x ∈ R tal que para todos los números reales y, x + y = 0.

Recuerde que invertir el orden de los cuantificadores en un enunciado con dos cuantificadores diferentes puede cambiar el valor de verdad del enunciado, pero no necesariamente es así. Todas las afirmaciones en los pares de la página siguiente se refieren al mundo Tarski de la Figura 3.3.1. En cada par, el orden de los cuantificadores se invierte pero todo lo demás es igual. Para cada par, determine si las afirmaciones tienen valores de verdad iguales o opuestos. Justifica tus respuestas.







∗Se llama principio de Arquímedes porque fue formulado por primera vez (en términos geométricos) por el gran matemático griego Arquímedes de Siracusa, que vivió aproximadamente entre el 287 y el 212 a.E.C.







(1) Para todo cuadrado y existe un triángulo x tal que x y

Tienes diferente color.

(2) Existe un triángulo x tal que para todos los cuadrados y, x y

Tienes diferentes colores.

(1) Para todos los círculos y existe un cuadrado x tal que xey

tener el mismo color.

(2) Existe un cuadrado x tal que para todos los círculos y, x y

Tienes el mismo color.

Para cada una de las siguientes ecuaciones, determine cuáles de las siguientes afirmaciones son verdaderas:

Para todos los números reales x, existe un número real y

tal que la ecuación sea verdadera.

Existe un número real x, tal que para todos los números reales y, la ecuación es verdadera.

Tenga en cuenta que es posible que ambas afirmaciones sean verdaderas o que ambas sean falsas.

2x + y = 7

y + x = x + y

C. x2 − 2xy + y2 = 0

d. (x − 5)(y − 1) = 0

mi. x2 + y2 = −1

En 22 y 23, reescribe cada afirmación sin usar variables ni el símbolo ∀ o ∃. Indique si la aseveración es cierta o falsa.

R tal que y R− (el conjunto de números reales negativos), x > y.

Considere la afirmación “Todo el mundo es mayor que alguien”. Reescribe esta declaración en la forma “∀ personas x,

∃.”

Considere la afirmación “Alguien es mayor que todos”. Reescribe esta afirmación en la forma "∃ una persona x tal que ∀".

En 33–39, (a) reescriba el enunciado formalmente usando cuantificadores y variables, y (b) escriba una negación para el enunciado.

Todos aman a alguien.

Alguien ama a todos.

Todo el mundo confía en alguien.

Alguien confía en todos.

Cualquier número par es igual al doble de un número entero.

Cada acción tiene una reacción igual y opuesta.

Existe un programa que da la respuesta correcta a cada pregunta que se le plantea.

En el habla informal, la mayoría de las oraciones del tipo “Hay



a. ∀ números reales x, ∃ un número real y tal que x + y = 0. cada ” deben entenderse como



b. ∃ un número real y tal que ∀ números reales x, x + y = 0.

a. ∀ números reales distintos de cero r, ∃ un número real s tal que

r = 1.

∃ un número real r tal que ∀ números reales distintos de cero

s, rs = 1.

Utilice las leyes para negar enunciados universales y existenciales para derivar las siguientes reglas:

a. ∼(∀x ∈ D(∀y ∈ E( P(x, y))))

≡ ∃x ∈ D(∃y ∈ E(∼P(x, y)))

b. ∼(∃x ∈ D(∃y ∈ E( P(x, y))))

≡ ∀x ∈ D(∀y ∈ E(∼P(x, y)))

Cada afirmación de 25 a 28 se refiere al mundo Tarski de la figura.

3.3.1. Para cada uno, (a) determine si el enunciado es verdadero o falso y justifique su respuesta, (b) escriba una negación para el enunciado (refiriéndose, si lo desea, al resultado del ejercicio 24).

∀ círculos x y ∀ cuadrados y, x está por encima de y.

∀ círculos x y ∀ triángulos y, x está por encima de y.



que significa "", aunque el cuantificador existencial que existe viene antes que el cuantificador universal cada. Tenga en cuenta que esta interpretación se aplica a las siguientes frases conocidas. Reescríbalos usando cuantificadores y variables.

Cada minuto nace un tonto.

Hay un tiempo para cada propósito bajo el cielo.

Indique cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas. Justifica tus respuestas lo mejor que puedas.

∀x ∈ Z+, ∃y ∈ Z+ tal que x = y + 1.

∀x ∈ Z, ∃y ∈ Z tal que x = y + 1.

∃x ∈ R tal que ∀y ∈ R, x = y + 1.

∀x ∈ R+, ∃y ∈ R+ tal que xy = 1.

∀x ∈ R, ∃y ∈ R tal que xy = 1.

∀x ∈ Z+ y ∀y ∈ Z+, ∃z ∈ Z+ tales que z = x − y.

∀x ∈ Z y ∀y ∈ Z, ∃z ∈ Z tales que z = x − y.

∃u ∈ R+ tal que ∀v ∈ R+, uv< v.

Escriba la negación de la definición de límite de una secuencia dada en el ejemplo 3.3.7.



27. un círculo x y un cuadrado y tales que x está encima de y y x

y tienen diferentes colores.



43. La siguiente es la definición de lim



x →a



f (x) = L:



un triángulo x y un cuadrado y tal que x está encima de y y x

y y tienen el mismo color.

Para cada uno de los enunciados en 29 y 30, (a) escriba un nuevo enunciado intercambiando los símbolos y , y (b) indique cuál es verdadero: el enunciado dado, el versión con cuantificadores intercambiados, ninguno o ambos.

∀x ∈ R, ∃y ∈ R tal que x < y.



Para todos los números reales ε> 0, existe un número real δ> 0 tal que para todos los números reales x, si a − δ< x < a + δ y x /= a entonces

L − ε< f(x) < L + ε.

Escribe lo que significa para limx→a f (x) L. En otras palabras, escribe la negación de la definición.

La notación ∃! representa las palabras "existe un único". Así, por ejemplo, “∃! x tal que x es primo y x es par”







significa que hay uno y sólo un número primo par. ¿Cuáles de las siguientes afirmaciones son verdaderas y cuáles son falsas? Explicar.

∃! número real x tal que ∀ números reales y, xy = y.

∃! entero x tal que 1/x es un número entero.

∀ números reales x, ∃! número real y tal que x + y = 0.

✶ 45. Supongamos que P(x) es un predicado y D es el dominio de x. Reescribe la declaración “∃! x ∈ D tal que P(x)” sin utilizar el símbolo ∃!. (Consulte el ejercicio 44 para conocer el significado de ∃!.)

En 46–54, consulte el mundo Tarski que se muestra en la Figura 3.1.1, que se imprime nuevamente aquí como referencia. Los dominios de todas las variables constan de todos los objetos del mundo Tarski. Para cada enunciado, (a) indique si el enunciado es verdadero o falso y justifique su respuesta, (b) escriba el enunciado dado usando la notación lógica formal ilustrada en el Ejemplo 3.3.10, y (c) escriba la negación del enunciado dado usando la notación lógica formal del Ejemplo 3.3.10.



 









Para cada objeto x , existe un objeto y tal que x y

y xey tienen diferentes colores.

Para cada objeto x, existe un objeto y tal que si x y

entonces xey tienen colores diferentes.

Existe un objeto y tal que para todos los objetos x, si x y

entonces xey tienen colores diferentes.

Para todos los círculos x y para todos los triángulos y, x está a la derecha de y.

Hay un círculo x y un cuadrado y tales que x e y

tener el mismo color.

Hay un círculo x y hay un triángulo y tal que x y

Tienes el mismo color.

Sean P(x) y Q(x) predicados y supongamos que D es el dominio de x. En 55-58, para las formas de enunciado en cada par, determine si (a) tienen el mismo valor de verdad para cada elección de P(x), Q(x) y D, o (b) hay una elección de P(x), Q(x) y D para los cuales tienen valores de verdad opuestos.

55. ∀x ∈ D,( P(x) ∧ Q(x)), y

(∀x ∈ D, P(x)) ∧ (∀x ∈ D, Q(x))

56. ∃x ∈ D,( P(x) ∧ Q(x)), y

(∃x ∈ D, P(x)) ∧ (∃x ∈ D, Q(x))

57. ∀x ∈ D,( P(x) ∨ Q(x)), y

(∀x ∈ D, P(x)) ∨ (∀x ∈ D, Q(x))

58. ∃x ∈ D,( P(x) ∨ Q(x)), y

(∃x ∈ D, P(x)) ∨ (∃x ∈ D, Q(x))

En 59–61, encuentre las respuestas que daría Prolog si se agregaran las siguientes preguntas al programa dado en el ejemplo 3.3.11.









Hay un triángulo x tal que para todos los cuadrados y, x está por encima de y.

Hay un triángulo x tal que para todos los círculos y, x está por encima de y.

Para todos los círculos x, existe un cuadrado y tal que y está a la derecha de x.



59. a. ?está arriba(b1, w1)

b. ?color(X, blanco)

C. ?está arriba(X, b3)

61. a. ?está arriba(w2, b3)

b. ?color(X, gris)

C. ?está arriba(g, X )



60. a. ?está arriba(w1, g)

b. ?color(w2, azul)

C. ?está arriba(X, b1)







Respuestas para Ponte a prueba

un elemento y en E; y; P(x, y) 2. un elemento x en D; y en mi; P(x, y) 3. x tal que y, la propiedad P(x, y) es falsa. 4. x, y tal que la propiedad P(x, y) sea falsa. 5. La respuesta es (c): la verdad o falsedad de un enunciado en el que los cuantificadores están invertidos.

Depende de la naturaleza de la propiedad que involucra a x e y.







La única salvaguardia completa contra el mal razonamiento es el hábito de razonar bien; familiaridad con los principios del razonamiento correcto; y práctica en la aplicación de esos principios. -John Stuart Mill



La regla de instanciación universal (in-stan-she-AY-shun) dice lo siguiente:





El uso de las palabras instanciación universal indica que la verdad de una propiedad en un caso particular se sigue como una instancia especial de su verdad más general o universal. La validez de esta forma de argumento se deriva inmediatamente de la definición de valores de verdad para un enunciado universal. Uno de los ejemplos más famosos de creación de instancias universales es el siguiente:

Todos los hombres son mortales. Sócrates es un hombre.

∴ Sócrates es mortal.

La instanciación universal es la herramienta fundamental del razonamiento deductivo. Las fórmulas, definiciones y teoremas matemáticos son como plantillas generales que se utilizan una y otra vez en una amplia variedad de situaciones particulares. Un teorema dado dice que tal o cual cosa es cierta para todas las cosas de cierto tipo. Si, en una situación dada, tienes un objeto particular de ese tipo, entonces, mediante instanciación universal, concluyes que tal o cual cosa es cierta para ese objeto en particular. Puedes repetir este proceso 10, 20 o más veces en una sola prueba o solución de problema.

Como ejemplo de instanciación universal, supongamos que está resolviendo un problema que requiere simplificar rk+1·r,

donde r es un número real particular y k es un número entero particular. Sabes por tu estudio de álgebra que las siguientes afirmaciones universales son verdaderas:

Para todos los números reales x y todos los números enteros m y n, xm · xn = xm+n.

Para todos los números reales x, x 1 = x . Entonces procedes un s sigue:

rk+1·r = rk+1·r 1 Paso 1

= r(k+1)+1 Paso 2

= rk+2 por álgebra básica.

El razonamiento detrás de los pasos 1 y 2 se describe a continuación.



Paso 1: Para todos los números reales x, x 1 x. verdad universal

r es un número real particular. instancia particular

∴ r 1 = r. conclusión

Paso 2: Para todos los números reales x y todos los números enteros

m y n, xm xn xm+n. verdad universal

r es un número real particular y k 1

y 1 son números enteros particulares. instancia particular

∴ rk+1·r 1 = r(k+1)+1. conclusión

Ambos argumentos son ejemplos de instanciación universal.





Modus Ponentes Universales

La regla de instanciación universal se puede combinar con el modus ponens para obtener la forma válida de argumento llamada modus ponens universal.



Tenga en cuenta que la primera premisa, o principal, del modus ponens universal podría escribirse “Todo lo que hace que P(x) sea verdadero hace que Q(x) sea verdadero”, en cuyo caso la conclusión se seguiría únicamente mediante la instanciación universal. Sin embargo, la forma si-entonces es más natural de usar en la mayoría de situaciones matemáticas.



Ejemplo 3.4.1 Reconocimiento del Modus Ponens Universal

Reescribe el siguiente argumento usando cuantificadores, variables y símbolos de predicados. ¿Es válido este argumento? ¿Por qué?

Si un número entero es par, entonces su cuadrado es par.

k es un número entero particular que es par.

∴ k2 es par.

Solución La premisa principal de este argumento se puede reescribir como

∀x, si x es un número entero par entonces x 2 es par.

Sea E(x) “x es un entero par”, sea S(x) “x 2 es par” y sea k un número entero particular que es par. Entonces el argumento tiene la siguiente forma:

∀x, si E(x) entonces S(x). E(k), para un k particular.

∴S(k).

Este argumento tiene la forma de modus ponens universal y, por tanto, es válido. ■



Ejemplo 3.4.2 Sacar conclusiones utilizando el Modus Ponens universal

Escribe la conclusión que se puede inferir usando el modus ponens universal.



Si T es cualquier triángulo rectángulo con hipotenusa

c y los catetos a y b, entonces c2 = a2 + b2. El triángulo que se muestra a la derecha es un triángulo rectángulo con ambos catetos iguales a 1 y

hipotenusa c.

∴.

Solución c2 = 12 + 12 = 2





Teorema de pitágoras

c 1

1



Tenga en cuenta que si toma la raíz cuadrada no negativa de ambos lados de esta ecuación, obtendrá

obtenga c = 2. Este √ muestra que hay un segmento de recta cuya longitud es 2. Sección 4.7

contiene una prueba de que 2 no es un número racional. ■



Uso del Modus Ponens Universal en una prueba

En el capítulo 4 analizamos métodos para probar afirmaciones cuantificadas. Aquí hay una prueba de que la suma de dos números enteros pares cualesquiera es par. Hace uso de la definición de número entero par, es decir, que un número entero es par si, y sólo si, es igual al doble de algún número entero. (O, más formalmente: ∀ enteros x, x es par si, y sólo si, ∃ un entero k tal que x = 2k.)

Supongamos que m y n son números enteros pares particulares pero elegidos arbitrariamente. Entonces m = 2r para algún número entero r,(1) y n = 2s para algún número entero s.(2) Por lo tanto

m + n = 2r + 2s por sustitución

= 2(r + s)(3) factorizando el 2.

Ahora bien, r + s es un número entero,(4) y por tanto 2(r + s) es par.(5) Por tanto, m + n es par.

La siguiente ampliación de la demostración muestra cómo cada uno de los pasos numerados se justifica mediante argumentos que son válidos según el modus ponens universal.





Nota El principio lógico de la instanciación existencial dice que si sabemos que algo existe, podemos darle un nombre. Este principio, que se analiza con más detalle en la sección 4.1, nos permite dar a los números enteros los nombres r y s.



Si un número entero es par, entonces es igual al doble de un número entero.

m es un número entero par particular.

∴ m es igual al doble de algún número entero r.

Si un número entero es par, entonces es igual al doble de un número entero.

n es un número entero par particular.

∴ n es igual al doble de algún número entero s.

Si una cantidad es un número entero, entonces es un número real.

r y s son números enteros particulares.

∴ r y s son números reales.

Para todos a, b y c, si a, b y c son números reales, entonces ab ac a(b c). 2, r y s son números reales particulares.

∴ 2r + 2s = 2(r + s).

Para todos u y v, si u y v son números enteros, entonces u v es un número entero.

r y s son dos números enteros particulares.

∴ r + s es un número entero.

Si un número es igual al doble de un número entero, entonces ese número es par. 2(r + s) es igual al doble del número entero r + s.

2(r + s) es par.

Por supuesto, la prueba real de que la suma de números enteros pares es par no contiene explícitamente la secuencia de argumentos dada anteriormente. (¡Dios no lo quiera!) Y, de hecho, las personas que son buenas en el pensamiento analítico normalmente ni siquiera son conscientes de que están razonando de esta manera. Pero eso se debe a que han absorbido el método tan completamente que se ha vuelto casi tan automático como respirar.



Modus universal de peajes

Otra regla de inferencia de crucial importancia es el modus tollens universal. Su validez resulta de combinar la instanciación universal con el modus tollens. El modus tollens universal es el corazón de la prueba de contradicción, que es uno de los métodos más importantes de argumentación matemática.









Ejemplo 3.4.3 Reconocimiento de la forma del Modus Tollens universal

Reescribe el siguiente argumento usando cuantificadores, variables y símbolos de predicados. Escribe la premisa mayor en forma condicional. ¿Es válido este argumento? ¿Por qué?

ATodos los seres humanos son mortales. Zeus no es mortal.

∴ Zeus no es humano.

Solución La premisa principal se puede reescribir como

∀x, si x es humano entonces x es mortal.

Sea H(x) “x es humano”, sea M(x) “x es mortal” y sea Z el equivalente de Zeus. El argumento se convierte

∀x, si H(x) entonces M(x)

∼M(Z)

∴ ∼H(Z).

Este argumento tiene la forma de un modus tollens universal y, por tanto, es válido. ■



Ejemplo 3.4.4 Sacar conclusiones utilizando el modo universal Tollens

Escribe la conclusión que se puede inferir usando el modus tollens universal.

Todos los profesores están distraídos. Tom Hutchins no está distraído.

∴.

Solución Tom Hutchins no es profesor. ■



Demostrar la validez de argumentos con afirmaciones cuantificadas

La definición intuitiva de validez para argumentos con enunciados cuantificados es la misma que para argumentos con enunciados compuestos. Un argumento es válido si, y sólo si, la verdad de su conclusión se sigue necesariamente de la verdad de sus premisas. La definición formal es la siguiente:







Como ya se señaló, la validez de la instanciación universal se deriva inmediatamente de la definición del valor de verdad de un enunciado universal. Las pruebas formales generales de validez de argumentos en el cálculo de predicados están fuera del alcance de este libro. Damos la prueba de la validez del modus ponens universal como ejemplo para mostrar que tales pruebas son posibles y dar una idea de cómo se ven.

El modus ponens universal afirma que

∀x, si P(x) entonces Q(x). P(a) para un a particular.

∴ Q(a).

Para demostrar que esta forma de argumento es válida, supongamos que las premisas mayor y menor son ambas verdaderas. [Debemos demostrar que la conclusión “Q(a)” también es verdadera.] Según la premisa menor, P(a) es verdadera para un valor particular de a. Según la premisa mayor y la instanciación universal, la afirmación “Si P(a) entonces Q(a)” es verdadera para ese a en particular. Pero por modus ponens, dado que las afirmaciones “Si P(a) entonces Q(a)” y “P(a)” son ambas verdaderas, se deduce que Q(a) también es verdadera. [Esto es lo que se iba a mostrar.]

La prueba de validez dada anteriormente es abstracta y algo sutil. Incluimos las pruebas no porque esperemos que usted pueda inventarlas usted mismo en esta etapa de su estudio. Más bien, pretende ser un vistazo a un tratamiento más avanzado del tema, que puede probar en los ejercicios 35 y 36 al final de esta sección si lo desea.

¡Una de las paradojas del estudio formal de la lógica es que las leyes de la lógica se utilizan para demostrar que las leyes de la lógica son válidas!

En la siguiente parte de esta sección mostraremos cómo se pueden utilizar diagramas para analizar la validez o invalidez de argumentos que contienen afirmaciones cuantificadas. Los diagramas no proporcionan pruebas totalmente rigurosas de validez e invalidez y en algunos entornos complejos pueden incluso resultar confusos, pero en muchas situaciones son útiles y convincentes.



Uso de diagramas para probar la validez

Considere la declaración







O, formalmente,



Todos los números enteros son números racionales.





∀ enteros n, n es un número racional.



Imagine el conjunto de todos los números enteros y el conjunto de todos los números racionales como discos. La verdad del enunciado dado se representa colocando el disco de números enteros completamente dentro del disco de racionales, como se muestra en la Figura 3.4.1.



Figura 3.4.1



Debido a que las dos afirmaciones “x D, Q(x)” y “x, si x está en D entonces Q(x)” son lógicamente equivalentes, ambas pueden representarse mediante diagramas como el anterior.





Quizás la primera persona que utilizó diagramas como éstos para analizar argumentos fue el matemático y filósofo alemán Gottfried Wilhelm Leibniz. Leibniz estaba muy adelantado a su tiempo al anticipar la lógica simbólica moderna. También desarrolló las ideas principales del cálculo diferencial e integral aproximadamente al mismo tiempo que (e independientemente de) Isaac Newton (1642-1727).

Para probar la validez de un argumento de forma esquemática, represente la verdad de ambas premisas con diagramas. Luego analice los diagramas para ver si necesariamente representan también la verdad de la conclusión.



GW Leibniz (1646-1716)



Ejemplo 3.4.5 Uso de un diagrama para mostrar validez

Utilice diagramas para mostrar la validez del siguiente silogismo:

Todos los seres humanos son mortales. Zeus no es mortal.

∴ Zeus no es un ser humano.

Solución La premisa principal se muestra a la izquierda en la Figura 3.4.2 colocando un disco con la etiqueta "seres humanos" dentro de un disco con la etiqueta "mortales". La premisa menor se muestra a la derecha en la Figura 3.4.2 colocando un punto con la etiqueta "Zeus" fuera del disco con la etiqueta "mortales".











Zeus







Premisa mayor





Figura 3.4.2



Premisa menor





Los dos diagramas encajan entre sí de una sola manera, como se muestra en la Figura 3.4.3.











Zeus





Figura 3.4.3



Como el punto de Zeus está fuera del disco de los mortales, necesariamente está fuera del disco de los seres humanos. Así, la verdad de la conclusión se sigue necesariamente de la verdad de las premisas. Es imposible que las premisas de este argumento sean verdaderas y la conclusión falsa; por tanto el argumento es válido. ■





Ejemplo 3.4.6 Uso de diagramas para mostrar la invalidez

Utilice un diagrama para mostrar la invalidez del siguiente argumento:

todo ser humano Los seres son mortales. Félix es mortal.

∴ Félix es un ser humano.

Solución Las premisas mayor y menor se representan esquemáticamente en la Figura 3.4.4.







Premisa mayor





Figura 3.4.4



Premisa menor





Todo lo que se sabe es que el punto Félix se encuentra en algún lugar dentro del disco de los mortales. No se puede determinar dónde se encuentra con respecto al disco del ser humano. Cualquiera de las situaciones que se muestran en la Figura 3.4.5 podría ser el caso.







¡Precaución! ¡Tenga cuidado al utilizar diagramas para probar la validez! Por ejemplo, en este ejemplo, si junta los diagramas de las premisas para obtener solo la Figura 3.4.5(a) y no la Figura 3.4.5(b), concluiría erróneamente que

















(a)

















Figura 3.4.5





















el argumento era válido.



La conclusión “Félix es un ser humano” es cierta en el primer caso, pero no en el segundo (Félix podría ser, por ejemplo, un gato). Como la conclusión no se sigue necesariamente de las premisas, el argumento es inválido. ■



El argumento del ejemplo 3.4.6 sería válido si la premisa mayor fuera reemplazada por su inversa. Pero dado que un enunciado condicional universal no es lógicamente equivalente a su inverso, en general no se puede realizar tal reemplazo. Decimos que este argumento exhibe el error inverso.













La siguiente forma de argumento sería válida si un enunciado condicional fuera lógicamente equivalente a su inverso. Pero no es así y la forma del argumento no es válida. Decimos que presenta el error inverso. Se le pide que demuestre la invalidez de esta forma de argumento en los ejercicios al final de esta sección.





Ejemplo 3.4.7 Un argumento con "No"

Utilice diagramas para probar la validez del siguiente argumento:

Ninguna función polinómica tiene asíntotas horizontales. Esta función tiene una asíntota horizontal.

∴ Esta función no es una función polinómica.

Solución Una buena manera de representar la premisa principal en forma de diagrama se muestra en la figura 3.4.6, dos discos (un disco para funciones polinómicas y un disco para funciones con asíntotas horizontales) que no se superponen en absoluto. La premisa menor se representa colocando un punto con la etiqueta "esta función" dentro del disco para funciones con asíntotas horizontales.



Figura 3.4.6



El diagrama muestra que “esta función” debe estar fuera del disco de funciones polinómicas, por lo que la verdad de la conclusión se sigue necesariamente de la verdad de las premisas. Por tanto el argumento es válido. ■



Un enfoque alternativo a este ejemplo es transformar la afirmación "Ninguna función polinómica tiene asíntotas horizontales" en la forma equivalente "x, si x es una función polinómica, entonces x no tiene asíntotas horizontales". Si se hace esto, se puede ver que el argumento tiene la forma

∀x, si P(x) entonces Q(x).

∼Q(a), para un a en particular.

∴ ∼P(a).

donde P(x) es “x es una función polinómica” y Q(x) es “x no tiene asíntota horizontal”. Esto es válido mediante el modus tollens universal.





Crear formas adicionales de argumento

El modus ponens y el modus tollens universales se obtuvieron combinando la instanciación universal con el modus ponens y el modus tollens. De la misma manera, se pueden obtener formas adicionales de argumentos que involucran enunciados cuantificados universalmente combinando la instanciación universal con otras de las formas de argumento válidas dadas en la Sección 2.3. Por ejemplo, en la Sección 2.3 se introdujo la forma de argumento llamada transitividad:

p → q q → r

∴ pag → r

Esta forma de argumento se puede combinar con la instanciación universal para obtener la siguiente forma de argumento válida.





Ejemplo 3.4.8 Evaluación de un argumento a favor del mundo de Tarski

El siguiente argumento se refiere al tipo de disposición de objetos de varios tipos y colores descritos en los Ejemplos 3.1.13 y 3.3.1. Reordene y reescriba las premisas para demostrar que la conclusión se sigue como consecuencia válida de las premisas.

Todos los triángulos son azules.

Si un objeto está a la derecha de todos los cuadrados, entonces está encima de todos los círculos.

Si un objeto no está a la derecha de todos los cuadrados, entonces no es azul.

∴ Todos los triángulos están sobre todos los círculos.

Solución Es útil comenzar reescribiendo las premisas y la conclusión en forma si-entonces:

∀x, si x es un triángulo, entonces x es azul.

∀x, si x está a la derecha de todos los cuadrados, entonces x está encima de todos los círculos.

∀x, si x no está a la derecha de todos los cuadrados, entonces x no es azul.

∴ ∀x , si x es un triángulo, entonces x está por encima de todos los círculos.

El objetivo es reordenar las premisas para que la conclusión de cada una sea la misma que la hipótesis de la siguiente. Además, la hipótesis de la conclusión del argumento debe ser la misma que la hipótesis de la primera premisa, y la conclusión de la conclusión del argumento debe ser la misma que la conclusión de la última premisa. Para lograr este objetivo, puede que sea necesario reescribir algunas de las afirmaciones en forma contrapositiva.

En este ejemplo puedes ver que la primera premisa debe permanecer donde está, pero la segunda y la tercera premisa deben intercambiarse. Entonces la hipótesis del argumento es la misma que la hipótesis de la primera premisa, y la conclusión de La conclusión del argumento es la misma que la conclusión de la tercera premisa. Pero las hipótesis y





Las conclusiones de las premisas no coinciden del todo. Esto se soluciona reescribiendo la tercera premisa en forma contrapositiva.

Por tanto, las premisas y la conclusión del argumento se pueden reescribir de la siguiente manera:

∀x, si x es un triángulo, entonces x es azul.

3. ∀x, si x es azul, entonces x está a la derecha de todos los cuadrados.

2. ∀x, si x está a la derecha de todos los cuadrados, entonces x está encima de todos los círculos.

∴ ∀x , si x es un triángulo, entonces x está por encima de todos los círculos.

La validez de este argumento se deriva fácilmente de la validez de la transitividad universal. Juntando 1 y 3 y usando la transitividad universal se obtiene que

4. ∀x, si x es un triángulo, entonces x está a la derecha de todos los cuadrados.

Y juntando 4 con 2 y usando la transitividad universal se obtiene que

∀x, si x es un triángulo, entonces x está por encima de todos los círculos,

que es la conclusión del argumento. ■



Observación sobre los errores inversos e inversos

Una de las razones por las que tanta gente comete errores inversos e inversos es que las formas de los argumentos resultantes serían válidas si la premisa mayor fuera un bicondicional en lugar de un condicional simple. Y, como señalamos en la sección 2.2, mucha gente tiende a combinar bicondicionales y condicionales.

Consideremos, por ejemplo, el siguiente argumento:

Todos los delincuentes de la ciudad frecuentan el bar Den of Iniquity. John frecuenta el bar Den of Iniquity.

∴ John es uno de los criminales de la ciudad.

La conclusión de este argumento es inválida: resulta de cometer el error inverso. Por tanto, puede ser falso incluso cuando las premisas del argumento sean verdaderas. Este tipo de argumento intenta injustamente establecer la culpabilidad por asociación.

Sin embargo, cuanto más se acerca la premisa mayor a ser bicondicional, más probable es que la conclusión sea cierta. Si casi nadie más que delincuentes frecuenta el bar y John también frecuenta el bar, entonces es probable (aunque no seguro) que John sea un criminal. Sobre la base de las premisas dadas, podría ser sensato sospechar de John, pero sería un error condenarlo.

Una variación del error inverso es una herramienta de razonamiento muy útil, siempre que se utilice con precaución. Es el tipo de razonamiento que utilizan los médicos para hacer diagnósticos médicos y los mecánicos de automóviles para reparar automóviles. Es el tipo de razonamiento utilizado para generar explicaciones de los fenómenos. Dice así: Si una declaración de la forma

Para todo x, si P(x) entonces Q(x)

es verdad y si

Q(a) es verdadera, para un a particular,

luego revisa el enunciado P(a); puede que sea verdad. Por ejemplo, supongamos que un médico sabe que

Para todo x, si x tiene neumonía, entonces x tiene fiebre y escalofríos, tose profundamente y se siente excepcionalmente cansado y miserable.

























Pruébate



Y supongamos que el médico también sabe que

John tiene fiebre y escalofríos, tose profundamente y se siente excepcionalmente cansado y miserable.

Basándose en estos datos, el médico concluye que el diagnóstico de neumonía es una gran posibilidad, aunque no una certeza. El médico probablemente intentará obtener más apoyo para este diagnóstico mediante pruebas de laboratorio diseñadas específicamente para detectar la neumonía. Tenga en cuenta que cuanto más cerca esté un conjunto de síntomas de ser una condición necesaria y suficiente para una enfermedad, más seguro podrá estar el médico de su diagnóstico.

Esta forma de razonamiento ha sido denominada abducción por los investigadores que trabajan en inteligencia artificial. Se utiliza en ciertos programas informáticos, llamados sistemas expertos, que intentan duplicar el funcionamiento de un experto en algún campo del conocimiento.



La regla de instanciación universal dice que si alguna propiedad es verdadera para en un dominio, entonces es verdadera para .



Si las dos primeras premisas del modus ponens universal se escriben como “Si x hace que P(x) sea verdadero, entonces x hace que Q(x) sea verdadero” y “Para un valor particular de a”, entonces la conclusión se puede escribir como “.”



Si las dos primeras premisas del modus tollens universal se escriben como “Si x hace que P(x) sea verdadero, entonces x hace que Q(x) sea verdadero” y





Conjunto de ejercicios 3.4

Sea la siguiente ley del álgebra el primer enunciado de un argumento: Para todos los números reales a y b,

(a + b)2 = a2 + 2ab + b2.

Supongamos que cada uno de los siguientes enunciados es, a su vez, el segundo enunciado del argumento. Utilice la instanciación universal o el modus ponens universal para escribir la conclusión que sigue en cada caso.

a = x y b = y son números reales particulares.

a = fi y b = f j son números reales particulares.



"Para un valor particular de a", entonces la conclusión se puede escribir como "".

Si las dos primeras premisas de la transitividad universal se escriben como “Cualquier x que haga verdadero a P(x) hace verdadero a Q(x)” y “Cualquier x que haga verdadero a Q(x) hace verdadero a R(x), entonces la conclusión - sión se puede escribir como "."

Los diagramas pueden ser útiles para probar la validez de un argumento. Sin embargo, si no se dibujan algunas configuraciones posibles de las premisas, una persona podría concluir que un argumento fue cuando en realidad lo fue.







números reales r, a y b, si r es positivo, entonces

(ra)b rab.

r 3, a 1/2 y b 6 son números reales particulares tales que r es positivo.

∴.

Utilice el modus tollens universal para completar conclusiones válidas para los argumentos de 5 y 6.

Todos los números irracionales son números reales.

1 no es un número real.







a = 3u y b = 5v son números reales particulares. 0.

a = g(r) y b = g(s) son números reales particulares.



a = log(t1) y b = log(t2) son números reales particulares.

Utilice la instanciación universal o el modus ponens universal para completar conclusiones válidas para los argumentos del 2 al 4.

Si un número entero n es igual a 2 k y k es un número entero, entonces n es par.

0 es igual a 2 0 y 0 es un número entero.

∴.

Para todos los números reales a, b, cyd, si b /= 0 y d /= 0, entonces a/b + c/d = (ad + bc)/bd.

a = 2, b = 3, c = 4 y d = 5 son números reales particulares tales que b /= 0 y d /= 0.



Si un programa de computadora es correcto, la compilación del programa no produce mensajes de error.

La compilación de este programa produce mensajes de error.

∴.

Algunos de los argumentos de 7 a 18 son válidos según el modus ponens universal o el modus tollens universal; otros no son válidos y presentan el error inverso o inverso. Indique cuáles son válidas y cuáles no. Justifica tus respuestas.

Todas las personas sanas comen una manzana al día. Keisha come una manzana al día.

∴ Keisha es una persona sana.







Todos los estudiantes de primer año deben tomar escritura. Caroline es una estudiante de primer año.

∴ Caroline debe aprender a escribir.

Todas las personas sanas comen una manzana al día. Herbert no es una persona sana.

∴ Herbert no come una manzana al día.

Si el producto de dos números es 0, entonces al menos uno de los números es 0.

Para un número particular x, ni (2x 1) ni (x 7) son iguales a 0.

∴ El producto (2x + 1)(x − 7) no es 0.

Todos los tramposos se sientan en la última fila. Monty se sienta en la última fila.

∴ Monty es un tramposo.

Toda la gente honesta paga sus impuestos. Darth no es honesto.

∴ Darth no paga sus impuestos.

Para todos los estudiantes x, si x estudia matemáticas discretas, entonces

x es bueno en lógica.

Tarik estudia matemáticas discretas.

∴ Tarik es bueno en lógica.

Si la compilación de un programa informático produce mensajes de error, entonces el programa no es correcto.

La compilación de este programa no produce mensajes de error.

∴ Este programa es correcto.

Cualquier suma de dos números racionales es racional. La suma r s es racional.

∴ Los números r y s son ambos racionales.

Si un número es par, entonces el doble de ese número es par. El número 2n es par, para un número particular n.

∴ El número particular n es par.

Si una serie infinita converge, entonces los términos van a 0.



Ningún buen coche es barato. Un Simbaru no es barato.

∴ Un Simbaru es un buen coche.

Ningún buen coche es barato.

Un VX Roadster es barato.

∴ Un VX Roadster no es bueno.

Ningún buen coche es barato.

Un Omnex no es un buen coche.

∴ Un Omnex es barato.

a. Utilice un diagrama para mostrar que el siguiente argumento puede tener premisas verdaderas y una conclusión falsa.

Todos los perros son carnívoros. Aaron no es un perro.

∴ Aarón no es carnívoro.

b. ¿Qué puedes concluir sobre la validez o invalidez de la siguiente forma de argumento? Explique cómo el resultado del inciso (a) lleva a esta conclusión.

∀x, si P(x) entonces Q(x).

∼P(a) para un a particular.

∴ ∼Q(a).

Indique si los argumentos de 21 a 27 son válidos o no válidos. Respalde sus respuestas dibujando diagramas.

Todas las personas son ratones. Todos los ratones son mortales.

∴ Todas las personas son mortales.

Todos los estudiantes de matemáticas discretas pueden distinguir un argumento válido de uno no válido.

Todas las personas reflexivas pueden distinguir un argumento válido de uno inválido.

∴ Todos los estudiantes de matemáticas discretas son reflexivos.

Todos los profesores cometen errores ocasionalmente. Ningún dios jamás comete errores.

∴ Ningún maestro es dios.



Los términos de la serie infinita.

 





1 va a 0.

norte



Ningún vegetariano come carne.





∴ La serie infinita

norte=1



norte converge.



∴ Ningún vegano come carne.

Ninguna comida de la cafetería de la universidad es buena.



18. Si una serie infinita converge, entonces sus términos llegan a 0. No se desperdicia ningún buen alimento.

∞ norte



 

Los términos de la serie infinita no llegan a 0.

norte=1



∴ No se desperdicia comida de la cafetería de la universidad.

Todas las funciones polinómicas son diferenciables.



∞

norte=1



n no converge.

norte + 1



Todas las funciones diferenciables son continuas.

∴ Todas las funciones polinómicas son continuas.



Reescribe el enunciado “Ningún auto bueno es barato” en la forma “x, si P(x) entonces Q(x)”. Indique si cada uno de los siguientes argumentos es válido o inválido y justifique sus respuestas.

Ningún buen coche es barato.

Un Rimbaud es un buen coche.

∴ Un Rimbaud no es barato.



[Adaptado de Lewis Carroll.] Nada inteligible me desconcierta jamás. La lógica me desconcierta.

∴ La lógica es ininteligible.







En los ejercicios 28 a 32, reordene las premisas de cada uno de los argumentos para demostrar que la conclusión se sigue como consecuencia válida de las premisas. Puede resultar útil reescribir los enunciados en forma si-entonces y reemplazar algunos enunciados por sus contrapositivos. Los ejercicios 28 a 30 se refieren a los tipos de mundos Tarski analizados en los ejemplos 3.1.13 y 3.3.1. Los ejercicios 31 y 32 están adaptados de la Lógica Simbólica de Lewis Carroll.∗

1. Cada objeto que está a la derecha de todos los objetos azules está encima de todos los triángulos.

Si un objeto es un círculo, entonces está a la derecha de todos los círculos azules. objetos.

Si un objeto no es un círculo, entonces no es gris.

∴ Todos los objetos grises están sobre todos los triángulos.

1. Todos los objetos que están a la derecha de todos los triángulos están encima de todos los círculos.

Si un objeto no está sobre todos los objetos negros, entonces no es un cuadrado.

Todos los objetos que están encima de todos los objetos negros están a la derecha de todos los triángulos.

∴ Todos los cuadrados están sobre todos los círculos.

1. Si un objeto está por encima de todos los triángulos, entonces está por encima de todos los objetos azules.

Si un objeto no está sobre todos los objetos grises, entonces no es un cuadrado.

Cada objeto negro es un cuadrado.

Todo objeto que está por encima de todos los objetos grises está por encima de todos los triángulos.

∴ Si un objeto es negro, entonces se trata sobre todo de los objetos azules.

1. Confío en cada animal que me pertenece.

Los perros roen huesos.

No admito animales en mi estudio a menos que me supliquen cuando se les indique que lo hagan.

Todos los animales del patio son míos.

Admito a todos los animales en los que confío en mi estudio.



∗Lewis Carroll, Symbolic Logic (Nueva York: Dover, 1958), págs. 118, 120, 123.



Los únicos animales que realmente están dispuestos a mendigar cuando se les dice que lo hagan son los perros.

∴ Todos los animales del jardín roen huesos.

1. Cuando trabajo un ejemplo lógico sin quejarme, puedes estar seguro de que lo entiendo.

Los argumentos en estos ejemplos no están organizados en un orden regular como a los que estoy acostumbrado.

Ningún ejemplo fácil me produce dolor de cabeza.

No puedo entender ejemplos si los argumentos no están organizados en un orden regular como a los que estoy acostumbrado.

Nunca me quejo de un ejemplo a menos que me dé dolor de cabeza.

∴ Estos ejemplos no son fáciles.



En 33 y 34 se deduce una única conclusión cuando se toman en consideración todas las premisas dadas, pero es difícil de ver porque las premisas están mezcladas. Reordene las premisas para dejar claro que se sigue una conclusión lógica y establezca la conclusión válida que se puede extraer. (Puede resultar útil reescribir algunos de los enunciados en forma si-entonces y reemplazar algunos por sus contrapositivos.)

1. Ningún pájaro, excepto los avestruces, mide al menos 9 pies de altura.

No hay pájaros en este aviario que pertenezcan a nadie más que a mí.

Ningún avestruz vive de pasteles de carne picada.

No tengo pájaros de menos de 9 pies de altura.

1. Todos los escritores que comprenden la naturaleza humana son inteligentes.

Nadie es un verdadero poeta a menos que pueda conmover el corazón humano.

Shakespeare escribió Hamlet.

Ningún escritor que no comprenda la naturaleza humana puede conmover el corazón humano.

Nadie excepto un verdadero poeta podría haber escrito Hamlet.

✶ 35. Derive la validez del modus tollens universal a partir de la validez de la instanciación universal y del modus tollens.

✶ 36. Derive la validez de la forma universal del inciso (a) de la regla de eliminación a partir de la validez de la instanciación universal y del argumento válido llamado eliminación en la Sección 2.3.





Respuestas para Ponte a prueba

1. todos los elementos; cualquier elemento particular en el dominio (O: cada elemento individual del dominio) 2. P(a) es verdadera; Q(a) es verdadera

Q(a) es falsa; P(a) es falsa 4. Cualquier x que haga que P(x) sea verdadera hace que R(x) sea verdadera. 5. válido; inválido (O: inválido; válido).





















Es probable que le resulte familiar el contenido subyacente de este capítulo. Consta de propiedades de números enteros (números enteros), números racionales (fracciones enteras) y números reales. El tema subyacente de este capítulo es la cuestión de cómo determinar la verdad o falsedad de un enunciado matemático.

A continuación se muestra un ejemplo de un concepto utilizado con frecuencia en informática. Dado cualquier número real x, el piso de x, o el mayor entero en x, denotado x], es el mayor entero que es menor o igual a x. En la recta numérica, x ] es el número entero inmediatamente a la izquierda de x (o igual a x si x es, en sí mismo, un número entero). Por tanto, 2,3]= 2, 12,99999]= 12 y −1,5]= −2. Considere las siguientes dos preguntas:

Para cualquier número real x , ¿es x − 1]= x ]− 1?

Para cualquier número real x e y, ¿es x − y]= x ]− y]?

Tómese unos minutos para intentar responder estas preguntas usted mismo.



Resulta que la respuesta a (1) es sí, mientras que la respuesta a (2) es no. ¿Son estas las respuestas que obtuviste? Si no, no te preocupes. En la Sección 4.5 aprenderá las técnicas que necesita para responder estas preguntas y más. Si obtuvo las respuestas correctas, ¡felicidades! Tienes una excelente intuición matemática. Ahora pregúntate: “¿Qué tan seguro estoy de mis respuestas? ¿Eran conjeturas plausibles o certezas absolutas? ¿Hubo alguna diferencia en la certeza entre mis respuestas a (1) y (2)? ¿Habría estado dispuesto a apostar una gran suma de dinero a la exactitud de mis respuestas?

Una de las mejores formas de pensar en una demostración matemática es como un argumento cuidadosamente razonado para convencer a un oyente escéptico (a menudo a usted mismo) de que una afirmación determinada es verdadera. Imagine al oyente desafiando su razonamiento en cada paso del camino, preguntando constantemente: "¿Por qué es así?". Si puedes contrarrestar todos los desafíos posibles, entonces tu prueba en su conjunto será correcta.

Como ejemplo, imagina demostrarle a alguien que no está muy familiarizado con la notación matemática que si x es un número con 5x + 3 = 33, entonces x = 6. Se podría argumentar de la siguiente manera:

Si 5x + 3 = 33, entonces 5x + 3 menos 3 será igual a 33 − 3, ya que restar el mismo número de dos cantidades iguales da resultados iguales. Pero 5x + 3 menos 3 es igual a 5x porque sumar 3 a 5x y luego restar 3 solo deja 5x. Además, 33 − 3 = 30. Por lo tanto, 5x = 30. Esto significa que x es un número que multiplicado por 5 da 30. Pero el único número con esta propiedad es 6. Por lo tanto, si 5x + 3 = 33 entonces x = 6 .

Por supuesto, hay otras formas de expresar esta demostración, dependiendo del nivel de sofisticación matemática del lector al que se dirige. En la práctica, los matemáticos a menudo omiten

145





razones para ciertos pasos de un argumento cuando están seguros de que el lector puede proporcionarlas fácilmente. Sin embargo, cuando estás aprendiendo a escribir pruebas, es mejor pecar de dar demasiadas razones que muy pocas. Con demasiada frecuencia, cuando incluso los mejores matemáticos examinan cuidadosamente algunos “detalles” de sus argumentos, descubren que esos detalles son en realidad falsos. Una de las razones más importantes para exigir una demostración en matemáticas es que escribir una demostración nos obliga a tomar conciencia de las debilidades de nuestros argumentos y de las suposiciones inconscientes que hemos hecho.

A veces, la corrección de un argumento matemático puede ser una cuestión de vida o muerte. Supongamos, por ejemplo, que un matemático forma parte de un equipo encargado de diseñar un nuevo tipo de motor de avión, y supongamos que al matemático se le asigna la tarea de determinar si el empuje entregado por varios tipos de motor es adecuado. Si supiera que el matemático estaba bastante seguro, pero no seguro, de la exactitud de su análisis, probablemente no querría viajar en el avión resultante.

En cierto momento de Alicia en el país de las maravillas de Lewis Carroll (ver ejercicio 28 en la Sección 2.2), la Liebre de Marzo le dice a Alicia que “di lo que quieres decir”. En otras palabras, debe ser precisa en el uso del lenguaje: si quiere decir algo, entonces eso es exactamente lo que debe decir. En este capítulo, tal vez más que en cualquier otro curso de matemáticas que haya tomado, le resultará necesario decir lo que quiere decir. La precisión del pensamiento y del lenguaje es esencial para lograr la certeza matemática necesaria si se quiere tener total confianza en las soluciones a los problemas matemáticos.





Las matemáticas, como ciencia, comenzaron cuando por primera vez alguien, probablemente un griego, demostró proposiciones sobre “cualquier” cosa o sobre “algunas” cosas sin especificar cosas particulares definidas. —Alfred North Whitehead, 1861–1947



Tanto el descubrimiento como la prueba son partes integrales de la resolución de problemas. Cuando crea que ha descubierto que cierta afirmación es verdadera, intente descubrir por qué es cierta. Si lo logras, sabrás que tu descubrimiento es genuino. Incluso si fracasa, el proceso de intentarlo le dará una idea de la naturaleza del problema y puede llevarle a descubrir que la afirmación es falsa. Para problemas complejos, la interacción entre descubrimiento y prueba no está reservada al final del proceso de resolución del problema, sino que es una parte importante de cada paso.





El contenido matemático de esta sección se refiere principalmente a números enteros pares e impares, así como a números primos y compuestos.





Definiciones

Para evaluar la verdad o falsedad de una afirmación, es necesario comprender de qué se trata la afirmación. En otras palabras, debe conocer el significado de todos los términos que aparecen en la declaración. Los matemáticos definen los términos con mucho cuidado y precisión y consideran importante aprender las definiciones prácticamente palabra por palabra.





De la definición se deduce que si estás resolviendo un problema en el que sabes que cierto número entero es par, puedes deducir que tiene la forma 2 (algún número entero). Por el contrario, si sabes en alguna situación que un número entero es igual a 2 (algún número entero), entonces puedes deducir que el número entero es par.



conocer un particular





deducir



n tiene la forma



el entero n es par.



−−−−−→ 2 ·(algún número entero).



Saber que n tiene la forma 2 ·(algún número entero).



Ejemplo 4.1.1 Enteros pares e impares



−−−−−→



n es par.



Utilice las definiciones de par e impar para justificar sus respuestas a las siguientes preguntas.

¿Es 0 par?

¿Es impar −301?

Si a y b son números enteros, ¿6a2b es par?

Si a y b son números enteros, ¿es impar 10a + 8b + 1?

¿Todo número entero es par o impar?

Solución

a. Sí, 0 = 2 · 0.

b. Sí, −301 = 2(−151) + 1.

Sí, 6a2b 2(3a2b), y dado que a y b son números enteros, también lo es 3a2b (siendo un producto de números enteros).

Sí, 10a 8b 1 2(5a 4b) 1, y dado que a y b son números enteros, también lo es 5a 4b (siendo una suma de productos de números enteros).

La respuesta es sí, aunque la prueba no es obvia. (Intente dar una razón usted mismo.) En la sección 4.4 mostraremos que este hecho es el resultado de otro hecho conocido como teorema del cociente del resto. ■



El número entero 6, que es igual a 2 3, es producto de dos números enteros positivos más pequeños. Por otro lado, 7 no se puede escribir como producto de dos números enteros positivos más pequeños; es solamente





Los factores positivos son 1 y 7. Un número entero positivo, como 7, que no se puede escribir comos un producto de dos números enteros positivos más pequeños se llama primo.









Ejemplo 4.1.2 Números primos y compuestos

¿Es 1 primo?

¿Todo número entero mayor que 1 es primo o compuesto?

Escribe los primeros seis números primos.

Escribe los primeros seis números compuestos.

Solución



Nota La razón para no permitir que 1 sea primo es



a. No. Se requiere que un número primo sea mayor que 1.



discutido en la Sección 4.3. b. Sí. Sea n cualquier número entero mayor que 1. Considere todos los pares de números enteros positivos

r y s tales que n rs. Existen al menos dos de estos pares, a saber, r n y s 1 y r 1 y s n. Además, dado que n rs, todos esos pares satisfacen las desigualdades

1 r n y 1 s n. Si n es primo, entonces los dos pares mostrados son las únicas formas de escribir n como rs. De lo contrario, existe un par de enteros positivos r y s tales que n rs y ni r ni s son iguales a 1 o n. Por lo tanto, en este caso 1 < r < n y 1 < s < n, y por tanto n es compuesto.

C. 2, 3, 5, 7, 11, 13

d. 4, 6, 8, 9, 10, 12 ■



Demostrar declaraciones existenciales

Según la definición dada en la Sección 3.1, una declaración en la forma

∃x ∈ D tal que Q(x)

es verdadera si, y sólo si,

Q(x) es verdadera para al menos una x en D.

Una forma de demostrar esto es encontrar una x en D que haga que Q(x) sea verdadero. Otra forma es dar un conjunto de instrucciones para encontrar dicha x. Ambos métodos se denominan pruebas constructivas de existencia.





Ejemplo 4.1.3 Pruebas constructivas de existencia

Demuestre lo siguiente: un número entero par n que se puede escribir de dos maneras como suma de dos números primos.

Supongamos que r y s son números enteros. Demuestre lo siguiente: ∃ un número entero k tal que 22r + 18s = 2k.

Solución

Sea n = 10. Entonces 10 = 5 + 5 = 3 + 7 y 3, 5 y 7 son todos números primos.

Sea k 11r 9s. Entonces k es un número entero porque es una suma de productos de números enteros; y por sustitución, 2k 2(11r 9s), que es igual a 22r 18s según la ley distributiva del álgebra. ■



Una prueba no constructiva de existencia implica mostrar (a) que la existencia de un valor de x que hace que Q(x) sea verdadero está garantizada por un axioma o un teorema previamente demostrado o (b) que la suposición de que no existe tal x conduce a a una contradicción. La desventaja de una prueba no constructiva es que prácticamente no da ninguna pista sobre dónde o cómo se puede encontrar x. El uso generalizado de computadoras digitales en los últimos años ha generado cierta insatisfacción con este aspecto de las pruebas no constructivas y ha aumentado los esfuerzos para producir pruebas constructivas que contengan instrucciones para el cálculo informático de la cantidad en cuestión.



Refutar afirmaciones universales mediante contraejemplos

Refutar una afirmación significa demostrar que es falsa. Considere la cuestión de refutar una declaración de la forma

∀x en D, si P(x) entonces Q(x).

Demostrar que esta afirmación es falsa equivale a demostrar que su negación es verdadera. La negación del enunciado es existencial:

∃x en D tal que P(x) y no Q(x).

Pero para demostrar que un enunciado existencial es verdadero, generalmente damos un ejemplo, y como el ejemplo se utiliza para mostrar que el enunciado original es falso, lo llamamos contraejemplo. Así, el método de refutación mediante contraejemplo se puede escribir de la siguiente manera:





Ejemplo 4.1.4 Refutación mediante contraejemplo

Refute la siguiente afirmación encontrando un contraejemplo:

∀ números reales a y b, si a2 = b2 entonces a = b.

Solución Para refutar esta afirmación, necesitas encontrar números reales a y b tales que la hipótesis a2 = b2 sea verdadera y la conclusión a = b sea falsa. El hecho de que ambos aspectos positivos





y los números enteros negativos tienen cuadrados positivos que ayudan en la búsqueda. Si hojeas algunas posibilidades en tu mente, verás rápidamente que 1 y −1 funcionarán (o 2 y −2, o

0,5 y −0,5, y así sucesivamente).



■



Es un signo de inteligencia hacer generalizaciones. Con frecuencia, después de observar que una propiedad se cumple en un gran número de casos, se puede adivinar que se cumple en todos los casos. Sin embargo, es posible que tenga dificultades cuando intente demostrar su suposición. Quizás simplemente no hayas descubierto la clave de la prueba. Pero quizás tu suposición sea falsa. En consecuencia, cuando tenga serias dificultades para demostrar una afirmación general, debe interrumpir sus esfuerzos para buscar un contraejemplo. Analizar los tipos de problemas que encuentra en sus esfuerzos de prueba puede ayudar en la búsqueda. Incluso puede suceder que si encuentra un contraejemplo y, por lo tanto, demuestra que el enunciado es falso, su comprensión se aclare lo suficiente como para poder formular una versión más limitada pero verdadera del enunciado. Por ejemplo, el Ejemplo 4.1.4 muestra que no siempre es cierto que si los cuadrados de dos números son iguales, entonces los números son iguales. Sin embargo, es cierto que si los cuadrados de dos números positivos son iguales, entonces los números son iguales.





Demostrando declaraciones universales

La gran mayoría de los enunciados matemáticos que deben demostrarse son universales. Al discutir cómo probar tales afirmaciones, es útil imaginarlas en una forma estándar:

∀x ∈ D, si P(x) entonces Q(x).

Las secciones 1.1 y 3.1 dan ejemplos. Ejemplos que muestran cómo escribir cualquier declaración universal en esta forma. Cuando D es finito o cuando sólo un número finito de elementos satisface P(x), tal afirmación puede demostrarse mediante el método de agotamiento.





Ejemplo 4.1.5 El método de agotamiento

Utilice el método de agotamiento para demostrar el siguiente enunciado:

n Z, si n es par y 4 n 26, entonces n se puede escribir como la suma de dos números primos.

Solución 4 = 2 + 2 6 = 3 + 3 8 = 3 + 5 10 = 5 + 5

12 = 5 + 7 14 = 11 + 3 16 = 5 + 11 18 = 7 + 11

20 = 7 + 13 22 = 5 + 17 24 = 5 + 19 26 = 7 + 19 ■



Sin embargo, en la mayoría de los casos en matemáticas no se puede utilizar el método de agotamiento. Por ejemplo, ¿puedes demostrar por agotamiento que todo número entero par mayor que 2 puede escribirse como suma de dos números primos? No. Para hacer eso tendrías que comprobar cada número entero par y, como hay infinitos números de este tipo, ésta es una tarea imposible.





Incluso cuando el dominio es finito, puede resultar inviable utilizar el método de agotamiento. Imagínese, por ejemplo, intentar comprobar por agotamiento que el circuito de multiplicación de una computadora en particular da el resultado correcto para cada par de números en el rango de la computadora. Dado que una computadora típica requeriría miles de años simplemente para calcular todos los productos posibles de todos los números en su rango (sin mencionar el tiempo que tomaría verificar la exactitud de las respuestas), verificar la exactitud mediante el método de agotamiento es obviamente poco práctico.

La técnica más poderosa para demostrar un enunciado universal es aquella que funciona independientemente del tamaño del dominio sobre el cual se cuantifica el enunciado. Se llama método de generalizar a partir del particular genérico. Aquí está la idea subyacente al método:









Ejemplo 4.1.6 Generalización a partir del particular genérico

Es posible que en algún momento te hayan mostrado un “truco matemático” como el siguiente. Le pides a una persona que elija cualquier número, sume 5, multiplique por 4, reste 6, divida por 2 y reste el doble del número original. Luego sorprendes a la persona al anunciar que su resultado final fue 7. ¿Cómo funciona este “truco”? Sea un cuadro vacío Q o el símbolo x el número que elige la persona. Esto es lo que sucede cuando la persona sigue tus instrucciones:





Por lo tanto, no importa con qué número comience la persona, el resultado siempre será 7. Tenga en cuenta que la x en el análisis anterior es particular (porque representa una cantidad única), pero también es elegida arbitrariamente o genérica (porque cualquier número puede ser puesto en su lugar). Esto ilustra el proceso de sacar una conclusión general a partir de un objeto particular pero genérico. ■





El objetivo de que x sea elegido arbitrariamente (o genérico) es hacer una prueba que pueda generalizarse a todos los elementos del dominio. Al elegir x arbitrariamente, no se hacen suposiciones especiales sobre x que no sean válidas para todos los demás elementos del dominio. La palabra genérico significa "compartir todas las características comunes de un grupo o clase". Por tanto, todo lo que se deduce sobre un elemento genérico x del dominio es igualmente cierto para cualquier otro elemento del dominio.

Cuando el método de generalizar a partir del particular genérico se aplica a una propiedad de la forma “Si P(x) entonces Q(x)”, el resultado es el método de prueba directa. Recuerde que la única forma en que un enunciado si-entonces puede ser falso es que la hipótesis sea verdadera y la conclusión sea falsa. Por lo tanto, dado el enunciado “Si P(x) entonces Q(x)”, si puede demostrar que la verdad de P(x) obliga a la verdad de Q(x), entonces habrá demostrado el enunciado. Por el método de generalizar a partir del particular genérico se deduce que para demostrar que “x, si P(x) entonces Q(x)” es cierto para todos los elementos x en un conjunto D, se supone que x es un elemento particular pero elegido arbitrariamente. elemento de D que hace que P(x) sea verdadero, y luego demuestra que x hace que Q(x) sea verdadero.









Ejemplo 4.1.7 Demostración directa de un teorema

Demuestre que la suma de dos números enteros pares cualesquiera es par.



¡Precaución! La palabra dos en esta declaración no necesariamente se refiere a dos números enteros distintos. Si se hace una elección arbitraria de números enteros, es muy probable que sean distintos, pero pueden ser iguales.



Solución Siempre que se le presente una afirmación que debe demostrarse, es una buena idea preguntarse si cree que es cierta. En este caso, podrías imaginar algunos pares de números enteros pares, digamos 2 4, 6 10, 12 12, 28 54, y comprobar mentalmente que sus sumas sean pares. Sin embargo, como no es posible comprobar todos los pares de números pares, no se puede saber con certeza si la afirmación es verdadera en general comprobando su veracidad en estos casos particulares. Muchas propiedades son válidas para un gran número de ejemplos y, sin embargo, no son ciertas en general.

Para probar esta afirmación en general, es necesario demostrar que no importa qué números enteros pares se den, su suma es par. Pero dados dos números enteros pares cualesquiera, es posible representarlos como 2r y 2s para algunos números enteros r y s. Y por la ley distributiva del álgebra, 2r 2s 2(r s), que es par. Por tanto, la afirmación es cierta en general.

Supongamos que la declaración es pLos problemas eran mucho más complicados que esto. ¿Cuál es el método que podría utilizar para derivar una prueba?

Reformulación formal: ∀ enteros myn, si myn son pares entonces m + n es par.

Esta afirmación se cuantifica universalmente en un dominio infinito. Por lo tanto, para demostrarlo en general, es necesario demostrar que no importa qué dos números enteros se nos den, si ambos son pares, su suma también será par.

Luego pregúntese: "¿Por dónde empiezo?" o "¿Qué estoy suponiendo?" La respuesta a esa pregunta nos da el punto de partida, o la primera frase, de la demostración.





Punto de partida: supongamos que m y n son números enteros particulares pero elegidos arbitrariamente y que son pares.

O, en forma abreviada:

Supongamos que m y n son números enteros pares.

Luego pregúntese: "¿Qué conclusión necesito mostrar para completar la prueba?"

Para mostrar: m + n es par.

En este punto es necesario preguntarse: “¿Cómo llego del punto de partida a la conclusión?” Dado que ambos implican el término entero par, debes usar la definición de este término y, por lo tanto, debes saber qué significa que un número entero sea par. De la definición se deduce que, dado que m y n son pares, cada uno es igual al doble de un número entero. Una de las leyes básicas de la lógica, llamada instanciación existencial, dice, en efecto, que si sabes que algo existe, puedes darle un nombre. Sin embargo, no se puede utilizar el mismo nombre para referirse a dos cosas diferentes, ambas actualmente en discusión.











¡Precaución! Como m y n se eligen arbitrariamente, podrían ser cualquier par de números enteros pares. Una vez que se introduce r para satisfacer

2r, entonces r no está disponible para representar otra cosa. Si hubieras configurado m 2r , y

2r, entonces m sería igual a n, lo cual no tiene por qué ser el caso.



Por lo tanto, dado que m es igual al doble de un número entero, puede darle un nombre a ese número entero, y dado que n

es igual al doble de un número entero, también puedes darle un nombre a ese número entero:

m = 2r, para algún número entero r y n = 2s, para algún número entero s.

Ahora lo que quieres mostrar es que m n es par. En otras palabras, desea demostrar que m n es igual a 2 (algún número entero). Habiendo encontrado representaciones alternativas para m (como 2r) y n (como 2s), parece razonable sustituir estas representaciones en lugar de myn:

metro + norte = 2r + 2s.

Tu objetivo es demostrar que m n es par. Por definición de par, esto significa que m n puede escribirse en la forma

2 ·(algún número entero).

Este análisis reduce la brecha entre el punto de partida y lo que se va a mostrar para mostrar que



2r + 2s = 2 ·(algún número entero).

¿Por qué es esto cierto? Primero, debido a la ley distributiva del álgebra, que dice que

2r + 2s = 2(r + s),

y, segundo, porque la suma de dos números enteros cualesquiera es un número entero, lo que implica que r s

es un número entero.

Esta discusión se resume reescribiendo el enunciado como un teorema y dando una demostración formal del mismo. (En matemáticas, la palabra teorema se refiere a una afirmación que se sabe que es verdadera porque ha sido demostrada). La demostración formal, así como muchas otras en este texto, incluye notas explicativas para hacer evidente su flujo lógico. Estos comentarios son puramente para comodidad del lector y podrían omitirse por completo. Por esta razón están en cursiva y entre corchetes en cursiva: [ ].





Donald Knuth, uno de los pioneros de la ciencia de la computación, ha comparado la construcción de un programa de computadora a partir de un conjunto de especificaciones con la escritura de una demostración matemática basada en un conjunto de axiomas.* De acuerdo con esta analogía, los comentarios entre corchetes pueden ser Se considera similar a la documentación explicativa proporcionada por un buen programador. La documentación no es necesaria para que un programa se ejecute, pero ayuda al lector humano a comprender lo que está sucediendo.



























Nota Introducir t para igualar r s es otro uso de la instanciación existencial.



■



La mayoría de los teoremas, como el anterior, se pueden analizar hasta el punto en que te das cuenta de que tan pronto como se demuestra algo determinado, el teorema quedará demostrado. Cuando eso se ha demostrado, es natural terminar la prueba con las palabras "esto es lo que necesitábamos mostrar". Las palabras latinas para esto son quod erat demonstrandum, o Q.E.D. para abreviar. Las pruebas de libros de matemáticas más antiguos terminan con estas iniciales.

Tenga en cuenta que tanto la parte si como la única si de la definición de par se utilizaron en la demostración del teorema 4.1.1. Como se sabía que myn eran pares, la parte única si ( ) de la definición se usó para deducir que myn tenían una cierta forma general. Luego, después de algunas sustituciones y manipulaciones algebraicas, se utilizó la parte if (⇐) de la definición para deducir que m + n era par.



Instrucciones para escribir pruebas de enunciados universales

Piense en una prueba como una forma de comunicar un argumento convincente a favor de la verdad de un enunciado matemático. Cuando escriba una prueba, imagine que se la enviará a un compañero de clase capaz que tuvo que faltar a la última semana o dos de su curso. Intenta ser claro y completo. Ten en cuenta que tu compañero de clase solo verá lo que realmente escribas, no ningún pensamiento no expresado detrás de ello. Idealmente, tu prueba llevará a tu compañero de clase a comprender por qué la afirmación dada es verdadera.







∗Donald E. Knuth, El arte de la programación informática, 2ª ed., vol. I (Reading, MA: Addison-Wesley, 1973), pág. IX.

†Consulte la página 134 para una discusión sobre el papel del modus ponens universal en esta prueba.





Con el paso de los años, las siguientes reglas de estilo se han vuelto bastante estándar para escribir las versiones finales de las pruebas:

Copia el enunciado del teorema que vas a demostrar en tu trabajo.

Marque claramente el comienzo de su prueba con la palabra Prueba.

Haga su prueba autónoma.

Esto significa que debes explicar el significado de cada variable utilizada en tu prueba en el cuerpo de la prueba. Así, comenzarás las pruebas introduciendo las variables iniciales y declarando qué tipo de objetos son. La primera oración de su demostración sería algo así como "Supongamos que m y n son números enteros pares" o "Sea x un número real tal que x es mayor que 2". Esto es similar a declarar variables y sus tipos de datos al comienzo de un programa de computadora.

En un punto posterior de tu prueba, puedes introducir una nueva variable para representar una cantidad que se sabe que existe en ese momento. Por ejemplo, si ha asumido que un número entero n en particular es par, entonces sabe que n es igual a 2 veces algún número entero, y puede darle un nombre a este número entero para poder trabajar con él de manera concreta más adelante en la demostración. Por lo tanto, si decide llamar al número entero, digamos, s, escribiría: "Dado que n es par, n = 2s para algún número entero s", o "dado que n es par, existe un número entero s tal que n = 2s". "

Escribe tu prueba en oraciones completas y gramaticalmente correctas.

Esto no significa que debas evitar el uso de símbolos y abreviaturas taquigráficas, sólo que debes incorporarlos en las oraciones. Por ejemplo, la demostración del teorema 4.1.1 contiene la oración

Entonces m + n = 2r + 2s

= 2(r + s).

Para leer dicho texto como una oración, lea el primer signo igual como “igual” y cada signo igual subsiguiente como “que es igual”.

Mantenga a su lector informado sobre el estado de cada declaración en su prueba.

Su lector nunca debe tener dudas sobre si algo en su prueba se ha asumido o establecido o aún está por deducirse. Si se supone algo, prefacielo con una palabra como Suponer o Suponer. Si aún no se ha mostrado, prefacíelo con palabras como Debemos mostrar eso o En otras palabras, debemos mostrar eso. Esto es especialmente importante si introduce una variable al reformular lo que necesita mostrar. (Consulte Errores comunes en la página siguiente).

Da una razón para cada afirmación en tu prueba.

Cada afirmación en una prueba debe provenir directamente de la hipótesis del teorema, o derivarse de la definición de uno de los términos del teorema, o ser un resultado obtenido anteriormente en la prueba, o ser un resultado matemático que haya sido previamente establecido o se acuerda asumirlo. Indique el motivo de cada paso de su demostración usando frases como por hipótesis, por definición de... y por teorema...

Incluye las “pequeñas palabras y frases” que dejen clara la lógica de tus argumentos.

Al escribir un argumento matemático, especialmente una prueba, indique cómo se relaciona cada oración con la anterior. ¿Se deriva de la oración anterior o de una combinación de la oración anterior y otras anteriores? Si es así, comience la oración indicando la razón por la cual sigue o escribiendo Entonces, o Así, o Así, o Por lo tanto, o Por lo tanto, o En consecuencia, o Se sigue eso, e incluya la razón al final de la oración. Por ejemplo, en la demostración del Teorema 4.1.1, una vez que sabes que m es par, puedes escribir: “Por definición de par, m = 2r para algún entero r”, o puedes escribir: “Entonces m = 2r para algún número entero r por definición de par”.





Si una oración expresa un nuevo pensamiento o hecho que no sigue como consecuencia inmediata de la declaración anterior pero que es necesario para una parte posterior de una demostración, introdúzcalo escribiendo Observe eso, o Note eso, o Pero, o Ahora. .

A veces, en una prueba es deseable definir una nueva variable en términos de variables anteriores. En tal caso, introduzca la nueva variable con la palabra Let. Por ejemplo, en la demostración del Teorema 4.1.1, una vez que se sabe que m + n = 2(r + s), donde r y s son números enteros, se introduce una nueva variable t para representar r + s. La prueba continúa diciendo: “Sea t = r + s. Entonces t es un número entero porque es la suma de dos números enteros”.

Mostrar ecuaciones y desigualdades.

La convención es mostrar ecuaciones y desigualdades en líneas separadas para aumentar la legibilidad, tanto para otras personas como para nosotros mismos, de modo que podamos verificar más fácilmente la precisión de nuestro trabajo. Seguimos la convención en el texto de este libro, pero para ahorrar espacio, la violamos en algunos de los ejercicios y en muchas de las soluciones contenidas en el Apéndice B. Por lo tanto, es posible que necesites copiar algunas partes de soluciones en papel borrador para comprenderlas completamente. Siga la convención en su propio trabajo. ¡Deja mucho espacio vacío y no seas tacaño con el papel!



Variaciones entre pruebas

Es raro que dos pruebas de una afirmación determinada, escritas por dos di personas diferentes, son idénticas. Incluso cuando los pasos matemáticos básicos son los mismos, las dos personas pueden usar notaciones diferentes o pueden dar cantidades diferentes de explicaciones para sus pasos, o pueden elegir palabras diferentes para vincular los pasos en forma de párrafo. Una pregunta importante es qué tan detalladas deben ser las explicaciones de los pasos de una prueba. En última instancia, esto debe resolverse entre el redactor de una prueba y el lector previsto, ya sea estudiante y profesor, profesor y estudiante, estudiante y compañero de estudios, o matemático y colega. Su profesor puede proporcionarle pautas explícitas para que las utilice en su curso. O puede seguir el ejemplo de las demostraciones de este libro (que generalmente se explican de forma bastante completa para que puedan ser comprendidas por estudiantes en distintas etapas del desarrollo matemático). Recuerde que las frases escritas entre corchetes [ ] tienen como objetivo dilucidar el flujo lógico o los supuestos subyacentes de la prueba y no es necesario escribirlos en absoluto. Es enteramente su decisión incluir tales frases en sus propias pruebas.



Errores comunes

Los siguientes son algunos de los errores más comunes que comete la gente al escribir demostraciones matemáticas.

Argumentando a partir de ejemplos.

Mirar ejemplos es una de las prácticas más útiles que puede realizar un solucionador de problemas y es fomentada por todos los buenos profesores de matemáticas. Sin embargo, es un error pensar que se puede probar una afirmación general demostrando que es cierta en algunos casos especiales. Una propiedad a la que se hace referencia en un enunciado universal puede ser verdadera en muchos casos sin serlo en general.

He aquí un ejemplo de este error. Es una “prueba” incorrecta del hecho de que la suma de dos números enteros pares cualesquiera es par. (Teorema 4.1.1).

Esto es cierto porque si m = 14 y n = 6, ambos pares, entonces m + n = 20, que también es par.

Algunas personas encuentran convincente este tipo de argumento porque, después de todo, consiste en evidencia que respalda una conclusión verdadera. Pero recuerde que cuando discutimos argumentos válidos, señalamos que un argumento puede ser inválido y aun así tener un significado verdadero.





conclusión. De la misma manera, un argumento basado en ejemplos puede usarse erróneamente para “probar” una afirmación verdadera. En el ejemplo anterior, no es suficiente demostrar que la conclusión “m n es par” es verdadera para m 14 y n 6. Debe dar un argumento para demostrar que la conclusión es verdadera para cualesquiera enteros pares m y n.

Usar la misma letra para significar dos cosas diferentes.

Algunos demostradores principiantes de teoremas dan a una nueva cantidad variable el mismo nombre de letra que a una variable introducida previamente. Considere el siguiente fragmento de "prueba":

Supongamos que myn son números enteros impares. Entonces por definición de impar,

m = 2k + 1 y n = 2k + 1 para algún número entero k.

Esto es incorrecto. Usar el mismo símbolo, k, en las expresiones para m y n implica que m 2k 1 n. De ello se deduce que el resto de la demostración se aplica sólo a los números enteros myn que son iguales entre sí. Esto es inconsistente con la suposición de que myn son enteros impares elegidos arbitrariamente. Por ejemplo, la prueba no demostraría que la suma de 3 y 5 sea par.

Saltando a una conclusión.

Sacar una conclusión precipitada significa alegar la verdad de algo sin dar una razón adecuada. Considere la siguiente "prueba" de que la suma de dos números enteros pares cualesquiera es par.

Supongamos que m y n son números enteros pares. Por definición de par, m = 2r y

n = 2s para algunos números enteros r y s. Entonces m + n = 2r + 2s. Entonces m + n es par.

El problema con esta “prueba” es que el cálculo crucial

2r + 2s = 2(r + s)

Está perdido. El autor de la “prueba” llegó prematuramente a una conclusión.

Razonamiento circular.

Participar en un razonamiento circular significa asumir lo que se va a demostrar; es una variación de llegar a una conclusión precipitada. Como ejemplo, considere la siguiente "prueba" del hecho de que el producto de dos números enteros impares cualesquiera es impar:

Supongamos que myn son números enteros impares. Cuando se multiplican números enteros impares, su producto es impar. Por tanto mn es impar.

Confusión entre lo que se sabe y lo que aún está por mostrar.

Una forma más sutil de participar en un razonamiento circular se produce cuando la conclusión que se va a mostrar se reformula utilizando una variable. Aquí hay un ejemplo de una “prueba” de que el producto de dos números enteros impares cualesquiera es impar:

Supongamos que myn son números enteros impares. Debemos demostrar que mn es impar. Esto significa que existe un número entero s tal que

min = 2s + 1.

También por definición de impar, existen números enteros a y b tales que

metro = 2a + 1 y norte = 2b + 1.



Entonces





mn = (2a + 1)(2b + 1) = 2s + 1.



Entonces, dado que s es un número entero, mn es impar por definición de impar.

En este ejemplo, cuando el autor reformuló la conclusión que se iba a mostrar (que mn es impar), escribió "existe un número entero s tal que mn 2s 1". Posteriormente el autor saltó a una conclusión injustificada al asumir la existencia de esta s cuando





que en realidad no se había establecido. Este error podría haberse evitado si el autor hubiera escrito “Esto significa que debemos demostrar que existe un número entero s tal que

min = 2s + 1.Una forma de evitar este tipo de error es no introducir una variable en una prueba a menos que sea parte de la hipótesis o sea deducible de ella.

Uso de any en lugar de some.

Hay algunas situaciones en las que las palabras any y some pueden usarse indistintamente. Por ejemplo, al comenzar una demostración de que el cuadrado de cualquier entero impar es impar, se podría escribir correctamente "Supongamos que m es un entero impar" o "Supongamos que m es un entero impar". Sin embargo, en la mayoría de las situaciones las palabras any y some no son intercambiables. Aquí está el comienzo de una “demostración” de que el cuadrado de cualquier número entero impar es impar, que usa any cuando la palabra correcta es some:

Supongamos que m es un número entero impar particular pero elegido arbitrariamente. Por definición de impar, m = 2a + 1 para cualquier número entero a.

En la segunda oración es incorrecto decir que “m = 2a + 1 para cualquier número entero a” porque a no puede ser simplemente “cualquier” número entero; de hecho, resolver m = 2a + 1 para a muestra que el único valor posible para a es (m − 1)/2. La forma correcta de terminar la segunda oración es “m = 2a + 1 para algún número entero a” o “existe un número entero a tal que m = 2a + 1”.

Mal uso de la palabra si.

Otro error común no es grave en sí mismo, pero refleja un pensamiento impreciso que a veces conduce a problemas más adelante en una demostración. Este error implica el uso de la palabra si cuando realmente se quiere decir la palabra porque. Considere el siguiente fragmento de prueba:

Supongamos que p es un número primo. Si p es primo, entonces p no se puede escribir como producto de dos números enteros positivos más pequeños.

El uso de la palabra if en la segunda oración es inapropiado. Sugiere que la primacía de p está en duda. Pero se sabe que p es primo por la primera oración. No se puede escribir como producto de dos números enteros positivos más pequeños porque es primo. Aquí hay una versión correcta del fragmento:

Supongamos que p es un número primo. Como p es primo, p no se puede escribir como producto de dos números enteros positivos más pequeños.



Comenzando con las pruebas

Lo creas o no, una vez que comprendas la idea de generalizar a partir de lo particular genérico y el método de demostración directa, podrás escribir los principios de las demostraciones incluso para teoremas que no comprendas. La razón es que el punto de partida y lo que se debe demostrar en una prueba dependen sólo de la forma lingüística del enunciado que se debe demostrar, no del contenido del enunciado.



Ejemplo 4.1.8 Identificación del “punto de partida” y la “conclusión que se debe mostrar”





Nota No se espera que usted sepa nada sobre gráficos bipartitos completos.



Escriba la primera oración de una prueba (el “punto de partida”) y la última oración de una prueba (la “conclusión a mostrar”) para la siguiente afirmación:

Todo grafo bipartito completo está conectado.





Solución Es útil reescribir el enunciado formalmente usando un cuantificador y una variable:



conclusión de la hipótesis de dominio

Reformulación formal: ∀ grafica G, si G es completo y bipartito, entonces G es conexo.

La primera oración, o punto de partida, de una demostración supone la existencia de un objeto (en este caso G) en el dominio (en este caso el conjunto de todas las gráficas) que satisface la hipótesis de la parte si-entonces del enunciado ( en este caso que G es completo y bipartito). La conclusión que se mostrará es simplemente la conclusión de la parte si-entonces del enunciado (en este caso, que G es conexo).

Punto de partida: supongamos que G es un gráfico [particular pero elegido arbitrariamente] tal que G

es completo y bipartito. Conclusión que se mostrará: G es conexo. Así la prueba tiene la siguiente forma:

Prueba:

Supongamos que G es un gráfico [particular pero elegido arbitrariamente] tal que G es completo y bipartito.

.

Por tanto, G es conexo. ■



Demostrar que una afirmación existencial es falsa

Recordemos que la negación de un enunciado existencial es universal. De ello se deduce que para demostrar que una afirmación existencial es falsa, se debe demostrar que una afirmación universal (su negación) es verdadera.



Ejemplo 4.1.9 Refutar una afirmación existencial

Demuestre que la siguiente afirmación es falsa:

Existe un entero positivo n tal que n2 + 3n + 2 es primo.

Solución Demostrar que la afirmación dada es falsa equivale a demostrar que su negación es verdadera. La negación es

Para todos los números enteros positivos n, n2 + 3n + 2 no es primo.

Como la negación es universal, se prueba generalizando a partir del particular genérico.

Afirmación: La afirmación “Existe un entero positivo n tal que n2 3n 2 es primo” es falsa.

Prueba:

Supongamos que n es cualquier número entero positivo [particular pero elegido arbitrariamente]. [Mostraremos que n2 + 3n + 2 no es primo.] Podemos factorizar n2 + 3n + 2 para obtener n2 + 3n + 2 = (n + 1)(n + 2). También observamos que n + 1 y n + 2 son números enteros (porque son sumas de números enteros) y que tanto n + 1 > 1 como n + 2 > 1 (porque n ≥ 1). Por tanto, n2 + 3n + 2 es un producto de dos números enteros, cada uno de ellos mayor que 1, por lo que n2 + 3n + 2 no es primo. ■

Conjetura, prueba y refutación

Hace más de 350 años, el matemático francés Pierre de Fermat afirmó que es imposible encontrar números enteros positivos x, y y z con xn yn zn si n es un número entero que vale al menos 3. (Para n 2, la ecuación h

tantas soluciones enteras, como 32 42 52 y 52 122 132.) Fermat escribió su afirmación en el margen de un libro, junto con el comentario: "He descubierto una PRUEBA verdaderamente notable de este teorema que este margen











Pedro de Fermat (1601-1665)





Andrew Wiles (nacido en 1953)





























Pruébate



Es demasiado pequeño para contenerlo”. Sin embargo, no se encontró ninguna prueba entre sus artículos y, a lo largo de los años, algunas de las mentes matemáticas más importantes intentaron, sin éxito, descubrir una prueba o un contraejemplo de lo que llegó a conocerse como el último teorema de Fermat.

En 1986, Kenneth Ribet, de la Universidad de California en Berkeley, demostró que si se podía demostrar otro enunciado, la conjetura de Taniyama-Shimura, se aplicaría el teorema de Fermat. Andrew Wiles, matemático inglés y miembro de la facultad de la Universidad de Princeton, se había sentido intrigado por la afirmación de Fermat cuando aún era un niño y, de adulto, había llegado a trabajar en la rama de las matemáticas a la que pertenecía la conjetura de Taniyama-Shimura. Tan pronto como se enteró del resultado de Ribet, Wiles inmediatamente se puso a trabajar para probar la conjetura. En junio de 1993, después de siete años de esfuerzo concentrado, presentó una prueba que obtuvo el reconocimiento mundial.

Sin embargo, durante el verano de 1993, mientras se comprobaba cuidadosamente cada parte de la prueba para preparar su publicación formal, Wiles descubrió que no podía justificar un paso y que ese paso podría en realidad estar equivocado. Trabajó incesantemente durante un año más para resolver el problema, y finalmente se dio cuenta de que la brecha en la prueba era un error genuino, pero que un enfoque en el que había trabajado años antes y abandonado proporcionaba una solución a la dificultad. A finales de 1994, la prueba revisada había sido revisada minuciosamente y considerada correcta en cada detalle por expertos en el campo. Se publicó en Annals of Mathematics en 1995. Se han producido varios libros y un excelente programa de televisión documental que transmite el dramatismo y la emoción del descubrimiento de Wiles.∗

Uno de los problemas más antiguos de las matemáticas que sigue sin resolver es la conjetura de Goldbach. En el ejemplo 4.1.5 se demostró que cada número entero par del 4 al 26 se puede representar como la suma de dos números primos. Hace más de 250 años, Christian Goldbach (1690-1764) conjeturó que todo número par mayor que 2 puede representarse así. Cálculos explícitos asistidos por computadora han demostrado que la conjetura es cierta al menos hasta 1018. Pero hay un enorme abismo entre 1018 y el infinito. Como señaló James Gleick del New York Times, muchas otras conjeturas plausibles en teoría de números han resultado falsas. Leonhard Euler (1707-1783), por ejemplo, propuso en el siglo XVIII que a4 b4 c4 d4 no tenía soluciones con números enteros no triviales. En otras palabras, no hay tres cuartas potencias perfectas que sumen otra cuarta potencia perfecta. Para números pequeños, la conjetura de Euler parecía buena. Pero en 1987, un matemático de Harvard, Noam Elkies, demostró que estaba equivocado. Un contraejemplo, encontrado por Roger Frye de Thinking Machines Corporation en una larga búsqueda por computadora, es 95,8004 217,5194 414,5604 422,4814.†

En mayo de 2000, “para celebrar las matemáticas en el nuevo milenio”, el Instituto Clay de Matemáticas de Cambridge, Massachusetts, anunció que otorgaría premios de

1 millón de dólares cada uno para las soluciones a siete preguntas matemáticas clásicas de larga data. Uno de ellos, “P vs. NP”, pregunta si los problemas que pertenecen a una determinada clase se pueden resolver en una computadora usando métodos más eficientes que los métodos muy ineficientes que actualmente se sabe que funcionan para ellos. Esta cuestión se analiza brevemente al final del Capítulo 11.



Las respuestas a las preguntas de Pruébese usted mismo se encuentran al final de cada sección.





Un número entero es par si y sólo si.

Un número entero es impar si y sólo si.





Un número entero n es primo si, y sólo si, .

La forma más común de refutar una afirmación universal es encontrar .





∗“The Proof”, producida en 1997, para la serie Nova del Public Broadcasting System; El enigma de Fermat: la búsqueda épica para resolver el problema matemático más grande del mundo, por Simon Singh y John Lynch (Nueva York: Bantam Books, 1998); El último teorema de Fermat: Descubriendo el secreto de un antiguo problema matemático por Amir D. Aczel (Nueva York: Delacorte Press, 1997).

†James Gleick, “El último teorema de Fermat todavía no tiene soluciones”, New York Times, 17 de abril de 1988.







Según el método de generalizar a partir del particular genérico, para demostrar que cada elemento de un conjunto satisface una determinada propiedad, supongamos que x es a y demuestre que .



Para utilizar el método de prueba directa para demostrar un enunciado de la forma “Para todo x en un conjunto D, si P(x) entonces Q(x)”, se supone eso y se demuestra que .









Serie de ejercicios 4.1*

En 1 a 3, utiliza las definiciones de par, impar, primo y compuesto para justificar cada una de tus respuestas.

Supongamos que k es un número entero particular.

¿Es −17 un número entero impar? b. ¿Es 0 un número entero par?

C. ¿Es impar 2k − 1?

Supongamos que myn son números enteros particulares.

¿Son pares 6m + 8n? b. ¿Es impar 10 minutos + 7?

C. Si m > n > 0, ¿m2 − n2 es compuesto?

Supongamos que r y s son p

Un incluso mejor

números enteros articulares.

¿4rs es par? b. ¿Es impar 6r + 4s2 + 3?

C. Si r y s son positivos, ¿es r 2 + 2rs + s2 compuesto? Pruebe las afirmaciones del 4 al 10.

Hay números enteros m y n tales que m > 1 y n > 1 y





14. (a + b)2 = a2 + b2 H 15. −an = (−a)n

El promedio de dos números enteros impares cualesquiera es impar.



Demuestre las afirmaciones de 17 y 18 por el método de agotamiento.



Todo número par positivo menor que 26 se puede expresar como la suma de tres o menos cuadrados perfectos. (Por ejemplo, 10 = 12 + 32 y 16 = 42.)

Para cada número entero n con 1 n 10, n2 n 11 es un número primo.

a. Reescribe el siguiente teorema de tres maneras diferentes: como

  , si entonces , como , (sin usar las palabras si o entonces), y como Si , entonces (sin usar un cuantificador universal explícito).



1 1



m + n es un número entero.

Hay números enteros distintos myn tales que 1 1 es un número entero.

Hay números reales a y b tales que



b. Completa los espacios en blanco en la demostración del teorema.

Teorema: La suma de cualquier entero par y cualquier entero impar es impar.

Prueba: Supongamos que m es cualquier número entero par y n es (a). Por



  √ √

a + b = a + b.



definición de par, m = 2r para algunos (b), y por definición de impar, n = 2s + 1 para algunos enteros s. Por sustitución



Hay un número entero n > 5 tal que 2n − 1 es primo.

Existe un número real x tal que x > 1 y 2x > x 10.



y álgebra,

metro + norte = (c) = 2(r + s) + 1.







Hay un cuadrado perfecto que se puede escribir como suma de otros dos cuadrados perfectos.

Existe un número entero n tal que 2n2 − 5n + 2 es primo. Refute las afirmaciones de 11 a 13 dando un contraejemplo.

Para todos los números reales a y b, si a < b entonces a2 < b2.

Para todos los números enteros n, si n es impar, entonces n−1 es impar.

Para todos los números enteros myn, si 2m n es impar, entonces myn son ambos impares.

En 14-16, determine si la propiedad es verdadera para todos los números enteros, verdadera para ningún número entero o verdadera para algunos números enteros y falsa para otros enteros. Justifica tus respuestas.



Dado que r y s son números enteros, también lo es su suma r s. Por eso

m n tiene la forma dos veces un entero más uno, y así

(d) por definición de impar.



Cada una de las afirmaciones de 20 a 23 es verdadera. Para cada uno, (a) reescriba el enunciado con la cuantificación implícita como Si , entonces

           y (b) escribir la primera oración de una prueba (el “punto de partida”) y la última oración de una prueba (la “conclusión que se mostrará”). Tenga en cuenta que no es necesario comprender las afirmaciones para poder realizar estos ejercicios.

Para todos los números enteros m, si m > 1 entonces 0 < 1 < 1.

Para todos los números reales x, si x > 1 entonces x 2 > x.

Para todos los números enteros myn, si mn = 1 entonces m = n = 1 o

metro = norte = −1.

Para todos los números reales x, si 0 < x < 1 entonces x 2 < x .





∗Para los ejercicios con números azules, las soluciones se dan en el Apéndice B. El símbolo H indica que solo se da una pista o una solución parcial. El símbolo ✶ indica que un ejercicio es más desafiante de lo habitual.







Pruebe las afirmaciones de 24 a 34. En cada caso, utilice sólo las definiciones de los términos y los supuestos enumerados en la página 146, no ninguna propiedad previamente establecida de números enteros pares e impares. Siga las instrucciones dadas en esta sección para escribir pruebas de enunciados universales.

El negativo de cualquier número par es par.

La diferencia de cualquier número par menos cualquier número impar es impar.

H 26. La diferencia entre cualquier número entero impar y cualquier número par es impar. (Nota: la “prueba” que se muestra en el ejercicio 39 contiene un error. ¿Puedes detectarlo?)

La suma de dos números enteros impares cualesquiera es par.

Para todos los números enteros n, si n es impar, entonces n2 es impar.

Para todos los números enteros n, si n es impar, entonces 3n + 5 es par.

Para todos los números enteros m, si m es par, entonces 3m + 5 es impar.

Si k es un número entero impar y m es un número entero par, entonces,

k2 + m2 es impar.

Si a es un entero impar y b es un entero par, entonces 2a + 3b es par.

Si n es un número entero par, entonces (−1)n = 1.

Si n es cualquier número entero impar, entonces (−1)n = −1. Demuestre que las afirmaciones de 35 a 37 son falsas.

Existe un número entero m ≥ 3 tal que m2 − 1 es primo.

Existe un número entero n tal que 6n2 + 27 es primo.

Existe un número entero k 4 tal que 2k2 5k 2 es primo.

Encuentre los errores en las “pruebas” que se muestran en 38–42.

Teorema: Para todos los números enteros k, si k > 0 entonces k2 2k 1 es compuesto.

“Prueba: Para k = 2, k2 + 2k + 1 = 22 + 2 · 2 + 1 = 9. Pero 9 = 3 · 3, por lo que 9 es compuesto. Por tanto, el teorema es verdadero”.

Teorema: La diferencia entre cualquier número entero impar y cualquier número par es impar.

“Prueba: supongamos que n es un número entero impar y m es un número entero par. Por definición de impar, n 2k 1 donde k es un número entero, y por definición de par, m 2k donde k es un número entero. Entonces



1 < r < (k2 + 2k + 1)

y 1 < s < (k2 + 2k + 1).

Dado que k2 + 2k + 1 = rs

y tanto r como s están estrictamente entre 1 y k2 2k 1, entonces k2 2k 1 no es primo. Por lo tanto, k2 2k 1 es compuesto como se iba a demostrar”.

Teorema: El producto de un entero par y un entero impar es par.

“Prueba: supongamos que m es un número entero par y n es un número entero impar. Si m · n es par, entonces por definición de par existe un número entero r tal que m · n = 2r. también sinc e m es par, existe un número entero p tal que m = 2 p, y como n es impar existe un número entero q tal que n = 2q + 1. Así

mn = (2 p)(2q + 1) = 2r,

donde r es un número entero. Entonces, por definición de par, m n es par, como se iba a demostrar”.

Teorema: La suma de dos números enteros pares cualesquiera es igual a 4k para algún número entero k.

“Prueba: supongamos que m y n son dos números enteros pares cualesquiera. Por definición de par, m 2k para algún entero k y n 2k para algún entero k. Por sustitución,

metro + norte = 2k + 2k = 4k.

Esto es lo que se iba a mostrar”.



En 43–60 determine si la afirmación es verdadera o falsa. Justifique su respuesta con una prueba o un contraejemplo, según corresponda. En cada caso, utilice únicamente las deﬁniciones de los términos y los supuestos enumerados en la página 146, no ninguna propiedad previamente establecida.

El producto de dos números enteros impares cualesquiera es impar.

El negativo de cualquier número impar es impar.

La diferencia de dos números enteros impares cualesquiera es impar.

El producto de cualquier número par por cualquier número entero es par.

Si la suma de dos números enteros es par, entonces una de las sumas es par. (En la expresión a b, a y b se llaman sumandos.)

La diferencia de dos números enteros pares cualesquiera es par.



norte − metro = (2k + 1) − 2k = 1.

Pero 1 es impar. Por lo tanto, la diferencia entre cualquier número entero impar y cualquier número par es impar”.



La diferencia de dos números enteros impares cualesquiera es par.

Para todos los números enteros n y m, si n m es par, entonces n3 m3 es par.



40. Teorema: Para todos los números enteros k, si k

compuesto.



> 0 entonces k2 + 2k + 1 es



Para todos los números enteros n, si n es primo, entonces (−1)n = −1.

Para todos los números enteros m, si m > 2 entonces m2 − 4 es compuesto.



“Prueba: supongamos que k es cualquier número entero tal que k > 0. Si k2 2k 1 es compuesto, entonces k2 2k 1 rs para algunos números enteros r y s tales que



Para todo número entero n, n2 − n + 11 es un número primo.

Para todo número entero n, 4(n2 + n + 1) − 3n2 es un cuadrado perfecto.





Todo número entero positivo se puede expresar como la suma de tres o menos cuadrados perfectos.

H ✶ 56. (Dos números enteros son consecutivos si, y sólo si, uno es uno



número real no negativo único y, denotado √x, tal que

y2 = x.)

Para todos los números reales no negativos a y b,



más que el otro.) Cualquier producto de cuatro números enteros consecutivos es uno menos que un cuadrado perfecto.



 

a + b =



√a +



57. Si myn son números enteros positivos y mn es un cuadrado perfecto, entonces myn son cuadrados perfectos.



Supongamos que los números enteros myn son cuadrados perfectos. Entonces





m + n + 2 mn también es un cuadrado perfecto. ¿Por qué?



La diferencia de los cuadrados de dos enteros consecutivos cualesquiera H ✶ 62. Si p es un número primo, ¿2p − 1 también debe ser primo? Probar



gers es extraño.

Para todos los números reales no negativos a y b, √ab √a√b. (Tenga en cuenta que si x es un número real no negativo, entonces existe un



o dar un contraejemplo.

✶ 63. Si n es un entero no negativo, ¿debe ser primo 22n 1? Demuestre o dé un contraejemplo.





Respuestas para Ponte a prueba

1. es igual al doble de un número entero 2. es igual al doble de un número entero más 1 3. n es mayor que 1 y si n es igual al producto de dos enteros positivos cualesquiera, entonces uno de los números enteros es igual a 1 y el otro es igual a n. 4. un contraejemplo 5. elemento del conjunto particular pero elegido arbitrariamente; x satisface la propiedad dada 6. x es un elemento particular pero elegido arbitrariamente del conjunto D que hace verdadera la hipótesis P(x); x hace que la conclusión Q(x) sea verdadera.





Ése es, pues, todo el arte de convencer. Está contenido en dos principios: definir todas las notaciones utilizadas y demostrar todo reemplazando mentalmente los términos definidos por sus definiciones. — Blaise Pascal, 1623–1662



Las sumas, diferencias y productos de números enteros son números enteros. Pero la mayoría de los cocientes de números enteros no son números enteros. Sin embargo, los cocientes de números enteros son importantes; se les conoce como números racionales.





La palabra racional contiene la palabra razón, que es otra palabra para cociente. Un número racional se puede escribir como una razón de números enteros.



Ejemplo 4.2.1 Determinar si los números son racionales o irracionales

¿Es 10/3 un número racional?



es - 5



un numero racional?



¿Es 0,281 un número racional?

¿Es el 7 un número racional?

¿Es 0 un número racional?





¿Es 2/0 un número racional?

¿Es 2/0 un número irracional?

¿Es 0,12121212... un número racional (donde se supone que los dígitos 12 se repiten para siempre)?

Si m y n son números enteros y ni m ni n son cero, ¿es (m + n)/mn un número racional?

Solución

Sí, 10/3 es un cociente de los números enteros 10 y 3 y, por tanto, es racional.

Sí, − 5 = −5 , que es un cociente de los números enteros −5 y 39 y, por tanto, es racional.

Sí, 0,281 281/1000. Tenga en cuenta que los números reales representados en la pantalla de una calculadora típica son todos decimales finitos. Una explicación similar a la de este ejemplo muestra que cualquier número de este tipo es racional. De ello se deduce que una calculadora con dicha pantalla sólo puede representar números racionales.

d. Sí, 7 = 7/1.

mi. Sí, 0 = 0/1.

F. No, 2/0 no es un número (no se permite la división entre 0).

gramo. No, porque todo número irracional es un número y 2/0 no es un número. En las secciones 4.6, 4.7 y 9.4 se analizan técnicas adicionales para determinar si los números son irracionales.

h. Sí. Sea x = 0.12121212... . Entonces 100x = 12.12121212 Así

100x − x = 12,12121212 ... − 0,12121212 = 12.

Pero también 100x − x = 99x mediante álgebra básica

Por tanto 99x = 12,

y entonces x 12 .

99



Por lo tanto, 0,12121212 12/99, que es una proporción de dos números enteros distintos de cero y, por lo tanto,

es un número racional.

Tenga en cuenta que puede utilizar un argumento similar a este para demostrar que cualquier decimal periódico es un número racional. En la sección 9.4 mostramos que cualquier número racional se puede escribir como decimal periódico o terminal.

i. Sí, dado que m y n son números enteros, también lo son m n y mn (porque las sumas y productos de números enteros son números enteros). También mn 0 por la propiedad del producto cero. Una versión de esta propiedad dice lo siguiente:







(Véase el Teorema T11 en el Apéndice A y el ejercicio 8 al final de esta sección). Se deduce que (m n)/mn es un cociente de dos números enteros con un denominador distinto de cero y, por tanto, es un número racional. ■



Más sobre generalizar a partir del particular genérico

A algunas personas les gusta pensar que el método de generalizar a partir de lo particular genérico es un proceso de desafío. Si afirma que una propiedad se cumple para todos los elementos de un dominio, entonces alguien puede cuestionar su afirmación escogiendo cualquier elemento del dominio y pidiéndole que demuestre que ese elemento satisface la propiedad. Para probar su reclamo, debe poder enfrentar todos esos desafíos. Es decir, debe tener una manera de convencer al retador de que la propiedad es cierta para un elemento elegido arbitrariamente en el dominio.

Por ejemplo, supongamos que "A" afirma que todo número entero es un número racional. “B” cuestiona esta afirmación pidiéndole a “A” que la demuestre para n = 7. “A” observa que

77 que es un cociente de números enteros y por tanto racional.

1

“B” acepta esta explicación pero la cuestiona nuevamente con n = −12. “A” responde que

−12 = −12 que es un cociente de números enteros y, por tanto, racional.

Luego “B” intenta hacer tropezar a “A” desafiándolo con n = 0, pero “A” responde que

0 0 que es un cociente de números enteros y por tanto racional.

1

Como puede ver, "A" es capaz de responder eficazmente a todos los desafíos de "B" porque "A" tiene un procedimiento general para poner números enteros en forma de números racionales: "A" simplemente divide cualquier número entero que "B" dé entre 1. Es decir, no importa qué entero n “B” dé “A”, “A” escribe

norte

n = 1 que es un cociente de números enteros y por tanto racional.

Esta discusión prueba el siguiente teorema.





En el ejercicio 11 al final de esta sección se le pide que condense la discusión anterior en una prueba formal.



Demostrar propiedades de números racionales

El siguiente ejemplo muestra cómo utilizar el método de generalizar a partir del particular genérico para demostrar una propiedad de los números racionales.



Ejemplo 4.2.2 Una suma de racionales es racional

Demuestre que la suma de dos números racionales cualesquiera es racional.

Solución Comience reescribiendo mental o explícitamente el enunciado que desea probar en la forma “∀, si entonces”.





Reformulación formal: ∀ números reales r y s, si r y s son racionales entonces r + s es racional. Luego pregúntese: "¿Por dónde empiezo?" o "¿Qué estoy suponiendo?" La respuesta le da el punto de partida, o la primera oración, de la demostración.

Punto de partida: supongamos que r y s son números reales particulares pero elegidos arbitrariamente, de modo que r y s son racionales; o, más simplemente,

Supongamos que r y s son números racionales.

Luego pregúntese: "¿Qué debo mostrar para completar la prueba?"

Para mostrar: r + s es racional.

Finalmente pregunte: "¿Cómo llego del punto de partida a la conclusión?" o "¿Por qué r s debe ser racional si tanto r como s son racionales?" La respuesta depende de manera esencial de la definición de racional.

Los números racionales son cocientes de números enteros, por lo que decir que r y s son medios racionales



eso





ra y s c b d







para algunos números enteros a, b, c y d

donde b /= 0 y d /= 0.



Se deduce por sustitución que

r + s un c .

= b + d

Debes demostrar que r s es racional, lo que significa que r s se puede escribir como una única fracción o proporción de dos números enteros con un denominador distinto de cero. Pero el lado derecho de la ecuación (4.2.1) en



un anuncio publicitario



bc reescribiendo la fracción con un común



b + d = bd + bd

anuncio + bc bd



denominador



Sumar fracciones con denominador común.



¿Es esta fracción una razón de números enteros? Sí. Como los productos y las sumas de números enteros son números enteros, ad bc y bd son ambos números enteros. ¿El denominador es bd 0? Sí, por la propiedad del producto cero (ya que b 0 y d 0). Por tanto, r s es un número racional.

Esta discusión se resume de la siguiente manera:



Prueba:

Supongamos que r y s son números racionales. [Debemos demostrar que r + s es racional.] Entonces, por definición de racional, r = a/b y s = c/d para algunos números enteros a, b, c y d con b /= 0 y d /= 0. Así



r + s a c





por sustitución



anuncio + bc bd







por álgebra básica.







■



Derivando nuevas matemáticas de las antiguas

La sección 4.1 se centró en establecer la verdad y la falsedad de los teoremas matemáticos utilizando únicamente el álgebra básica que normalmente se enseña en la escuela secundaria; el hecho de que los números enteros son cerrados en suma, resta y multiplicación; y las definiciones de los términos en los propios teoremas. En el futuro, cuando le pidamos que demuestre algunaSi sacamos algo directamente de las definiciones, queremos decir que debe limitarse a este enfoque. Sin embargo, una vez que se ha demostrado una colección de afirmaciones directamente a partir de las definiciones, se hace posible otro método de prueba. Las declaraciones de la colección se pueden utilizar para obtener resultados adicionales.



Ejemplo 4.2.3 Obtención de resultados adicionales sobre enteros pares e impares

Supongamos que ya has demostrado las siguientes propiedades de los números enteros pares e impares:



La suma, el producto y la diferencia de dos números enteros pares son pares.

La suma y la diferencia de dos números enteros impares son pares.

El producto de dos números enteros impares cualesquiera es impar.

El producto de cualquier número entero par y cualquier número entero impar es par.

La suma de cualquier número entero impar y cualquier número par es impar.

La diferencia de cualquier número entero impar menos cualquier número entero par es impar.

La diferencia de cualquier número par menos cualquier número impar es impar.



Utilice las propiedades enumeradas anteriormente para demostrar que si a es un número entero par y b es un número entero impar, entonces a2+b2+1 es un número entero.

Solución Supongamos que a es un número entero par y b es un número entero impar. Por la propiedad 3, b2 es impar y por la propiedad 1, a2 es par. Entonces, según la propiedad 5, a2 + b2 es impar, y como 1 también es impar, la suma (a2 + b2) + 1 = a2 + b2 + 1 es par según la propiedad 2. Por lo tanto, por definición de par, existe un número entero k tal que a2 + b2 + 1 = 2k. Dividiendo ambos lados por 2

da a2+b2+1 = k, que es un número entero. Por tanto, a2+b2+1 es un número entero [como debía ser

mostrado]. ■

Un corolario es un enunciado cuya verdad puede deducirse inmediatamente de un teorema que ya ha sido demostrado.





Ejemplo 4.2.4 El doble de un número racional

Deduzca lo siguiente como corolario del teorema 4.2.2.





Solución El doble de un número es simplemente su suma consigo mismo. Pero como la suma de dos números racionales cualesquiera es racional (Teorema 4.2.2), la suma de un número racional consigo mismo es racional. Por tanto, el doble de un número racional es racional. Aquí hay una versión formal de este argumento:

Prueba:

Supongamos que r es cualquier número racional. Entonces 2r r r es la suma de dos números racionales. Entonces, según el teorema 4.2.2, 2r es racional. ■









Pruébate

Para demostrar que un número real es racional, debemos demostrar que podemos escribirlo como .









Un número irracional es un es decir.

El cero es un número racional porque.









Conjunto de ejercicios 4.2

Los números del 1 al 7 son todos racionales. Escribe cada número como una razón de dos números enteros.

35 4 2









Completa los espacios en blanco en la siguiente prueba de que el cuadrado de cualquier número racional es racional:

Prueba: Supongamos que r es (a). Por definición de racional,



1. − 6 2. 4.6037 3.

4. 0,37373737 ...

5. 0,56565656 ...

6. 320.5492492492 ...

7. 52.4672167216721 ...



5 + 9



r = a/b para algún (b) con b /= 0. Por sustitución,

r2 = (c) = a2/b2.

Dado que a y b son números enteros, también lo son los productos a2 y

   (d) . También b2 0 por el (e) . Por tanto, r 2 es una razón de dos

números enteros con un denominador distinto de cero, y por lo tanto (f ) por definición de racional.

Considere la afirmación: El negativo de cualquier número racional



La propiedad del producto cero dice que si el producto de dos números reales es 0, entonces uno de los números debe ser 0.

Escriba esta propiedad formalmente usando cuantificadores y variables.

Escribe el contrapositivo de tu respuesta al inciso (a).

Escriba una versión informal (sin símbolos cuantificadores ni variables) para su respuesta al inciso (b).

Suponga que a y b son números enteros y que a 0 y b 0. Explique por qué (b a)/(ab2) debe ser un número racional.

Suponga que m y n son números enteros y que n /= 0. Explique por qué (5m + 12n)/(4n) debe ser un número racional.

Demuestre que todo número entero es un número racional.



ber es racional.

Escriba el enunciado formalmente usando un cuantificador y una variable.

Determina si la afirmación es verdadera o falsa y justifica tu respuesta.

Considere la afirmación: el cuadrado de cualquier número racional es un número racional.

Escriba el enunciado formalmente usando un cuantificador y una variable.

Determina si la afirmación es verdadera o falsa y justifica tu respuesta.

Determine cuáles de las afirmaciones de 15 a 20 son verdaderas y cuáles son falsas. Demuestre cada afirmación verdadera directamente a partir de las definiciones y dé un contraejemplo para cada afirmación falsa.







En caso de que la afirmación sea falsa, determine si un pequeño cambio la haría verdadera. Si es así, realice el cambio y pruebe la nueva declaración. Siga las instrucciones para escribir pruebas en la página 154.

El producto de dos números racionales cualesquiera es un número racional.

H 16. El cociente de dos números racionales cualesquiera es un número racional.

H 17. La diferencia de dos números racionales cualesquiera es un número racional.

H 18. Si r y s son dos números racionales cualesquiera, entonces r + s es racional.







Demuestre que si una solución para una ecuación cuadrática de la forma x 2 bx c 0 es racional (donde b y c son racionales), entonces la otra solución también es racional. (Utilice el hecho de que si las soluciones de la ecuación son r y s, entonces x 2 + bx + c = (x − r)(x − s).)

Demuestre que si un número real c satisface una ecuación polinómica de la forma

r3x 3 + r2x 2 + r1x + r0 = 0,

donde r0, r1, r2 yr3 son números racionales, entonces c satisface una ecuación de la forma

norte x 3 + norte x 2 + norte x + norte = 0,



H 19. Para todos los números reales a y b, si a < b entonces a < a+b < b.



3 2 1 0



2

(Puede utilizar las propiedades de las desigualdades en T17–T27 del Apéndice A.)

Dados dos números racionales cualesquiera r y s con r < s, hay otro número racional entre r y s. (Pista: utilice los resultados de los ejercicios 18 y 19.)

Utilice las propiedades de los números enteros pares e impares que se enumeran en el Ejemplo 4.2.3 para hacer los ejercicios 21 a 23. Indique qué propiedades utiliza para justificar su razonamiento.

¿Verdadero o falso? Si m es un número entero par y n es un número entero impar, entonces m2 + 3n es impar. Explicar.

¿Verdadero o falso? Si a es un número entero impar, entonces a2 a es par. Explicar.

¿Verdadero o falso? Si k es un número entero par y m es un número entero impar, entonces (k + 2)2 − (m − 1)2 es par. Explicar.

Derive los enunciados de 24 a 26 como corolarios de los teoremas 4.2.1, 4.2.2 y los resultados de los ejercicios 12, 13, 14, 15 y 17.

Para cualquier número racional r y s, 2r + 3s es racional.

Si r es cualquier número racional, entonces 3r 2 − 2r + 4 es racional.

Para cualquier número racional s, 5s3 + 8s2 − 7 es racional.

Es un hecho que si n es cualquier número entero no negativo, entonces



donde n0, n1, n2 y n3 son números enteros.



✶ 32. Demuestre que para todos los números reales c, si c es una raíz de un polinomio con coeficientes racionales, entonces c es una raíz de un polinomio con coeficientes enteros.



Utilice las propiedades de los números enteros pares e impares que se enumeran en el Ejemplo 4.2.3 para hacer los ejercicios 33 y 34.

Cuando se multiplican expresiones de la forma (x r)(x s), se obtiene un polinomio cuadrático. Por ejemplo, (x − 2)(x − (−7)) = (x − 2)(x + 7) = x 2 + 5x − 14.

Ja. ¿Qué se puede decir acerca de los coeficientes del polinomio obtenido al multiplicar (x r)(x s) cuando tanto r como s son enteros impares? cuando tanto r como s son números enteros pares? cuando uno de r y s es par y el otro es impar?

b. Del inciso a) se deduce que x2 1253x 255 no se puede escribir como producto de dos polinomios con coeficientes enteros. Explique por qué esto es así.

✶ 34. Observa que (x − r)(x − s)(x − t)



1 1 1







1 1 − (1/2n+1)







= x 3 − (r + s + t)x 2 + (rs + rt + st)x − primero.



1 + 2 + 22 + 23 + ··· + 2n =



1-(1/2) .



(Una forma más general de esta afirmación se prueba en la Sección 5.2). ¿Es racional el lado derecho de esta ecuación? Si es así, exprésalo como una razón de dos números enteros.

28. Supongamos que a, b, cyd son números enteros y a c. Supongamos también que x es un número real que satisface la ecuación

hacha + b 1.

cx+d

¿Debe x ser racional? Si es así, expresa x como una razón de dos números enteros.

✶ 29. Supongamos que a, b y c son números enteros y x, y y z son números reales distintos de cero que satisfacen las siguientes ecuaciones:



Deducir un resultado para polinomios cúbicos similar al resultado

en la parte (a) del ejercicio 33 para polinomios cuadráticos.

¿Se puede escribir x 3 7x 2 8x 27 como producto de tres polinomios con coeficientes enteros? Explicar.

En 35–39 encuentre los errores en las “pruebas” de que la suma de dos números racionales cualesquiera es un número racional.

“Prueba: dos números racionales cualesquiera producen un número racional cuando se suman. Entonces, si r y s son números racionales particulares pero elegidos arbitrariamente, entonces r s es racional”.

“Prueba: Sean dados los números racionales r = 1 y s = 1.



xy xz

= a y







yz

= b y



=c.



Entonces r + s = 1 + 1 = 3, que es un número racional. Este





x + y



x+z



y+z



4 2 4





¿Es x racional? Si es así, exprésalo como una razón de dos números enteros.



es lo que se iba a mostrar”.







“Prueba: supongamos que r y s son números racionales. Por definición de racional, r = a/b para algunos enteros a y b con b /= 0, y s = a/b para algunos enteros a y b con b /= 0.





Pero esta es la suma de dos fracciones, que es una fracción. Entonces r s es un número racional ya que un número racional es una fracción”.

“Prueba: supongamos que r y s son números racionales. Si r + s es



un un 2a



racional, entonces por definición de racional r + s = a/b para algunos



r + s = segundo + segundo = segundo .



enteros a y b con b /= 0. Además, dado que r y s son racionales,



Sea p = 2a. Entonces p es un número entero ya que es producto de números enteros. Por tanto r + s = p/b, donde p y b son números enteros



r = i/j y s = m/n para algunos números enteros i, j, m y n con

j /= 0 y n /= 0. Se deduce que



y b /= 0. Por lo tanto, r + s es un número racional por definición de



soy un



racional. Esto es lo que se iba a mostrar”.

38. “Prueba: supongamos que r y s son números racionales. Entonces r = a/b y s = c/d para algunos números enteros a, b, cyd con b /= 0 y d /= 0 (por definición de racional). Entonces



r + s = j + norte = segundo ,

que es un cociente de dos números enteros con denominador distinto de cero. Por tanto es un número racional. Esto es lo que se iba a mostrar”.



una c

r + s = segundo + re .



Respuestas para Ponte a prueba

1. una proporción de números enteros con un denominador distinto de cero 2. un número real; no racional 3. 0 0

1







La cualidad esencial de una prueba es obligar a creer. —Pierre de Fermat



Cuando te presentaron por primera vez el concepto de división en la escuela primaria, probablemente te enseñaron que 12 dividido entre 3 es 4 porque si separas 12 objetos en grEn grupos de 3, obtienes 4 grupos sin nada sobrante.



Es posible que también le hayan enseñado a describir este hecho diciendo que “12 es divisible por 3” o “3 divide a 12 por igual”.

La noción de divisibilidad es el concepto central de una de las materias más bellas de las matemáticas avanzadas: la teoría de números, el estudio de las propiedades de los números enteros.







Ejemplo 4.3.1 Divisibilidad

¿21 es divisible por 3? b. ¿5 divide a 40? C. ¿7 | 42?

d. ¿Es 32 múltiplo de −16? mi. ¿Es 6 un factor de 54? F. ¿Es 7 un factor de −7?

Solución

a. Sí, 21 = 3 · 7. b. Sí, 40 = 5 · 8. c. Sí, 42 = 7 · 6.

d. Sí, 32 = (−16) · (−2). mi. Sí, 54 = 6 · 9. f. Sí, −7 = 7 · (−1). ■



Ejemplo 4.3.2 Divisores de cero

Si k es cualquier número entero distinto de cero, ¿k divide a 0?

Solución Sí, porque 0 = k · 0. ■



Dos propiedades útiles de la divisibilidad son (1) que si un entero positivo divide a un segundo entero positivo, entonces el primero es menor o igual que el segundo, y (2) que los únicos divisores de 1 son 1 y −1.



■



Prueba:

Dado que 1 1 1 y ( 1)( 1) 1, tanto 1 como 1 son divisores de 1. Ahora supongamos que m es cualquier número entero que divide a 1. Entonces existe un número entero n tal que 1 mn. Según el teorema T25 del Apéndice A, tanto myn son positivos como ambos myn son negativos. Si tanto m como n son positivos, entonces m es un divisor entero positivo de 1. Según el teorema 4.3.1, m ≤ 1 y, dado que el único entero positivo que es menor o igual

continúa en la página 172









Ejemplo 4.3.3 Divisibilidad de expresiones algebraicas

Si a y b son números enteros, ¿3a + 3b son divisibles por 3?

Si k y m son números enteros, ¿10 km son divisibles por 5?

Solución

Sí. Según la ley distributiva del álgebra, 3a 3b 3(a b) y a b es un número entero porque es la suma de dos números enteros.

Sí. Según la ley asociativa del álgebra, 10km 5 (2km) y 2km es un número entero porque es producto de tres números enteros. ■



Cuando la definición de divisiones se reescribe formalmente utilizando el cuantificador existencial, el resultado es

re | n ⇔ ∃ un número entero k tal que n = dk.

Dado que la negación de un enunciado existencial es universal, se deduce que d no divide a n (denotado como d n) si, y sólo si, los números enteros k, n dk o, en otras palabras, el cociente n/d no es un número entero.





















¡Precaución!



Ejemplo 4.3.4 Comprobación de la no divisibilidad

¿4 | ¿15?

Solución No, 15 = 3,75, que no es un número entero. ■

Tenga cuidado de distinguir entre la notación a | b y la notación a/b. La notación a | b representa la oración “a divide b”, lo que significa que hay un número entero k tal que b = ak. Al dividir ambos lados por a se obtiene b/a = k, un número entero. Así, cuando a /= 0, a | b si,



a b denota la oración “a divide b”, mientras que a/b denota el número a dividido por b.



y sólo si, b/a es un número entero. Por otro lado, la notación a/b representa el número a/b que es el resultado de dividir a por b y que puede ser o no un número entero. En particular, asegúrese de evitar escribir cosas como

zz ss



4s|s(3zs+sz5)z=z4 | 8.

Si se lee en voz alta, esto se convierte en “4 divide la cantidad 3 más 5 es igual a 4 divide 8”, lo cual no tiene sentido.



Ejemplo 4.3.5 Números primos y divisibilidad

Una forma alternativa de definir un número primo es decir que un número entero n > 1 es primo si, y sólo si, sus únicos divisores enteros positivos son 1 y él mismo. ■





Demostrar las propiedades de la divisibilidad

Una de las propiedades más útiles de la divisibilidad es que es transitiva. Si un número divide a un segundo y el segundo número divide a un tercero, entonces el primer número divide al tercero.





Ejemplo 4.3.6 Transitividad de la divisibilidad

Demuestre que para todos los números enteros a, b y c, si a | byb | c, luego a | C.

Solución Dado que el enunciado que se va a demostrar ya está escrito formalmente, se puede seleccionar inmediatamente el punto de partida, o primera oración de la demostración, y la conclusión que se debe mostrar.

Punto de partida: supongamos que a, b y c son números enteros particulares pero elegidos arbitrariamente, tales que

un | byb | C.

Para mostrar: un | C.

Necesitas demostrar que a | c, o en otras palabras, que

c = a ·(algún número entero).



Pero desde un | b,



Y desde b | C,



b = ar para algún número entero r. 4.3.1

c = bs para algún número entero s. 4.3.2



La ecuación 4.3.2 expresa c en términos de by la ecuación 4.3.1 expresa b en términos de a. Por lo tanto, si sustituyes 4.3.1 en 4.3.2, tendrás una ecuación que expresa c en términos de a.

c = bs por la ecuación 4.3.2

= (ar)s por la ecuación 4.3.1.

Pero (ar)s = a(rs) por la ley asociativa de la multiplicación. Por eso

c = a(rs).

Ya casi has terminado. Has expresado c como (algo). Sólo queda comprobar que ese algo es un número entero. Pero claro que lo es, porque es producto de dos números enteros.

Esta discusión se resume de la siguiente manera:





Prueba:

Supongamos que a, b y c son números enteros [particulares pero elegidos arbitrariamente] tales que a divide

b y b dividen a c. [Debemos demostrar que a divide a c.] Por definición de divisibilidad,

b = ar y c = bs para algunos números enteros r y s.

continúa en la página 174







■



De la definición de primo parecería que para demostrar que un número entero es primo sería necesario demostrar que no es divisible por cualquier número entero mayor que 1 y menor que él mismo. De hecho, sólo necesitas comprobar si es divisible por un número primo menor o igual a él mismo. Esto se desprende de los teoremas 4.3.1, 4.3.3 y del siguiente teorema, que dice que cualquier número entero mayor que 1 es divisible por un número primo. La idea de la prueba es bastante simple. Empiezas con un número entero positivo. Si es primo, ya está; si no, es producto de dos factores positivos menores. Si uno de estos es primo, ya está; si no, puedes elegir uno de los factores y escribirlo como producto de factores positivos aún más pequeños. Puedes continuar de esta manera, factorizando los factores del número con el que empezaste, hasta que uno de ellos resulte ser primo. Esto debe suceder eventualmente porque se pueden elegir todos los factores para que sean positivos y cada uno de ellos sea más pequeño que el anterior.





Prueba:

Supongamos que n es un número entero [particular pero elegido arbitrariamente] que es mayor que 1. [Debemos demostrar que hay un número primo que divide a n.] Si n es primo, entonces n es divisible por un número primo (es decir, él mismo), y hemos terminado. Si n no es primo, entonces, como se analizó en el ejemplo 4.1.2b,

n r0s0 donde r0 y s0 son números enteros y 1 < r0 < n y 1 < s0 < n.

Por definición de divisibilidad se deduce que r0 n.

Si r0 es primo, entonces r0 es un número primo que divide a n, y listo. Si r0 no es primo, entonces

r0 r1s1 donde r1 y s1 son números enteros y 1 < r1 < r0 y 1 < s1 < r0.

De la definición de divisibilidad se deduce que r1 r0. Pero ya sabemos que r0 n. En consecuencia, por transitividad de la divisibilidad, r1 n.

Si r1 es primo, entonces r1 es un número primo que divide a n, y listo. Si r1 no es primo, entonces

r1 r2s2 donde r2 y s2 son números enteros y 1 < r2 < r1 y 1 < s2 < r1.











Contraejemplos y divisibilidad

Para demostrar que una propiedad de divisibilidad propuesta no es universalmente cierta, sólo es necesario encontrar un par de números enteros para los cuales sea falsa.

Supongamos que n es un número entero impar [particular pero elegido arbitrariamente]. Según el teorema del cociente del resto, n se puede escribir en una de las formas

4q o 4q + 1 o 4q + 2 o 4q + 3

para algún número entero q. De hecho, como n es impar y 4q y 4q 2 son pares, n debe tener una de las formas



4q+1 o 4q+3.

Caso 1 (n = 4q + 1 para algún número entero q): [Debemos encontrar un número entero m tal que n2 = 8m + 1.] Dado que n = 4q + 1,

n2 = (4q + 1)2 por sustitución

= (4q + 1)(4q + 1) por definición de cuadrado

= 16q2 + 8q + 1

= 8(2q2 + q) + 1 por las leyes del álgebra.

Sea m 2q2 q. Entonces m es un número entero ya que 2 y q son números enteros y las sumas y productos de números enteros son números enteros. Así, sustituyendo,

n2 = 8m + 1 donde m es un número entero.

Caso 2 (n = 4q + 3 para algún número entero q): [Debemos encontrar un número entero m tal que n2 = 8m + 1.] Dado que n = 4q + 3,

n2 = (4q + 3)2 por sustitución

= (4q + 3)(4q + 3) por definición de cuadrado

= 16q2 + 24q + 9

= 16q2 + 24q + (8 + 1)

= 8(2q2 + 3q + 1) + 1 por las leyes del álgebra.

[La motivación para la elección de los pasos de álgebra fue el deseo de escribir la expresión en la forma 8 · (algún número entero) + 1.]



∗Ver ejercicio 18 para una perspectiva diferente.







■



Tenga en cuenta que el resultado del teorema 4.4.3 también se puede escribir: "Para cualquier entero impar n, n2 mod 8 1".

En general, según el teorema del cociente del resto, si un número entero n se divide por un número entero d, los restos posibles son 0, 1, 2,..., (d 1). Esto implica que n puede escribirse en una de las formas

dq, dq + 1, dq + 2,, ..., dq + (d − 1) para algún número entero q.

Se pueden obtener muchas propiedades de los números enteros dando a d una variedad de valores diferentes y analizando los casos resultantes.



El valor absoluto y la desigualdad del triángulo

La desigualdad triangular es uno de los resultados más importantes que involucran valor absoluto. Tiene aplicaciones en muchas áreas de las matemáticas.





La desigualdad triangular dice que el valor absoluto de la suma de dos números es menor o igual a la suma de sus valores absolutos. Damos una prueba basada en los dos hechos siguientes, los cuales se derivan mediante división en casos. Enunciamos ambos como lemas. Un lema es una afirmación que no tiene mucho interés intrínseco pero que es útil para derivar otros resultados.



Prueba:

Supongamos que r es cualquier número real. Dividimos en casos según si r 0 o

r<0.

Caso 1 (r ≥ 0): En este caso, por definición de valor absoluto, |r |= r . Además, dado que r es positivo y −|r | es negativo, −|r | <r. Así es cierto que

−|r |≤ r ≤ |r |.

continúa en la página 188











Los lemas 4.4.4 y 4.4.5 proporcionan ahora una base para demostrar la desigualdad del triángulo.



Prueba:

Supongamos que x e y son números reales.

Caso 1 (x + y ≥ 0): En este caso, |x + y|= x + y, y así, según el Lema 4.4.4,

x ≤ |x | y y ≤ |y|.

Por lo tanto, según el teorema T26 del Apéndice A,

|x + y|= x + y ≤ |x |+ |y|.











Pruébate

1. El teorema del cociente del resto dice que para todos los números enteros n y d con d 0, existen q y r tales que y .







Según el teorema del cociente del resto, si un número entero n se divide por un entero positivo d, los restos posibles son. Esto implica que n puede escribirse en una de las formas de algún número entero q.



2. Si n y d son números enteros con d > 0, n div d es y n

mod d es.



Para probar una afirmación de la forma “Si A1 C”, pruebe y y.



o A2



o A3, entonces



3. La paridad de un número entero indica si el número entero es

  .



Conjunto de ejercicios 4.4

Para cada uno de los valores de n y d dados en 1-6, encuentre los números enteros q

y r tal que n = dq + r y 0 ≤ r < d.

1. n = 70, d = 9 2. n = 62, d = 7

3. n = 36, d = 40 4. n = 3, d = 11

5. norte = −45, re = 11 6. norte = −27, re = 8

Evalúe las expresiones del 7 al 10.

a. 43 división 9 b. 43 mod 9

a. 50 divisiones 7 b. 50 mod 7

a. 28 divisiones 5 b. 28 mod 5

a. 30 divisiones 2 b. 30 mod 2

Verifique la exactitud de la fórmula (4.4.1) dada en el ejemplo

4.4.3 para los siguientes valores de DayT y N .

DíaT = 6 (sábado) y N = 15

DíaT = 0 (domingo) y N = 7

DíaT = 4 (jueves) y N = 12

✶ 12. Justifique la fórmula (4.4.1) para los valores generales de DayT y N.

13. Un lunes un amigo te dice que te volverá a ver dentro de 30 días. ¿Qué día de la semana será ese?

H 14. Si hoy es martes, ¿qué día de la semana será dentro de 1000 días?

El 1 de enero de 2000 fue sábado y el año 2000 fue un año bisiesto. ¿Qué día de la semana será el 1 de enero de 2050?

Supongamos que d es un número entero positivo y n es cualquier número entero. Si d n, ¿cuál es el resto que se obtiene cuando se aplica el teorema del cociente-resto a n con divisor d?



La desigualdad del triángulo dice que para todos los números reales x y

y, .







Demuestre que el producto de dos números enteros consecutivos es par.

El resultado del ejercicio 17 sugiere que el segundo aparente callejón sin salida en la discusión del Ejemplo 4.4.7 podría no serlo después de todo. Escribe una nueva demostración del teorema 4.4.3 basada en esta observación.

Demuestre que para todo número entero n, n2 − n + 3 es impar.

Supongamos que a es un número entero. Si un mod 7 es 4, ¿qué es 5a mod 7? En otras palabras, si la división de a entre 7 da un resto de 4, ¿cuál es el resto cuando se divide 5a entre 7?

Supongamos que b es unn número entero. Si b mod 12 5, ¿cuál es?

8b mod 12? En otras palabras, si la división de b entre 12 da un resto de 5, ¿cuál es el resto cuando se divide 8b entre 12?

Supongamos que c es un número entero. Si c mod 15 3, ¿cuál es?

10c mod 15? En otras palabras, si la división de c entre 15 da un resto de 3, ¿cuál es el resto cuando se divide 10c entre 15?

Demuestre que para todos los números enteros n, si n mod 5 = 3 entonces

n2 mod 5 = 4.

Demuestre que para todos los números enteros m y n, si m mod 5 = 2 y

n mod 3 = 6 entonces mn mod 5 = 1.

Demuestre que para todos los números enteros a y b, si a mod 7 = 5 y

b mod 7 = 6 luego ab mod 7 = 2.

H 26. Demuestre que una condición necesaria y suficiente para que un entero no negativo n sea divisible por un entero positivo d es que n mod d = 0.







Demuestre que cualquier número entero n se puede escribir en una de las tres formas

n = 3q o n = 3q + 1 o n = 3q + 2 para algún número entero q.

a. Utilice el teorema del cociente del resto con d 3 para demostrar que el producto de tres números enteros consecutivos es divisible por 3.

b. Utilice la notación mod para reescribir el resultado del inciso (a).

Utilice el teorema del cociente del resto con d = 3 para demostrar



41. Para todos los números enteros m, m2 = 5k, o m2 = 5k + 1, o

m2 = 5k + 4 para algún número entero k.

H 42. Todo número primo excepto 2 y 3 tiene la forma 6q + 1 o 6q + 5 para algún entero q.

43. Si n es un número entero impar, entonces n4 mod 16 = 1.

H 44. Para todos los números reales x e y, |x |·|y|= |xy|.

Para todos los números reales r y c con c ≥ 0, si −c ≤ r ≤ c, entonces

|r |≤c.



H 29.





que el cuadrado de cualquier número entero tiene la forma 3k o 3k 1 para algún número entero k.

Utilice la notación mod para reescribir el resultado del inciso (a).



Para todos los números reales r y c con c ≥ 0, si |r |≤ c, entonces

−c ≤ r ≤ c.

Una matriz M tiene 3 filas y 4 columnas.



a. Utilice el teorema del cociente del resto con d 3 para demostrar que el producto de dos enteros consecutivos cualesquiera tiene la forma 3k o 3k + 2 para algún entero k.

b. Utilice la notación mod para reescribir el resultado del inciso (a). En 31–33, puede utilizar las propiedades enumeradas en el Ejemplo 4.2.3.

a. Demuestre que para todos los números enteros m y n, m n y m n

son ambos impares o ambos pares.

b. Encuentre todas las soluciones de la ecuación m2 n2 56 para las cuales m y n son enteros positivos.

C. Encuentre todas las soluciones de la ecuación m2 n2 88 para las cuales m y n son enteros positivos.

Dados números enteros a, b y c, si a b es par y b c es par, ¿qué puedes decir acerca de la paridad de 2a (b c)? Demuestre su respuesta.

Dados números enteros a, b y c, si a b es impar y b c es par, ¿qué puedes decir sobre la paridad de a c? Demuestre su respuesta.

H 34. Dado cualquier número entero n, si n > 3, ¿podrían n, n 2 y n 4 ser primos? Demuestre o dé un contraejemplo.

Demuestre cada una de las afirmaciones de 35 a 46.

35. La cuarta potencia de cualquier número entero tiene la forma 8m u 8m 1 para algún número entero m.

H 36. El producto de cuatro números enteros consecutivos es divisible por 8.

37. El cuadrado de cualquier número entero tiene la forma 4k o 4k 1 para algún número entero k.

H 38. Para cualquier número entero n, n2 + 5 no es divisible por 4.

H 39. La suma de cuatro números enteros consecutivos tiene la forma 4k + 2 para algún número entero k.

Para cualquier número entero n, n(n2 − 1)(n + 2) es divisible por 4.

Respuestas para Ponte a prueba



a11 a12 a13 a14



a31 a32 a33 a34

Las 12 entradas de la matriz deben almacenarse en forma de fila principal en las ubicaciones 7609 a 7620 en la memoria de una computadora. Esto significa que las entradas de la primera fila (leyendo de izquierda a derecha) se almacenan primero, luego las entradas de la segunda fila y finalmente las entradas de la tercera fila.

¿En qué ubicación se almacenará a22?

Escribe una fórmula (en i y j) que dé el número entero n de modo que aij se almacene en la ubicación 7,609 + n.

Encuentre fórmulas (en n) para r y s para que ars se almacene en la ubicación 7,609 + n.

48. Sea M una matriz con m filas yn columnas, y supongamos que las entradas de M se almacenan en la memoria de una computadora en forma de fila mayor (ver ejercicio 47) en las ubicaciones N, N + 1, N + 2,... ., N + mn − 1. Encuentre fórmulas en k para r y s de modo que ars se almacene en la ubicación N + k.

✶ 49. Si m, n y d son números enteros, d > 0, y m mod d n mod d, ¿se sigue necesariamente que m n? ¿Que m n es divisible por d? Demuestre sus respuestas.

✶ 50. Si m, n y d son números enteros, d > 0 y d (m n), ¿cuál es la relación entre m mod d y n mod d? Demuestre su respuesta.

✶ 51. Si m, n, a, byd son números enteros, d > 0, y m mod d = a y n mod d = b, ¿es (m + n) mod d = a + b? ¿Es (m + n) mod d = (a + b) mod d? Demuestre sus respuestas.

✶ 52. Si m, n, a, b y d son números enteros, d > 0, y m mod d a y n mod d b, ¿es (mn) mod d ab? ¿Es (mn) mod d ab mod d? Demuestre sus respuestas.

53. Demuestre que si m, d y k son números enteros y d > 0, entonces

(m + dk) mod d = m mod d.



1. números enteros; norte = dq + r ; 0 ≤ r < d 2. el cociente obtenido al dividir n por d; el resto no negativo obtenido cuando n se divide por d 3. par o impar 4. 0, 1, 2, ..., (d − 1); dq, dq + 1, dq + 2, ..., dq + (d − 1) 5. Si A1, entonces C ; Si A2, entonces C; Si A3, entonces C 6. |x + y|≤ |x |+ |y|









La prueba sirve para muchos propósitos simultáneamente. Al estar expuesto al escruti ny y juicio de una nueva audiencia, [una] prueba está sujeta a un proceso constante de crítica y revalidación. Los errores, ambigüedades y malentendidos se aclaran mediante una exposición constante. La prueba es la respetabilidad. La prueba es el sello de la autoridad.

La prueba, en sus mejores casos, aumenta la comprensión al revelar el meollo del asunto. La prueba sugiere nuevas matemáticas. El novato que estudia las demostraciones se acerca a la creación de nuevas matemáticas. La prueba es el poder matemático, el voltaje eléctrico del sujeto que vitaliza las afirmaciones estáticas de los teoremas.

Finalmente, la prueba es un ritual y una celebración del poder de la razón pura.

— Philip J. Davis y Reuben Hersh, La experiencia matemática, 1981



Imagine un número real sentado en una recta numérica. El piso y el techo del número son los números enteros inmediatamente a la izquierda y a la derecha inmediata del número (a menos que el número sea, en sí mismo, un número entero, en cuyo caso su piso y su techo son ambos iguales al número mismo). Muchos lenguajes informáticos tienen funciones integradas que calculan el piso y el techo automáticamente. Estas funciones son muy cómodas de utilizar al escribir ciertos tipos de programas informáticos. Además, los conceptos de piso y techo son importantes para analizar la eficiencia de muchos algoritmos informáticos.







X



norte norte + 1



piso de x = [x♩





X



norte – 1 norte



techo de x = [x|





Ejemplo 4.5.1 Pisos y techos informáticos

Calcule x ] y 「x para cada uno de los siguientes valores de x: a. 25/4 b. 0,999c. −2,01

Solución

a. 25/4 = 6,25 y 6 < 6,25 < 7; por lo tanto 25/4]= 6 y 「25/4 = 7.

b. 0 < 0,999 < 1; por lo tanto 0,999]= 0 y 「0,999 = 1.

C. −3 < −2,01 < −2; por lo tanto −2,01]= −3 y 「−2,01 = −2.

Tenga en cuenta que en algunas calculadoras x ] se denota INT (x). ■



Ejemplo 4.5.2 Una aplicación

Los 1.370 estudiantes de una universidad tienen la oportunidad de tomar autobuses para ir a un partido fuera de la ciudad. Cada autobús tiene capacidad para un máximo de 40 pasajeros.

Por razones de economía, el director deportivo enviará únicamente autobuses completos. ¿Cuál es la cantidad máxima de autobuses que enviará el director deportivo?

Si el director deportivo está dispuesto a enviar un autobús parcialmente lleno, ¿cuántos autobuses se necesitarán para permitir que todos los estudiantes hagan el viaje?



Solución

a. 1370/40]= 34,25]= 34 b. 「1370/40 = 「34,25 = 35 ■

Ejemplo 4.5.3 Algunos valores generales de piso

Si k es un número entero, ¿cuáles son k] y k + 1/2]? ¿Por qué?

Solución Supongamos que k es un número entero. Entonces

  k]= k porque k es un número entero y k ≤ k < k + 1,

y

,k + 1 , = k porque k es un número entero y k ≤ k + 1 < k + 1. ■

2 2



Ejemplo 4.5.4 Refutación de una supuesta propiedad de piso

¿La siguiente expresión es cierta o falsa?

Para todos los números reales x e y, x + y]= x ]+ y].

Solución La afirmación es falsa. Como contraejemplo, tomemos x = y = 1. Entonces

  x ]+ y]= , 1 , + , 1 , = 0 + 0 = 0,







mientras





  x + y



, 1 1 ,





1] = 1.



]= 2 + 2 =

Por tanto x + y] /= x ]+ y].

Para llegar a este contraejemplo, se podría haber razonado de la siguiente manera: Supongamos que xey son números reales. ¿Debe ser necesariamente el caso que x + y]= x ]+ y], o podrían x e y ser tales que x + y] /= x ]+ y]? Imaginemos los valores que podrían tomar las distintas cantidades. Por ejemplo, si tanto x como y son positivos, entonces x ] e y] son las partes enteras de x ] e y] respectivamente; Tal como

3 3

25 = 2 + 5







Asi es



parte entera



parte fraccional







y



x = x ]+ parte fraccionaria de x



y = y]+ parte fraccionaria de y.



donde aquí se entiende por parte fraccionaria la parte del número a la derecha del punto decimal cuando el número se escribe en notación decimal. Por tanto, si x e y son positivos,

x + y = x ]+ y]+ la suma de las partes fraccionarias de x e y.



Pero también





x + y = x + y]+ la parte fraccionaria de (x + y).



Estas ecuaciones muestran que si existen números xey tales que la suma de las partes fraccionarias de xey es al menos 1, entonces se puede encontrar un contraejemplo. Pero existen tales xey; por ejemplo, x = 1 e y = 1 como antes. ■



El análisis del ejemplo 4.5.4 indica que si x e y son positivos y la suma de sus partes fraccionarias es menor que 1, entonces x y x y . En particular, si x es positivo y m es un entero positivo, entonces x m x m x m. (La parte fraccionaria de m es 0; por lo tanto, la suma de las partes fraccionarias de x y m es igual a la parte fraccionaria de x, que es menor que 1). Resulta que puedes usar la definición de piso para demostrar que esta ecuación es válido para todos los números reales x y para todos los números enteros m.



Ejemplo 4.5.5 Demostración de una propiedad de piso

Demuestre que para todos los números reales x y para todos los enteros m, x + m]= x ]+ m.

Solución Comience suponiendo que x es un número real particular pero elegido arbitrariamente y que m es un número entero particular pero elegido arbitrariamente. Debes demostrar que x + m]=

  x ]+ metro. Dado que esta es una ecuación que involucra x ] y x + m], es razonable darle un nombre a una de estas cantidades: Sea n = x ]. Por definición de piso,

n es un número entero y n ≤ x < n + 1.





Esta doble desigualdad le permite calcular el valor de x m en términos den sumando m a todos los lados:

norte + metro ≤ x + metro < norte + metro + 1.

Por lo tanto, el lado izquierdo de la ecuación que se mostrará es



  x + m]= n + m.

Por otro lado, dado que n = x ], el lado derecho de la ecuación que se mostrará es

  x ]+ m = n + m

también. Así x + m]= x ]+ m. Esta discusión se resume de la siguiente manera:





■





El análisis de una serie de algoritmos informáticos, como los algoritmos de búsqueda binaria y ordenación por fusión, requiere que conozca el valor de n/2, donde n es un número entero. La fórmula para calcular este valor depende de si n es par o impar.











Dado cualquier entero n y un entero positivo d, el teorema del cociente del resto garantiza la existencia de enteros únicos q y r tales que



norte = dq + r y 0 ≤ r < d.

El siguiente teorema establece que la notación de suelo se puede utilizar para describir q y r de la siguiente manera:

q = , norte y r = norte - re , norte , .

Por lo tanto, si en una calculadora o en un lenguaje de computadora, el piso está incorporado pero div y mod no, div y mod se pueden definir de la siguiente manera: Para un entero no negativo n y un entero positivo d,





4.5.1







Tenga en cuenta que d divide a n si, y sólo si, n mod d 0 o, en otras palabras, n d n/d . Se le pide que lo demuestre en el ejercicio 13.











Ejemplo 4.5.6 Cálculo de div y mod

Utilice la notación de piso para calcular 3850 div 17 y 3850 mod 17.

Solución Por fórmula (4.5.1),

3850 div 17 = 3850/17]= 226.4705882 .. .]= 226

3850 mod 17 = 3850 − 17 · 3850/17]

= 3850 − 17 · 226

= 3850 − 3842 = 8. ■









Pruébate

Dado cualquier número real x, el piso de x es el entero único

n tal que .









Dado cualquier número real x, el techo de x es el único entero n tal que .







Conjunto de ejercicios 4.5

Calcule x ] y 「x para cada uno de los valores de x en 1-4.

1. 37.999 2. 17/4

3. −14.00001 4. −32/5





Para todos los números reales x, x − 1]= x ]− 1.

Para todos los números reales x, x 2]= x ]2.

H 17. Para todos los números enteros n,





Utilice la notación de piso para expresar 259 div 11 y 259 mod 11.



  n/3]= ⎧⎪⎨



n/3 si n mod 3 = 0

(norte − 1)/3 si norte mod 3 = 1 .



Si k es un número entero, ¿cuál es 「k? ¿Por qué?

Si k es un número entero, ¿cuánto es k + 1? ¿Por qué?

Se necesitan siete libras de materia prima para fabricar cada unidad de un determinado producto. Exprese el número de unidades que se pueden producir a partir de n libras de materia prima utilizando la notación de piso o de techo. ¿Qué notación es más apropiada?

Las cajas, cada una con capacidad para 36 unidades, se utilizan para enviar un producto desde el fabricante al mayorista. Exprese el número de cajas que se necesitarían para enviar n unidades del producto utilizando la notación de piso o de techo. ¿Qué notación es más apropiada?

Si 0 domingo, 1 lunes, 2 martes,..., 6 sábado, entonces el 1 de enero del año n ocurre en el día de la semana dado por la siguiente fórmula:



(n − 2)/3 si n mod 3 = 2

H 18. Para todos los números reales x e y, 「x + y = 「x + 「y.

H 19. Para todos los números reales x, 「x − 1 = 「x − 1.

Para todos los números reales x e y, 「xy = 「x ·「y.

Para todos los enteros impares n, 「n/2 = (n + 1)/2.

Para todos los números reales x e y, 「xy = 「x · y]. Demuestre cada una de las afirmaciones de 23 a 29.

Para cualquier número real x, si x no es un número entero, entonces

  x ]+ −x ]= −1.

Para cualquier número entero m y cualquier número real x , si x no es un número entero, entonces x ]+ m − x ]= m − 1.

H 25. Para todos los números reales x, x/2]/2]= x/4].



norte - 1 norte - 1 norte - 1



26. Para todos los números reales x, si x − x ] < 1/2 entonces



  norte + ,



4, −, 100, +, 400, mod 7.



  2x]= 2x].



a. Utilice esta fórmula para encontrar el 1 de enero de

2050 ii. 2100 iii. el año de tu nacimiento.

Hb. Interpreta los diferentes componentes de esta fórmula.



Para todos los números reales x , si x − x ]≥ 1/2 entonces

  2x]= 2x]+ 1.

Para cualquier entero impar n,



Indique una condición necesaria y suficiente para el piso de una





, n2 ,









   norte - 1 norte + 1









Demuestre que si n es un número entero par, entonces n/2]= n/2.

Supongamos que n y d son números enteros y d 0. Demuestre cada uno de los siguientes.



Para cualquier entero impar n,

, n2 ,











n2 3

4 .



Si d | n, entonces n = n/d]· d.

Si n = n/d]· d, entonces d | norte.

Utilice la notación mínima para establecer una condición necesaria y suficiente para que un número entero n sea divisible por un número entero d.

Algunas de las afirmaciones de 14 a 22 son verdaderas y otras falsas. Demuestre cada enunciado verdadero y encuentre un contraejemplo para cada enunciado falso, pero no utilice el teorema 4.5.1. en tus pruebas.

14. Para todos los números reales x e y, x − y]= x ]− y].



Respuestas para Ponte a prueba

1. n ≤ x < n + 1 2. n − 1 < x ≤ n



Encuentre el error en la siguiente “prueba” de que n/2

(n 1)/2 si n es un número entero impar.

“Prueba: supongamos que n es cualquier número entero impar. Entonces n 2k 1 para algún número entero k. Como consecuencia,

, 2k + 1 , = (2k + 1) − 1 = 2k = k.

Pero n = 2k + 1. Al resolver k se obtiene k = (n − 1)/2. Por lo tanto, por sustitución, n/2]= (n − 1)/2.”









La reducción al absurdo es una de las mejores armas de un matemático. Es una táctica mucho mejor que cualquier táctica de ajedrez: un jugador de ajedrez puede ofrecer el sacrificio de un peón o incluso una pieza, pero el matemático ofrece el juego. — GH Hardy, 1877–1947



En una prueba directa se comienza con la hipótesis de un enunciado y se hace una deducción tras otra hasta llegar a la conclusión. Las pruebas indirectas son mrotonda del mineral. Un tipo de prueba indirecta, el argumento por contradicción, se basa en el hecho de que una afirmación es verdadera o falsa, pero no ambas. Entonces, si se puede demostrar que la suposición de que una determinada afirmación no es verdadera conduce lógicamente a una contradicción, una imposibilidad o un absurdo, entonces esa suposición debe ser falsa y, por tanto, la afirmación dada debe ser verdadera. Este método de prueba también se conoce como reducción al imposible o reducción al absurdo porque se basa en reducir un supuesto determinado a una imposibilidad o un absurdo.

El argumento por contradicción ocurre en muchos entornos diferentes. Por ejemplo, si un hombre acusado de atracar un banco puede demostrar que se encontraba en otro lugar en el momento en que se cometió el delito, seguramente será absuelto. La lógica de su defensa es la siguiente:

Supongamos que cometí el crimen. Entonces, en el momento del crimen, yo habría tenido que estar en la escena del crimen. De hecho, en el momento del crimen me encontraba en una reunión con 20 personas alejadas del lugar del crimen, como testificarán. Esto contradice la suposición de que cometí el delito ya que es imposible estar en dos lugares al mismo tiempo. Por tanto, esa suposición es falsa.

Otro ejemplo ocurre en el debate. Una técnica de debate es decir: "Supongamos por un momento que lo que dice mi oponente es correcto". A partir de esta suposición, el polemista deduce una afirmación tras otra hasta llegar finalmente a una afirmación completamente ridícula e inaceptable para el público. De esta manera, el polemista demuestra que la afirmación del oponente es falsa.

El punto de partida de una prueba por contradicción es el supuesto de que el enunciado a demostrar es falso. El objetivo es razonar ante una contradicción. Así, la prueba por contradicción tiene el siguiente esquema:







Nota ¡Ten mucho cuidado al escribir la negación!









No existen reglas claras sobre cuándo probar una prueba directa y cuándo probar una prueba por contradicción, pero existen algunas pautas generales. La prueba por contradicción se indica si se quiere demostrar que no hay ningún objeto con una determinada propiedad, o si se quiere demostrar que un determinado objeto no tiene una determinada propiedad. Los dos ejemplos siguientes ilustran estas situaciones.



Ejemplo 4.6.1 No existe el mayor número entero

Utilice la prueba por contradicción para demostrar que no existe un número entero mayor.





Solución La mayoría de los niños pequeños creen que existe un número entero mayor; a menudo lo llaman “millones”. Pero con la edad y la experiencia, cambian sus creencias. En algún momento se dan cuenta de que si hubiera un número entero mayor, podrían sumarle 1 para obtener un número entero que fuera aún mayor. Como se trata de una contradicción, no puede existir ningún número entero mayor. Esta línea de razonamiento es el corazón de la prueba formal.

Para la prueba, la “propiedad determinada” es la propiedad de ser el mayor número entero. Para demostrar que no existe ningún objeto con esta propiedad, se comienza suponiendo la negación: que existe un objeto con esa propiedad.

Punto de partida: Supongamos que no. Supongamos que hay un número entero mayor; Llámalo N. Esto significa que N ≥ n para todos los números enteros n.

Mostrar: Esta suposición conduce lógicamente a una contradicción.



■

Una vez que se ha llegado a una contradicción, la lógica del argumento es siempre la misma: “Esto es una contradicción. Por tanto, la suposición es falsa y el teorema es verdadero”. Debido a esto, la mayoría de los textos de matemáticas terminan las demostraciones por contradicción en el punto en el que se obtuvo la contradicción.

La contradicción del siguiente ejemplo se basa en el hecho de que 1/2 no es un número entero.



Ejemplo 4.6.2 Ningún número entero puede ser par e impar al mismo tiempo

El hecho de que ningún número entero puede ser par e impar se desprende de la parte de unicidad del teorema del cociente del resto. Una demostración completa de esta versión del teorema se describe en el ejercicio 18 de la sección 4.7. Este ejemplo muestra cómo utilizar la prueba por contradicción para probar un caso específico.



Prueba:

[Tomamos la negación del teorema y suponemos que es verdadera.] Supongamos que no. Es decir, supongamos que hay al menos un número entero n que es par e impar. [Debemos deducir una contradicción.] Por definición de par, n = 2a para algún entero a, y por definición de impar, n = 2b + 1 para algún entero b. Como consecuencia,

2a = 2b + 1 igualando las dos expresiones para n

continúa en la página 200







■



El siguiente ejemplo te pide que demuestres que la suma de cualquier número racional y cualquier número irracional es irracional. Una forma de pensar en esto es en términos de que un determinado objeto (la suma de un racional y un irracional) no tenga una determinada propiedad (la propiedad de ser racional). Esto sugiere intentar una prueba por contradicción: supongamos que el objeto tiene la propiedad y deduzca una contradicción.





Ejemplo 4.6.3 La suma de un número racional y un número irracional

Utilice la prueba por contradicción para demostrar que la suma de cualquier número racional y cualquier número irracional es irracional.









¡Precaución! La negación de "La suma de cualquier número irracional y cualquier número racional es irracional" NO es "La suma de cualquier número irracional y cualquier número racional es racional".



SoluciónComienza suponiendo la negación de lo que vas a probar. Tenga mucho cuidado al escribir lo que esto significa. Si tomas la negación incorrectamente, todo el resto de la prueba será defectuoso. En este ejemplo, la declaración que se va a probar se puede escribir formalmente como

∀ números reales r y s, si r es racional y

s es irracional, entonces r + s es irracional.

De esto puedes ver que la negación es

∃ un número racional r y un número irracional s tal que r + s es racional.

De ello se desprende que el punto de partida y lo que se quiere mostrar son los siguientes:

Punto de partida: Supongamos que no. Es decir, supongamos que hay un número racional r y un número irracional s tales que r + s es racional.

Mostrar: Esta suposición conduce a una contradicción.

Para derivar una contradicción, es necesario comprender lo que se supone: que hay números r y s tales que r es racional, s es irracional y r s es racional. Por definición de racional e irracional, esto significa que s no puede escribirse como un cociente de dos números enteros cualesquiera, pero que r y r + s pueden:



a

b

r + s = c



para algunos enteros a y b con b /= 0, y 4.6.1

para algunos enteros cyd con d /= 0. 4.6.2





Si sustituyes (4.6.1) en (4.6.2), obtienes

una c

segundo + s = re .

Restar a/b de ambos lados da

c un

= re - segundo

anuncio antes de Cristo

= bd − bd reescribiendo c/d y a/b como fracciones equivalentes



antes de Cristo - anuncio bd



por la regla para restar fracciones con el mismo denominador.



Pero tanto bc ad como bd son números enteros porque los productos y diferencias de números enteros son números enteros, y bd 0 por la propiedad del producto cero. Por tanto, s puede expresarse como un cociente de dos números enteros con un denominador distinto de cero, por lo que s es racional, lo que contradice la suposición de que es irracional.

Esta discusión se resume en una prueba formal.



■



Argumento por contraposición

Una segunda forma de argumento indirecto, el argumento por contraposición, se basa en la equivalencia lógica entre un enunciado y su contrapositivo. Para probar un enunciado por contraposición, se toma el contrapositivo del enunciado, se prueba el contrapositivo mediante una prueba directa y se concluye que el enunciado original es verdadero. El razonamiento subyacente





es que dado que un enunciado condicional es lógicamente equivalente a su contrapositivo, si el contrapositivo es verdadero entonces el enunciado también debe ser verdadero.







Ejemplo 4.6.4 Si el cuadrado de un número entero es par, entonces el número entero es par

Demuestre que para todos los números enteros n, si n2 es par, entonces n es par.

Solución Primero forme el contrapositivo del enunciado a demostrar.

Contrapositivo: Para todos los números enteros n, si n no es par, entonces n2 no es par.

Según el teorema del cociente del resto con d 2, cualquier número entero es par o impar, por lo que cualquier número entero que no sea par es impar. Además, según el teorema 4.6.2, ningún número entero puede ser par e impar al mismo tiempo. Entonces, si un número entero es impar, entonces no es par. Por tanto, el contrapositivo se puede reformular de la siguiente manera:

Contrapositivo: para todos los números enteros n, si n es impar, entonces n2 es impar.

Un cálculo sencillo es el núcleo de una prueba directa de esta afirmación, como se muestra a continuación.





Usamos aquí la palabra proposición en lugar de teorema porque aunque la palabra teorema

puede referirse a cualquier afirmación que haya sido probada, los matemáticos a menudo la restringen a





declaraciones especialmente importantes que tienen muchas y variadas consecuencias. Luego usan la palabra proposición para referirse a una declaración que es algo menos trascendental pero

no obstante, vale la pena escribirlo. Usaremos la Proposición 4.6.4 en la Sección 4.7 para demostrar

ese 2 es irracional. ■



Relación entre prueba por contradicción y prueba por contraposición

Obsérvese que cualquier prueba por contraposición puede reformularse en el lenguaje de la prueba por contradicción. En una prueba por contraposición, la afirmación

∀x en D, si P(x) entonces Q(x)

se demuestra dando una prueba directa de la declaración equivalente

∀x en D, si ∼Q(x) entonces ∼P(x).

Para hacer esto, se supone que se le da un elemento arbitrario x de D tal que ∼Q(x). Luego demuestras que ∼P(x). Esto se ilustra en la Figura 4.6.1.



secuencia de pasos





Figura 4.6.1 Prueba por contraposición



Se puede utilizar exactamente la misma secuencia de pasos como núcleo de una prueba por contradicción para el enunciado dado. Lo único que cambia es el contexto en el que se escriben los pasos.

Para reescribir la prueba como una prueba por contradicción, se supone que hay una x en D tal que P(x) y Q(x). Luego se siguen los pasos de la prueba por contraposición para deducir el enunciado P(x). Pero P(x) es una contradicción con la suposición de que P(x) y Q(x). (Porque para contradecir una conjunción de dos enunciados, sólo es necesario

contradicen uno de ellos.) Este proceso se ilustra en la Figura 4.6.2.



misma secuencia de pasos





Figura 4.6.2 Prueba por contradicción



Como ejemplo, aquí hay una prueba por contradicción de la Proposición 4.6.4, es decir, que para cualquier número entero n, si n2 es par, entonces n es par.



Prueba (por contradicción):

[Tomamos la negación del teorema y suponemos que es verdadera.] Supongamos que no. Es decir, supongamos que existe un número entero n tal que n2 es par y n no es par. [Debemos deducir e una contradicción.] Según el teorema del cociente del resto con d = 2, cualquier número entero

continúa en la página 204









Tenga en cuenta que cuando utiliza la prueba por contraposición, sabe exactamente qué conclusión necesita mostrar, es decir, la negación de la hipótesis; mientras que en la prueba por contradicción puede resultar difícil saber hacia qué contradicción dirigirse. Por otro lado, cuando se utiliza la prueba por contradicción, una vez que se ha deducido cualquier contradicción, ya está. La principal ventaja de la contraposición sobre la contradicción es que evita tener que tomar (posiblemente incorrectamente) la negación de una afirmación complicada. La desventaja de la contraposición en comparación con la contradicción es que sólo se puede utilizar la contraposición para una clase específica de enunciados: aquellos que son universales y condicionales.

La discusión anterior muestra que cualquier afirmación que pueda probarse por contraposición

puede demostrarse por contradicción. Pero la conversación no es verdadera. Declaraciones como “2

es irracional” (que se analiza en la siguiente sección) puede probarse por contradicción pero no por contraposición.



La prueba como herramienta de resolución de problemas

La prueba directa, la refutación por contraejemplo, la prueba por contradicción y la prueba por contraposición son herramientas que pueden usarse para ayudar a determinar si las afirmaciones son verdaderas o falsas. Dada una declaración de la forma

Para todos los elementos de un dominio, si (hipótesis) entonces (conclusión),

Imagine elementos en el dominio que satisfagan la hipótesis. Pregúntese: ¿Deben satisfacer la conclusión? Si puede ver que la respuesta es “sí” en todos los casos, entonces la afirmación es verdadera y su percepción formará la base para una prueba directa. Si después de pensarlo un poco no está claro que la respuesta sea “sí”, pregúntese si hay elementos del dominio que satisfacen la hipótesis y no la conclusión. Si logra encontrar alguno, entonces la afirmación es falsa y tiene un contraejemplo. Por otro lado, si no se logra encontrar dichos elementos, es posible que no exista ninguno. Quizás pueda demostrar que asumir la existencia de elementos en el dominio que satisfacen la hipótesis y no la conclusión conduce lógicamente a una contradicción. Si es así, entonces la afirmación dada es verdadera y tiene la base para una prueba por contradicción. Alternativamente, se podrían imaginar elementos del dominio para los cuales la conclusión es falsa y preguntarse si dichos elementos tampoco satisfacen la hipótesis. Si la respuesta en todos los casos es “sí”, entonces tienes una base para una prueba por contraposición.

Resolver problemas, especialmente los difíciles, rara vez es un proceso sencillo. En cualquier etapa de seguir las pautas anteriores, es posible que desee probar nuevamente el método de una etapa anterior. Si, por ejemplo, no logra encontrar un contraejemplo para una determinada afirmación, su experiencia al intentar encontrarlo podría ayudarle a decidir volver a intentar un argumento directo en lugar de intentar uno indirecto. Los psicólogos que han estudiado la resolución de problemas han descubierto que los solucionadores de problemas más exitosos son aquellos que son flexibles y están dispuestos a utilizar una variedad de enfoques sin quedarse atrapados en ninguno de ellos durante mucho tiempo.



























Pruébate



muy largo. A veces los matemáticos trabajan durante meses (o más) en problemas difíciles. No se desanime si algunos de los problemas de este libro le llevarán bastante tiempo resolverlos.

Aprender las habilidades de demostrar y refutar es muy parecido a aprender otras habilidades, como las que se utilizan en la natación, el tenis o tocar un instrumento musical. Cuando empiezas, es posible que te sientas desconcertado por todas las reglas y que no te sientas seguro al intentar cosas nuevas. Pero con la práctica, las reglas se internalizan y puedes usarlas junto con todos tus demás poderes (equilibrio, coordinación, juicio, sentido estético) para concentrarte en ganar una competencia, ganar un partido o tocar un concierto con éxito.

Ahora que ha trabajado en las primeras cinco secciones de este capítulo, regrese a la idea de que, por encima de todo, una prueba o refutación debe ser un argumento convincente. Necesita saber cómo se estructuran las pruebas y contraejemplos directos e indirectos. Pero para utilizar este conocimiento de forma eficaz, debes utilizarlo junto con tus poderes imaginativos, tu intuición y, especialmente, tu sentido común.



Para probar un enunciado por contradicción, se supone que

  y eso lo demuestras.

Una prueba por contraposición de un enunciado de la forma “x D, si P(x) entonces Q(x)” es una prueba directa de .



Para probar un enunciado de la forma “x D, si P(x) entonces Q(x)” por contraposición, se supone eso y se demuestra que.







Conjunto de ejercicios 4.6

Completa los espacios en blanco en la siguiente prueba por contradicción de que no existe un número real mínimo positivo.





racional, existen números enteros a, b, cyd con b /= 0 y

d /= 0 de modo que x = (c) y x − y = (d) . Por sustitución,



Prueba: Supongamos que no. Es decir, supongamos que hay al menos una c



número real positivo x . [Debemos deducir (a) ] Considere el número x/2. Como x es un número real positivo, x/2 también es

   (b) . Además, podemos deducir que x/2 < x by multiplicar-

dividiendo ambos lados de la desigualdad 1 < 2 por (c) y dividiendo

   (d) . Por tanto, x/2 es un número real positivo que es menor que el número real menos positivo. Esta es una (e) [Por lo tanto, el soporte







segundo - y = re

Sumar y y restar c en ambos lados da

d

y = (mi)

anuncio antes de Cristo

= -



¿Es 1 un número irracional? Explicar. 0



anuncio - antes de Cristo bd



por álgebra.



Utilice la prueba por contradicción para demostrar que para todos los números enteros n,

3n + 2 no es divisible por 3.

Utilice la prueba por contradicción para demostrar que para todos los números enteros

m, 7m + 4 no es divisible por 7.

Formule cuidadosamente las negaciones de cada una de las afirmaciones del 5 al 7. Luego prueba cada enunciado por contradicción.

No existe un entero par mayor.

No existe un número real negativo mayor.

No existe ningún número racional mínimo positivo.

Complete los espacios en blanco para la siguiente prueba de que la diferencia entre cualquier número racional y cualquier número irracional es irracional.

Prueba: Supongamos que no. Es decir, supongamos que existe (a)

x y (b) y tales que x − y es racional. Por definición de



Ahora bien, tanto ad bc como bd son números enteros porque los productos y diferencias de (f) son (g). Y bd 0 por el (h).

Por tanto, y es una razón de números enteros con un denominador distinto de cero y, por tanto, y es (i) por definición de racional. Nosotros por lo tanto

Tenemos que y es irracional y que y es racional, lo cual es una contradicción. [Por tanto, la suposición es falsa y la afirmación que se ha de probar es verdadera.]

a. Cuando se le pidió que probara que la diferencia entre cualquier número irracional y cualquier número racional es irracional, un estudiante comenzó: “Supongamos que no. Es decir, supongamos que la diferencia entre cualquier número irracional y cualquier número racional es racional”. ¿Qué hay de malo en comenzar la demostración de esta manera? (Pista: revise la respuesta al ejercicio 11 de la Sección 3.2.)

b. Demuestre que la diferencia de cualquier número irracional y

cualquier número racional es irracional.







Demuestre cada afirmación de 10 a 17 mediante contradicción.

La raíz cuadrada de cualquier número irracional es irracional.

El producto de cualquier número racional distinto de cero y cualquier número irracional es irracional.

Si a y b son números racionales, b /= 0 y r es un número irracional, entonces a + br es irracional.

H 13. Para cualquier número entero n, n2 − 2 no es divisible por 4.

H 14. Para todos los números primos a, byc, a2 + b2 /= c2.

H 15. Si a, b y c son números enteros y a2 b2 c2, entonces al menos uno de a y b es par.

H ✶ 16. Para todos los números enteros impares a, byc, si z es una solución de ax 2 bx c 0 entonces z es irracional. (En la demostración, utilice las propiedades de los enteros pares e impares que se enumeran en el Ejemplo 4.2.3.)

Para todos los números enteros a, si mod 6 = 3, entonces mod 3 /= 2.

Complete los espacios en blanco en la siguiente prueba por contraposición de que para todos los números enteros n, si 5 / | n2 entonces 5 / | norte.

Prueba (por contraposición): [El contrapositivo es: Para todos los números enteros n, si 5 n entonces 5 n2.] Supongamos que n es cualquier número entero tal que (a). [Debemos demostrar que (b) .] Por definición de divisibilidad, n = (c) para algún entero k. Por sustitución



24. El recíproco de cualquier número irracional es irracional. (El

el recíproco de un número real distinto de cero x es 1/x .)

H 25. Para todos los números enteros n, si n2 es impar, entonces n es impar.

26. Para todos los números enteros a, b y c, si a / | antes de Cristo entonces a / | b. (Recuerde que el símbolo/ | significa “no divide”).

H 27. Para todos los números enteros myn, si m n es par, entonces myn son pares o myn son impares.

Para todos los números enteros m y n, si mn es par entonces m es par o n

incluso.

Para todos los números enteros a, b y c, si a b y a c, entonces

a B C). (Sugerencia: para probar p q r, basta con probar p q r o p r q. Consulte el ejercicio 14 de la sección 2.2.)

La siguiente “prueba” de que todo número entero es racional es incorrecta. Encuentra el error.

“Prueba (por contradicción): Supongamos que no. Supongamos que todo número entero es irracional. Entonces el número entero 1 es irracional. Pero

1 1/1, que es racional. Esto es una contradicción. [Por tanto, la suposición es falsa y el teorema es verdadero.] "



a. Demuestre por contraposición: para todos los números enteros positivos n, r y s, si rs ≤ n, entonces r ≤ n o s ≤ n.

b. Demuestre: Para todos los números enteros n > 1, si n no es primo√e, entonces







ción, n2 = (d) = 5(5k2). Pero 5k2 es un número entero porque



existe un número primo p tal que p ≤ n y



es producto de números enteros. Por tanto, n2 5 (un número entero), y así

[como se iba a mostrar].

Demuestre las afirmaciones de 19 y 20 por contraposición.

Si el producto de dos números reales positivos es mayor que 100, entonces al menos uno de los números es mayor que 10.

Si la suma de dos números reales es menor que 50, entonces al menos uno de los números es menor que 25.

Considere la afirmación “Para todo número entero n, si n2 es impar, entonces

n es impar”.

Escribe lo que supondrías y lo que necesitarías demostrar para probar esta afirmación por contradicción.

Escribe lo que supondrías y lo que necesitarías demostrar para probar esta afirmación por contraposición.

Considere la afirmación “Para todos los números reales r, si r 2 es irracional, entonces r es irracional”.

Escribe lo que supondrías y lo que necesitarías demostrar para probar esta afirmación por contradicción.

Escribe wqué supondrías y qué necesitarías demostrar para probar esta afirmación por contraposición.

Demuestre cada una de las afirmaciones de 23 a 29 de dos maneras: (a) por contraposición y (b) por contradicción.

El negativo de cualquier número irracional es irracional.



n es divisible por p. (Sugerencias: utilice el resultado del inciso (a), teoremas 4.3.1, 4.3.3 y 4.3.4, y la propiedad transitiva del orden).

C. Indique el contrapositivo del resultado del inciso (b).

Los resultados del ejercicio 31 proporcionan una forma de comprobar si un número entero es primo.





Utilice la prueba de primalidad para determinar si los siguientes números son primos o no.

a. 667 b. 557 c. 527 d. 613

El tamiz de Eratóstenes, que lleva el nombre de su inventor, el erudito griego Eratóstenes (276-194 a. E.C.), proporciona una manera de encontrar todos los números primos menores o iguales a algún número fijo n. Para construirlo, escribe todos los números enteros del 2 al n. Tacha todos los múltiplos de 2 excepto el 2 mismo, luego todos los múltiplos de 3 excepto el 3 mismo, luego todos los múltiplos de 5 excepto el 5 mismo, y así sucesivamente. Continúe tachando el





múltiplos de cada número primo sucesivo hasta √n. Los números que no están tachados son todos los números primos del 2 al n. Aquí tienes un tamiz de Eratóstenes que incluye los números del 2 al 27. Los múltiplos de 2 se tachan con una /, los múltiplos de 3 con una y los múltiplos de 5 con una —.





Usa el tamiz de Eratóstenes para encontrar todos los números primos menores que 100.

Utilice la prueba de primalidad y el resultado del ejercicio 33 para determinar si los siguientes números son primos.

a. 9.269 b. 9.103 c. 8.623 d. 7,917



4 6

17 19



10 12

23 25



H ✶ 35. Utilice la prueba por contradicción para demostrar que todo número entero

mayor que 11 es la suma de dos números compuestos.







Respuestas para Ponte a prueba

la afirmación es falsa; esta suposición conduce a una contradicción 2. la contrapositiva del enunciado, es decir, ∀x ∈ D, si ∼Q(x)

entonces ∼P(x) 3. x es cualquier elemento [particular pero elegido arbitrariamente] de D para el cual Q(x) es falso; P(x) es falso





Es indigno del nombre de hombre quien no sabe que la diagonal de un cuadrado es inconmensurable con su lado.—Platón (ca. 428–347 a.E.C.)

Esta sección contiene pruebas de dos de los teoremas más famosos de las matemáticas: que √2 es irracional y que hay infinitos números primos. Ambas pruebas son ejemplos de argumentos indirectos y eran bien conocidas hace más de 2.000 años, pero siguen siendo modelos ejemplares de argumento matemático hasta el día de hoy.

La irracionalidad de √2

Cuando las matemáticas florecieron en la época de los antiguos griegos, los matemáticos creían que dados dos segmentos de línea cualesquiera, digamos A: y B:, se podía encontrar una cierta unidad de longitud de modo que el segmento A tenía exactamente una unidad de largo y el segmento B tenía exactamente b. unidades de largo. (Se decía que los segmentos eran conmensurables con respecto a esta unidad especial de longitud). Entonces, la razón de las longitudes de A y B sería la misma proporción que la razón de los números enteros a y b. Simbólicamente:

longitud A

longitud B = b .

Ahora es fácil encontrar un segmento de recta de longitud √2; solo toma la diagonal de la unidad

cuadrado:





1





1

Según el teorema de Pitágoras, c2 12 12 2, por lo que c √2. Si la creencia de los antiguos griegos fuera correcta, habría números enteros a y b tales que

longitud (diagonal) a

longitud (lado) = b .







Y esto implicaría que



c = √2 = √2 = a .





Pero entonces √2 sería una razón de dos números enteros o, en otras palabras, √2 sería racional. En el siglo IV o V a.E.C., √los seguidores del matemático griego y

El filósofo Pitágoras descubrió que 2 no era racional. Este descubrimiento fue muy

Esto les molestó, porque socavó su creencia profunda y casi religiosa en el poder de



números enteros para describir fenómenos.

La siguiente prueba de la irracionalidad de



√2 era conocido por Aristóteles y es similar a



eso en el décimo libro de Los Elementos de Geometría de Euclides. El matemático griego Euclides es más conocido como geómetra. De hecho, el conocimiento de la geometría de los primeros seis libros de sus Elementos se ha considerado una parte esencial de una educación liberal durante más de 2.000 años. Sin embargo, los libros 7 a 10 de sus Elementos contienen mucho de lo que ahora llamaríamos





Euclides



teoría de los números.

La prueba comienza suponiendo la negación:



√2 es racional. Esto significa que hay



(ﬂ. 300 a.E.C.)



existen números enteros myn tales que 2 = m/n. Ahora bien, si m y n tienen factores comunes,









Nota En sentido estricto, poder suponer que m y n no tienen factores comunes es una consecuencia del “principio de buen ordenamiento de los números enteros”, que se analiza en la sección 5.4.



estos pueden factorizarse para obtener una nueva fracción, igual a m/n, en la que el numerador y el denominador no tienen factores comunes. (Por ejemplo, 18/12 (6 3)/(6 2) 3/2, que es una fracción cuyo numerador y denominador no tienen factores comunes.) Por lo tanto, sin pérdida de generalidad, podemos suponer que m y n no tenían factores comunes en primer lugar. Luego derivaremos la contradicción de que m y n tienen un factor común de 2. El argumento hace uso de la Proposición 4.6.4. Si el cuadrado de un número entero es par, entonces ese número entero es par.













Ahora que has visto la prueba de que √2 es irracional, puedes usar la irracionalidad de 2 para derivar la irracionalidad de otros números reales.

Ejemplo 4.7.1 Irracionalidad de 1 + 3√2

Demuestre por contradicción que 1 + 3√2 es irracional.

Solución La esencia del argumento es√la observación de que si 1 + 3√2 pudiera escribirse

como razón de números enteros, entonces también podría ser 2. Pero por el teorema 4.7.1, sabemos que eso es imposible.





■





¿Existen infinitos números primos?

Sabes que un número primo es un entero positivo que no se puede factorizar como producto de dos enteros positivos más pequeños. ¿El conjunto de todos esos números es infinito o existe un número primo mayor? Euclides conocía la respuesta, y en el libro 9 de sus Elementos de geometría aparece una prueba de que el conjunto de todos los números primos es infinito.

La prueba de Euclides requiere un hecho adicional que aún no hemos establecido: si un número primo divide a un número entero, entonces no divide al siguiente entero sucesivo.







La idea de la demostración de Euclides es la siguiente: supongamos que el conjunto de números primos fuera finito. Luego podrías tomar el producto de todos los números primos y sumar uno. Según el teorema 4.3.4, este número debe ser divisible por algún número primo. Pero según la Proposición 4.7.3, este número no es divisible por ninguno de los números primos del conjunto. Por tanto debe haber un número primo que no esté en el conjunto de todos los números primos, lo cual es imposible.

La siguiente prueba formal completa los detalles de este esquema.



Prueba (por contradicción):

Supongamos que no. Es decir, supongamos que el conjunto de números primos es finito. [Debemos deducir una contradicción.] Entonces algún número primo p es el mayor de todos los números primos y, por lo tanto, podemos enumerar los números primos en orden ascendente:

2, 3, 5, 7, 11,. . . , pag.

Sea N el producto de todos los números primos más 1:

norte = (2 · 3 · 5 · 7 · 11··· p) + 1

Entonces N > 1, y así, según el Teorema 4.3.4, N es divisible por algún número primo q. Como q es primo, q debe ser igual a uno de los números primos 2, 3, 5, 7, 11, ..., p.





























































Ben Joseph Green (nacido en 1977)



Terence Chi-Shen Tao (nacido en 1975)



■



La demostración del teorema 4.7.4 muestra que si se forma el producto de todos los números primos hasta cierto punto y se suma uno, el resultado, N, es divisible por un número primo que no está en la lista. La prueba no muestra que N sea, en sí mismo, primo. En los ejercicios al final de esta sección se le pide que encuentre un ejemplo de un número entero N construido de esta manera que no sea primo.



Cuándo utilizar pruebas indirectas

Los ejemplos de esta sección y de la sección 4.6 no han proporcionado una respuesta definitiva a la pregunta de cuándo probar una afirmación directamente y cuándo probarla indirectamente. Muchos teoremas se pueden demostrar de cualquier manera. Sin embargo, cuando ambos tipos de prueba son posibles, la prueba indirecta suele ser más complicada que la prueba directa. En ausencia de pistas obvias que sugieran un argumento indirecto, intente primero probar una afirmación directamente. Luego, si eso no funciona, busque un contraejemplo. Si la búsqueda de un contraejemplo no tiene éxito, busque una prueba por contradicción o contraposición.



Preguntas abiertas en teoría de números

En esta sección demostramos que hay infinitos números primos. No existe una fórmula conocida para obtener números primos, pero se ha descubierto que algunas fórmulas tienen más éxito en producirlos que otras fórmulas. Uno de ellos se debe a Marin Mersenne, un monje francés que vivió entre 1588 y 1648. Los primos de Mersenne tienen la forma 2p 1, donde p es primo. No todos los números de esta forma son primos, pero debido a que es más fácil probar la primalidad de los primos de Mersenne que otros números, la mayoría de los números primos más grandes conocidos son primos de Mersenne.

Una pregunta interesante es si hay infinitos números primos de Mersenne. A la fecha de publicación de este libro, no se conoce la respuesta, pero cada día se hacen nuevos descubrimientos matemáticos y para cuando leas esto, es posible que alguien haya descubierto la respuesta. Otra fórmula que parece producir un número relativamente grande de números primos se debe a Fermat. Los primos de Fermat son números primos de la forma 22n 1,

donde n es un número entero positivo. ¿Hay infinitos números primos de Fermat? Una vez más, hasta el momento nadie lo sabe. De manera similar, se desconoce si hay infinitos números primos de la forma n2 1, donde n es un entero positivo, y si siempre hay un número primo entre los números enteros n2 y (n 1)2.

Otra famosa pregunta abierta que involucra a los primos es la conjetura de los primos gemelos, que establece que hay infinitos pares de números primos de la forma p y p 2. Como ocurre con otros problemas bien conocidos de la teoría de números, esta conjetura ha resistido las pruebas informáticas. hasta números extremadamente grandes, y se han logrado algunos avances hacia una prueba. En 2004, Ben Green y Terence Tao demostraron que para cualquier número entero m > 1, existe una secuencia de m enteros equiespaciados, todos los cuales son primos. En otras palabras, hay números enteros positivos n y k, por lo que los siguientes números son todos primos:

norte, norte + k, norte + 2k, norte + 3k, . . . , norte + (metro - 1)k.

Relacionada con la conjetura de los primos gemelos hay una conjetura hecha por Sophie Germain, una matemática francesa nacida en 1776, que hizo avances significativos hacia la demostración del último teorema de Fermat. Germain conjeturó que hay infinitos números primos.











María Sofía Germain (1776–1831)















Pruébate



pares de la forma p y 2 p 1. Los valores iniciales de p con esta propiedad son 2, 3, 5, 11, 23, 29, 41 y 53, y las pruebas por computadora han verificado la conjetura para muchos valores adicionales. De hecho, al momento de escribir este libro, el primo p más grande para el cual también se sabe que 2 p 1 es primo es 183027 2265440 1. ¡Este es un número con 79911 dígitos decimales! Pero comparado con el infinito, cualquier número, por grande que sea, es menos que una gota en el balde. En 1844, el matemático belga Eugène Catalan conjeturó que la única solución a la ecuación xn ym 1, donde x, y, n y m son todos números enteros mayores que 1, es

32 23 1. Esta conjetura también sigue sin resolverse hasta el día de hoy.

En 1993, mientras intentaba demostrar el último teorema de Fermat, un teórico de números aficionado, Andrew Beal, quedó intrigado por la ecuación xm yn zk, donde no hay dos de x, y o z que tengan un factor común distinto de 1. Cuando se hace un esfuerzo diligente, primero a mano y luego por computadora, no logró revelar ninguna solución, Beal conjeturó que no existen soluciones. Su conjetura se conoce como la conjetura de Beal y ha ofrecido un premio de 100.000 dólares a cualquiera que pueda probarla o refutarla.

Estas son sólo algunas de las muchas preguntas abiertas en la teoría de números. Mucha gente cree que las matemáticas son una materia fija que cambia muy poco de un siglo a otro. De hecho, ahora se están planteando más cuestiones matemáticas y se están descubriendo más resultados que nunca antes en la historia.



Los antiguos griegos descubrieron que en un triángulo rectángulo donde ambos catetos tienen longitud 1, la razón entre la longitud de la hipotenusa y la longitud de uno de los catetos no es igual a una razón de .

Una forma de demostrar que √2 es un número irracional es

supongamos que 2 = a/b para algunos enteros a y b que tienen



que si el cuadrado de un número entero es par entonces , y finalmente demostrar que a y b .

Una forma de demostrar que hay infinitos números primos es suponer que existe un número primo mayor p, construir el número , y luego demostrar que este número tiene que ser divisible por un número primo mayor que



ningún factor común mayor que 1, usa el lema que dice



Serie de ejercicios 4.7

La pantalla de una calculadora muestra que √2 = 1,414213562 y 1,414213562 1414213562. Esto sugiere que √2 es un

1000000000

número racional, lo que contradice el teorema 4.7.1. Explique la discrepancia.

El ejemplo 4.2.1(h) ilustra una técnica para demostrar que cualquier número decimal periódico es racional. La pantalla de una calculadora muestra el resultado de un determinado cálculo como 40,72727272727. ¿Puedes estar seguro de que el resultado del cálculo es un número racional? Explicar.

Determine qué afirmaciones de 3 a 13 son verdaderas y cuáles son falsas. Demostrar las que son verdaderas y refutar las que son falsas.

6 − 7√2 es irracional. 4. 3√2 − 7 es irracional.







  .







La suma de dos números irracionales positivos cualesquiera es irracional.

El producto de dos números irracionales cualesquiera es irracional.

H 13. Si un número entero mayor que 1 es un cuadrado perfecto, entonces su raíz cúbica es irracional.

Considere la siguiente oración: Si x es racional entonces √x es irracional. ¿Es esta frase siempre verdadera, a veces verdadera y a veces falsa, o siempre falsa? Justifica tu respuesta.

a. Demuestre que para todos los números enteros a, si a3 es par, entonces a es par.

b. Demuestre que 3 2 es irracional.

a. Utilice la prueba por contradicción para demostrar que para cualquier número entero n, es imposible que n sea igual a 3q1 + r1 y



5. √4 es irracional. 6. √2/6 es racional.



3q2 + r2, donde q1, q2, r1 y r2, son números enteros, 0 ≤ r1 <

3, 0 ≤ r2 < 3 y r1 /= r2.



La suma de dos números irracionales cualesquiera es irracional.

La diferencia de dos números irracionales cualesquiera es irracional.

La raíz cuadrada positiva de un número irracional positivo es irracional.

Si r es cualquier número racional y s es cualquier número irracional, entonces r/s es irracional.



b. Utilice la prueba por contradicción, el cociente-resto

teorema, división en casos y el resultado del inciso (a) para demostrar que para todos los números enteros n, si n2 es divisible por 3, entonces n es divisible por 3.

C. Demuestre que 3 es irracional.

17. Dé un ejemplo para demostrar que si d no es primo y n2 es divisible por d, entonces n no necesita ser divisible por d.







H 18. El teorema del cociente-resto dice no sólo que existen cocientes y restos sino también que el cociente y el resto de una división son únicos. Demuestre la unicidad. Es decir, demuestre que si a y d son números enteros con d > 0 y si q1, r1, q2 y r2 son números enteros tales que

a = dq1 + r1 donde 0 ≤ r1 < d

y



Para los ejercicios 28 y 29, utilice el hecho de que para todos los números enteros n,

norte!= norte(norte − 1)... 3 · 2 · 1.

Una prueba alternativa de la infinidad del primo nLos números comienzan de la siguiente manera:

Prueba: supongamos que sólo hay un número finito de números primos. Entonces uno es el más grande. Llámalo pág. Sea M = p!+ 1. Nosotros







entonces



a = dq2 + r2



donde 0 ≤ r2



<d,



demostrará que existe un número primo q tal que q > p. Completa esta prueba.

H ✶ 29. Demuestre que para todo número entero n, si n > 2 entonces hay un número primo



q1 = q2 y r1 = r2.

H 19. Demuestre que 5 es irracional.

H 20. Demuestre que para cualquier número entero a, 9 / | (a2-3).

Una prueba alternativa de la irracionalidad de







√2 cuenta el



número p tal que n < p < n!.

H ✶ 30. Demuestre que si p1, p2,... y pn son números primos distintos con p1 = 2 y n > 1, entonces p1 p2 ··· pn + 1 se puede escribir en la forma 4k + 3 para algunos entero k.

H 31. a. El último teorema de Fermat dice que para todo número entero n > 2,



número de 2 en los dos lados de la ecuación 2n2 m2 y utiliza el teorema de factorización única de números enteros para deducir una contradicción. Escribe una prueba que utilice este enfoque.

Utilice la técnica de demostración ilustrada en el ejercicio 21 para demostrar que si n es cualquier número entero que no sea un cuadrado perfecto, entonces n es irracional.

H 23. Demuestra que √2 + √3 es irracional.

✶ 24. Demuestre que log5(2) es irracional. (Sugerencia: utilice el teorema de factorización única de números enteros).

H 25. Sea N 2 3 5 7 1. ¿Qué resto se obtiene cuando

¿N se divide por 2? 3? 5? 7? ¿N es primo? Justifica tu respuesta.

H 26. Supongamos que a es un número entero y p es un número primo tal que

pag | ayp | (un + 3). ¿Qué puedes deducir sobre p? ¿Por qué?

27. Sea p1, p2, p3,... una lista de todos los números primos en orden ascendente. Aquí hay una tabla de los primeros seis:





Ja. Para cada i 1, 2, 3, 4, 5, 6, sea Ni p1 p2 pi 1.

Calcule N1, N2, N3, N4, N5 y N6.

b. Para cada i 1, 2, 3, 4, 5, 6, encuentre el número primo más pequeño qi tal que qi divida a Ni. (Sugerencia: utilice la prueba de primalidad del ejercicio 31 de la Sección 4.6 para determinar sus respuestas).



la ecuación xn yn zn no tiene solución entera positiva (solución para la cual x, y y z son números enteros positivos). Demuestre lo siguiente: Si para todos los números primos p > 2, x p y p z p no tiene una solución entera positiva, entonces para cualquier número entero n > 2 que no sea una potencia de 2, xn yn zn no tiene una solución entera positiva.

b. Fermat demostró que no existen números enteros x, y y z tales que x 4 y4 z4. Utilice este resultado para eliminar la restricción del inciso (a) de que n no sea una potencia de 2. Es decir, demuestre que si n es una potencia de 2 y n > 4, entonces xn yn zn no tiene solución entera positiva.



Para los ejercicios 32 a 35, tenga en cuenta que para demostrar que existe un objeto único con una determinada propiedad, demuestre que (1) hay un objeto con la propiedad y (2) si los objetos A y B tienen la propiedad, entonces A = B.

Demuestre que existe un número primo único de la forma n2 1, donde n es un número entero mayor o igual a 2.

Demuestre que existe un número primo único de la forma

n2 + 2n − 3, donde n es un entero positivo.

Demuestre que existe como máximo un número real a con la propiedad de que a r r para todos los números reales r . (Este número se llama identidad aditiva).

Demuestre que existe como máximo un número real b con la propiedad de que br r para todos los números reales r . (Un número así se llama identidad multiplicativa).









Respuestas para Ponte a prueba

dos números enteros 2. el número entero es par; tienen un factor común mayor que 1 3. 2 · 3 · 5 · 7 · 11 ··· p + 1; pag







Empiece por el principio... y continúe hasta llegar al final: luego deténgase.

— Lewis Carroll, Las aventuras de Alicia en el país de las maravillas, 1865









Señora Lovelace (1815-1852)



En esta sección mostraremos cómo los hechos de la teoría de números desarrollados en este capítulo forman la base de algunos algoritmos informáticos útiles.

La palabra algoritmo se refiere a un método paso a paso para realizar alguna acción. Algunos ejemplos de algoritmos en la vida cotidiana son recetas de preparación de alimentos, instrucciones para ensamblar equipos o kits de pasatiempos, instrucciones de patrones de costura e instrucciones para completar formularios de impuestos sobre la renta. Gran parte de las matemáticas de la escuela primaria se dedica a aprender algoritmos para hacer aritmética, como la suma y resta de varios dígitos, la multiplicación de varios dígitos (o larga) y la división larga.

La idea de un algoritmo informático se atribuye a Ada Augusta, condesa de Lovelace. Formada como matemática, se interesó mucho en el diseño de Charles Babbage de una "máquina analítica", una máquina similar en concepto a una computadora moderna. Lady Lovelace amplió las exploraciones de Babbage sobre cómo funcionaría una máquina así, reconociendo que su importancia residía “en la posibilidad de utilizar una secuencia dada de instrucciones repetidamente, siendo el número de veces preasignado o dependiente de los resultados del cálculo”. Ésta es la esencia de un algoritmo informático moderno.



Un lenguaje algorítmico

El lenguaje algorítmico utilizado en este libro es una especie de pseudocódigo que combina elementos de Pascal, C, Java y VB.NET y un inglés común, pero bastante preciso. Usaremos algunas de las construcciones formales de los lenguajes informáticos, como declaraciones de asignación,bucles, etc., pero ignoraremos los detalles más técnicos, como el requisito de delimitadores explícitos de final de declaración, el rango de valores enteros disponibles en una instalación particular, etc. Los algoritmos presentados en este texto pretenden ser lo suficientemente precisos como para traducirlos fácilmente a prácticamente cualquier lenguaje informático de alto nivel. En los lenguajes informáticos de alto nivel, el término variable se utiliza para referirse a una ubicación de almacenamiento específica en la memoria de una computadora. Decir que la variable x tiene el valor 3 significa que la ubicación de memoria correspondiente a x contiene el número 3. Una ubicación de almacenamiento determinada sólo puede contener un valor a la vez. Entonces, si a una variable se le da un nuevo valor durante la ejecución del programa, entonces el valor anterior se borra. El tipo de datos de una variable indica el conjunto en el que la variable toma sus valores, ya sea el conjunto de números enteros, números reales o

cadenas de caracteres, o el conjunto 0, 1 (para una variable booleana), etc.

Una declaración de asignación da un valor a una variable. Tiene la forma

x := mi,

donde x es una variable y e es una expresión. Esto se lee "a x se le asigna el valor e" o "sea x e". Cuando se ejecuta una declaración de asignación, la expresión e se evalúa (usando los valores actuales de todas las variables en la expresión) y luego su valor se coloca en la ubicación de memoria correspondiente a x (reemplazando cualquier contenido anterior de esta ubicación).

Normalmente, las declaraciones de algoritmo se ejecutan una tras otra en el orden en que están escritas. Las declaraciones condicionales permiten anular este orden natural utilizando los valores actuales de las variables del programa para determinar qué declaración de algoritmo se ejecutará a continuación. Las declaraciones condicionales se denotan

a. si (condición) o b. si (condición) entonces s1

entonces s1

más s2





donde condición es un predicado que involucra variables de algoritmo y donde s1 y s2 son declaraciones de algoritmo o grupos de declaraciones de algoritmo. Generalmente usamos sangría para indicar que las declaraciones pertenecen juntas como una unidad. Sin embargo, cuando es posible la ambigüedad, podemos unir explícitamente un grupo de afirmaciones en una unidad precediendo al grupo con la palabra do y siguiéndolo con la palabra final do.

La ejecución de una declaración if-then-else ocurre de la siguiente manera:

La condición se evalúa sustituyendo los valores actuales de todas las variables del algoritmo que aparecen en ella y evaluando la verdad o falsedad de la declaración resultante.

Si la condición es verdadera, entonces se ejecuta s1 y la ejecución pasa a la siguiente declaración del algoritmo después de la declaración if-then-else.

Si la condición es falsa, entonces se ejecuta s2 y la ejecución pasa a la siguiente declaración del algoritmo después de la declaración if-then-else.

La ejecución de una declaración si-entonces es similar a la ejecución de una declaración si-entonces-de lo contrario, excepto que si la condición es falsa, la ejecución pasa inmediatamente a la siguiente declaración del algoritmo que sigue a la declaración si-entonces.

A menudo, la condición se denomina guardia porque está estacionada antes de s1 y s2 y restringe el acceso a ellos.



Ejemplo 4.8.1 Ejecución de declaraciones if-then-else y if-then

Considere los siguientes segmentos de algoritmo:

a. si x > 2b. y := 0

entonces y := x + 1 si x > 2 entonces y := 2x

de lo contrario haz x := x − 1

y := 3 · x fin hacer

¿Cuál es el valor de y después de la ejecución de estos segmentos para los siguientes valores de x?

i. x = 5ii. x = 2

Solución

(i) Debido a que el valor de x es 5 antes de la ejecución, la condición de protección x > 2 es verdadera en el momento en que se evalúa. Por lo tanto, se ejecuta la siguiente declaración, por lo que el valor de x + 1 = 5 + 1 se calcula y se coloca en la ubicación de almacenamiento correspondiente a y. Entonces después de la ejecución, y = 6.

Debido a que el valor de x es 2 antes de la ejecución, la condición de protección x > 2 es falsa en el momento en que se evalúa. Por lo tanto, se ejecuta la siguiente declaración else. El valor de x − 1 = 2 − 1 se calcula y se coloca en la ubicación de almacenamiento correspondiente a x, y el valor de 3 · x = 3 · 1 se calcula y se coloca en la ubicación de almacenamiento correspondiente a y. Entonces después de la ejecución, y = 3.

(i) Dado que x = 5 inicialmente, la condición x > 2 es verdadera en el momento en que se evalúa. Entonces se ejecuta la siguiente declaración y y obtiene el valor 25 = 32.

Dado que x 2 inicialmente, la condición x > 2 es falsa en el momento en que se evalúa. Por lo tanto, la ejecución pasa a la siguiente declaración después de la declaración si-entonces, y el valor de y no cambia de su valor inicial de 0. ■



Las sentencias iterativas se utilizan cuando una secuencia de sentencias algorítmicas debe ejecutarse una y otra vez. Usaremos dos tipos de declaraciones iterativas: bucles while y bucles for-next.





Un bucle while tiene la forma



mientras (condición)

[declaraciones que componen el cuerpo del bucle]

terminar mientras

donde condición es un predicado que involucra variables de algoritmo. La palabra while marca el comienzo del bucle y las palabras terminan while marcan su final. La ejecución de un bucle while ocurre de la siguiente manera:

La condición se evalúa sustituyendo los valores actuales de todas las variables del algoritmo y evaluando tLa verdad o falsedad de la declaración resultante.

Si la condición es verdadera, todas las declaraciones del cuerpo del bucle se ejecutan en orden. Luego, la ejecución regresa al comienzo del ciclo y el proceso se repite.

Si la condición es falsa, la ejecución pasa a la siguiente declaración del algoritmo después del ciclo.

Se dice que el bucle se itera (IT-a-rate-ed) cada vez que se ejecutan las declaraciones en el cuerpo del bucle. Cada ejecución del cuerpo del bucle se denomina iteración (it-er-AY-shun) del bucle.





Ejemplo 4.8.2 Seguimiento de la ejecución de un bucle while

Rastree la ejecución del siguiente segmento de algoritmo encontrando los valores de todas las variables del algoritmo cada vez que se cambian durante la ejecución:



yo:= 1, s:= 0

mientras (i ≤ 2) s := s + i i := i + 1

terminar mientras



Solución Dado que a i se le da un valor inicial de 1, la condición i 2 es verdadera cuando el tiempo

Se ingresa al bucle. Entonces las declaraciones dentro del bucle se ejecutan en orden:

s = 0 + 1 = 1 y yo = 1 + 1 = 2.

Luego la ejecución regresa al comienzo del ciclo.

La condición i 2 se evalúa utilizando el valor actual de i , que es 2. La condición es verdadera, por lo que las declaraciones dentro del bucle se ejecutan nuevamente:

s = 1 + 2 = 3 y yo = 2 + 1 = 3.

Luego la ejecución regresa al comienzo del ciclo.

La condición i 2 se evalúa utilizando el valor actual de i , que es 3. Esta vez la condición es falsa, por lo que la ejecución pasa más allá del bucle a la siguiente declaración del algoritmo.

Esta discusión se puede resumir en una tabla, llamada tabla de seguimiento, que muestra los valores actuales de las variables del algoritmo en varios puntos durante la ejecución. La tabla de seguimiento de un bucle while generalmente proporciona todos los valores inmediatamente después de cada iteración del bucle. (“Después de la iteración cero” significa lo mismo que “antes de la primera iteración”).





Tabla de seguimiento

Número de iteración 0 1 2

Nombre de la variable

■

La segunda forma de iteración que usaremos es un bucle for-next. Un bucle for-next tiene la siguiente forma:

para variable := expresión inicial a expresión final

[declaraciones que componen el cuerpo del bucle]

siguiente (misma) variable

Un bucle for-next se ejecuta de la siguiente manera:

La variable del bucle for-next se establece igual al valor de la expresión inicial.

Se realiza una verificación para determinar si el valor de la variable es menor o igual al valor de la expresión final.

Si el valor de la variable es menor o igual que el valor de la expresión final, entonces las declaraciones en el cuerpo del bucle se ejecutan en orden, la variable aumenta en 1 y la ejecución regresa al paso 2.

Si el valor de la variable es mayor que el valor de la expresión final, entonces la ejecución pasa a la siguiente declaración del algoritmo que sigue al ciclo.



Ejemplo 4.8.3 Tabla de seguimiento para un bucle for-next

Convierta el bucle for-next que se muestra a continuación en un bucle while. Construya una tabla de seguimiento para el bucle.

para i := 1 a 4

x := yo 2

siguiente yo

Solución El bucle for-next dado es equivalente al siguiente:

yo := 1

mientras (yo ≤ 4)

x := yo 2

yo := yo + 1

terminar mientras

Su tabla de seguimiento es la siguiente:



Tabla de seguimiento

Número de iteración

0 1 2 3 4



Nombre de la variable

■































al-Khowârizmî (ca. 780–850)



Una notación para algoritmos

Expresaremos los algoritmos como subrutinas que pueden ser invocadas por otros algoritmos según sea necesario y utilizadas para transformar un conjunto de variables de entrada con valores dados en un conjunto de variables de salida con valores específicos. Se supone que las variables de salida y sus valores se devuelven al algoritmo de llamada. Por ejemplo, el algoritmo de división especifica un procedimiento para tomar dos números enteros positivos cualesquiera como entrada y producir el cociente y el resto de la división de un número por el otro como salida. Siempre que un algoritmo requiere tal cálculo, el algoritmo puede simplemente "llamar" al algoritmo de división para que haga el trabajo.

Generalmente incluimos la siguiente información al describir formalmente algoritmos:

El nombre del algoritmo, junto con una lista de variables de entrada y salida.

Una breve descripción de cómo funciona el algoritmo.

Los nombres de las variables de entrada, etiquetados por tipo de datos (ya sea entero, número real, etc.).

Las declaraciones que conforman el cuerpo del algoritmo, posiblemente con comentarios explicativos.

Los nombres de las variables de salida, etiquetados por tipo de datos.

Quizás te preguntes de dónde viene la palabra algoritmo. Evolucionó a partir de la última parte del nombre del matemático persa Abu Ja'far Mohammed ibn Mûsâ al-Khowârizmî. Durante la Edad Media de Europa, el mundo árabe disfrutó de un período de intensa actividad intelectual. Una de las grandes obras matemáticas de ese período fue un libro escrito por al-Khowârizmî que contenía ideas fundamentales para la materia de álgebra. La traducción de este libro al latín en el siglo XIII tuvo una profunda influencia en el desarrollo de las matemáticas durante el Renacimiento europeo.



El algoritmo de división

Para un número entero a y un entero positivo d, el teorema del cociente del resto garantiza la existencia de números enteros q y r tales que

a = dq + r y 0 ≤ r < d.q y r para a y d dados donde a no es negativo. (La extensión a a negativo se deja para los ejercicios al final de esta sección.) El siguiente ejemplo ilustra la idea detrás del algoritmo. Considere intentar encontrar el cociente y el resto de la división de 32 entre 9, pero suponga que no recuerda la tabla de multiplicar y tiene que calcular la respuesta a partir de principios básicos. El cociente representa el número de 9 que están contenidos en 32. El resto es el número que queda cuando se restan todos los grupos posibles de 9. Así puedes calcular el cociente y el resto restando repetidamente 9 a 32 hasta obtener un número menor que 9:



32 − 9 = 23 ≥ 9, y

32 − 9 − 9 = 14 ≥ 9, y

32 - 9 - 9 - 9 = 5 < 9.

Esto muestra que se pueden restar 3 grupos de 9 de 32 y sobran 5. Entonces el cociente es 3 y el resto es 5.









Tenga en cuenta que los valores de q y r obtenidos del algoritmo de división son los mismos que los calculados por las funciones div y mod integradas en varios lenguajes informáticos. Es decir, si q y r son el cociente y el resto obtenidos del algoritmo de división con las entradas a y d, entonces las variables de salida q y r satisfacen

q = a div d y r = a mod d.

El siguiente ejemplo solicita un rastro del algoritmo de división.





Ejemplo 4.8.4 Seguimiento del algoritmo de división

Trace la acción del algoritmo 4.8.1 en las variables de entrada a = 19 y d = 4.

Solución Haga una tabla de seguimiento como se muestra a continuación. La columna debajo de la k-ésima iteración proporciona los estados de las variables después de la k-ésima iteración del ciclo.



Número de iteración

0 1 2 3 4





Nombre de la variable



■





El algoritmo euclidiano

El máximo común divisor de dos números enteros a y b es el mayor número entero que divide a a y b. Por ejemplo, el máximo común divisor de 12 y 30 es 6. El algoritmo euclidiano proporciona una forma muy eficaz de calcular el máximo común divisor de dos números enteros.





Ejemplo 4.8.5 Calcular algunos mcd

a. Encuentre mcd(72, 63).

b. Encuentre mcd(1020, 630).

C. En la definición de máximo común divisor, no se permite mcd(0, 0). ¿Por qué no? ¿A qué sería igual mcd(0, 0) si se encontrara de la misma manera que los máximos divisores comunes de otros pares de números?

Solución

72 = 9 · 8 y 63 = 9 · 7. Entonces 9 | 72 y 9 | 63, y ningún número entero mayor que 9 divide a 72 y 63. Por lo tanto, mcd(72, 63) = 9.

b. Por las leyes de los exponentes, 1020 = 220 · 520 y 630 = 230 · 330 = 220 · 210 · 330. Se sigue



220 | 1020 y 220 | 630,

y según el teorema de factorización única de números enteros, ningún número entero mayor que 220 divide a 1020 y 630 (porque no más de veinte 2 dividen 1020, ningún 3 divide 1020 y ningún 5 divide 630). Por tanto, mcd(1020, 630) = 220.

C. Supongamos que mcd(0, 0) se definiera como el mayor factor común que divide 0 y 0. El problema es que todo entero positivo divide a 0 y no existe un entero más grande. ¡Entonces no existe el máximo común divisor! ■



Calcular el mcd usando el método ilustrado en el ejemplo 4.8.5 funciona sólo cuando los números se pueden factorizar por completo. Según el teorema de factorización única de números enteros, todos los números pueden, en principio, factorizarse por completo. Pero, en la práctica, incluso utilizando las computadoras de mayor velocidad, el proceso es inviable para números enteros muy grandes. Hace más de 2.000 años, Euclides ideó un método para encontrar el máximo común divisor que es fácil de usar y mucho más eficiente que factorizar los números o probar repetidamente la divisibilidad de ambos números por enteros sucesivamente mayores.

El algoritmo euclidiano se basa en los dos hechos siguientes, que se exponen como lemas.











La prueba del segundo lema se basa en un ingenioso patrón de argumentación que se utiliza en muchas áreas diferentes de las matemáticas: para demostrar que A = B, demuestre que A ≤ B y que B ≤ A.















El algoritmo euclidiano se puede describir de la siguiente manera:

Sean A y B números enteros con A > B ≥ 0.

Para encontrar el máximo común divisor de A y B, primero verifique si B 0. Si es así, entonces mcd( A, B) A según el Lema 4.8.1. Si no es así, entonces B > 0 y el teorema del cociente-resto se puede utilizar para dividir A entre B y obtener un cociente q y un resto r:























































Nota En sentido estricto, el hecho de que las repeticiones finalmente terminen se justifica por el principio de buen ordenamiento de los números enteros, que se analiza en la sección 5.4.



A = Bq + r donde 0 ≤ r < B.

Según el Lema 4.8.2, mcd( A, B) mcd(B, r). Así, el problema de encontrar el máximo común divisor de A y B se reduce al problema de encontrar el máximo común divisor de B y r.

Lo que hace que esta información sea útil es que B y r son números más pequeños que A y B. Para ver esto, recuerde que asumimos



A > B ≥ 0.

Además, la r encontrada por el teorema del cociente del resto satisface



0 ≤ r < B.

Al juntar estas dos desigualdades se obtiene



0 ≤ r < B < A.

Entonces el número mayor del par (B, r) es menor que el número mayor del par

(A, B).

Ahora simplemente repita el proceso, comenzando de nuevo en (2), pero use B en lugar de A y r en lugar de B. Las repeticiones

En esta sección, damos un algoritmo para calcularSe garantiza que terminarán eventualmente con r 0 porque cada nuevo resto es menor que el anterior y todos son no negativos.

Por cierto, siempre se da el caso de que el número de pasos requeridos en el algoritmo euclidiano es como máximo cinco veces el número de dígitos del entero más pequeño. Así lo demostró el matemático francés Gabriel Lamé (1795-1870).





El siguiente ejemplo ilustra cómo utilizar el algoritmo euclidiano.



Ejemplo 4.8.6 Cálculo manual de mcd utilizando el algoritmo euclidiano

Utilice el algoritmo euclidiano para encontrar mcd(330, 156).

Solución

Divida 330 entre 156:

  2 ← cociente

156 330

312

18 ← resto



Por lo tanto, 330 = 156 · 2 + 18 y por lo tanto mcd(330, 156) = mcd(156, 18) según el Lema 4.8.2.

Divida 156 entre 18:

  8 ← cociente

18 156

144

12 ← resto



Por lo tanto, 156 = 18 · 8 + 12 y por lo tanto mcd(156, 18) = mcd(18, 12) según el Lema 4.8.2.

Divida 18 entre 12:

     1 ← cociente

12 18

12

6 ← resto



Por lo tanto, 18 = 12 · 1 + 6 y por lo tanto mcd(18, 12) = mcd(12, 6) según el Lema 4.8.2.

Dividir 12 entre 6:

     2 ← cociente

6 12

12

0 ← resto



Por lo tanto, 12 = 6 · 2 + 0 y por lo tanto mcd(12, 6) = mcd(6, 0) según el Lema 4.8.2.

Al juntar todas las ecuaciones anteriores se obtiene

mcd(330, 156) = mcd(156, 18)

= mcd(18, 12)

= mcd(12, 6)

= mcd(6, 0)

= 6 según el Lema 4.8.1.

Por lo tanto, mcd(330, 156) = 6. ■

La siguiente es una versión del algoritmo euclidiano escrito utilizando notación de algoritmo formal.











Pruébate

Cuando se ejecuta una declaración algorítmica de la forma x e, .

Considere una declaración de algoritmo de la siguiente forma.

si (condición)

entonces s1

más s2

Cuando se ejecuta tal declaración, se evalúa la verdad o falsedad de la condición. Si la condición es verdadera, . Si la condición es falsa, .

Considere una declaración de algoritmo de la siguiente forma.

mientras (condición)

[declaraciones que componen el cuerpo del bucle]

terminar mientras

Cuando se ejecuta tal declaración, se evalúa la verdad o falsedad de la condición. Si la condición es verdadera, . Si la condición es falsa, .

Considere una declaración de algoritmo de la siguiente forma.

desde la expresión inicial variable hasta la expresión final.

[declaraciones que componen el cuerpo del bucle]

siguiente (misma) variable







Cuando se ejecuta una declaración de este tipo, la variable se establece igual al valor de la expresión inicial y se realiza una verificación para determinar si el valor de la variable es menor o igual al valor de la expresión final. En ese caso, . Si no, .



Dado un entero no negativo a y un entero positivo d, el algoritmo de división calcula.



Dados los números enteros a y b, no ambos cero, mcd(a, b) es el número entero d que satisface las dos condiciones siguientes: y

  .



Si r es un entero positivo, entonces mcd(r, 0) = .

Si a y b son números enteros distintos de cero y si q y r son números enteros no negativos tales que a = bq + r entonces mcd(a, b) =



Dados los enteros positivos A y B con A > B, el algoritmo euclidiano calcula .







Conjunto de ejercicios 4.8

Encuentre el valor de z cuando se ejecuta cada uno de los segmentos del algoritmo en 1 y 2.







Utilice el algoritmo euclidiano para calcular manualmente los máximos divisores comunes de cada uno de los pares de números enteros del 13 al 16.



1. yo := 2

si (i > 3 o i ≤ 0) entonces z := 1 si no z := 0



2. yo := 3

si (i ≤ 3 o i > 6) entonces z := 2 en caso contrario z := 0



13. 1.188 y 385 14. 509 y 1.177

15. 832 y 10.933 16. 4.131 y 2.431

Haga una tabla de seguimiento para rastrear la acción del Algoritmo 4.8.2 para las variables de entrada dadas en 17 y 18.



3. Considere el siguiente segmento de algoritmo:

si x · y > 0 entonces haz y := 3 · x

x := x + 1 fin hacer

z := x · y

Encuentre el valor de z si antes de la ejecución xey tienen los valores que se indican a continuación.

a. x = 2, y = 3 b. x = 1, y = 1

Encuentre los valores de a y e después de la ejecución de los bucles en 4 y 5:



17. 1.001 y 871 18. 5.859 y 1.232

H 19. Demuestre que para todos los enteros positivos a y b, a b si, y sólo si, mcd(a, b) a. (Tenga en cuenta que para demostrar “A si, y sólo si, B”, es necesario demostrar “si A, entonces B” y “si B, entonces A”).

a. Demuestre que si a y b son números enteros, no ambos cero, y d mcd(a, b), entonces a/d y b/d son números enteros sin un divisor común mayor que uno.

Escriba un algoritmo que acepte el numerador y el denominador de una fracción como entrada y produzca como salida el numerador y el denominador de esa fracción escrita.



4. un := 2

para i := 1 a 2

un un 1







5. mi := 0, f := 2

para j := 1 a 4

f := f · j



diez en términos más bajos. (El algoritmo puede recurrir al algoritmo euclidiano según sea necesario).

Complete la demostración del Lema 4.8.2 probando lo siguiente: Si a y b son números enteros con b /= 0 y q y r son



:= 2 + un

siguiente yo



mi := mi + 1

siguiente j



cualquier número entero tal que

a = bq + r.





Haga una tabla de seguimiento para rastrear la acción del Algoritmo 4.8.1 para las variables de entrada dadas en 6 y 7.

6. a = 26 d = 7 7. a = 59 d = 13



entonces mcd(b, r) ≤ mcd(a, b).

H 22. a. Demuestre: Si a y d son números enteros positivos y q y r son números enteros tales que a = dq + r y 0 < r < d, entonces



−a = d(−(q + 1)) + (d − r)



El siguiente segmento de algoritmo realiza cambios; Dada una cantidad de dinero A entre 1c/ y 99c/, determina un desglose de A en veinticinco centavos (q), diez centavos (d), cinco centavos (n) y centavos (p).q := A div 25 A := A mod 25 d := A div 10 A := A mod 10 n := A div 5

p := Un mod 5

Traza este segmento de algoritmo para A = 69.

Traza este segmento de algoritmo para A = 87.

Encuentra el máximo común divisor de cada uno de los pares de números enteros del 9 al 12. (Utilice cualquier método que desee).

9. 27 y 72 10. 5 y 9

11. 7 y 21 12. 48 y 54



y 0 < re - r < re.

b. Indique cómo modificar el algoritmo 4.8.1 para permitir que la entrada a sea negativa.

a. Demuestre que si a, d, q y r son números enteros tales que a =

dq + r y 0 ≤ r < d, entonces

q = a/d] y r = a − a/d]· d.

b. En un lenguaje informático con una función de piso incorporada,

div y mod se pueden calcular de la siguiente manera:

a div d = a/d] y a mod d = a − a/d]· d.

Vuelva a escribir los pasos del algoritmo 4.8.2 para un lenguaje de computadora con una función de piso incorporada pero sin div ni mod.

Una alternativa al algoritmo euclidiano utiliza la resta en lugar de la división para calcular los máximos comunes divisores. (Después de todo, la división es una resta repetida). Se basa en el siguiente lema:

Lema 4.8.3

Si a ≥ b > 0, entonces mcd(a, b) = mcd(b, a − b).





Demuestre el Lema 4.8.3.

Trace la ejecución del Algoritmo 4.8.3 para A = 630 y

B = 336.

Trace la ejecución del Algoritmo 4.8.3 para A = 768 y

B = 348.

Los ejercicios 25 a 29 se refieren a la siguiente definición.

Encontrar

a. mcm(12, 18) b. mcm(22 3 5, 23 32)

C. mcm(2800, 6125)

Demuestre que para todos los enteros positivos a y b, mcd(a, b) =

mcm(a, b) si, y sólo si, a = b.

Demuestre que para todos los números enteros positivos a y b, a | b si, y sólo si, mcm(a, b) = b.

Demuestre que para todos los números enteros a y b, mcd(a, b) | mcm(a, b).

H 29. Demuestre que para todos los números enteros positivos a y b,

mcd(a, b) · mcm(a, b) = ab.















Respuestas para Ponte a prueba

1. se evalúa la expresión e (usando los valores actuales de todas las variables en la expresión), y este valor se coloca en la ubicación de memoria correspondiente a x (reemplazando cualquier contenido anterior de la ubicación) 2. se ejecuta la declaración s1; se ejecuta la sentencia s2

todas las declaraciones en el cuerpo del bucle se ejecutan en orden y luego la ejecución regresa al principio del bucle y el proceso se repite; la ejecución pasa a la siguiente declaración del algoritmo después del ciclo 4. las declaraciones en el cuerpo del ciclo se ejecutan en orden, la variable aumenta en 1 y la ejecución regresa a la parte superior del ciclo; la ejecución pasa a la siguiente declaración del algoritmo siguiendo el ciclo 5. enteros q y r con la propiedad de que n = dq + r y 0 ≤ r < d 6. d divide tanto a como b; si c es un divisor común de a y b, entonces c ≤ d 7. r 8. mcd(b, r) 9. el máximo común divisor de A y B (O: mcd(A,B))





















Una de las tareas más importantes de las matemáticas es descubrir y caracterizar patrones regulares, como los asociados con procesos que se repiten. La principal estructura matemática utilizada en el estudio de procesos repetidos es la secuencia, y la principal herramienta matemática utilizada para verificar conjeturas sobre secuencias es la inducción matemática. En este capítulo presentamos la notación y terminología de secuencias, mostramos cómo usar la inducción matemática ordinaria y fuerte para probar propiedades sobre ellas, ilustramos las diversas formas en que surgen secuencias definidas recursivamente, describimos un método para obtener una fórmula explícita para una secuencia definida recursivamente y explicar cómo verificar la exactitud de dicha fórmula. También analizamos un principio (el principio de buen ordenamiento de los números enteros) que es lógicamente equivalente a las dos formas de inducción matemática y mostramos cómo adaptar la inducción matemática para demostrar la corrección de los algoritmos informáticos. En la sección final analizamos definiciones recursivas más generales, como la utilizada para la formulación cuidadosa del concepto de expresión booleana y la idea de función recursiva.







Un matemático, como un pintor o un poeta, es un creador de patrones.

— G. H. Hardy, La disculpa de un matemático, 1940



Imaginemos que una persona decide contar a sus antepasados. Tiene dos padres, cuatro abuelos, ocho bisabuelos, etc. Estos números se pueden escribir en una fila como

2, 4, 8, 16, 32, 64, 128,...

El símbolo ".. ." se llama elipsis. Es una abreviatura de "y demás".

Para expresar el patrón de los números, supongamos que cada uno está etiquetado por un número entero que indica su posición en la fila.





El número correspondiente a la posición 1 es 2, que equivale a 21. El número correspondiente a la posición 2 es 4, que equivale a 22. Para las posiciones 3, 4, 5, 6 y 7, el correspondiente

227











Nota Estrictamente hablando, el verdadero valor de Ak es menor que 2k cuando k es grande, porque los antepasados de una rama del árbol genealógico también pueden aparecer en otras ramas del árbol.



Los números son 8, 16, 32, 64 y 128, que equivalen a 23, 24, 25, 26 y 27, respectivamente. Para un valor general de k, sea Ak el número de antepasados en la k-ésima generación anterior. El patrón de valores calculados sugiere fuertemente lo siguiente para cada k:

Ak = 2k.











Normalmente representamos una secuencia como un conjunto de elementos escritos en una fila. En estossecuencia denotada

soy, soy+1, soy+2,..., un,

cada elemento individual ak (léase “un sub k”) se denomina término. La k en ak se llama subíndice o índice, m (que puede ser cualquier número entero) es el subíndice del término inicial y n (que debe ser mayor o igual que m) es el subíndice del término final. la notación

soy, soy+1, soy+2,...

denota una secuencia infinita. Una fórmula explícita o fórmula general para una secuencia es una regla que muestra cómo los valores de ak dependen de k.

El siguiente ejemplo muestra que es posible que dos fórmulas diferentes den secuencias con los mismos términos.



Ejemplo 5.1.1 Encontrar términos de secuencias dadas mediante fórmulas explícitas

Defina las secuencias a1, a2, a3,... y b2, b3, b4,... mediante las siguientes fórmulas explícitas:



k ak = k + 1



para todos los números enteros k ≥ 1,



segundo yo - 1

i



para todos los números enteros i ≥ 2.



Calcule los primeros cinco términos de ambas secuencias.



Solución 1 1

un = =





segundo = 2 - 1 = 1







1 + 1 2



2 2 2



2 2

un = =





segundo = 3 - 1 = 2







2 + 1 3



3 3 3



3 3

un = =





segundo = 4 - 1 = 3







3 + 1 4



4 4 4



4 4

un = =





segundo = 5 - 1 = 4







4 + 1 5



5 5 5



5 5

un = =





segundo = 6 - 1 = 5







5 + 1 6



6 6 6



Como puedes ver, los primeros términos de ambas secuencias son 1, 2, 3, 4, 5; de hecho, puede ser

    

2 3 4 5 6

Se muestra que todos los términos de ambas secuencias son idénticos. ■





El siguiente ejemplo muestra que una secuencia infinita puede tener un número finito de valores.





Ejemplo 5.1.2 Una secuencia alterna

Calcule los primeros seis términos de la secuencia c0, c1, c2,... definida de la siguiente manera:

c j = (−1) j para todos los números enteros j ≥ 0.

Solución c0 = (−1)0 = 1

c1 = (−1)1 = −1

c2 = (−1)2 = 1

c3 = (−1)3 = −1

c4 = (−1)4 = 1

c5 = (−1)5 = −1

Así, los primeros seis términos son 1, −1, 1, −1, 1, −1. Según los ejercicios 33 y 34 de la Sección 4.1, las potencias pares de −1 son iguales a 1 y las potencias impares de −1 son iguales a −1. De ello se deduce que la secuencia oscila infinitamente entre 1 y −1. ■



En los ejemplos 5.1.1 y 5.1.2 la tarea consistió en calcular los primeros valores de una secuencia dada por una fórmula explícita. El siguiente ejemplo trata la cuestión de cómo encontrar una fórmula explícita para una secuencia con términos iniciales dados. Cualquier fórmula de este tipo es una suposición, pero es muy útil poder hacer esas conjeturas.





Ejemplo 5.1.3 Encontrar una fórmula explícita que se ajuste a los términos iniciales dados

Encuentre una fórmula explícita para una secuencia que tenga los siguientes términos iniciales:

1, - 1, 1, - 1, 1, - 1,....

Solución Denote el término general de la secuencia por ak y suponga que el primer término es a1. Luego observa que el denominador de cada término es un cuadrado perfecto. Por tanto, los términos se pueden reescribir como

1, (-1), 1, (-1), 1, (-1).





12 22 32

| | |

1 2 3



42 52 62

| | |

4 5 6



Tenga en cuenta que el denominador de cada término es igual al cuadrado del subíndice de ese término y que el numerador es igual a ±1. Por eso

un ±1 .

k

Además el numerador oscila hacia adelante y hacia atrás entre 1 y 1; es 1 cuando k es impar y 1 cuando k es par. Para lograr esta oscilación, inserte un factor de ( 1)k+1 (o ( 1)k−1) en la fórmula para ak . [Porque cuando k es impar, k 1 es par y por tanto ( 1)k+1 1; y cuando k es par, k 1 es impar y por lo tanto ( 1)k+1 1.] En consecuencia, una fórmula explícita que da los primeros seis términos correctos es

(−1)k+1

ak = k2 para todos los números enteros k ≥ 1.











¡Precaución! También es posible que dos secuencias comiencen con los mismos valores iniciales pero luego diverjan. Consulte el ejercicio 5 al final de esta sección.

















José Luis Lagrange (1736–1813)



Tenga en cuenta que convertir el primer término en a0 habría llevado a la fórmula alternativa



(1) k

ak = (k + 1)2 para todos los números enteros k ≥ 0.

Debes comprobar que esta fórmula también proporciona los primeros seis términos correctos. ■





Notación de suma

Consideremos nuevamente el ejemplo en el que Ak 2k representa el número de antepasados que tiene una persona en la késima generación anterior. ¿Cuál es el número total de antepasados de las últimas seis generaciones? La respuesta es



A1 + A2 + A3 + A4 + A5 + A6 = 21 + 22 + 23 + 24 + 25 + 26 = 126.

Es conveniente utilizar una notación abreviada para escribir dichas sumas. En 1772, el matemático francés Joseph Louis Lagrange introdujo la letra griega mayúscula sigma, Σ, para denotar la palabra suma (o sumatoria), y definió la notación de sumatoria de la siguiente manera:













Ejemplo 5.1.4 Calcular sumatorias

Sea a1 = −2, a2 = −1, a3 = 0, a4 = 1 y a5 = 2. Calcule lo siguiente:

5 2 2

Ak b. Alaska c. a2k



k=1

Solución

5



k=2



k=1



a. ak = a1 + a2 + a3 + a4 + a5 = (−2) + (−1) + 0 + 1 + 2 = 0

k=1 2

ak = a2 = −1

k=2 2

C. a2k = a2 · 1 + a2 · 2 = a2 + a4 = −1 + 1 = 0 ■

k=1





A menudo, los términos de una sumatoria se expresan mediante una fórmula explícita. Por ejemplo, es común ver sumas como

5 8 yo



k2 o

k=1



(-1) .

yo = 0 yo + 1





Ejemplo 5.1.5 Cuando los términos de una suma están dados por una fórmula

Calcule la siguiente sumatoria:

5

k2.

k=1

5



Solución



k2 = 12 + 22 + 32 + 42 + 52 = 55. ■

k=1



Cuando el límite superior de una sumatoria es una variable, se utilizan puntos suspensivos para escribir la sumatoria en forma expandida.



Ejemplo 5.1.6 Cambio de notación de suma a forma expandida

Escribe el siguiente resumen.ción en forma expandida:

n yo









n yo 0



(-1) .

yo = 0 yo + 1

1 2 3 norte



Solución



   (-1)



= (−1) + (−1) + (−1) + (−1) + ··· + (−1)



1 (-1) 1







(-1)







(-1)norte







= 1 +



2 + 3 +



4 + ··· + n + 1



1 1 1







(-1)norte







= 1 − 2 + 3 − 4 + ··· + n + 1 ■

Ejemplo 5.1.7 Cambio de forma expandida a notación de suma

Expresa lo siguiente usando notación de suma:

1 2 3 norte + 1

+ + + ··· + .



norte norte + 1 norte + 2 2 norte

Solución El término general de esta sumatoria se puede expresar como k + 1 para números enteros k de



0 al n. Por eso



norte + k

norte



1 + 2 + 3 + ··· + norte + 1 = k + 1 . ■

Para valores pequeños de n, la forma expandida de una suma puede parecer ambigua. Por ejemplo, considere

12 + 22 + 32 + ··· + n2.

Esta expresión pretende representar la suma de cuadrados de números enteros consecutivos que comienzan con 12 y terminan con n2. Por lo tanto, si n = 1 la suma es solo 12, si n = 2 la suma es 12 + 22, y si n = 3 la suma es 12 + 22 + 32.





Ejemplo 5.1.8 Evaluación de a1, a2, a3,..., an para n pequeño



¿Cuál es el valor de la expresión 1?



1 1 1

+ + + ··· +







cuando



norte = 1? norte = 2? norte = 3?

Solución



1 · 2



2 · 3



3 · 4



norte · (norte + 1)



¡Precaución! No escribas que para n = 1, la suma es



Cuando n 1, la expresión es igual a 1 1.

1 2 2

1 1 1 1 2



1 1 1

+ +



1

+· · · + .



Cuando n = 2, es igual a 1 · 2 + 2 · 3 = 2 + 6 = 3.



1 · 2 2 · 3 3 · 4



1 · 2



1 1 1 1 1 1 3



Está tachado porque es incorrecto.



Cuando n = 3, es 1 · 2 + 2 · 3 + 3 · 4 = 2 + 6 + 12 = 4.







Una definición matemáticamente más precisa de sumatoria, llamada definición recursiva,

es el siguiente:∗ Si m es cualquier número entero, entonces

metro norte norte −1

   ak = am y ak = ak + an para todos los números enteros n > m.

Al resolver problemas, suele ser útil reescribir una suma utilizando la forma recursiva

de la definición, ya sea separando el término final de una sumatoria o agregando un término final a una sumatoria.



Ejemplo 5.1.9 Separar un término final y agregar un término final

n+1

Reescribe separando el último término.

yo 2

yo = 1

norte

Escribe 2k + 2n+1 como una suma única.

k=0



Solución

norte+1 norte





norte norte+1



a. 1 = 1 + 1







b. 2k + 2n+1 = 2k ■







En determinadas sumas, cada término es una diferencia de dos cantidades. Cuando escribes estas sumas en forma desarrollada, a veces ves que todos los términos se cancelan excepto el primero y el último. Las sucesivas cancelaciones de plazos colapsan la suma como un telescopio.



Ejemplo 5.1.10 Una suma telescópica

Algunas sumas se pueden transformar en sumas telescópicas, que luego se pueden reescribir como una expresión simple. Por ejemplo, observe que

1 - 1 = (k + 1) - k = 1.





k k + 1



k(k + 1)

norte



k(k + 1)



Utilice esta identidad para encontrar una expresión simple para 1.

k=1 k(k + 1)



∗Otras secuencias definidas recursivamente se analizan más adelante en esta sección y, con mayor detalle, en la Sección 5.6.







Solución

    1



     1



     1









1 2 2 3 3 4

1



norte - 1 norte



norte norte + 1



= 1 - norte + 1 . ■

Notación del producto

La notación del producto de una secuencia de números es análoga a la notación de su suma. La letra mayúscula griega pi, П, denota un producto. Por ejemplo,

5

ak = a1a2a3a4a5.

k=1





Si m y n son números enteros y m ≤ n, el símbolo . ak, lee el producto de k





k m

, es el producto de todos los términos



soy, un



m+1



, soy+2



, ..., un.



escribimos norte

ak = soy · soy+1 · soy+2 ··· an.

k=metro





Una definición recursiva para la notación del producto es la siguiente: Si m es cualquier número entero, entonces



k.=m



ak = soy y



k.=m



ak =



norte-1



k=metro



y



· an para todos los números enteros n > m.





Ejemplo 5.1.11 Productos informáticos

Calcule los siguientes productos:

5 1







Solución





k=1



5



k=1k + 1



1



a. . k = 1 · 2 · 3 · 4 · 5 = 120 segundo. . k = 1 = 1



Propiedades de sumatorias y productos

El siguiente teorema establece propiedades generales de sumas y productos. La demostración del teorema se analiza en la Sección 5.6.









Ejemplo 5.1.12 Uso de propiedades de suma y producto

Sean ak k 1 y bk k 1 para todos los números enteros k. Escribe cada una de las siguientes expresiones como una sola suma o producto:







a.

k=metro



ak + 2 ·







k=metro





bkb.



norte





k=metro



ak & ·



norte





k=metro



bk y



Solución

n n n n

ak + 2 · bk = (k + 1) + 2 · (k − 1) por sustitución



k=metro



k m k m k m

nn



= (k + 1) + 2 · (k − 1) según el teorema 5.1.1 (2)

k m k m

norte

= ((k + 1) + 2 · (k − 1)) por el Teorema 5.1.1 (1)

k=metro

por simplificación algebraica



norte



k=metro



ak & ·



nk=m



bk y



k=metro

norte

=

k=m norte



(k+1)& ·



nk=m



(k-1)&







por sustitución



= (k + 1) · (k − 1) según el teorema 5.1.1 (3)

k=metro

norte

2 por algebraico

simplificación

k=metro





Cambio de variable

Observa eso





y también eso





3

k2 = 12 + 22 + 32

k=1

3

yo 2 = 12 + 22 + 32.

yo = 1





3 3





Por eso



   k2 = yo 2.







Esta ecuación ilustra el hecho de que el símbolo utilizado para representar el índice de una sumatoria puede ser reemplazado por cualquier otro símbolo siempre que el reemplazo se realice en cada lugar donde aparece el símbolo. Como consecuencia, el índice de una sumatoria se denomina variable ficticia. Una variable ficticia es un símbolo que deriva todo su significado de su contexto local. Fuera de ese contexto (tanto antes como después), el símbolo puede tener un significado completamente diferente.

La aparición de un La suma también puede verse alterada mediante cambios de variable más complicados. Por ejemplo, observe que



4

( j − 1)2 = (2 − 1)2 + (3 − 1)2 + (4 − 1)2

j=2

= 12 + 22 + 32

3

=k2.

k=1

En el ejemplo 5.1.13 se ilustra un procedimiento general para transformar la primera suma en la segunda.



Ejemplo 5.1.13 Transformación de una suma mediante un cambio de variable

Transforme la siguiente sumatoria realizando el cambio de variable especificado.





6

suma:

k=0 k + 1



cambio de variable: j = k + 1





Solución Primero calcule los límites inferior y superior de la nueva suma:



Cuando k = 0, j = k + 1 = 0 + 1 = 1.

Cuando k = 6, j = k + 1 = 6 + 1 = 7.

Así, la nueva suma va de j 1 a j 7.

Luego calcule el término general de la nueva sumatoria. Deberá reemplazar cada aparición de k por una expresión en j:



Dado que j = k + 1, entonces k = j − 1.

1 1 1

Por tanto k + 1 = ( j − 1) + 1 = j .

Finalmente, junte los pasos para obtener



6 7



       1 = 1 .





5.1.1









A la ecuación (5.1.1) se le puede dar un giro adicional observando que debido a que j en la sumatoria de la derecha es una variable ficticia, puede ser reemplazada por cualquier otra variable.





nombre, siempre y cuando la sustitución se realice en cada ubicación donde aparece j. En particular, es legal sustituir k en lugar de j para obtener

7 7

   1 = 1 . 5.1.2

Al juntar las ecuaciones (5.1.1) y (5.1.2) se obtiene



6 7

       1 = 1 .



A veces es necesario desplazar los límites de una sumatoria para sumarla a otra. Un ejemplo es la demostración algebraica del teorema del binomio, que se presenta en la sección 9.7. En el siguiente ejemplo se ilustra un procedimiento general para realizar dicho cambio cuando el límite superior es parte del sumando.



Ejemplo 5.1.14 Cuando aparece el límite superior en la expresión que se va a sumar

Transforme la siguiente sumatoria realizando el cambio de variable especificado.



  norte+1k

Transforme la sumatoria obtenida en el inciso (a) cambiando todas las j por k.

Solución

Cuando k 1, entonces j k 1 1 1 0. (Entonces el nuevo límite inferior es 0.) Cuando

k n 1, luego j k 1 (n 1) 1 n. (Entonces el nuevo límite superior es n.)

Dado que j k 1, entonces k j 1. Tenga en cuenta también que n es una constante en lo que respecta a los términos de la suma. Resulta que



k





norte + k



j+1





norte + (j + 1)



y entonces el término general de la nueva sumatoria es



  j + 1 .

norte + (j + 1)



Por lo tanto,





norte+1 norte



       k = j + 1 . 5.1.3

Cambiando todas las j por k en el lado derecho de la ecuación (5.1.3) se obtiene

nn



    j + 1 = k + 1



5.1.4



La combinación de las ecuaciones (5.1.3) y (5.1.4) da como resultado

norte+1 norte

       k = k + 1 .





Notación factorial y “n Elija r”

El producto de todos los números enteros consecutivos hasta un número entero dado ocurre con tanta frecuencia en matemáticas que se le asigna una notación especial: notación factorial.





La definición de factorial cero como 1 puede parecer extraña, pero, como verá cuando lea el capítulo 9, es conveniente para muchas fórmulas matemáticas.



Ejemplo 5.1.15 Los primeros diez factoriales

0!= 1 1!= 1

2!= 2 · 1 = 2 3!= 3 · 2 · 1 = 6

4!= 4 · 3 · 2 · 1 = 24 5!= 5 · 4 · 3 · 2 · 1 = 120

6!= 6 · 5 · 4 · 3 · 2 · 1 = 720 7!= 7 · 6 · 5 · 4 · 3 · 2 · 1 = 5,040

8!= 8 · 7 · 6 · 5 · 4 · 3 · 2 · 1 9!= 9 · 8 · 7 · 6 · 5 · 4 · 3 · 2 · 1

= 40.320 = 362.880 ■

Como puede ver en el ejemplo anterior, los valores de n! crecer muy rápidamente. Por ejemplo, 40 ∼ 8,16 1047, que es un número demasiado grande para calcularlo exactamente utilizando la aritmética entera estándar de las implementaciones específicas de máquina de muchos lenguajes informáticos. (El símbolo ∼ significa “es aproximadamente igual a”).

Una definición recursiva de factorial es la siguiente: Dado cualquier entero no negativo n,





¡Precaución! Tenga en cuenta que n (n 1)! debe interpretarse como

norte·[(norte − 1)!].



norte 1 si norte = 0

norte · (norte − 1)! si norte ≥ 1.

El siguiente ejemplo ilustra la utilidad de la definición recursiva para realizar cálculos.





Ejemplo 5.1.16 Cálculo con factoriales

Simplifica las siguientes expresiones:



a. 8! 7!

Solución



b. 5!

2!· 3!



1

2!· 4!



1

+ 3! · 3!



d. (n+1)!

¡norte!



mi. ¡norte!

(norte - 3)!



a. 8! = 8·7! = 8



7! 7!

b. 5! = 5 · 4 · 3! = 5 · 4 = 10



2!· 3! 2!· 3! 2 · 1







C. 1 + 1 = 1 3







1 4 multiplicando cada numerador y

·



 



2!· 4!



3!· 3!



2!· 4! · 3 + 3! · 3! 4



denominador por justo lo necesario para

obtener un denominador común



3 4

= 3 · 2! · 4! + 3! · 4 · 3! reordenando factores

3 4

= 3! · 4! + 3! · 4! porque 3·2!= 3! y 4·3!= 4!







d. (n+1)!

¡norte!



7

= 3! · 4!

7

= 144

= norte + 1



por la regla para sumar fracciones con un denominador común



mi. ¡norte! = norte · (norte − 1) · (norte − 2) · (norte − 3)! = norte · (norte - 1) · (norte - 2)



(norte - 3)!



(norte - 3)!

= n3 − 3n2 + 2n ■





Un uso importante de la notación factorial es el cálculo de valores de cantidades, llamadas n elige r, que ocurren en muchas ramas de las matemáticas, especialmente aquellas relacionadas con el estudio de las técnicas de conteo y la probabilidad.





Observe que la definición implica que n siempre será un número entero porque es un número de subconjuntos. En la Sección 9.5 exploraremos muchos usos de n elija r para resolver problemas que involucran conteo y probaremos la siguiente fórmula computacional:



Mientras tanto , le brindaremos algunas experiencias sobre su uso. Debido a que n elige r es siempre un número entero, puedes estar seguro de que todos los factores en el denominador de la fórmula serán cancelados por los factores en el numerador. Muchas calculadoras electrónicas tienen teclas para



A veces se les llama coeficientes binomiales debido a la conexión con

el teorema del binomio analizado en la sección 9.7.



Ejemplo 5.1.17 Calcular n a mano

Utilice la fórmula para calcular n para evaluar las siguientes expresiones:

a. 8b. 4c. norte + 1

Solución





5 5!(8 − 5)!

     8 · 7 · 6 · 5 · 4 · 3 · 2 · 1

(5 · 4 · 3 · 2 · 1) · ( · 3 · 2 · 1)

= 56.





Siempre cancela los factores comunes antes de multiplicar.



b. 4 = 4! = 4!



= 4 · 3 · 2 · 1 = 1







4 4!(4 − 4)! 4!0! (4 · 3 · 2 · 1)(1)

El hecho de que 0 1 hace que esta fórmula sea computable. Da el valor correcto porque un conjunto de tamaño 4 tiene exactamente un subconjunto de tamaño 4, es decir, él mismo.

n n!((n + 1) − n)! n!1! ¡norte!



Secuencias en programación informática

Un tipo de datos importante en la programación de computadoras consiste en secuencias finitas. En contextos de programación de computadoras, estos generalmente se denominan matrices unidimensionales. Por ejemplo, considere un programa que analiza los salarios pagados a una muestra de 50 trabajadores. Un programa de este tipo podría calcular el salario promedio y la diferencia entre cada salario individual y el promedio. Esto requeriría que cada salario se almacene en la memoria para recuperarlo más adelante en el cálculo. Para evitar el uso de nombres de variables completamente separados para los 50 salarios, cada uno se escribe como un término de una matriz unidimensional:

W[1], W[2], W[3],..., W[50].

Tenga en cuenta que las etiquetas de los subíndices están escritas entre corchetes. La razón es que hasta hace relativamente poco tiempo, era imposible escribir subíndices eliminados en la mayoría de los teclados de computadora.

La principal dificultad que tienen los programadores cuando utilizan matrices unidimensionales es mantener las etiquetas rectas.



Ejemplo 5.1.18 Variable ficticia en un bucle

La variable de índice para un bucle for-next es una variable ficticia. Por ejemplo, los siguientes tres segmentos de algoritmo producen el mismo resultado:

para i := 1 an 2. para j := 0 an − 1 3. para k := 2 an + 1

imprimir un[i] imprimir un[j + 1] imprimir un[k − 1]

siguiente i siguiente j siguiente k ■

Las definiciones recursivas de suma, producto y factorial conducen naturalmente a algoritmos computacionales. Por ejemplo, aquí hay dos conjuntos de pseudocódigo para encontrar la suma de a[1], a[2],..., a[n]. El de la izquierda imita exactamente la definición recursiva de





inicializando la suma para que sea igual a a[1]; el de la derecha inicializa la suma para que sea igual a 0. En

En ambos casos la salida es .n a[k].

s := a[1] s := 0

para k := 2 an para k : = 1 an

s := s + a[k] s := s + a[k]

siguiente k siguiente k







Aplicación: Algoritmo para convertir de base 10 a base 2 mediante división repetida por 2

La sección 2.5 contiene algunos ejemplos de conversión de números enteros de notación decimal a binaria. Sin embargo, el método mostrado allí sólo es conveniente para números pequeños. Un algoritmo sistemático para convertir cualquier número entero no negativo a notación binaria utiliza la división repetida por 2.

Supongamos que a es un número entero no negativo. Divide a por 2 usando el teorema del cociente del resto para obtener un cociente q 0 y un resto r 0. Si el cociente es distinto de cero, divida por 2 nuevamente para obtener un cociente q 1 y un resto r 1. Continúe este proceso hasta obtener un cociente de 0. En cada etapa, el resto debe ser menor que el divisor, que es 2. Por lo tanto, cada resto es 0 o 1. El proceso se ilustra a continuación para un 38. (Lea las divisiones de abajo hacia arriba).

resto = 1 = r [5] resto = 0 = r [4] resto = 0 = r [3] resto = 1 = r [2] resto = 1 = r [1] resto = 0 = r [0]

2



Los resultados de todas estas divisiones se pueden escribir como una secuencia de ecuaciones:

38 = 19 · 2 + 0,

19 = 9 · 2 + 1,

9 = 4 · 2 + 1,

4 = 2 · 2 + 0,

2 = 1 · 2 + 0,

1 = 0 · 2 + 1.

Entonces, mediante sustitución repetida,

38 = 19 · 2 + 0

= (9 · 2 + 1) · 2 + 0 = 9 · 22 + 1 · 2 + 0

= (4 · 2 + 1) · 22 + 1 · 2 + 0 = 4 · 23 + 1 · 22 + 1 · 2 + 0

= (2 · 2 + 0) · 23 + 1 · 22 + 1 · 2 + 0

= 2 · 24 + 0 · 23 + 1 · 22 + 1 · 2 + 0

= (1 · 2 + 0) · 24 + 0 · 23 + 1 · 22 + 1 · 2 + 0

= 1 · 25 + 0 · 24 + 0 · 23 + 1 · 22 + 1 · 2 + 0.





Tenga en cuenta que cada coeficiente de una potencia de 2 en el lado derecho de la página anterior es uno de los restos obtenidos en la división repetida de 38 entre 2. Esto también es cierto para el 1 más a la izquierda, porque 1 = 0 · 2 + 1. Así

3810 = 1001102 = (r[5]r[4]r[3]r[2]r[1]r[0])2.

En general, si un entero no negativo a se divide repetidamente por 2 hasta obtener un cociente de cero y se encuentra que los restos son r [0], r [1],..., r [k], entonces por el cociente - teorema del resto cada r [i ] es igual a 0 o 1, y mediante sustitución repetida del teorema,

a = 2k ·r [k]+ 2k−1·r [k − 1] + ··· + 22·r [2]+ 21·r [1]+ 20·r [0]. 5.1.5

Así, la representación binaria de a se puede leer en la ecuación (5.1.5):

a10 = (r [k]r [k − 1] r [2]r [1]r [0])2.





Ejemplo 5.1.19 Conversión de notación decimal a binaria usando división repetida por 2

Usar División repetida por 2 para escribir el número 2910 en notación binaria.

Solución



resto = r [4] = 1 resto = r [3] = 1 resto = r [2] = 1 resto = r [1] = 0 resto = r [0] = 1

2



Por lo tanto, 2910 = (r [4]r [3]r [2]r [1]r [0])2 = 111012. ■



El procedimiento que hemos descrito para la conversión de base 10 a base 2 se formaliza en el siguiente algoritmo:





[En el Algoritmo 5.1.1 la entrada es un número entero no negativo n. El objetivo del algoritmo es producir una secuencia de dígitos binarios r 0 , r 1 , r 2 ,..., r k de modo que la representación binaria de a sea







Eso es,



(r [k]r [k − 1]··· r [2]r [1]r [0])2.



n = 2k ·r [k]+ 2k−1·r [k − 1] + ··· + 22·r [2]+ 21·r [1]+ 20·r [0].]

continúa en la página 242







Pruébate

Las respuestas a las preguntas de Pruébese usted mismo se encuentran al final de cada sección.

norte



1. La notación ak se lee “ .”



5. Si n es un entero positivo, entonces n!= .







k=metro

norte



6. ak + c bk = .



La forma expandida de a es.



k=metro



k=metro



  k

k=metro



norte

7. un



&%.norte



b & = .



El valor de a1 + a2 + a3 + ··· + an cuando n = 2 k k



es "	."

norte



k=metro
F | | 

para la ciencia 

y la tecnología 



























Tipler | Mosca 





64 edición 

















Volumen 2 

Electricidad y magnetismo/Lu: 



































*Otros datos sobre el sistema solar se pueden encontrar en el Apéndice B y en 





http://nssde.gsfc.nasa.gov/ planetary/ planetfact.html. 





*De centro a centro. 





Prefijos de potencias de 10* El alfabeto griego 

Múltiplo Prefijo Abreviatura Alfa A e Ny N >» 

Beta B Xi Z 

E oa pS Gamma . T , Ómicron O > 

102 zetta Z 

apa pro E Delta A 38 Pi n o” 

1015 pela P Épsilon E ee Rho Pp 

102 tra T Zeta z A Sigma o 0 

107 giga G Eta H 7 Tau Tom 

10% mega M Theta o. 0 Ípsilon Y 

10 kilo k ota bo Phi vos 

10 hecto h Kappa Ko k Ji Xx ox 

A! pea A Lambda A A Psi voy 

101 deci d 

10? cent ó My Mo op Omega Q w 

103 mili m 

1076 micro m 

10 nano n 

10" pico Pp 

a ña E Símbolos matemáticos 

10 atto a 

a beciid hi = es igual a 

10 yocto y 4 

= es equivalente a 

*Los prefijos más habituales están en azul. + no es igual a 

” es aproximadamente igual a 

- es del orden de 

Datos terrestres y datos astronómicos” a es proporelonalla 

Aceleración de la gravedad g  98lm/s*=322ft/8 E RATA 

en la superficie de la Tierra _ es mayor o igual que 

Radio de la Tierra Ry 6371 km = 3959 mi > es mucho mayor que 

Masa de la Tierra M; 5,97 X 10% kg < es menor que 

Masa del Sol 1,99 x 10% kg < es menor o igual que 

Masa de la Luna 7,35 X 10” kg << es mucho menor que 

Velocidad de escape 11,2 km/s = 6,95 mi/s Ax variación o incremento de x 

REP Aena dx variación diferencial en x 

Temperatura y presión 0*C = 273,15 K ; 

normales (C.N.) 1 atm = 101,3 kPa ho vibe nes 

Distancia Tierra-Luna* 3,84 x 10% m =2,39 X 105 mi [o valor absclio da 

Distancia Tierra-Sol (media)' 1,50 % 10% m = 9,30 X 107 mi al an 1Xn—2)...1 

Velocidad del sonido en aire seco (a CN.) 331 m/s z ic 

Velocidad del sonido en aire seco 343 m/s lim límite 

(20 *C, 1 atm) AL=0 At tiende a cero 

Densidad del aire (C.N.) 1,29 kg/m* dx derivada de x 

Densidad de aire seco (20 “C, 1 atm) 1,20 kg/m* de respecto a | 

Densidad del agua (4*C, 1 atm) 1000 kg/m? dx derivada parcial de x 

Calor de fusión del H,O (0*C, 1 atm) — L,  333,5kJ/kg 7 respecto a É 

Calor de vaporización del H,O L, 2,257 MJ/kg . 

(100:%C, 1 áten) [ feddx integral definida 





" Pla) Fx) 





* 











MN. A 











Abreviaturas de unidades 





A ampére 

Á ángstrom (1071 m) 

atm atmósfera 

Btu unidad térmica inglesa 

Ba becquerel 

Ss coulomb 

al grados centígrados 

cal caloría 

Ci curie 

cm centímetro 

dyn dina 

ev electronvolt 

>F grados Fahrenheit 

fm femtometro, fermi (101% m) 

ñ pie 

Gm gigametro (10% m) 

E gauss 

cy Bray 

8 gramo 

Factores de conversión 

Longitud 





1 m = 39,37 in = 3,281 ft = 1,094 yd 

1 m = 10% fm = 101 Á = 10% nm 



1 km = 0,6214 mi 



1 mi = 5280 ft = 1,609 km 



l año-luz= 1c+a = 9,461 x 105 m 

1 in = 2,540 cm 





Volumen 

1L=10* cm? 











1073 m3 = 1,057 qt 





Tiempo 

1h = 3600 s = 3,6 ks 

La = 365,24 d = 3,156 x 107 s 





Velocidad 

1 km/h = 0,278 m/s = 0,6214 mi/h 

1 ft/s = 0,3048 m/s = 0,6818 mi/h 





Ángulo y velocidad angular 

1 rev = 21r rad = 360% 



1 rad = 57,30% 



1 rev/min = 0,1047 rad/s 





henry nm nanómetro (107? m) 

hora pt pinta 



hertz qt quart 



pulgada rev revolución 



joule R roentgen 



kelvin Sv sievert 



kilogramo s segundo 



kilómetro T tesla 

kilo-electronvolt u unidad de masa unificada 

libra v volt 



litro w watt 



metro Wb weber 

mega-electronvolt y año 



'megametro (10% m) yd yarda 



milla pm micrometro (107% m) 

minuto us microsegundo 

milímetro pe microcoulomb 

milisegundo 2 ohm 



newton 





Fuerza-presión 

1N = 105 dina = 0,2248 lb 

1 1b = 4,448 N 





1 atm = 101,3 kPa = 1,013 bar = 76,00 cmHg = 14,70 lb/in? 





Masa 



1 u = [(10-? mol”)/N,] kg = 1,661 X 107 kg 

1 tonelada = 10? kg = 1 Mg 



1 slug = 14,59 kg 



1 kg = 2,205 lb 





Energía-Potencia 



1] = 107 erg = 0,7376 ft- lb = 9,869 X 10 atm - L 

1kW-h=3,6 MJ 



1 cal = 4,184] = 4,129 X 10? atm - L 



1 atm - L= 101,325 J = 24,22 cal 



1eV = 1,602 x 101] 



1 Btu = 778 ft- lb = 252 cal = 1054] 



1 caballo de vapor = 550 ft -1b/s = 746 W 











Conductividad térmica 

1 W/(m-K) = 6,938 Btu «in/(h + fé +*F) 





Campo magnético 

1T=10'G 





Viscosidad 

1 Pa+s =10 poise 

















06 

SEXTA EDICIÓN 





FÍSICA PARA 

LA CIENCIA : 

Y LA TECNOLOGÍA 

















VOLUMEN 2 

Electricidad y magnetismo/Luz 

















» 











SEXTA EDICIÓN 





FÍSICA PARA 

LA CIENCIA o 

Y LA TECNOLOGÍA 





VOLUMIEN 2 

Electricidad y magnetismo/Luz 





Paul A. Tipler 

Gene Mosca 





(ER) 

EDITORIAL 





REVERTÉ 





Barcelona «e Bogotá * Buenos Aires e Caracas e México 























Registro bibliográfico (ISBD) 





Tipler, Paul A. 



[Physics for scientists and engineers. Español] 



Física para la ciencia y la tecnología. Electricidad y magnetismo, luz / Paul A. Típler, Gene Mosca ; coordinador y traductor: José 

Casas-Vázquez; traductores: Albert Bramon Planas... [et al.]. — Barcelona ; Reverté, 2010. 



XXI! P. 693-1172, [9] p.:il. col. ;27cm. 



Índice. 



DL. B-25923-2010. — ISBN 978-84-291-4430-7 





1. Física, |. Mosca. Gene, coaut. II. Casas-Vázquez, José, coord., trad. 111, Bramon Planas, Albert, trad. IV. Título. 

53 























Título de la obra original: 

Physics for Scientists and Engineers, Sixth Edition. 

Edición original en lengua inglesa publicada por 





W. H, FREEMAN AND COMPANY, New York and Basingstoke 

41 Madison Avenue, New York (NY) - U.S.A. 





Copyright O 2008 by W. H. Freeman and Company. All Rights Reserved 





Edición en español: 

O Editorial Reverté, S. A., 2010 





178-84-291-4430-7 — Volumen 2 

: 978-84-291-4428-4 Obra completa 











Versión española: 





COORDINADOR Y TRADUCTOR 





Dr, José Casas-Vázquez 

Catedrático de Física de la 











ria Condensada 

TRADUCTORES 





Dr. Albert Bramon Planas 

Catedrático de Física Teórica 











Enric Llebot Rabagliati 

¡co de Física de la Materia Condensada 





Dr, Fernando M. López Aguilar 

Catedrático de Física Apli 











Dr. Viceng Méndez López 

Profesor Agregado de Física de la Materia Condensada 





Departamento de Física PONTIFICIA UNIVERSIDAD JAVERIANA 





Universidad Autónoma de Barcelona BIBLIOTECA GENERAL 

España ADQUISICIONES 

Xx 

MAQUETACIÓN: REVERTÉ-AGUILAR compralX ] enel] nowcioni_] 

CORRECCIÓN DE ESTILO: CARLOS CISTUÉ SOLÁ ECHA. 











PROCEDENCIA. Ecliton1a! 

SOLICITADO POR: Fisica________ 





Propiedad de: 381 2] 





EDITORIAL REVERTÉ, S. A. 

Loreto, 13-15. Local B 



Tel: (34) 93 419 33 36 wWww.reverte.com 

Fax: (34) 93 419 51 89 



08029 Barcelona. ESPAÑA 



reverteOreverte.com 











Reservados todos los derechos. La reproducción total o parcial de esta obra, por cualquier medio o procedimiento, comprendidos la reprogra- 

fía y el tratamiento informático, y la distribución de ejemplares de ella mediante alquiler o préstamo públicos, queda rigurosamente prohibida 

sin la autorización escrita de los titulares del copyright, bajo las sanciones establecidas por las leyes. 





Impreso en España - Printed ín Spain 











PT: Para Claudia 

GM: Para Vivian 

















| . VOLUMEN 1 





Volumen 1A 











PARTE | 





MECÁNICA 











000 o0IA ON 





o 





11 

12 

13 





Medida y vectores / 1 



El movimiento en una dimensión / 27 

Movimiento en dos y tres dimensiones / 63 

Leyes de Newton / 93 



Aplicaciones adicionales de las leyes de Newton / 127 

Trabajo y energía cinética / 173 

Conservación de la energía / 201 

Conservación del momento lineal / 247 

Rotación / 289 



Momento angular / 331 



Gravedad / 363 



Equilibrio estático y elasticidad / 397 

Fluidos / 423 





Volumen 1B 











PARTE Il 





OSCILACIONES Y ONDAS 











14 

15 

16 





Oscilaciones / 457 

Movimiento ondulatorio / 495 

Superposición y ondas estacionarias / 533 





Volumen 1C 











PARTE lll TERMODINÁMICA 











17 

18 

19 

20 



R 





Temperatura y teoría cinética de los gases / 563 

Calor y primer principio de la termodinámica / 591 

Segundo principio de la termodinámica / 629 

Propiedades y procesos térmicos / 665 

Relatividad especial / R.1 





Índice abreviado de la obra completa 





Thinkstock/Alamy 

















vii 

















viii | Índice abreviado de la obra completa 





VOLUMEN 2 





Volumen 2A 











PARTE IV ELECTRICIDAD Y MAGNETISMO 











21 Campo eléctrico l: distribuciones discretas de carga / 693 

22 Campo eléctrico Il: distribuciones continuas de carga / 727 

23 Potencial eléctrico / 763 



24 Capacidad / 801 



25 Corriente eléctrica y circuitos de corriente continua / 839 



26 El campo magnético / 887 



27 Fuentes del campo magnético / 917 



28 Inducción magnética / 959 



29 Circuitos de corriente alterna / 995 



30 Ecuaciones de Maxwell y ondas electromagnéticas / 1029 





Volumen 2B 











PARTE V LUZ 

















3 Propiedades de la luz / 1055 

32 Imágenes ópticas / 1097 

33 Interferencia y difracción / 1141 





FÍSICA MODERNA 

R Relatividad especial / R.1 











PARTE VI MECÁNICA CUÁNTICA, RELATIVIDAD Y 

ESTRUCTURA DE LA MATERIA 











34 Dualidad onda-partícula y física cuántica / 1173 



35 Aplicaciones de la ecuación de Schródinger / 1203 



36 Átomos / 1227 



37 Moléculas / 1261 



38 Sólidos / 1281 



39 Relatividad / 1319 



40 Física nuclear / 1357 



41 Las partículas elementales y el origen del universo / 1389 





APÉNDICES Y RESPUESTAS 





Apéndice A Unidades SI y factores de conversión / AP.1 

Apéndice B_ Datos numéricos / AP.3 



Apéndice C Tabla periódica de los elementos / AP.6 



Apéndice de matemáticas / M.1 



Respuestas de los problemas impares del final de los capítulos / A.1 





x>_— _—_ A 





Índice analítico 





Volumen 2 





A —_—_—_—_—_— __—_———— 





Prefacio 

Acerca de los autores 





* Materias opcionales 











PARTE IV ELECTRICIDAD Y 

MAGNETISMO 











Capítulo 21 





CAMPO ELÉCTRICO l: DISTRIBUCIONES 





DISCRETAS DE CARGA / 693 





21.1 Carga eléctrica 

21.2 Conductores y aislantes 





Temperatura (*C) 

o 50 





NASA/Goddard Space Flight Center Scientific Visualization Studio 





694 

697 

















21.3 Ley de Coulomb 

21.4 El campo eléctrico 

21.5 Líneas de campo eléctrico 





7n 





21.6 Acción del campo eléctrico sobre las cargas 714 











Temas de actualidad en Física: 











Recubrimiento industrial con polvo 

electrostático / 719 



Resumen 



Problemas 





Capítulo 22 

CAMPO ELÉCTRICO Il: 

DISTRIBUCIONES CONTINUAS 

DE CARGA / 727 





22.1 Cálculo del campo eléctrico E mediante 

la ley de Coulomb 





22.2 Ley de Gauss 





22.3 Cálculo del campo eléctrico E con la ley de 





Gauss utilizando la simetría 

22.4  Discontinuidad de E, 





22.5 Carga y campo en la superficie de 

los conductores 





*22.6 Equivalencia de la ley de Gauss y 

la ley de Coulomb en Electrostática 





Temas de actualidad en Física: 











728 

738 





742 

749 





750 





753 





Distribución de carga—caliente y frío / 754 





Resumen 

Problemas 





755 

















x Índice analítico 











Capítulo 23 

POTENCIAL ELÉCTRICO / 763 





23.1 Diferencia de potencial 





23.2 Potencial debido a un sistema de 

cargas puntuales 





23.3 Determinación del campo eléctrico 

a partir del potencial 





23.4 Cálculo de V para distribuciones 

continuas de carga 





23.5 Superficies equipotenciales 

23.6 Energía potencial electrostática 





Temas de actualidad en Física: 











764 





767 





772 





773 

781 

787 





Relámpagos—Campos de atracción / 791 





Resumen 

Problemas 





Capítulo 24 

CAPACIDAD / 801 





24.1 Capacidad 



24.2 Almacenamiento de la energía eléctrica 

24.3  Condensadores, baterias y circuitos 

24.4  Dieléctricos 



24.5 Estructura molecular de un dieléctrico 





Temas de actualidad en Física: 











Cambios en Condensadores— 

Carga directa / 828 





Resumen 

Problemas 





Capítulo 25 





CORRIENTE ELÉCTRICA Y CIRCUITOS 





DE CORRIENTE CONTINUA / 839 





25.1 Corriente y movimiento de cargas 

25.2 Resistencia y ley de Ohm 



25,3 La energía en los circuitos eléctricos 

25.4 Asociaciones de resistencias 



25.5 Reglas de Kirchhoff 



25.6 Circuitos RC 





Temas de actualidad en Física: 





792 

794 





802 

806 

810 

817 

824 





829 

831 





840 

844 

849 

854 

860 

868 





Sistemas eléctricos de los automóviles: 





innovación en la conducción / 874 





Resumen 

Problemas 





875 

877 











Capítulo 26 

EL CAMPO MAGNÉTICO / 887 





26.1 Fuerza ejercida por un campo magnético 





26.2 Movimiento de una carga puntual en 

un campo magnético 





26.3 Momentos de fuerza sobre espiras 

de corriente e imanes 





26.4 Efecto Hall 





Temas de actualidad en Físi 

















Cambios en los magnetismos 

de la Tierra y el Sol / 908 

Resumen 



Problemas 





Capítulo o 27 





FUENTES DEL CAMPO 

MAGNÉTICO / 917 





27.1 Campo magnético creado por cargas 

puntuales en movimiento 





27,2 Campo magnético creado por corrientes 

eléctricas: ley de Biot y Savart 



27.3 Ley de Gauss para el magnetismo 



27.4 Ley de Ampére 



27.5 El magnetismo en la materia 

Temas de actualidad en Física: 

Aplicaciones del solenoide / 947 

Resumen 

Problemas 





Capítulo 28 

INDUCCIÓN MAGNÉTICA / 959 





28.1 Flujo magnético 

28.2 Fem inducida y ley de Faraday 

28.3 Ley de Lenz 

28.4 Fem de movimiento 

28.5 Corrientes de Foucault o turbillonarias 

28.6  Inductancia 

28.7 Energía magnética 

*28.8 Circuitos RL 

*28.9 Propiedades magnéticas de 

los superconductores 





Temas de actualidad en Física: 





888 





892 





900 

904 





909 

910 





918 





919 

932 

933 

937 





948 

950 





960 

961. 

965 

969 

974 

974 

977 

979 





983 





La promesa de los superconductores / 985 





Resumen 

Problemas 





986 

988 





Índice analítico xi 











Capítulo 29 

CIRCUITOS DE CORRIENTE ALTERNA / 995 











29.1 Corriente alterna en una resistencia 996 

29.2 Circuitos de corriente alterna 999 

*29.3 El transformador 1004 

*29.4 Circuitos LC y LCR sin generador 1007 

*29.5  Fasores 1010 

*29.6 Circuitos LCR con generador 1011 

Temas de actualidad en Física: 

La red eléctrica: energía para el público 

en general / 1019 

Resumen 1020 

Problemas 1022 

Capítulo 30 





ECUACIONES DE MAXWELL Y ONDAS 

ELECTROMAGNÉTICAS / 1029 























30.1 Corriente de desplazamiento de Maxwell 1030 

30.2 Ecuaciones de Maxwell 1033 

30.7 La ecuación de ondas para las ondas 

electromagnéticas 1034 

30.4 Radiación electromagnética 1040 

Temas de actualidad en Física: 

Comunicación inalámbrica: espacio 

electromagnético compartido / 1049 

Resumen “1050 

Problemas 1051 

PARTE V LUZ 

Capítulo 31 

PROPIEDADES DE LA LUZ / 1055 

31.1 La velocidad de la luz 1056 

31.2 Propagación de la luz 1059 

31.3 Reflexión y refracción 1060 

31.4  Polarización 1070 

31.5 Deducción de las leyes de reflexión 

y refracción 1077 





























31.6  Dualidad onda-partícula 1079 

31.7 Espectros de luz 1080 

*31.8 Fuentes luminosas 1081 

Temas de actualidad en Física: 

Pinzas y vórtices ópticos: 

trabajar con la luz / 1088 

Resumen 1089 

Problemas 1090 

Capítulo 32 

IMÁGENES ÓPTICAS / 1097 

32.1 Espejos 1097 

32.2 Lentes 1108 

*32.3  Aberraciones 121 

*32.4 Instrumentos ópticos n22 

Temas de actualidad en Física: 

Avances en cirugía ocular / 1131 

Resumen 1132 

Problemas 1134 

ítulo 33 

INTERFERENCIA Y DIFRACCIÓN / 1141 

33.1 Diferencia de fase y coherencia 142 

33.2 Interferencia en películas delgadas 143 

33.3 Diagrama de interferencia de dos rendijas 1145 

33.4 Diagrama de difracción de una sola rendija 1149 

*33.5 Suma de ondas armónicas mediante 

fasores 1152 

33.6  Difracción de Fraunhofer y de Fresnel 1159 

33.7  Difracción y resolución 1160 

*33.8 Redes de difracción 1162 





Temas de actualidad en Física: 











Hologramas: interferencia guiada / 1165 





166 

1167 





Resumen 

Problemas 





ÍNDICE ALFABÉTICO / 1.1 











Prefacio 





La sexta edición de Física para la ciencia y la tecnología presenta un texto y herra- 

mientas online completamente integrados que ayudarán a los estudiantes a apren- 

der de un modo más eficaz y que permitirá a los profesores adaptar sus clases para 

enseñar de un modo más eficiente. 



El texto incluye un nuevo enfoque estratégico de resolución de problemas, un 

apéndice de matemáticas integrado y nuevas herramientas para mejorar la com- 

prensión conceptual, Los nuevos temas de actualidad en física destacan temas 

innovadores que ayudan a los estudiantes a relacionar lo que aprenden con las tec- 

nologías del mundo real. 





CARACTERÍSTICAS CLAVE 





ESTRATEGIA DE RESOLUCIÓN DE PROBLEMAS 





En la sexta edición destaca una nueva estrategia de resolución de problemas en la 

que los Ejemplos siguen un formato sistemático de Planteamiento, Solución y 

Comprobación. Este formato conduce a los estudiantes a través de los pasos im- 

plicados en el análisis del problema, la resolución del problema y la comprobación 

de sus respuestas. Los Ejemplos a menudo incluyen útiles secciones de Observa- 

ción que presentan formas alternativas de resolución de problemas, hechos intere- 

santes, o información adicional relativa a los conceptos presentados. Siempre que 

se considera necesario, los Ejemplos van seguidos de Problemas Prácticos para 

que los estudiantes puedan evaluar su dominio de los conceptos. 



En esta edición, las etapas de resolución de problemas siguen contando con las 

ecuaciones necesarias al lado, de manera que a los estudiantes les resulte más fácil 

seguir el razonamiento. 















Después de cada enunciado del problema, los 

estudiantes van al Planteamiento del problema. 

Aquí, el problema se analiza tanto 











Un coche se muere lucia el ete 360 £m/h Toma una curva y 3 más tad viaja hacia el 

norte 160 km/h. Determinar la aceleración media del coche 





PLANTEAMIENTO. Calculamos la scclración media a parir de su definición 

















conceptualmente como visualmente, 





En la sección Solución, cada paso de la solución se 

presenta con un enunciado escrito en la columna de 

la izquierda y las ecuaciones matemáticas 

correspondientes en la columna de la derecha. 





La Comprobación recuerda a los estudiantes que han de 

verificar que sus resultados son precisos y razonables. 





La Observación sugiere una forma distinta de enfocar 

un ejemplo o da información adicional relevante para el 





ejemplo. SS 





A la solución le sigue normalmente un 



Problema Práctico, lo que permite a los estudiantes 

comprobar su comprensión. Al final del capítulo 



se incluyen las respuestas para facilitar una 

comprobación inmediata. 





Primer calculamos 45 que eel vector que sumado a 7, nos da 



















soLuCIÓN 



1. La aceleración media eel cosente entre la variación de velocidad 

y elintervao de tiempos 



2. Vara hallr-36, debemos especificar primero y 7, Dibujemos 7, 

y 5, igura 1792 y racemon el diagrama de suma vecturial 

(igura 370) comepondiente ad, — E, + Ai 



3. Elcambra de velocidad viene determinado por las 

velocidades inicial y fia: 

















land 











4. Seesituya los resultados anteriors para determinar la 





aceleración medir 50% 





AH 1000m 



5. Comenta 60 km/h a metros cof 2 y 00 o 9 3, 

porsegundo: 7 A 167 m/s 



16. Expaesela aceleración en metros por segundo al cuadrado: ñ ps a 











30 

- amis 4/5] 









































COMPROBACIÓN La componente dela velocidad en dirección ste disminuye de 60 km/h 

“acero, deal forma que cabría sperar que la componente x de a aceleración fue negativa. 

Así misma, la componente de La velocidad en dirección norte aumenta deceso 60 han/ ha 

de forma que cabría esperar que la componente y dela aceleración fuese positiva. El resul. 

tado del apartado 6 concuerda con estas expectativas. 





OBSERVACIÓN Obsérvese que el coche sigue acelerando aunque el módulo de su veloc 

dad se rantenga constante 





PROBLEMA PRÁCTICO 3.1 Determinar el módulo y la dirección del vector aceleración 

media. 

















a añ 





xiv Prefacio 





| En casi todos los capítulos se incluye un recuadro llamado 

Estrategia de resolución de problemas para reforzar el for- 

mato Planteamiento, Solución y Comprobación para solucio- 

| nar satisfactoriamente los problemas. 























ESTRATEGIA DE RESOLUCIÓN DE PROBLEMAS 

Velocidad relativa 





PLANTEAMIENTO El primer paso para la resolución de problemas de 



velocidad relativa es identificar y marcar los sistemas de referencia 



relevantes, Aquí les llamaremos sistema de referencia A y 



SOLUCIÓN 



1. Utilizando 9, = 7, + 8,y (ecuación 39), relacione la velocidad del 

objeto móvil partícula p) felativa al sistema A con la velocidad de la 

partícula relativa al sistema B. 



2. "Trace un diagrama de suma vectorial para la ecuación Ty =8,, + 8yg> 

Incluya ejes de coordenadas en el dibujo, 



3, Calcule la incógnita en cuestión. Utilice la teigonometría cuando sea. 

necesario. 



COMPROBACIÓN Asegúrese de que obtiene la velocidad o posición del 



cuerpo respecto del sistema de referencia correclo, 











APÉNDICE DE MATEMÁTICAS INTEGRADO 





Esta edición ha mejorado el apoyo matemático a los estudiantes que estudian Ma- 

temáticas al mismo tiempo que introducción a la Física o a los estudiantes que re- 





quieren repasar las Matemáticas. 

El Apéndice de Matemáticas completo 





+ revisa resultados básicos de álgebra, geometría, trigonometría y cálculo, 

» relaciona conceptos matemáticos con conceptos físicos del libro, 

* proporciona Ejemplos y Problemas Prácticos para que los estudiantes pue- 





dan comprobar su comprensión de los conceptos matemáticos. 











Desintegración radiactiva del cobalto-60 

















El pe 











do de semidesintegración del cobalto (*Co) es 327 años. A! = 0 so tiene uma 

"Co de masa 120 mi ¿Cuánto tempo en años) habrá de transcurrir para que 

0,400 m de la muestra de “Co xe hayan desintegrado? 











PLANTEAMIENTO En la «lesducción del pertodo de semidesintogración pusimos N/N, = 

1/2. En ente ejemplo, hemos de hallar el tiempo de permanencia de dos tercios de la mues- 

tro, es decir, cuando la fracción N/N, sea de 0,667. 











M2) Sustitie (ln2)/1 por A y calcular dl iempor 





SOLUCIÓN WN 

PCs la cn NIN, como ua fndónporeci Aro 

x 

2 CATA del Becas is Moe 

2. Dear 139 06 

ls 

A ÓN 

nan eds occ mt 











COMPROBACIÓN Para que la masa de una muestra de “Co decrecieso hasta el 50 de su 

masa inicial habrían de transcurrir 5,27 años. Por lo tanto, es de esporar que la muestra lar- 

ase menos de 5,27 años para perder el 33,3% de su masa. Por tanto, el resultado obtenido 





PA 











orstante de tempo de descarga de un condensador en ur E cálea 



que tarda el condensador en descargarse hasta (osea0368) caca] 

7 Y para un condensador, ¿unto impo (en segundos) , 

«lscargase hasta el 07 desu canga inca? 



28:54 la población de coyotes en un determinado lugar está ceci 

















canzará una población 1,5 veces la 











donde f, se calcu 





ly Ly se escribe 























que se ha de integrar) por las dimensi 





por década y continúa creciendo al mismo ritmo indefinidamen LA INTEGRAL COMO UN ÁREA BAJO UNA 

Po CURVA. ANÁLISIS DIMENSIONAL 





La integración está relacionada con el problema de hallar el 7 

rea bajo una curva, La figura M.27 muestra una función JU). 

El área del elemento sombreado es aproximadamente f, Al, 



en un punto cualquiera del inter 

Esta aproximación mejora si Al, es muy pequeño. 

área lolal desde 1, hasta 1, sumando todos los elementos de 

área desde 1, a, y tomando el límite cuando Af, tiende a cero, 

Este límite se denomina la integral de fextendida al intervalo 





j pt =á0cs,= Jim, EJ, 





| (3 años) concuerda con lo esperado. 

enostemas Pcrcos M2 AAN 





integral se puede considerar el inverso del cálculo di 0 

una función [() se integra, se obtiene una función 

FG), de forma que [0 es la derivada de F(1) con respecto a 1. 















































cn 

lo 























El 

























































































Jar Jar lar 

h 











+ 135) -] 











MZA 











Las dimensiones físicas de una integral de una función JU) se — siauma m.27 Función general) Fl área de elemento 

hallan multiplicando las dimensiones del integrando (la función — sombreado es aproximadamente, en donde e calcula para un 

s de la variable de in- — puntocualquiera del intervalo. 











Además, las notas al margen permiten a los estudiantes ver fácilmente la rela- 

ción entre los conceptos físicos del texto y los conceptos matemáticos. 





PEDAGOGÍA PARA ASEGU- 

RAR LA COMPRENSIÓN 

CONCEPTUAL 





Se han añadido herramientas prácticas para los 

estudiantes para facilitar un mejor comprensión 

conceptual de la física. 





+ Se han introducido nuevos Ejemplos 

conceptuales, para ayudar a los estudiantes 

a comprender en profundidad conceptos 

físicos esenciales. Estos ejemplos utilizan la 

estrategia Planteamiento, Solución y 

Comprobación, de modo que los 

estudiantes no sólo obtienen una 

comprensión conceptual básica sino que 

tienen que evaluar sus respuestas. 





Prefacio xv 





Véase el 





Apéndice de matemáticas 





EAS Colisiones con masilla 











para más información sobre 

Cálculo diferencial 





Conceptual 











María tene dos bolas de la misma maca, una bola de masilla y otra de goma. Lanza la bota 

de masila contra un bloque suspendido por dos cuerdas como se muestra en la figura 820. 

La bolalmpucta contra el bloque y cac al suelo. Como consecuencia, el loque asciende hasta 

una altura máima 1. Si hubiera Lanzado la bola de goma con la misma velocidad ¿el bleu 

Habría ascendido a una altura mayor que 42 La goma, a diferencia de la masilla, es elísica y 

Mabicrarebotado contra el bloque. 





PLANTEAMIENTO Durante el impacto, el cambio de momento del sistema bola-bloque es 

ero. Cuanto mayor es.el cambio de momento de la bola, mayor será el cambio de momento 

del bloque. ¿Aumenta más el cambio de momento dela bola si sebota en el bloque quesí no. 

lo hace? 























SOLUCIÓN 





toduel momento inicial para ganar momento. 

enla dirección opuesta. Por tanto, la ola de 

goma perdería mayor cantidad de momento que 

la bola de masia 











6 

















an 





COMPROBACIÓN El bloque ejer un impulso hacia atrás sobre la bola de masilla hasta a 

esla parar. El mismo impulso ac detener la bola de goma, pero además el bloque ejerce un. 

impulso adicional que la hacer retroceder. Así el bloque ejerce un mayor impulso sobre la 

"ola de goma que sobre la de masilla. Según la terra ley de Newton, el impulso de la bola 

obre el bloque es igual y opuesto al impulso del bloque sobre la bola. Entonces, la bola de 

goma ejerce un impulso mayor sobre el bloque confiiéndole un mayor cambio de momento. 





COMPROBACIÓN CONCEPTUAL 3,1 





Las nuevas Comprobaciones de conceptos facilitan a los estudiantes com- 

probar su comprensión conceptual de conceptos físicos mientras leen los 

capítulos. Las respuestas están situadas al final de cada capítulo para per- 

mitir una comprobación inmediata. Las comprobaciones de conceptos se 

colocan cerca de temas relevantes, de modo que los estudiantes puedan re- 

leer inmediatamente cualquier material que no comprendan del todo. 





Los nuevos avisos de errores frecuentes, identificados mediante signos de 

exclamación, ayudan a los estudiantes a evitar errores habituales. Estos 

avisos están situados cerca de los temas que habitualmente causan confu- 

sión, de manera que los estudiantes puedan resolver de inmediato cual- 

quier dificultad. 





donde U, la constante arbitraria de integración, es el valor de la energía potencial 

para y = 0. Como sólo definimos la variación de energía potencial, el valor real de U 

no es importante. Por ejemplo, si a la energía potencial gravitatoria del sistema 

Tierra-esquiador se le asigna un valor igual a cero cuando el esquiador está en el 



| fondo de la pista, su valor a la altura Jr sobre este nivel es mgh. También podemos 

asignar el valor cero de energía potencial al momento en que el esquiador está en un 

punto P a medio camino de la pendiente, en cuyo caso su valor en cualquier otro 

punto sería mgy, donde y es la distancia del esquiador respecto al punto P. 





La figura 3.9 es el diagrama del mo- 

vimiento de la saltadora antes, du- 

rante y después del instante de 

tiempo 1,, cuando se halla momen- 

táneamente en reposo en el punto 





más bajo de su descenso. En la 

parte de su ascenso mostrada en el 

esquema, la velocidad de la salta- 

dora aumenta. Utilice este dia- 

grama para determinar la dirección 

de la aceleración de la saltadora (a) 

enel instante? y (b)en el instante /,. 











Mvesercotzss> “a dara Uel 

valor cero en cualquier punto de 





referencia. 











Prefacio 





TEMAS DE ACTUALIDAD 

EN FÍSICA 





Los temas de actualidad en Física, que apa- 

recen al final de ciertos capítulos, tratan de 

aplicaciones actuales de la Física y relacionan 

estas aplicaciones con conceptos descritos en 

los capítulos. Estos temas van desde un par- 

que eólico hasta termómetros moleculares y 

motores de detonación pulsar. 











IMPRESOS 





guientes versiones: 





Volumen 1 





Volumen 2 





Volumen 14 

Volumen 1B 

Volumen 1C 

Volumen 2A 

Volumen 2B 





Física moderna 





Apéndices y respuestas 978-84-291-4427-7 











MEDIOS DE DIFUSIÓN Y SUPLEMENTOS 





A ES 





Soplando aire cálidos 





Los parques eólicos están desperdigados por la costa danesa, las planicies de alto 

'medic-oeste de EE.UU. y las montañas desde California hasta Vermont. El aprove- 

«hamiento de la energía cinética del viento no esnada nuevo, Durante siglos, los mo- 

Tinos de vienta se han utilizado para bombxar agua, ventilar minas! y moler cl grano. 



nda actualidad, las turbinas de viento hacen funcionar generadores eléctricos. 

Esas turbinas transforman energía cinética en energía electromagnética. Las turbi- 

"nas modernas tienen precios, tamaños y rendimientos muy variados. Algunas de 

ellas son pequeñas y sencillas máquinas que cuestan unos 500 dólares y producen 

tanos 100 watts de potes son gigantes y complejas y cuestan unos 2 mi- 

Mones de dólares pero generan hasta 25 MW por turbina. Todas ellas funcionan: 

acias a una fuente de energía [Scilmente disponible —el viento, 



La teoría que hay detrás de la conversión de energía cinótica en clectromagné- 

tica es simple, Las moléculas de aire golpean sobre las aspas de la hélice y hacen 

girar la tusbína. Las aspas hacer gárar unos engranajes que hacen aumentar la ve- 

Jocidad de rotación que a su vez hace girar el otor generados. El generador envía 

«energía electromagnética cables que soportan alta tensí 



Sin embargo, lo conversión dela energía cinética del viento en energía electro- 

magnética no es perfectamente eficiente de hecho, no puede ser 100% eficiente. Si 

las turbinas convirtieran completamente la energía cinética del viento en energía 

eléctrica el ave saldría de la turbinas sin energía cinética. Es decir las turbinas pa- 

aríam cl ave, Sila tucbina parase completamente el oleo, éste Muir alresor de 

la turbina en lugar de Muir a través de ela 



Así la turbina debe ser capaz de capturar la energía cinética del aincen movimiento. 

y de evitarelMujo de areas alrededor, Las turbinas propulbadas pur helcs sem las 

"más comunes y su eficiencia teórica varía de J0%. a 59. (Las eficiencias tóricas var 

rían en función de cómo el al Muye alrededor de la tusbina y través de las hélices) 



En resumen la más eficiente delas turbinas puede convertir el 10% dela encr- 

ía disponible, ¿Qué sucede? Antes de llegar ala turbina el aire Muye de forma lami- 



turbina el ale se vuelve turbulento, L 



+ de detrás de la turbina, un 

¿debida ala viscosidad del aire 

lentamente, aparecerá un rozamiento entre est ale y 

«lao más veloz que fluye pu alvdedor? Las hélicos se calientan y el ie también. 

Los engranajes de la tucbina también disipan energía debido al rozamiento, Las héli- 

«es vibran individualmente —la encngía absorbida para producir estas vibraciones 

también hace disminuir la eficiencia. Finalment, la turbina necesita corriente para 

hacer funcionar los motores que lubricar los engranajes y el motor que orienta la tur- 

bina ena disección má captura del viento, 



En definitiva, la mayoría de incionan con tuna eficiencia de entre un 10 

y un 20 por ciento." pero siguen siendo un recurso energético más limpio que «l pe- 

Árólco, Uno de los propietarios de turbinas colicas deca, “Lo fundamental del nego 

cio delas turbinas radica en que nos ayuda a controlar nuestro futuro” 















































































































Todos los suplementos de la obra están disponibles en Internet en la página 

www.reverte.com / microsites/tipleróed. 





FLEXIBILIDAD PARA LOS CURSOS DE FÍSICA 





Nos damos cuenta de que no todos los cursos de física son iguales. Para facilitar la 

utilización del libro, Física para la ciencia y la tecnología se halla disponible en las si- 





Mecánica/Oscilaciones y ondas/Termodinámica 

(Capítulos 1-20, R) 978-84-291-4429-1 

Electricidad y magnetismo/Luz 



(Capítulos 21-33) 978-84-291-4430-7 





Mecánica (Capítulos 1-13) 978-84-291-4421-5 



Oscilaciones y ondas (Capítulos 14-16) 978-84-291-4422-2 

Termodinámica (Capítulos 17-20) 978-84-291-4423-9 

Electricidad y magnetismo (Capítulos 21-30) 978-84-291-4424-6 

Luz (Capítulos 31-33) 978-84-291-4425-3 





Mecánica cuántica, relatividad y estructura de la materia 

(Capítulos R, 34-41) 978-84-291-4426-0 











Ln parque cólico que convierte lacra 

sinéica del ala en energía ética 

ag Ste 





E) 





Agradecimientos 





' Queremos expresar nuestro agradecimiento a los diversos profesores, estudiantes, 

colaboradores y amigos que han contribuido a esta edición y a las anteriores. 



Anthony]. Buffa, profesor emérito en California Polytechnic State University en 

California, escribió muchos de los nuevos problemas que aparecen al final de los 

capítulos y editó las secciones de problemas del final de cada capítulo. Laura Run- 

Kle escribió los Temas de actualidad en Física. Richard Mickey revisó la Revisión 

! de matemáticas de la quinta edición, que ahora constituye el Apéndice de mate- 

máticas de la sexta edición. David Mills, profesor emérito en el College of the Red- 

woods en California, revisó a fondo el Manual de Soluciones. Para redactar este 

libro y para comprobar la precisión y exactitud del texto y los problemas hemos 

contado con la ayuda inestimable de los siguientes profesores: 





Thomas Foster Jerome Licini 

Southern Illinois University Lehigh University 



| Karamjeet Arya Das 

San Jose State University 



University of Wisconsin 



Mirley Bala 

Texas A££M University —Corpus Christi Laura McCullough 

Michael Crivello University of Wisconsin, Stout 

San Diego Mesa College Jeannette Myers 

Carlos Delgado Francis Marion University 





Community College of Southern Nevada 

David Faust 



Mt. Hood Community College 



Robin Jordan Todd K. Pedlar 

Florida Atlantic University Luther College 





Marian Peters 

Appalachian State University 





Muchos profesores y estudiantes han realizado revisiones exhaustivas y útiles 

de uno o más capítulos de esta edición. Cada uno de ellos ha contribuido de un 

modo fundamental a mejorar la calidad de esta revisión, y merecen por ello nues- 

tro agradecimiento. Nos gustaría dar las gracias a los siguientes revisores: 





Ahmad H. Abdelhadi J. Robert Anderson 



James Madison University University of Maryland, College Park 

Edward Adelson Toby S. Anderson 



Ohio State University Tennessee State University 



Royal Albridge Wickram Ariyasinghe 



Vanderbilt University Baylor University 











Paul Quinn 

Kutztown University 





Peter Sheldon 





Randolph-Macon Woman's College 





Michael G. Strauss 

University of Oklahoma 





Brad Trees 

Ohio Wesleyan University 





George Zober 

Yough Senior High School 





Patricia Zober 

Ringgold High School 





Yildirim Aktas 





University of North Carolina, Charlotte 





Eric Ayars 

California State University 





James Battat 

Harvard University 





xvii 























xvi 











Agradecimientos 





Eugene W. Beier 

University of Pennsylvania 





Peter Beyersdorf 



San Jose State University 

Richard Bone 



Florida International University 

Juliet W. Brosing 



Pacific University 



Ronald Brown 



California Polytechnic State University 

Richard L. Cardenas 



St. Mary's University 



Troy Carter 



University of California, Los Angeles 

Alice D. Churukian 

Concordia College 



N. John DiNardo 



Drexel University 



Jianjun Dong 



Auburn University 



Fivos R Drymiotis 



Clemson University 



Mark A. Edwards 



Hofstra University 



James Evans 



Broken Arrow Senior High 

Nicola Fameli 



University of British Columbia 

N. G. Fazleev 



University of Texas at Arlington 

Thomas Furtak 



Colorado School of Mines 

Richard Gelderman 



Western Kentucky University 

Yuri Gershtein 



Florida State University 



Paolo Gondolo 



University of Utah 



Benjamin Grinstein 

University of California, San Diego 

Parameswar Hari 



University of Tulsa 



Joseph Harrison 



University of Alabama—Birmingham 

Patrick C, Hecking 



Thiel College 



Kristi R. G. Hendrickson 

University of Puget Sound 

Linnea Hess 



Olympic College 



Mark Hollabaugh 

Normandale Community College 

Daniel Holland 



Illinois State University 





Richard D. Holland II 

Southern Illinois University 





Eric Hudson 

Massachusetts Institute of 

Technology 





David C. Ingram 

Ohio University 



Colin Inglefield 

Weber State University 

Nathan Israeloff 

Northeastern University 





Donald J. Jacobs 

California State Unive: 





Erik L. Jensen 

Chemeketa Community College 





ity Northridge 











Colin P Jessop 

University of Notre Dame 

Ed Kearns 



Boston University 





Alice K. Kolakowska 

Mi pi State University 











Douglas Kurtze 



Saint Joseph's University 



Eric T. Lane 



University of Tennessee at Chattanooga 

Christie L. Larochelle 



Franklin € Marshall College 



Mary Lu Larsen 



Towson University 





Clifford L. Laurence 

Colorado Technical University 





Bruce W. Liby 

Manhattan College 

Ramon E. Lopez 

Florida Institute of Technology 





Ntungwa Maasha 

Coastal Georgia Community Collegee 

and University Center 





Jane H MacGibbon 

University of North Florida 





A. James Mallmann 

Milwaukee School of Engineering 

Rahul Mehta 





University of Central Arkansas 





R. A. McCorkle 

University of Rhode Island 





Linda McDonald 



North Park University 

Kenneth McLaughlin 

Loras College 



Eric R. Murray 



Georgia Institute of Technology 

Jeffrey S. Olafsen 

University of Kansas 





Richard P. Olenick 

University of Dallas 





Halina Opyrchal 

New Jersey Institute of Technology 





Russell L, Palma 



Minnesota State University —Mankato 

Todd K. Pedlar 



Luther College 



Daniel Phillips 



Ohio University 





Edward Pollack 

University of Connecticut 











Michael Politano 

Marquette University 

Robert L. Pompi 

SUNY Binghamton 

Damon A. Resnick 

Montana State University 

Richard Robinett 

Pennsylvania State Us 

John Rollino 

Rutgers University 





Daniel V. Schroeder 

Weber State University 

















versity 





Douglas Sherman 

San Jose State University 

Christopher Sirola 

Marquette University 

Larry K. Smith 



Snow College 



George Smoot 

University of California 

at Berkeley 



Zbigniew M. Stadnik 

University of Ottawa 





Kenny Stephens 

Hardin-Simmons University 

Daniel Stump 



Michigan State University 





Jorge Talamantes 

California State University, 

Bakersfield 





Charles G. Torre 

Utah State University 





Brad Trees 



Ohio Wesleyan University 



John K. Vassiliow 



Villanova University 



Theodore D. Violett 



Western State College 



Hai-Sheng Wu 



Minnesota State University —Mankato 





Anthony C. Zable 

Portland Community College 





Ulrich Zurcher 

Cleveland State University 











También estamos en deuda con los revisores de ediciones anteriores. Por lo que 

nos gustaría dar las gracias a los siguientes revisores, quienes nos proporcionaron 

un apoyo imprescindible mientras realizábamos la cuarta y la quinta ediciones: 





Edward Adelson 

The Ohio State University 





Michael Arnett 



Kirkwood Community College 

Todd Averett 



The College of William and Mary 

Yildirim M. Aktas 



University of North Carolina at Charlotte 

Karamjeet Arya 



San Jose State University 



Alison Baski 



Virginia Commonwealth University 

William Bassichis 



Texas AM University 



Joel C. Berlinghieri 



The Citadel 





Gary Stephen Blanpied 

University of South Carolina 





Frank Blatt 



Michigan State University 



Ronald Brown 



California Polytechnic State University 





Anthony J. Buffa 

California Polytechnic State University 





John E. Byrne 

Gonzaga University 



Wayne Carr 



Stevens Institute of Technology 

George Cassidy 



University of Utah 



Lay Nam Chang 



Virginia Polytechnic Institute 



L V. Chivets 



Trinity College, University of Dublin 

Harry T. Chu 



University of Akron 



Alan Cresswell 



Shippensburg University 



Robert Coakley 



University of Southern Maine 

Robert Coleman 



Emory University 



Brent A, Corbin 



UCLA 





Andrew Cornelius 

University of Nevada at Las Vegas 





Mark W. Coffey 

Colorado School of Mines 

Peter P. Crooker 

University of Hawaii 





Jeff Culbert 

London, Ontario 





Paul Debevec 



University of Illinois 



Ricardo S. Decca 



Indiana University-Purdue University 

Robert W. Detenbeck 



University of Vermont 



N. John DiNardo 



Drexel University 



Bruce Doak 



Arizona State University 



Michael Dubson 



University of Colorado at Boulder 

John Elliott 



University of Manchester, England 

William Ellis 



University of Technology — Sydney 

Colonel Rolf Enger 



US. Air Force Academy 





John W. Farley 

University of Nevada at Las Vegas 





David Faust 



Mount Hood Community College 

Mirela S. Fetea 



University of Richmond 



David Flammer 



Colorado School of Mines 



Philip Fraundorf 



University of Missouri, Saint Louis 

Tom Furtak 



Colorado School of Mines 



James Garland 



Retired 



James Garner 



University of North Florida 



lan Gatland 



Georgia Institute of Technology 

Ron Gautreau 



New Jersey Institute of Technology 

David Gavenda 



University of Texas at Austin 

Patrick C. Gibbons 

Washington University 



David Gordon Wilson 

Massachusetts Institute of Technology 

Christopher Gould 



University of Southern California 

Newton Greenberg 



SUNY Binghamton 



John B. Gruber 



San Jose State University 





Huidong Guo 

Columbia University 





Agradecimientos 





Phuoc Ha 

Creighton University 





Richard Haracz 

Drexel University 



Clint Harper 



Moorpark College 



Michael Harris 



University of Washington 

Randy Harris 



University of California at Davis 

Tina Harriott 



Mount Saint Vincent, Canada 

Dieter Hartmann 



Clemson University 



Theresa Peggy Hartsell 

Clark College 



Kcristi R.G. Hendrickson 

University of Puget Sound 

Michael Hildreth 



University of Notre Dame 

Robert Hollebeek 

University of Pennsylvania 

David Ingram 



Ohio University 



Shawn Jackson 



The University of Tulsa 



Madya Jalil 



University of Malaya 

Monwhea Jeng 



University of California — Santa Barbara 

James W. Johnson 

Tallahassee Community College 





Edwin R. Jones 

University of South Carolina 





Hon Joseph 

Columbia University 





David Kaplan 

University of California— Santa Barbara 





William C. Kerr 



Wake Forest University 

John Kidder 



Dartmouth College 



Roger King 



City College of San Francisco 

James J. Kolata 



University of Notre Dame 

Boris Korsunsky 

Northfield Mt, Hermon School 

Thomas O. Krause 

Towson University 





Eric Lane 

University of Tennessee, Chattanooga 





xix 











xx Agradecimientos 





Andrew Lang (graduate student) 

University of Missouri 





David Lange 

University of California — Santa Barbara 

Donald C. Larson 



Drexel University 



Paul L, Lee 



California State University, Northridge 





Peter M. Levy 

New York University 





Jerome Licini 

Lehigh University 



Isaac Leichter 



Jerusalem College of Technology 

William Lichten 



Yale University 



Robert Lieberman 



Cornell University 



Fred Lipschultz 



University of Connecticut 

Graeme Luke 



Columbia University 



Dan Maclsaac 



Northern Arizona University 

Edward McCliment 

University of lowa 



Robert R. Marchini 



The University of Memphis 

Peter E, C, Markowitz 

Florida International University 

Daniel Marlow 



Princeton University 

Fernando Medina 



Florida Atlantic University 

Howard McAllister 

University of Hawaii 



John A. McClelland 

University of Richmond 



Laura McCullough 

University of Wisconsin at Stout 

M. Howard Miles 

Washington State University 





Matthew Moelter 

University of Puget Sound 





Eugene Mosca 

US. Naval Academy 



Carl Mungan 



US. Naval Academy 



Taha Mzoughi 

Mississippi State University 

Charles Niederriter 

Gustavus Adolphus College 





John W. Norbury 

University of Wisconsin at Milwaukee 





Aileen O'Donughue 

St, Lawrence University 





Jack Ord 



University of Waterloo 



Jeffry S. Olafsen 



University of Kansas 



Melvyn Jay Oremland 



Pace University 



Richard Packard 



University of California 

Antonio Pagnamenta 

University of Illinois at Chicago 





George W. Parker 

North Carolina State Univ 











sity 

John Parsons 



Columbia University 



Dinko Pocanic 



University of Virginia 



Edward Pollack 



University of Connecticut 

Robert Pom 





The State University of New York at Bingham- 

ton 











Bernard G. Pope 

Michigan State University 





John M. Pratte 

Clayton College and State 



University 



Brooke Pridmore 



Clayton State College 



Yong-Zhong Oian 



University of Minnesota 



David Roberts 



Brandeis University 



Lyle D, Roelofs 



Haverford College 



R.J. Rollefson 



Wesleyan University 



Larry Rowan 



University of North Carolina at Chapel Hill 





Ajit S. Rupaal 

Western Washington University 





Todd G. Ruskell 

Colorado School of Mines 



Lewis H. Ryder 



University of Kent, Canterbury 

Andrew Scherbakov 



Georgia Institute of Technology 

Bruce A. Schumm 



University of California, Santa Cruz 

Cindy Schwarz 



Vassar College 



Mesgun Sebhatu 



Winthrop University 



Bernd Schuttler 



University of Georgia 





Murray Scureman 

Amdah] Corporation 











Marllin L. Simon 



Auburn University 



Scott Sinawi 



Columbia University 



Dave Smith 



University of the Virgin Islands 





Wesley H. Smith 

University of Wisconsin 





Kevork Spartalian 



University of Vermont 

Zbigniew M. Stadnik 

University of Ottawa 



G. R. Stewart 



University of Florida 



Michael G. Strauss 

University of Oklahoma 



Kaare Stegavik 



University of Trondheim, Norway 

Jay D. Strieb 



Villanova University 



Dan Styer 



Oberlin College 



Chun Fu Su 



Mississippi State University 

Jeffrey Sundquist 



Palm Beach Community College — South 

Cyrus Taylor 



Case Western Reserve University 

Martin Tiersten 



City College of New York 

Chin-Che Tin 



Auburn University 



Oscar Vilches 



University of Washington 





D.J. Wagner 

Grove City College 

Columbia University 





George Watson 

University of Delaware 

Fred Watts 



College of Charleston 

David Winter 



John A. Underwood 

Austin Community College 

John Weinstein 

University of Mississippi 

Stephen Weppner 

Eckerd College 



Suzanne E. Willis 

Northern Illinois University 

Frank L. H. Wolfe 

University of Rochester 

Frank Wolfs 



University of Rochester 





Roy C. Wood 

New Mexico State University 





4 











Ron Zammit Dean Zollman 

California Polytechnic State University Kansas State University 

Yuriy Zhestkov Fulin Zuo 



Columbia University University of Miami 





Es obvio que nuestro trabajo no termina nunca; por ello, esperamos recibir co- 

mentarios y sugerencias de nuestros lectores para poder mejorar el texto y corregir 

cualquier error. Si usted cree que ha hallado un error, o tiene cualquier otro co- 

mentario, sugerencia o pregunta, envíenos una nota a producciónOreverte.com 

Incorporaremos las correcciones en el texto en posteriores reimpresiones. 



Por último, nos gustaría agradecer a nuestros amigos de W. H. Freeman and 

Company su ayuda y aliento. Susan Brennan, Clancy Marshall, Kharissia Pettus, 

Georgia Lee Hadler, Susan Wein, Trumbull Rogers, Connie Parks, John Smith, Dena 

Digilio Betz, Ted Szczepanski y Liz Geller, quienes fueron muy generosos con su 

creatividad y duro trabajo en cada etapa del proceso. 



También estamos agradecidos por las contribuciones y ayuda de nuestros cole- 

gas Larry Tankersley, John Ertel, Steve Montgomery y Don Treacy. 











Agradecimientos 





Acerca de los autores 





Paul Tipler nació en la pequeña ciudad agrícola de Antigo, Wisconsin, en 

1933. Realizó sus estudios medios en Oshkosh, Wisconsin, en donde su padre era 

superintendente de las Escuelas Públicas. Recibió el título de Bachelor of Science 

en la Universidad de Purdue en 1955 y obtuvo su Ph.D. en la Universidad de IIli- 

nois, en donde estudió la estructura del núcleo. Impartió la enseñanza durante un 

año en la Wesleyan University de Connecticut mientras redactaba su lesis. Después 

se trasladó a la Universidad de Oakland en Michigan, donde fue uno de los pri- 

meros miembros del Departamento de Física, y desempeñó un papel importante 

en el desarrollo de los planes de estudio. Durante los siguientes 20 años, enseñó 

| casi todas las disciplinas de la física y escribió la primera y segunda ediciones de 

| sus ampliamente difundidos textos Física Moderna (1969, 1978) y Física (1976, 1982). 

| En 1982, se mudó a Berkeley, California, donde ahora reside y donde escribió Física 

preuniversitaria (1987) y la tercera edición de Física (1991). Además de la física, sus 

aficiones incluyen la música, excursionismo y camping. Es un excelente pianista de 

jazz y un buen jugador de póker, 





Gene Mosca nació en la ciudad de Nueva York y se crió en Shelter Island, 

en el Estado de Nueva York. Estudió en la Universidad de Villanova, en la Uni- 

versidad de Michigan y en la Universidad de Vermont, donde obtuvo su Ph.D. en 

física. Recientemente jubilado, Gene Mosca ha sido profesor en la U.S. Naval Aca- 

| demy, donde fue el impulsor de numerosas mejoras en la enseñanza de la Física, 

| tanto en los laboratorios como en las aulas. Proclamado por Paul Tipler como "el 

| mejor crítico que he tenido", Mosca se ha convertido en coautor del libro a partir 

de su quinta edición. 























rai 























Campo eléctrico 1: 

distribuciones 

discretas de carga 





21,1 

21.2 

213 

21.4 

215 

2165 





Carga eléctrica 

Conductores y aislantes 

Ley de Coulomb 



El campo eléctrico 



Líneas de campo eléctrico 











Acción del campo eléctrico sobre las cargas 





oy en día, nuestra vida diaria depende extraordinariamente de la electricidad, 

mientras que hace un siglo sólo disponíamos de alguna lámpara eléctrica. Sin 

embargo, aunque el uso generalizado de la electricidad es muy reciente, su 

estudio tiene una larga historia que comienza mucho antes de que apareciese 

la primera lámpara eléctrica. Las primeras observaciones de la atracción eléc- 





trica fueron realizadas por los antiguos griegos. 











'os observaron que al fro- 





tar el ámbar, éste atraía pequeños objetos como pajitas o plumas. Ciertamente, la 

palabra “eléctrico” procede del vocablo griego asignado al ámbar, elektrón. 





693 











EL COBRE ES UN CONDUCTOR CUYAS PROPIEDADES 

SON ÚTILES PORQUE HACEN POSIBLE EL 

TRANSPORTE DE LA ELECTRICIDAD. 



(Brooks R. Dillard/www.yuprocks.com) 











¿Cuál es la carga total de los 





electrones de una moneda? 

(Véase el ejemplo 21.1) 























694 CAPÍTULO 21 





Actualmente, la electricidad está en un proceso continuo de estudio, de investiga- 

ción y de búsqueda de nuevos usos. Los ingenieros eléctricos mejoran la tecnología 

existente en materia eléctrica, incrementando el rendimiento y eficacia de diferentes 

dispositivos eléctricos, tales como automóviles híbridos, plantas de producción eléc- 

trica, etc, Pinturas de fijación electrostática se utilizan en la industria de la automoción, 

en diversas partes del motor y de la estructura general del automóvil. Los procesos 

electrostáticos de cromación y de fijación de la pintura permiten realizar recubrimien- 

tos más duraderos, y de forma más ecológica y cuidadosa del medio ambiente que los 

que utilizan pinturas líquidas, dado que no utilizan ningún tipo de disolvente, 





En este capítulo, se inicia el estudio de la electricidad con la electrostática, que 

trata de las cargas eléctricas en reposo. Después de introducir el concepto de 

carga eléctrica, analizaremos brevemente el concepto de conductores y aislan- 

tes y la forma en que un conductor puede adquirir una carga. A continuación, 

estudiaremos la ley de Coulomb, que describe la fuerza ejercida por una carga 

eléctrica sobre otra. Posteriormente, introduciremos el concepto de campo 

eléctrico y veremos cómo puede describirse mediante las líneas de campo, las 

cuales indican el módulo y la dirección. del campo, del mismo modo en que 

describíamos el campo de velocidades de un fluido en movimiento mediante 





Campo eléctrico |: distribuciones discretas de carga 





'IM] CARGA ELÉCTRICA 





Al frotar una barra, ésta se carga eléc- 

tricamente. Repitiendo el experimento 

con diversos tipos de materiales, vemos 

que todos los objetos cargados pueden 

clasificarse en dos grupos: aquellos que 

se cargan como la barra de plástico fro- 

tada con un trozo de piel y los que se car- 

gan como la varilla de vidrio frotada con 

un paño de seda. Los objetos de un 

mismo grupo se repelen entre sí, mien- 

tras que los de grupos diferentes se 

atraen. Benjamín Franklin propuso un 

modelo de electricidad para explicar este 

fenómeno. Sugirió que todo objeto posee 

una cantidad normal de electricidad y 

que cuando dos objetos están muy próxi- 

mos, por ejemplo cuando se frotan entre 

sí, parte de la electricidad se transfiere de 

un cuerpo al otro: así pues, uno tiene un 

exceso de carga y el otro una deficiencia 

de carga de valor igual. Franklin descri- 

bió las cargas resultantes con los signos 

más y menos. Al tipo de carga adquirida 

por una barra de vidrio frotada con un 

paño de seda le llamó positiva, lo cual 

significaba que el paño de seda adquiría 





una carga negativa de igual magnitud. 

















líneas de corriente (capítulo 13). Por último, abordaremos el comporta- 

miento de las cargas puntuales y los dipolos en campos eléctricos. 





| Consideremos una barra de caucho que se frota con un trozo de piel y se 



| suspende de una cuerda que puede girar libremente. Si aproximamos a esta 



| barra una segunda barra de caucho, frotada también con una piel, observa- 

remos que las barras se repelen entre sí (figura 21.1). El mismo resultado se 

obtiene si repetimos el mismo experimento con dos barras de vidrio que 

han sido frotadas con seda (figura 21.1b). Sin embargo, si utilizamos una 



| barra de plástico frotada con piel y una varilla de vidrio frotada con seda, 

observaremos que las barras se atraen entre sí (figura 21.10), 











Un gato y un globo hinchado. (Roger Ressmeyer/CORBIS.) 





de 











/ caucho / 

SS er ne 

Doa — no FR LE” vidrio 



caucho vidrio 





(a) (b) 











FIGURA 21.1 (a) Dos barras de caucho 

frotadas con piel se repelen mutuamente. (b) 

L Igualmente, dos barras de vidrio frotadas con 











un material hecho de seda, se repelen entre sí. 





vidrio ++" caucho (c) Una barra de caucho que ha sido frotada 

con piel y otra de vidrio frotada con seda se 

() atraen mutuamente. 











Carga eléctrica 





Según esta elección de Franklin, el plástico frotado con una piel adquiere una carga 

negativa y la piel adquiere una carga positiva de igual magnitud. Dos objetos que 

portan el mismo tipo de carga se repelen entre sí, mientras que si portan cargas 

opuestas se atraen mutuamente (figura 21.1). 



Actualmente, es bien conocido que cuando un vidrio se frota con un trozo de seda, 

se transfieren electrones del vidrio al pedazo de seda. De acuerdo con la convención 

de Franklin, todavía en uso, la seda está cargada negativamente, y, consecuentemente, 

decimos que los electrones tienen carga negativa. La tabla 21.1 corresponde a una ver- 

sión reducida de una serie triboeléctrica (en griego tribos significa rozamiento). En 

esta serie, cuanto más baja es la ubicación de un material, mayor es su afinidad por 

captar electrones. Si dos materiales se ponen en contacto mediante rozamiento, se 

transfieren electrones del de la zona superior al de la inferior. Por ejemplo, electrones 

del nailon son transferidos al teflón cuando ambos se frotan entre sí. 





CUANTIZACIÓN DE LA CARGA 





La materia está formada por átomos eléctricamente neutros. Cada átomo posee un 

pequeño, pero masivo, núcleo que contiene protones y neutrones. Los protones 

están cargados positivamente, mientras que los neutrones no poseen carga. El nú- 

mero de protones en el núcleo es el número atómico Z del elemento. Rodeando al 

núcleo existe un número igual de electrones negativamente cargados, de modo que 

el átomo posee una carga neta cero. La masa del electrón es aproximadamente 2000 

veces menor que la del protón. Sin embargo, sus cargas son exactamente iguales 

pero de signo contrario. La carga del protón es e y la del electrón —e, siendo e la 

unidad fundamental de carga. La carga de un electrón o protón es una propiedad 

intrínseca de la partícula; del mismo modo, la masa y el espín de estas partículas 

son también propiedades intrínsecas de las mismas. 



Todas las cargas observables se presentan en cantidades enteras de la unidad 

fundamental de carga e. Es decir, la carga está cuantizada. Toda carga Q presente en 

la naturaleza puede escribirse en la forma Q = + Ne, siendo N un número entero.* 

Sin embargo, en los objetos ordinarios, N es habitualmente un número muy grande 

y la carga parece ser continua, del mismo modo que el aire parece ser un medio con- 

tinuo aunque realmente consta de muchas moléculas discretas. Por ejemplo, al car- 

gar una barra de plástico frotándola con un trozo de piel se transfieren del orden de 

101 electrones a la barra. 





CONSERVACIÓN DE LA CARGA 





Cuando dos objetos se frotan entre sí, uno de ellos queda con un exceso de elec- 

trones y, por lo tanto, cargado negativamente, y el otro queda con un déficit de 

electrones y, en consecuencia, cargado positivamente. La carga total, suma de la de 

los dos objetos, no cambia. Es decix, la carga se conserva. La ley de conservación de 

la carga es una ley fundamental de la naturaleza. En ciertas interacciones entre par- 

tículas elementales puede ocurrir que los electrones se creen o destruyan. Sin em- 

bargo, en todos estos procesos, se producen o destruyen cantidades iguales de 

cargas negativas y positivas, de manera que la carga del universo no varía. 



La unidad de carga del SI es el coulomb, el cual se define en función de la uni- 

dad de corriente o intensidad eléctrica, el ampere (A).* El coulomb (C) es la canti- 

dad de carga que fluye a través de un cable conductor en un segundo cuando la 

intensidad de corriente en el cable es de un ampere. La unidad fundamental de 

carga eléctrica e está relacionada con el coulomb por 





e = 1,602177 x 107 C = 1,60 x 10 C 21.1 

UNIDAD FUNDAMENTAL DE CARGA 











* En el modelo estándar de partículas elementales, los protones, neutrones y otras partículas elementales están consti- 

tuidas por partículas aún más fundamentales y primigenias llamadas querks, las cuales poseen cargas de +le o +3e, 

Los quarks no se han observado como partículas individuales. Sólo se han observado combinaciones de estas partícu- 

las elementales que constituyen una carga neta de +Ne, siendo N un número entero. 





' El ampere (A) es la unidad de corriente eléctrica. 





sección 21.1 | 695 





Tabla 21.1 





+ Extremo positivo de la serie 











Amianto 

Vidrio 



Nailon 



Lana 



Plomo 



Seda 



Aluminio 

Papel 



Algodón 



Acero 



Caucho (goma dura) 

Níquel y cobre 

Latón y plata 

Goma sintética 

Fibra acrílica 

Plástico flexible 

Polietileno 

Teflón 





Goma de silicona 











— Extremo negativo de la serie 

A 











696 CAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 











Carga por contacto. Una muestra de plástico de 

anchura 0,02 mm fue cargada mediante contacto con 

una pieza de níquel. Aunque el plástico posee una 

carga neta positiva, se aprecian regiones de carga 

negativa (oscuras) y regiones de carga positiva 

(amarillo). La fotografía se tomó barriendo una aguja 

cargada, de anchura 107 m, sobre la muestra y 

midiendo la fuerza electrostática sobre la aguja. 

(Bruce Terris/IBM Almaden Research Center.) 

















PROBLEMA PRÁCTICO 21.1 



Una carga de 50 nC (1 nC = 107? C) puede producirse en el laboratorio simplemente fro- 

tando entre sí dos objetos. ¿Cuántos electrones deben ser transferidos para producir esta 

carga? 























¿Cuánta carga hay en una moneda? 











Una moneda de cobre* (Z = 29) tiene una masa de 3 g. ¿Cuál es la carga total de todos los 

electrones contenidos en la moneda? 





PLANTEAMIENTO La carga total de los electrones contenidos en una moneda viene dada 

por el número de éstos, N,, multiplicado por la carga de uno de ellos, —e. Por tanto, el nú- 

mero de electrones será 29 veces el número de átomos de cobre, N,. Para determinar N,, hay 

que tener en cuenta que un mol de cualquier sustancia tiene un número de moléculas igual 

al número de Avogadro (N, = 6,02 X 10%) y el número de gramos de un mol es la masa mo- 

lecular M, que para el cobre es 63,5 g/mol. Como la molécula de cobre es monoatómica, de- 

terminaremos el número de átomos por gramo dividiendo el N, (átomos por mol) por el 

peso molecular M (gramos por mol). 























ll SOLUCIÓN 





1. La carga total es el número de electrones multiplicado por la Q =N/ ce) 

carga electrónica: 





2. El número de electrones es el número atómico Z multiplicado N,= ZN, 

por el número de átomos de cobre, Ny: 





6,02 X 10% átomos/mol 

3. Calcular el número de átomos de cobre en 3,10 g de este N, = (8,10 PR di = 2,94 X 10% átomos 





metal: 63,5 g/mol 





= ZN, = (29 electrones/átomo)(2,94 X 10% átomos) 

= 8,53 X 10% electrones 





4. Calcular el número de electrones, N,: 











5. Utilizar este valor de N, para determinar la carga total: Q =N, x (e) = (8,53 X 10% electronesK—1,60 X 1071 C/electrón) 

137 x 105 C 





COMPROBACIÓN Hay 29 x (6,02 x 103) electrones en 63,5 g de cobre. Por lo tanto, en 

3,5 gramos de este material hay (3,10/63,5) x 29 X (6,02 X 10%) = 8,53 x 10% electrones, lo 

cual está de acuerdo con el paso 4 del resultado del ejercicio. 

















PROBLEMA PRÁCTICO 21.2 Si cada habitante de los EE.UU. (aproximadamente 300 mi- 

llones de habitantes) recibiera un millón de electrones, ¿qué porcentaje del número de elec- 

trones contenido en la moneda representaría? 





























* Desde 1793 hasta 1837, el penique estaba compuesto del 100%, de cobre. En 1982, se cambió 

5% de cinc y 95% de cobre a una composición de 97,5/% de cinc y 2,5% de cobre. 





la composición pasando de 





o 











Conductores y aislantes SECCIÓN 21.2 697 











FIGURA 21.2 Electroscopio. Dos hojas de oro se conectan a 

una barra metálica terminada en la parte superior por una esfera de 

metal. Asimismo, las hojas están aisladas del recipiente. Cuando no 

están cargadas, las hojas cuelgan en dirección vertical, juntas. 

Cuando se toca la esfera con una barra de plástico cargada 

negativamente, se transfieren algunas cargas negativas de la barra a 

la esfera, y de ésta son conducidas a las hojas de oro, las cuales se 

separan entre ellas debido a la repulsión de sus respectivas cargas 

negativas. Si se toca la esfera con una barra de vidrio cargada 

positivamente, las hojas también se separan. (Poniendo en contacto 

la bola con una barra de vidrio cargada positivamente, las hojas de 

oro deberían separarse. En este caso, la barra de vidrio cargada 

positivamente atrae electrones de la esfera de metal, dejando una 

carga neta positiva en la bola, en la barra y en las hojas.) 

















NA CONDUCTORES Y AISLANTE 





En muchos materiales, tales como el cobre y otros metales, parte de los electrones Y] 

pueden moverse libremente en el seno del material. Estos materiales se denominan 

conductores. En otros materiales, tales como la madera o vidrio, todos los electro- 

nes están ligados a los átomos próximos y ninguno puede moverse libremente. 

Estos materiales se denominan aislantes. 



En un átomo de cobre aislado, existen 29 electrones ligados al núcleo por atrac- 

ción electrostática entre los electrones cargados negativamente y los núcleos carga- 

dos positivamente. Los electrones más externos están ligados más débilmente que 

los más internos a causa de su mayor distancia al núcleo y a la repulsión de los elec- 

trones más internos. Cuando un gran número de átomos de cobre se combinan en 

una pieza de cobre metálico, el enlace de los electrones de cada átomo individual se 

reduce debido a las interacciones con los átomos próximos. Uno o más de los elec- 

trones externos de cada átomo queda en libertad para moverse por todo el metal, 

del mismo modo que una molécula de gas se mueve en el interior de una caja. El 

número de electrones libres depende del metal de que se trate, pero generalmente 

es de alrededor de un electrón por átomo. Cuando a un átomo se le quita o se le 

añade un electrón, apareciendo una carga neta, se convierte en un ion. En el cobre 

metálico, los iones de cobre se distribuyen regularmente formando una red. 

Normalmente, un conductor es eléctricamente neutro porque existe un ion en la red 

portador de una carga positiva +e por cada electrón libre portador de una carga ne- 

gativa —e. La carga neta de un conductor puede variar por adición o extracción de 

electrones. Un conductor con una carga neta 

negativa tiene un exceso de electrones libres, 

mientras que un conductor con una carga neta 

positiva tiene un déficit de los mismos. 





COMPROBACIÓN CONCEPTUAL 21.1 





Una esfera conductora con carga 

+0 se pone en contacto con otra 

esfera, también conductora e 

idéntica de tamaño a la anterior y 

con carga inicial nula. (a) ¿Cuál 

será la carga de cada esfera des- 

pués de que se establezca el con- 

tacto? (b) Estando las esferas en 

contacto, una barra cargada posi- 

tivamente se aproxima a una de 

estas esferas, causando una redis- 

tribución de las cargas de las dos 

esferas, de forma que la que está 

más próxima a la barra tiene una 

carga —Q. ¿Cuál es la carga de la 

otra esfera? 

















CARGA POR INDUCCIÓN (a) 



La conservación de la carga puede ilustrase 



mediante un método simple de cargar un con- 



ductor llamado carga por inducción, que se 



muestra en la figura 21.3. Dos esferas metálicas A — _ __  _ _n———_— 



sin carga están en contacto. Al acercar a una de CURRO ada 



las esferas una barra cargada, los electrones flu- (a) Los dos conductores esféricos en coíttacto 



yen de una esfera a la otra, acercándose a la (6) adquieren cargas opuestas cuando la barra 



barra si ésta se encuentra positivamente car- cargada positivamente batallas electrones 



gada o alejándose si su carga es negativa. Sila hacia la esfera de la izquierda. (b) Si las esferas 



La ES a a te (6 se separan sin mover la barra de su posición, 



2130) ES pa S? en da le de éstas retienen sus cargas iguales y opuestas. 

3a), atrae a los electrones y la esfera más (0) Sila barra se retira y las esferas se separan, 



próxima a la barra adquiere electrones de la éstas quedan uniformemente cargadas con 





otra. La esfera más próxima adquiere carga ne- (9 cargas iguales y opuestas. 











698 CAPÍTULO 21 











(b) 





Campo eléctrico l: distribuciones discretas de carga 





Símbolo de 

conexión a 

tierra 

















o. 0 

















FIGURA 21.4 Inducción por conexión a tierra. (a) La carga 

libre sobre una esfera conductora se polariza mediante la barra 

cargada positivamente, que atrae las cargas negativas de la esfera. 

(b) Si la esfera se conecta a un conductor muy grande, tal como la 





neutralizan la carga positiva del lado más alejado de la barra y la 

esfera queda negativamente cargada. (c) La carga negativa 

permanece si el cable se desconecta antes de separar la barra. 

(d) Al quitar la barra, la esfera queda cargada negativamente de 











Tierra, por medio de un alambre, los electrones del suelo forma uniforme. 





gativa y la más alejada queda con una carga neta igual, pero positiva. Cuando un 

conductor tiene cargas separadas iguales y opuestas se dice que está polarizado. Si 

las esferas se separan antes de retirar la barra, quedarán con cantidades iguales de 

cargas opuestas (figura 21.3b), Un resultado semejante se obtiene con una barra 

cargada negativamente; los electrones pasarían de la esfera más próxima a la más 

alejada. 



La propia Tierra constituye un conductor que para muchos propósitos puede 

considerarse infinitamente grande y con un suministro de carga libre abundante, 

Cuando un conductor se pone en contacto con el suelo se dice que está conectado 

a tierra. Esto se representa esquemáticamente mediante un cable de conducción 

que termina en unas pequeñas líneas paralelas, como indica la figura 21.4b. La fi- 

gura 21.4 muestra cómo puede inducirse una carga en un conductor simple trans- 

firiendo electrones desde el suelo y, a continuación, interrumpiendo la conexión a 

tierra, (En la práctica, una persona que estuviera en el suelo tocando con sus manos 

la esfera podría servir como ejemplo de la demostración electrostática descrita 

aquí.) 











Estas damas utilizan sombreros con cadenas 





El pararrayos de este edificio está 

conectado a tierra para conducir los 

electrones desde el suelo a las nubes 

cargadas positivamente a fin de 

neutralizarlas. (O Grant Heilman.) 





metálicas que arrastran por el suelo, 

supuestamente para protegerse contra los 

rayos. (Ann Roman Picture Library.) 

















COMPROBACIÓN CONCEPTUAL 21.2 





Se cargan dos esferas idénticas 

conductoras mediante inducción 

electrostática y seguidamente se 

separan a gran distancia una de la 

otra; la esfera 1 tiene carga +0 yla 

esfera 2, carga —Q. Se dispone de 

una tercera esfera idéntica a las 

otras dos e inicialmente descar- 

gada. Si las esferas 3 y 1 se ponen 

en contacto y, seguidamente, se se- 

paran, y luego se ponen en con- 

tacto la 3 y la 2 y se separan, ¿cuál 

será la carga final de cada una de 

las tres esferas? 

















Ley de Coulomb SECCIÓN 21.3 699 













Enchufe doble 





Terminal 

a tierra 











—————————————— 

FIGURA 21.5 Las dos conexiones a tierra de 

un enchufe doble de pared se conectan con un hilo 

de cobre a una barra de 8 pies de longitud, la cual 

se introduce en la tierra. 





E) Ley DE COULOM 





La fuerza ejercida por una carga sobre otra fue estudiada por Charles Coulomb 

(1736-1806) mediante una balanza de torsión de su propia invención.* En el expe- 

rimento de Coulomb las esferas cargadas eran mucho menores que la distancia 

entre ellas, de modo que las cargas podían considerarse como puntuales. Coulomb 

utilizó el fenómeno de inducción para producir esferas igualmente cargadas y 

poder variar la carga depositada sobre ellas. Por ejemplo, comenzando con una 

carga q, sobre cada esfera, podía reducir la carga a $, conectando a tierra una de 

las esferas temporalmente para descargarla, tras lo cual la desconectaba de tierra y 

ponía las dos esferas en contacto. Los resultados de los experimentos de Coulomb 

y Otros científicos se resumen en la ley de Coulomb: 











La fuerza ejercida por una carga puntual sobre otra está dirigida a lo largo 

de la línea que las une. La fuerza varía inversamente con el cuadrado de la 

distancia que separa las cargas y es proporcional al producto de las mismas. 

Es repulsiva si las cargas tienen el mismo signo y atractiva si las cargas tie- 

nen signos opuestos. 





LEY DE COULOMB 











* El aparato experimental de Colomb era esencialmente el mismo que se describió en el experimento de Cavendish (ca- 

pítulo 11), con las masas reemplazadas por pequeñas esferas cargadas. La atracción gravitatoria de las esferas es com. 

pletamente despreciable comparada con la atracción o repulsión eléctrica producida por las cargas depositadas en las 

esferas por frotamiento. 





























'n de Coulomb. (Bundy 

Library, Norwalk, CT.) 





| 

l 700 |  carítuLo21 





El módulo de la fuerza eléctrica ejercida por una carga puntual q, sobre otra carga 

puntual q, a la distancia r viene dada por 





_Klayaal 



paz 

E 



LEY DE COULOMB PARA LA FUERZA EJERCIDA POR q, SOBRE q, 





21.2 





donde k es una constante positiva determinada experimentalmente conocida como 





constante de Coulomb, que tiene el valor 

k=8,99 x 10” N«m/C? 21.3 





Si q, se encuentra en la posición f, y q, en F, (figura 21.6), la fuerza E, ejercida por 

q, Sobre q, es 





E Mie, 

2. 212 

Ma 











21.4 





LEY DE COULOMB (FORMA VECTORIAL) 





donde F,, = F, — F, es el vector que apunta de q, a q, y F,, =.F,/1,, es un vector 

unitario que apunta de q, a q». ds 



De acuerdo con la tercera ley de Newton, la fuerza F,, ejercida por q, sobre q, 

es de sentido contrario a la fuerza F,,. Obsérvese la semejanza entre la ley de 

Coulomb y la ley de Newton de la gravedad (ecuación 11.3). Ambas son leyes que 

| dependen de la inversa del cuadrado de la distancia. Sin embargo, la fuerza gravi- 

| tatoria entre dos partículas es proporcional a las masas de las partículas y es siem- 

pre atractiva, mientras que la fuerza eléctrica es proporcional a las cargas de las 

¡ partículas y es repulsiva si ambas cargas tienen el mismo signo y atractiva si tienen 

signos contrarios. 

















Fuerza eléctrica en un átomo de hidrógeno 











| En el átomo de hidrógeno, el electrón está separado del protón por una distancia media de 

aproximadamente 5,3 X 1071! m. ¿Cuál es el módulo de la fuerza electrostática ejercida por 

| el protón sobre el electrón? 





PLANTEAMIENTO Asígnese la carga q, al protón y q, al electrón. Se utiliza la ley de 

Coulomb para determinar el módulo de la fuerza de atracción electrostática entre el protón 





Campo eléctrico |: distribuciones discretas de carga 











Ta 

h e a 

ES y 



A Fign PUR 











(b) 











FIGURA 21.6 (a) Carga q, en la posición 

T, y carga q, en 7, ambas respecto al origen O. 

La fuerza ejercida por q, sobre q, está en la 

dirección y sentido del vector 7, = F, — F, si 

ambas cargas tienen el mismo signo, y en 

sentido opuesto si sus signos son contrarios. El 

vector unitario f,, = F,/r,, tiene la dirección 

del vector que une la carga q, con la q. 

























" La ecuación 21.4 da la dirección 

correcta para la fuerza en los casos 

en que ambas cargas sean positivas, 

negativas o de diferente signo. 



































y el electrón. 

SOLUCIÓN 

1. Se dibuja el electrón y el protón colocándolos en Protón Electrón 

el dibujo con sendos símbolos diferenciados “mo mn 

(figura 21.7): - 

| q=+e qa=-8 FIGURA 21.7 

Ki 2 (8,99 x 10" N=m?/C?XL,60 x 1071 CP 

2. Usar la ecuación 21.2 (ley de Coulomb) para Fe lol _ de? _ ¡9 





A Pz 





calcular la fuerza electrostática: 











(5,3 x 10" mP 











COMPROBACIÓN El orden de magnitud está dentro de lo esperado, Las potencias de diez 

en el numerador combinadas son 10 x 1073 = 1072, la potencia de diez en el denominador 

es 10-2, y 10-29/10-2 = 107, Comparando con el resultado, se tiene que 8,2 X 1078 = 1077, 

















Ley de Coulomb SECCIÓN 21.3 





OBSERVACIÓN Comparada con las interacciones macroscópicas, esta fuerza es muy pe- 

queña. Sin embargo, como la masa del electrón es tan pequeña, aproximadamente 10% kg, 

esta fuerza produce una aceleración enorme, F/m = 9 X 10% m/s?. La masa del protón es 

casi 2000 veces mayor que la del electrón, así que la aceleración del protón es alrededor de 

4 x 10" m/s?. Compárese esta aceleración con la debida a la gravedad, g =10 m/s?. 





PROBLEMA PRÁCTICO 21.3 Dos cargas puntuales de 0,0500 4C cada una se colocan se- 

paradas por una distancia de 10 cm. Calcular el módulo de la fuerza ejercida por una de las 

cargas sobre la otra. 





Puesto que tanto la fuerza eléctrica como la fuerza gravitatoria entre dos partí- 

Culas varían en razón inversa con el cuadrado de su separación, la relación entre 

estas dos fuerzas es independiente de la distancia que separa las partículas. 

Podemos, pues, comparar las intensidades relativas de estas dos fuerzas en partí- 

culas elementales, tales como el electrón y el protón. 











Comparación cuantitativa entre las fuerzas 

eléctrica y gravitatoria 





Calcular la relación que existe entre la fuerza eléctrica y la fuerza gravitatoria ejercidas entre 

el protón y el electrón de un átomo de hidrógeno. 





PLANTEAMIENTO Utilizamos la ley de Coulomb con q, = e y q, = —e para hallar la 

fuerza eléctrica. Y usamos la ley de la gravitación de Newton junto con la masa del protón, 

1, = 1,67 X 1077 kg, y la masa del electrón, m, = 9,11 X 10731 kg, para hallar la fuerza de la 

gravedad. 





701 





































SOLUCIÓN 

Gm, 

1. Expresar los módulos de la fuerza eléctrica F. y la fuerza ña 

gravitatoria F, en función de las cargas, masas, distancia de 

separación r y las constantes eléctrica y de gravitación: 

E__ke 

2. Determinar la relación de ambas fuerzas. Obsérvese que la a 

distancia de separación r se anula: ¿ MM. 

F, (8,99 X 10” N- m?/C?X1,60 x 10-19 CR 











3. Sustituir por los valores numéricos: 











E, (6,67 X 101 Nm /kg?X1,67 X 10-7 kgX9,11 X 10 kg) 

















COMPROBACIÓN En el paso 3, las unidades eléctricas se cancelan en el numerador de la 

fracción. En el denominador se cancelan las unidades de masa. En consecuencia, tanto en el 

numerador como en el denominador, las unidades son N - mí. Por lo tanto, la fracción no 

tiene dimensiones, como era de esperar, ya que es una relación entre dos fuerzas. 

















OBSERVACIÓN Este resultado demuestra por qué los efectos de la gravedad no se consi- 

deran al tratar las interacciones atómicas o moleculares. 





Aunque la fuerza gravitatoria es increíblemente pequeña comparada con la 

fuerza eléctrica y prácticamente no desempeña papel alguno a nivel atómico, la 

gravedad es la fuerza dominante entre sistemas grandes, como planetas y estre- 

llas, porque estos objetos poseen un número casi igual de cargas positivas y ne- 

gativas y, por lo tanto, se neutralizan las fuerzas eléctricas atractivas y repulsivas. 

La fuerza neta entre objetos astronómicos es esencialmente la fuerza de atracción 

gravitatoria. 





























702 | cAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 





FUERZA EJERCIDA POR UN SISTEMA DE CARGAS 





En un sistema de cargas, cada una de ellas ejerce una fuerza dada por la ecuación 

21.4 sobre cada una de las restantes. Así, la fuerza neta sobre cada carga es la suma 

vectorial de las fuerzas individuales ejercidas sobre dicha carga por las restantes 

cargas del sistema. Esta es una consecuencia del principio de superposición de las 

fuerzas. 





GALA Fuerza neta 





Tres cargas puntuales se encuentran sobre el eje x; q, está en el origen, q, en x = 2 m y y 

en x (x > 2 m). (a) Determinar la fuerza neta sobre q, ejercida por q, y q, si q, = +25 NC, 

q» = —10 nC y y = 3,55 m. (b) Obtener una expresión de la fuerza neta sobre q, debida a q, 

y q, en el intervalo 2m<x<w, 











PLANTEAMIENTO La fuerza neta sobre q, es el vector suma de la fuerza F,y ejercida por 

q, y la fuerza E,y ejercida por q,. Las fuerzas individuales se determinan mediante la ley 

de Coulomb. Obsérvese que F,y = F,y = Í pues F,y Y $, Se encuentran ambos en la di- 

rección positiva de x. 











20 











Véase el 

Apéndice de matemáticas 

para más información sobre 





Trigonometría 

















SOLUCIÓN 





(a) 1.. Dibujar un croquis del sistema de 

cargas (figura 21.80). Indicar las 

distancias 1, y Y 124 =-10nC 











—4— 9, 

















x m 

q=+25nC o =+20nC 

FIGURA 21.8a 

e Kora! 

.: Hallar la fuerza ejercida por la carga q, Eo 

sobre la q, Estas cargas se repelen por ser Mo 

del mismo signo. La fuerza tiene la > ups Hindol (8,99 < 10" N + mP/C2(25 x 10? ¡20 X 10"C), 

dirección del eje x: da uE i 





= (0,37 x 104 N)Í 





Klgadol 





). Hallar la fuerza ejercida por la carga q, 7] 

sobre la q, Estas cargas se atraen por ser Bo 

de diferente signo. La fuerza tiene la 











asa (8,99 x 10? N -m?/C2)(10 x 10-2C)X20 x 10-9C) , 

E ES 3 

















dirección del eje =x: Ep = 





. Sumar los resultados para obtener la fuerza 

neta: 





Dibujar la configuración geométrica de las 

cargas, definiendo las distancias £, y Y 20 

(figura 21.8b): 











(1,5 mP 























FIGURA 21.8b 



































Ley de Coulomb SECCIÓN 213 | 703 





2. Obtener una expresión para la fuerza Ep= 

debida a la carga q: 











3. Obtener una expresión para la fuerza E,=- 

debida a la carga qy: 

















Ss (que. Klgadol 





4. Sumar los dos vectores resultantes obtenidos — E. = E, + E 

e (1-20mP 





en 2 y 3, para obtener la fuerza neta: 

















COMPROBACIÓN Enlos pasos 2, 3 y 4 de la parte (5), ambas fuerzas tienden a cero cuando 

* tiende a infinito, como era de esperar. Además, tal como estaba previsto, el módulo de la 

fuerza en el paso 3 tiende a infinito cuando x tiende a 2.0 m. 





OBSERVACIÓN La carga q, está localizada entre la q, y qy lo cual podría inducir a pensar 

que la presencia de q, podría afectar a la fuerza F,, que ejerce la q, Sobre la y: Sin embargo, 

esto no es así, ya que la presencia de q, no tiene influencia en la fuerza que ejerce la q, sobre o1- 

la q, (Este hecho se denomina principio de superposición.) La figura 21.9 muestra la com. 

Ponente x de la fuerza F, sobre q, como una función de su posición x en la región 2 m <x < 

<>. Cerca de q, domina la fuerza debida a q,, y como las cargas opuestas se atraen, la fuerza 

Sobre q está dirigida hacia el sentido negativo delas x. Para 1>>2 m, la fuerza está dirigida 

en el sentido positivo de las x porque la distancia entre q, y q, es despreciable, de modo que 

la fuerza debida a las dos cargas es casi la misma que si hubiese una única carga de +15 NC, 





Ep NN 





PROBLEMA PRÁCTICO 21.4 Si q, se encuentra en Y =1 m, determinar la fuerza neta que 

actúa sobre q. 























Para que un sistema de cargas permanezca estacionario, deben existir otras 

fuerzas no eléctricas actuando sobre las cargas, de modo que la fuerza resultante 

de todas las fuerzas que actúan sobre cada carga sea cero. En el ejemplo anterior y 

en los siguientes, supondremos la existencia de tales fuerzas, de modo que todas FIGURA 21.9 

las cargas permanecen estacionarias. 

















Fuerza neta en dos dimensiones 

















La carga q, = + 25 nC está en el origen, la carga q, 

y la carga q, = + 20nC está en el punto x=2m, y = 

Determinar el vector de la fuerza resultante sobre Ao 





—15 nC está sobre el eje xenx=2 m, 

m, como se indica en la figura 21.10. 













PLANTEAMIENTO La fuerza resultante es la suma vectorial de las fuerzas individuales 

ejercidas por cada una de las cargas sobre q, Calcularemos cada una de las fuerzas a partir 

de la ley de Coulomb y la escribiremos en función de sus componentes rectangulares. 











SOLUCIÓN 





1. Dibujar las posiciones de las tres cargas en un sistema de ejes 

coordenados. Mostrar la fuerza resultante F sobre la carga q, 





Como suma vectorial de las fuerzas F,, debida a q, y Ey 

debida a q, (figura 21.100): 























M=+25nC, q, =-15nC 











FIGURA 21.10a 

















704 carituLoO 21 Campo eléctrico l: distribuciones discretas de carga 





_ Klguaol _ (8,99 x 10” N +m*/C3)(25 x 10? C)20 x 10*C) 

















2. La fuerza resultante F sobre q, es la suma de las fuerzas F=E,+ Eo 

individuales: así 2E,= Fx Eos Y EE, 

3. La fuerza F,, está dirigida a lo largo de la línea dirigida dr da 

de q, a qy Utilizar r, , = 2,0 V2 m como distancia entre q, Y 

Y y Para calcular el módulo de la fuerza: = 5,62 Xx 107N 

4. Como F,, forma un ángulo de 45" con los ejes x e y, Sus Fsox = Eroy = Ep £os 45% = (5,62 X 107N) cos 45? 

componentes y e y son iguales entre sí: = 3,97 X 107N 

5. La fuerza E, ejercida por q, sobre q, es atractiva en la E,= j= 





y2 

Bo 





dirección —y, como se muestra en la figura 21.100: E 

(6,74 x 107N)j 





" 





6. Calcular las componentes de la fuerza resultante: Fo= Frios Faoy = (8,97 X 107 N) + 0= 3,97 X 107 N 

9y = (8,97 X 107 N) + (6,74 X 107N) 





F,=F 





y = joy HE 





F, = 2,77 X 107N 





7. Dibujar la fuerza resultante (figura 21.100) y sus dos 

componentes: 











FIGURA 21.10b 





ms Klaaml ¿(899 % 10" N =m?/C2)15 x 107? CX20 x 10*C) 

ES E y 











8. El módulo de la fuerza resultante se determina a partir de. F= WEI + F7=1/(0,97 X 107 NP + (52,77 x 107 NP 





sus componentes: 

, = 4,84 x 107N =| 4,8 x 107N 





9. La fuerza resultante apunta hacia la derecha y hacia abajo, 

como se muestra en la figura 21.10b, formando con el eje x 

un ángulo 0 dado por: 

















COMPROBACIÓN Comparando los resultados de los pasos 3 y 5, podemos constatar que 

los módulos de estas dos fuerzas son relativamente parecidos aunque |q,| es algo mayor que 

lq,|. ya que la diferencia entre el valor de q, y q, es menor que la existente entre q, y qy- 





PROBLEMA PRÁCTICO 21.5 Expresar $, del ejemplo 21.5 en combinación lineal de los 

vectores unitarios Í y f. 





PROBLEMA PRÁCTICO 21.6 En el ejemplo 21.5, donde x,, es la componente de $, ¿la 

componente x de la fuerza Fy = (Kq,9,/13,)%,y es igual a Kq,99/x3,? 





214 ERIN 





La fuerza eléctrica ejercida por una carga sobre otra es un ejemplo de acción a dis- 

tancia, semejante a la fuerza gravitatoria ejercida por una masa sobre otra. La idea de 

acción a distancia presenta un problema conceptual difícil. ¿Cuál es el mecanismo 

según el cual una partícula puede ejercer una fuerza sobre otra a través del espacio 

















El campo eléctrico 





vacío que existe entre las partículas? Supongamos que una partícula cargada situada 

en un punto determinado se mueve súbitamente. ¿Variaría instantáneamente la 

fuerza ejercida sobre otra partícula situada a la distancia y de la primera? Para evitar 

el problema de la acción a distancia se introduce el concepto de campo eléctrico. Una 

carga crea un campo eléctrico E en todo el espacio y este : Campo ejerce una fuerza 

sobre la otra carga. La fuerza es así ejercida por el campo E existente en la posición 

de la segunda carga, más que por la propia primera carga que se encuentra a cierta 

distancia. Los cambios del campo se propagan a través del espacio con la velocidad 

de la luz, c. Así, si una carga se mueve súbitamente, la fuerza que ejerce sobre otra 

Carga a la distancia r no se modifica hasta que transcurre el tiempo r/c. 



La figura 21.11a muestra una serie de cargas puntuales, q,, 9, Y Qy, dispuestas ar- 

bitrariamente en el espacio. Estas cargas producen un campo eléctrico E en cual- 

quier punto del espacio. Si situamos una pequeña carga testigo q, en algún punto 

próximo, ésta experimentará la acción de una fuerza debido a las otras cargas. La 

fuerza resultante ejercida sobre 4, es la suma vectorial de las fuerzas individuales 

ejercidas sobre q, por cada una de las otras cargas del sistema. Como cada una de 

estas fuerzas es proporcional a Ap, la fuerza neta será proporcional a Ap: El campo 

eléctrico E en un punto se define por esta fuerza dividida por qy:* 



E= 





21.5 





F A 

— (q) pequeña) 

do 





DEFINICIÓN: CAMPO ELÉCTRICO 





La unidad del SI del campo eléctrico es el newton por coulomb (N /C). Además, 

la carga testigo q, ejercerá una fuerza sobre cada una de las otras cargas (figura 

21.15), produciéndoles movimiento; por ello, se debe considerar la carga qy tan pe- 

queña como para que las fuerzas ejercidas sobre las otras cargas sean desprecia- 

bles. De esta forma, el campo eléctrico en el lugar donde se coloca la carga Ap Se 

define mediante la ecuación 21.5 en el límite en el que la carga q, tiende a cero. En 

la tabla 21.2 se presentan las magnitudes de algunos de los campos eléctricos que 

encontramos en la naturaleza. 



El campo eléctrico es un vector que describe la condición en el espacio creada 

por el sistema de cargas puntuales. Desplazando la carga testigo p de un punto a 

Otro, podemos determinar E en todos los puntos del espacio (excepto el ocupado 

Por una carga q). El campo eléctrico E es, por lo tanto, una función vectorial de la 

Posición, La fuerza ejercida sobre una carga testigo q, en cualquier punto está rela- 

cionada con el campo eléctrico en dicho punto por 





F =qÉ 21.6 











PROBLEMA PRÁCTICO 21.7 



Cuando se coloca una carga testigo de 5 nC en un punto determinado, sufre la acción de 

una fuerza de 2 X 10* N en la dirección creciente de y. ¿Cuál es el campo eléctrico E en 

dicho punto? 





PROBLEMA PRÁCTICO 21.8 

¿Cuál es la fuerza que actúa sobre un electrón situado en el punto donde el campo eléc- 

trico es E = (4,0 X 101 N/C)/? 

















El campo eléctrico debido a una sola carga Puntual q, en la posición 1, puede cal- 

cularse a partir de la ley de Coulomb. Si situamos una Pequeña carga testigo positiva 

4, en algún punto P a la distancia 1¡p de la carga q, la fuerza que actúa sobre ella es 





=_ Mm. 

Ep = rn ip 

ip 











* Esta definición es semejante ala del campo gravitatorio terrestre, formulada en la sección 4.3 como la fuerza por uni- 

dad de masa ejercida por la Tierra sobre tn cuerpo. 















































SECCIÓN 21.4 | 705 

16) 

Ma 

(A 

Eon 

ñ 

(b) 

FIGURA 21.11 (9) Una pequeña carga 

testigo (o de prueba) q, en las proximidades 





de un sistema de cargas y, y, 9, 

experimenta una fuerza F propor iu:al a q, 

La relación F/q, es el campo eléctrico en esa 

Posición. (b) La carga testigo q, ejerce también 













una fuerza sobre cada una de las 015 cargas 

que le rodean y cada una de estas Iuerzas es 

proporcional a qy. 

















En los cables domésticos 





En las ondas de la radio 





En la atmósfera 102 

En la luz solar 10% 

Bajo una nube tormentosa 101 





En la descarga de un relámpago 10* 

En un tubo de rayos X 108 





En el electrón de un átomo 

de hidrógeno 











En la superficie de un núcleo 

de uranio 2x 

















706 CAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 





El campo eléctrico en el punto P debido a la carga q, (figura 21.12) es, por lo tanto, 





21,7 











LEY DE COULOMB PARA EL CAMPO E 





donde f,, es un vector unitario que apunta desde el punto fuente ¡al punto de ob- 

servación del campo o punto campo P. 

El campo eléctrico resultante debido a una distribución de cargas puntuales se 

determina sumando los campos originados por cada carga separadamente: 

E. = DE 21.8 

CAMPO ELÉCTRICO E DEBIDO A UN SISTEMA DE CARGAS PUNTUALES 





Esto implica que el campo eléctrico satisface el principio de superposición. 











ESTRATEGIA DE RESOLUCIÓN DE PROBLEMAS 

Cálculo del campo eléctrico resultante 





PLANTEAMIENTO Para calcular el campo eléctrico resultante E, en un punto 

P generado por una distribución de cargas puntuales, se debe dibujar, en 

primer lugar, la configuración de las cargas. En el esquema hay que incluir los 

ejes de coordenadas y un punto arbitrario donde se desea calcular el campo. 





SOLUCIÓN 



1. Definir 1,p como el vector que tiene su origen en cualquier carga ¡ y su 

final en el punto P, y E,, como el vector del campo eléctrico generado por 

la carga ¡en el punto P. 



2. Si el punto P y todas las cargas puntuales no están alineados, se deben 

fijar los ángulos que cada vector E ,, forma con los tres ejes. 



3, Determinar las tres componentes de cada vector campo E, ¡p en los ejes 

y calcular las componentes del campo eléctrico resultante E, 





























MEJIA A Dirección del campo eléctrico 











Se coloca una carga positiva q, = +q en un punto del eje x= a, y otra q, = —2q en x =-a, 

tal como muestra la figura 21.13. Dividimos el eje x en tres intervalos: región I (+ < a), 

región II (a < x <a) y región III (x > a) ¿Existe algún punto en estas regiones donde el 

campo eléctrico sea igual a cero? ¿En qué regiones? 





PLANTEAMIENTO Sean E, y E, los campos eléctricos generados por q, y (, respectiva- 

mente. Como q, es positiva, E, apuntará en el sentido de alejamiento de la carga y, como q, 

es negativa, E, apuntará hacia la correspondiente carga q, El campo eléctrico resultante E 

es la suma vectorial de ambos campos (E = E, + E). Por lo tanto, es igual a cero si los 

campos de cada una de las cargas son iguales en módulo y tienen sentidos opuestos. Por 

otro lado, según nos vamos aproximando a dichas cargas, 5us respectivos campos tienden 

a infinito, Además, en puntos muy alejados de ambas cargas, siempre sobre el eje x, el 

campo resultante se aproxima al ejercido por la carga suma de ambas, q, + 9, localizada en 

el punto medio de ambas cargas, siendo un campo debido a una carga negativa, puesto que 

1 + 9, tiene carga resultante negativa. 











Punto campo P 





A 

% Pantofuentei 











FIGURA 21.12 El campo eléctrico É en 

un punto P debido a la carga q, colocada en un 

punto. 











! Aunque la expresión del campo 

eléctrico (ecuación 21.7) depende 

de la localización del punto P, el 

campo no depende, sin embargo, de la 

carga testigo qy; por ello, su valor no 

aparece en la ecuación 21.7, 











Conceptual 

















El campo eléctrico SECCIÓN 21.4 707 











SOLUCIÓN 





1. Enla figura 21.13 se representa la configuración de 

cargas del problema, mostrando las dos cargas sobre 

el eje x, y el campo eléctrico, dibujado en forma 

esquemática, debido a cada una de las cargas en cada 

una de las regiones 1, II y III, denominando los —— Mena! E Región . Región III 

respectivos puntos campo arbitrarios de estas 

regiones como P,, P., y Py. 











P; -a 0 +2 Pm 

















FIGURA 21.13 





2. Analizar en qué puntos, de la región I, los campos son En todos los puntos de la región 1, los dos campos eléctricos tienen sentidos 

iguales en módulo y tienen sentidos opuestos: opuestos, y el módulo E, es mayor que E, por dos razones: porque 

cualquier punto de la región T está más cerca de q, que de q, y, además, el 

valor absoluto de q, es doble que el de q,. En consecuencia, en esta región el 

campo eléctrico resultante no es cero en ninguno de sus puntos. 





3. Analizar en qué puntos, de la región II, los campos En la región II, los dos campos tienen el mismo sentido y, por lo tanto, en 

son iguales en módulo y tienen sentidos opuestos: ningún punto se puede anular la suma de ambos vectores. 



4. Analizar en qué puntos, de la región III, los campos En la región III, los dos campos tiene sentidos opuestos y, en puntos 

son iguales en módulo y tienen sentidos opuestos: Cercanos a x — a, E, es mayor que E, porque en estos puntos próximos a q,, 





E, tiende a infinito. Por el contrario, en puntos alejados, donde +>>, E, 

es mayor que E, porque a grandes distancias de las dos cargas, el sentido 

del campo viene determinado por el que crea la carga suma de ambas q, + 

9». Por consiguiente, habrá algún punto de dicha región en donde el 

campo resultante es igual a cero, puesto que el módulo de E, será en él 

igual al de E, y sus sentidos serán opuestos, por lo que se anularán. 

















COMPROBACIÓN El campo eléctrico resultante se anula en un punto de la región UL. Esta 

anulación se produce porque la carga q, es mayor en módulo, está más alejada de todos los 

puntos de esta región que la q,, y porque las dos cargas son de signo contrario. El resultado 

coincide con lo esperado. 





Campo eléctrico debido a dos cargas positivas en la recta que las une 

















Una carga positiva q, = + 8 nC se encuentra en el origen y una segunda carga positiva q, = 

+12 KC está sobre el eje x a la distancia a = 3 m. Determinar el campo eléctrico resultante 

(a) en el punto A sobre el eje x en x= 6 m y (5) en el punto B sobre el eje xen x =2 m. 





PLANTEAMIENTO Sean E, y E, los campos creados por q, y q, respectivamente. El sen- 

tido del campo É, se aleja de q, y el sentido del campo E, se aleja de q,, por ser ambas car- 

gas positivas. El problema trata de determinar el campo resultante en todos los puntos del 

eje x, mediante la suma vectorial de E = E, + E,. 











SOLUCIÓN H=+8,0nC 

(a) 1. La configuración de las cargas viene dada en la m 

figura 21.14. Se dibujan los campos debidos a L— 











cada una de las cargas en los puntos A y B: 

















FIGURA 21.14 Comog, y q, son cargas positivas, E, y E, apuntan en el 

sentido de alejamiento de las respectivas cargas tanto en A como en B. 





Kg, ENE bd 

= eE 

A 

(8,99 x 10” N-m?/C2X8,0 x 1070) , 4 899 X 10 N -m3/CóX12 x 100); 

- a 

(7.0 mp (3,0 mP 





= (1,47 N/O)í + (12,0 N/C)Í 

















2. Calcular E en el punto A, utilizando 2 ha 

Tia = lx, —x,] =6,0m — (10m) =7,0m y s 





Pan = |x, — x] = 6,0 m — (3,0 m) = 3,0 m: 























708 |  carituLo21 





(b) Calcular E en el punto B, donde 

li = hy — x] = 20m — (-L0 m) = 3,0 m y 

Tay = hy — 1) = [2,0 m — (3,0 m)| = 1,0 m: 





Campo eléctrico l: distribuciones discretas de carga 





Ko, Ka LAS Ka 

yy 



(8,99 x 10? N + m?/C?1(8,0 x 10?C), (8,99 x 10? N -m?/C?)(12 Xx 10-%C), 

= ES i 





(3,0 my (1,0 mP 





= (7,99 N/C)i — (108 N/C)í = 











-i) 























COMPROBACIÓN El campo en la parte (b) es grande en la dirección de las y negativas. Esto 

es así porque el punto B está más cercano de la carga 9, que de la q,, siendo q, (12 nC) la 





mayor de las dos. 





OBSERVACIÓN El campo eléctrico E, predomina en el 

campo resultante en los puntos cercanos a q, = 8 nC. Existe 

un punto entre q, y q, en el que el campo total es cero. Una 

carga testigo puesta en ese punto no experimentaría fuerza 

alguna, En la figura 21.15, se representa E, que es el mó- 

dulo de campo resultante en el eje x, en función de esta co- 





ordenada. 





PROBLEMA PRÁCTICO 21.9 A partir de los datos del 

ejemplo 21.7, localizar el punto del eje x donde el campo 





eléctrico es igual a cero. 





Ejemplo 21.8 











EyN/C 











oo 

















FIGURA 21.15 





Campo eléctrico en puntos del eje y debido 

a cargas puntuales colocadas en el eje x 





Inténtelo usted mismo 





Una carga puntual q, = +8,0nC está situada en el origen y una segunda carga 

q, = +12,0nC en x = 4,0 m. Determinar el campo eléctrico en y = 3,0 m. 





PLANTEAMIENTO Como en el ejemplo 21,7, 

E = E, + E,. El campo eléctrico E, en puntos 

del eje y debido a la carga q, tiene la propia di- 

rección de dicho eje, y el E, debido a q, se en- 

cuentra en el segundo cuadrante del plano. 

Para determinar el vector campo E, lo haremos 

calculando primero por separado sus compo- 

nentes x e y. 

















SOLUCIÓN 





Tape la columna de la derecha e intente 

resolverlo usted mismo. 





Pasos 





1. Enla figura 21.16a, están colocadas las 

cargas en el sistema de coordenadas y se 

propone un punto arbitrario del eje donde 

se dibuja el campo debido a cada una de 

las cargas; se indican las distancias y 

ángulos de forma apropiada. 





Respuestas 

ym 





50m 











q=+12nC 











1 m 

q1=+80nC 1 2 3 4 5 











FIGURA 21.16a 











El campo eléctrico SECCIÓN 21.4 709 





2. Calcular el módulo del campo E, debido aq,enel E, =kkq,/y?=7,99N/C 

punto (0, 3,0 m). Hallar las componentes sobrelos —— É, =0,E, =E,=7,99N/C 

ejes x e y de este campo. F . 





3. Calcular el módulo del campo El, debido a q. E, = 432N/C 



4. Expresar las componentes x e y de E, en función E,, = —E, sen; E,, = E, cos 

del ángulo 0. 



5. Calcular sen 6 y cos 0. send = 0,80; cosé = 0,60 



6. Calcular E,, y Ez, E,, = -3,46N/C; E, = 2,59 N/C 





7. En la figura 21.16b, se dibujan las componentes 

del campo resultante, incluyendo el vector E. y 

el ángulo que forma este vector con el eje x. 











FIGURA 21.16b 

















8. Determinar las componentes x e y del campo E, =E,, +E,, = -346N/C 

resultante E. E, = Ey, + E, = 10,6N/C 



9. Calcular el módulo de E a partir de sus E= VE + E =11,2N/C 

componentes. 





COMPROBACIÓN Tal como era de esperar, el módulo de E es mayor que el de E, y el de E, 

pero menor que la suma de ambos. (Este resultado es lógico porque el ángulo entre E, y E, 

es diferente de cero.) 





10. Determinar el ángulo 9, formado por E con el 

ejex. 

















AROS Campo eléctrico debido a dos cargas del mismo módulo y signo contrario 











Una carga + q se encuentra en x = a y una segunda carga —q en x = —a (figura 21.17). 

(a) Determinar el campo eléctrico sobre el eje x en un punto arbitrario x > a. (b) Determinar 

la forma límite del campo eléctrico para 1>> 0. 





PLANTEAMIENTO Usando el principio de superposición, E, = Ep + Exp, calculamos el 

campo eléctrico en el punto P. Para x > a, el campo eléctrico E, debido a la carga positiva 

tiene la dirección de las x positivas y el E_ debido a la carga negativa la de las x negativas. 

La distancia del punto P a la carga positiva es x — a, y a la carga negativa x — (0) =x +a. 











SOLUCIÓN ii 





(a) 1. La figura 21.17 muestra la distribución de las cargas y 

sus respectivas distancias al punto en el que se mide 

el campo: 





FIGURA 21.17 























710 | CAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 











2 Ms Kg un 

a 1) 





al 





2. Calcular el campo E debido a las dos cargas para x>a: 

(Observación: la ecuación de la derecha es válida sólo para 

x>0.): 























3. Poner los términos incluidos entre corchetes bajo un 

denominador común y simplificar: 





ld 

5-1 (+ a ar ] 

















y dax * ÑAX 2% 

(b) En el límite x>> a, podemos despreciar a? comparado con? É= rar = a H 





y simplificar así el denominador: 2 























COMPROBACIÓN Los dos resultados de los recuadros tienden a cero cuando « tiende a in- 

finito, tal como era de esperar. 





OBSERVACIÓN La figura 21.18 muestra E, en función de x para todo valor de x, para q = 

1 nC y a = 1 cm. Lejos de las cargas, el campo viene dado por 

> Akga, 





170 i  lx>>a 





Entre las cargas, la contribución de cada una de ellas se verifica en la dirección negativa. 

Una expresión válida para todo valor de x es 





E ko. Kg) 





TAR 





=1<x<a 





donde el vector unitario é, tiene el sentido de las x positivas para x mayor o igual que a, y el 

vector é_ el de las x negativas para x menor que a. (Todo ello con la excepción de x = —a,) 





(Obsérvese que é, = 

















x, cm 

3 











FIGURA 21.18 Gráfica de E, versus x 

para la distribución de carga del ejemplo 21.9. 

















DIPOLOS ELÉCTRICOS 





Un sistema de dos cargas iguales y opuestas q separadas por una pequeña distan- 

cia L se denomina dipolo eléctrico. Su intensidad y su orientación se describen me- F 

diante el momento dipolar eléctrico $, un vector que apunta de la carga negativa —_———— p=gL 





a la positiva y cuyo módulo es el producto q (figura 21.19): E 

a 1 =D +1 

P=qL 21.9 

DEFINICIÓN: MOMENTO DIPOLAR ELÉCTRICO FIGURA, 21:48 Da dipoureléctrios 

e consiste en dos cargas iguales y opuestas 

donde L es un vector cuyo origen está en la carga negativa y su extremo en la carga Separadas por una pequeña distancia L. El 

positiva. módulo del momento dipolar es j = qL, 





0 4 . >. A A donde q es el valor absoluto de una de las 

Para la configuración de la figura 21.17, L = 21 y el momento dipolar eléctrico es cargas y L es el módulo del vector posición de 





P=2aqi la carga positiva respecto de la negativa. 

















NE 





Líneas de campo eléctrico SECCIÓN 21.5 711 





En función del momento dipolar j, el campo eléctrico sobre el eje del dipolo en 

un punto a gran distancia |x| posee la dirección y sentido del momento dipolar y su 

magnitud es 



2kp 



Ip 

(Véase el ejemplo 21.9). En un punto alejado de un dipolo en cualquier dirección, el 

módulo del campo eléctrico es proporcional al momento dipolar y decrece con el 

cubo de la distancia. Cuando un sistema tiene una carga neta distinta de cero, el 

campo eléctrico disminuye según 1/1? a grandes distancias. En un sistema con carga 

neta nula, el campo eléctrico disminuye con mayor rapidez con la distancia. En el 

caso de un dipolo eléctrico, el campo disminuye según 1/1 en todas las direcciones. 





E 21.10 





215 





El campo eléctrico puede representarse dibujando líneas que indiquen su dirección. 

En cualquier punto, el vector campo E es tangente a las líneas de campo eléctrico, 

que se llaman también líneas de fuerza porque muestran la dirección de la fuerza 

ejercida sobre una carga testigo positiva. En cualquier punto próximo a una carga 

positiva, el campo eléctrico apunta radialmente alejándose de la carga; por lo tanto, 

cerca de una carga positiva las líneas de campo eléctrico también apuntan alejándose 

de ésta. Igualmente, las líneas del campo eléctrico convergen hacia un punto ocu- 

pado por una carga negativa. 



La figura 21,20 muestra las líneas de campo eléctrico de una sola carga puntual 

positiva. El espaciado de las líneas está relacionado con la intensidad del campo 

eléctrico. A medida que nos alejamos de la carga, el campo eléctrico se debilita y 

las líneas se separan. Consideremos una superficie esférica de radio r con su cen- 

tro en la carga. Su área es 41”. Así, cuando r crece, la densidad de las líneas de 

campo (el número de líneas por unidad de superficie) decrece según 1/1”, es decir, 

del mismo modo que decrece E. Por lo tanto, si adoptamos el convenio de dibujar 

un número fijo de líneas desde una carga puntual, siendo proporcional dicho nú- 

mero a la carga 9, y si dibujamos las líneas simétricamente alrededor de la carga 

puntual, la intensidad del campo vendrá indicada por la densidad de las líneas. 

Cuanto más próximas se encuentran las líneas, más intenso es el campo eléctrico. 



La figura 21.21 muestra las líneas de fuerza para dos cargas puntuales positivas 

iguales, q, separadas por una distancia pequeña. En un punto próximo a una de las 

cargas, el campo es debido prácticamente sólo a esta carga, pues la otra está tan ale- 

jada que podemos despreciar su contribución al campo. En consecuencia, las líneas 

de campo próximas a una cualquiera de las cargas son radiales e igualmente espa- 





DE CAMPO ELEC 











(eo) 











(6) 





(a) 











(b) 











FIGURA 21.20 (a) Líneas de campo 

eléctrico o líneas de fuerza de una sola carga 

puntual positiva. Si la carga fuera negativa, las 

flechas invertirían su dirección. (b) Las 

mismas líneas de campo eléctrico puestas de 

manifiesto por hebras de hilo suspendidas en 

aceite. El campo eléctrico del objeto cargado 

en el centro induce cargas opuestas en los 

extremos de cada trocito de hilo, haciendo que 

se alineen por sí mismos paralelamente al 

campo. (Harold M. Waage.) 











FIGURA 21.21 (0) Líneas 

de campo eléctrico 

correspondientes a dos cargas 

puntuales positivas. Las flechas 

se invertirían si ambas cargas 

fueran negativas. (b) Las líneas 

del mismo campo eléctrico 

puestas de manifiesto con 

hebras de hilo suspendidas en 

aceite, (Harold M. Waage.) 

















712 | CAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 





ciadas. Puesto que las cargas son iguales, dibujaremos un 

número igual de líneas saliendo de cada una de ellas. A una 

distancia muy grande de las cargas, los detalles del sistema 

carecen de importancia y el sistema se comporta como una 

carga puntual de magnitud 24. (Por ejemplo, si las dos car- 

gas estuvieran separadas 1 mm y las observásemos desde 

un punto situado a 100 km, parecerían una carga única.) 

Así, lejos de las cargas, el campo es aproximadamente igual 

que el generado por una carga puntual de magnitud 2q y las 

líneas están igualmente espaciadas, aproximadamente. 

Observando la figura 21.21 podemos deducir que el campo 

eléctrico que existe en el espacio entre las dos cargas es más 

débil, ya que el número de líneas en esta región es muy in- 

ferior al número de líneas que existe a la derecha o a la iz- 

quierda de las cargas, en donde las líneas están más juntas. 

Por supuesto, esta información también puede obtenerse 

mediante el cálculo directo del campo en los puntos de estas — FIGURA 21.22 Existen infinitas líneas de campo que salen de las 











regiones. dos cargas, dos de las cuales son líneas especiales que denominamos 

El razonamiento utilizado en los ejemplos precedentes líneas de campo solitarias. Estas dos líneas deberían terminar en el punto 

puede aplicarse para dibujar las líneas de fuerza de cual- medio de separación entre las dos cargas, donde, al anularse el campo, 





quier sistema de cargas puntuales. En un lugar próximo a Jaslibess dé campo desaparecen: 





cada una de las cargas, las líneas del campo poseen la 



misma separación y según el signo de la carga entran en ella o salen radialmente. 

Lejos de todas las cargas, los detalles de la estructura del sistema no son impor- 

tantes, y las líneas del campo son las mismas que las correspondientes a una única 

carga puntual igual a la carga neta del sistema. Resumimos a continuación las re- 

glas para dibujar las líneas de campo eléctrico. 











ESTRATEGIA DE RESOLUCIÓN DE PROBLEMAS / 





Dibujar líneas de campo 





PLANTEAMIENTO Las líneas de campo eléctrico comienzan en las cargas 

positivas (o en el infinito) y terminan en las negativas (o en el infinito). * (a) 





SOLUCIÓN 



1. Las líneas se dibujan uniformemente espaciadas, y saliendo o entrando en 

la carga. 



2. El número de líneas que abandonan una carga positiva o entran en una 

carga negativa es proporcional al módulo de la carga. 



3. La densidad de líneas (número de ellas por unidad de área perpendicular a 

las mismas) en un punto es proporcional al valor del módulo del campo en 

dicho punto. 



4, A grandes distancias de un sistema de cargas, las líneas de campo están 

igualmente espaciadas y son radiales, como si procediesen de una sola 

carga puntual igual a la carga neta del sistema. 











COMPROBACIÓN No pueden cortarse nunca dos líneas de campo. (Si dos 

líneas de campo se cruzaran, ésto indicaría dos direcciones para E en el punto 

de intersección, lo cual es imposible.) (6) 





























. A ñ 6 FIGURA 21.23 (1) Líneas de 

En la figura 21.23, se muestran las líneas de campo eléctrico para un dipolo cléc- — tn dipolo clésrico (0) Las mismas lagdo 





trico. Muy cerca de la carga positiva, las líneas son radiales y dirigidas hacia fuera. — puestas de manifiesto con hebras de hilo en 

Muy cerca de la carga negativa, las líneas son radiales y dirigidas hacia dentro. — aceite, (Harold M. Waage.) 











* Definimos líneas de campo solitarias como aquellas que no siguen la regla general, ya que salen de cualquiera de las 

cargas positivas, tal como se representa en la figura 21.22, y aunque se dirigen a la otra carga acaban en el punto medio 

de la distancia entre las dos cargas en donde el campo total es nulo. Entre estas dos cargas posítivas existen infinitas l£- 

neas de campo, dos de las cuales son líneas solitarias. 











A 











Líneas de campo eléctrico SECCIÓN 21.5 713 





Puesto que las cargas tienen el mismo valor, el número de 

líneas que empiezan en la carga positiva es igual al número 

de las que terminan en la carga negativa. En este caso, el 

campo es más intenso en la región entre las cargas, como in- 

dica el hecho de que la densidad de líneas del campo en 

esta región sea muy elevada. 



La figura 21.24 muestra las líneas de campo eléctrico 

para una carga negativa —q situada a una distancia pequeña 





> 

de otra positiva +2q. De la carga positiva salen el doble de (a) 

líneas de las que entran en la carga negativa. Es decir, la 

mitad de las líneas que comienzan en la carga positiva +2q 

entran en la carga negativa —q y la otra mitad abandonan el. 

sistema. Muy lejos de las cargas (figura 21.24b), las líneas 

que abandonan el sistema están espaciadas prácticamente 

+ de forma simétrica y apuntan radialmente hacia fuera, como 

si se tratara de una sola carga puntual positiva +9. 

+2q de 

FIGURA 21.24 (a) Líneas de campo 

eléctrico correspondientes a una carga 

puntual + 2q y otra segunda carga puntual 

—q. (b) A grandes distancias de las cargas, 

las líneas son similares a las que se 

obtienen con una sola carga +q localizada 

en el centro del sistema de cargas. (b) 





Ejemplo 21.10 























Líneas de campo eléctrico para l 

dos esferas conductoras Conceptual 





En la figura 21.25 se muestran las líneas de campo correspondientes a dos esferas conducto- 

ras. ¿Cuál es el signo y el valor relativo de las cargas sobre las dos esferas? 

PLANTEAMIENTO La carga sobre una esfera es positiva si salen más líneas que entran, y 

negativa si entran más líneas que salen. La relación de los módulos de las cargas es igual a 

La relación del número neto de líneas que entran o salen. | 

SOLUCIÓN 

1. Contar el número de líneas que Como 11 líneas de campo eléctrico salen de la 



salen de la esfera grande: esfera grande de la izquierda y 3 entran, el 



número neto de líneas que salen es 8. 



2. Contar el número de líneas que De la esfera pequeña salen 8 líneas de campo | 





























salen de la esfera pequeña: eléctrico y ninguna línea acaba en ella; en 

consecuencia, las líneas totales que salen de esta 

esfera son 8. FIGURA 21.25 

3. Determinar el signo de la carga de Dado que de ambas esferas salen más líneas de campo eléctrico de las que entran, 

cada esfera: E 

ambas esferas están cargadas positivamente. 

4. Determinar los valores absolutos Dado que de ambas esferas sale el mismo número total de líneas de campo eléctrico, 





1 : 

dejes cargas delas dos esferas los valores absolutos de las cargas de las dos esferas son iguales. 























714 CAPÍTULO 21 

La relación establecida entre la intensidad del campo eléctrico y las líneas de 

campo eléctrico es válida porque el campo varía en razón inversa con el cuadrado 

de la distancia a una carga puntual. Como el campo gravitatorio de una masa pun- 

tual también varía inversamente con el cuadrado de la distancia, el concepto de lí- 

neas de fuerza también es útil para dibujar el campo gravitatorio. Cerca de una 

masa puntual, las líneas de campo gravitatorio convergen hacia la masa, del 

mismo modo que las líneas de campo eléctrico convergen hacia una carga nega- 

tiva. Sin embargo, no hay puntos en el espacio en donde las líneas del campo gra- 

vitatorio diverjan como lo hacen las líneas de campo eléctrico cerca de una carga 

positiva, pues la fuerza gravitatoria es siempre atractiva y nunca repulsiva, 





VAN] ACCIÓN DEL CAMPO ELÉCTRICO SOBRE 

LAS CARGAS 





Un campo eléctrico uniforme puede ejercer una fuerza sobre una partícula cargada y 

también puede ejercer una fuerza y un momento de ésta sobre un dipolo eléctrico, 





MOVIMIENTO DE CARGAS PUNTUALES EN CAMPOS 

ELÉCTRICOS 





Cuando una partícula con carga q se coloca en un campo eléctrico E, experimenta 

la acción de una fuerza qE. Si la fuerza eléctrica es la única fuerza significativa que 

actúa sobre la partícula, ésta adquiere una aceleración 





SF 

2. 

m m 











siendo 11 la masa de la partícula. (Con frecuencia la velocidad de un electrón en un 

campo eléctrico es una fracción importante de la velocidad de la luz; en este caso, las 

leyes de Newton del movimiento deben sustituirse por la teoría especial de la relati- 

vidad de Einstein.) Si se conoce el campo eléctrico, la relación carga-masa de la partí- 

cula puede determinarse midiendo su aceleración. La desviación de los electrones en 

un campo eléctrico uniforme fue utilizada por J. J. Thomson en 1897 para demostrar 

la existencia de los electrones y para medir su relación carga /masa. El osciloscopio, el 

monitor del ordenador y el tubo de rayos catódicos de un televisor son ejemplos de 

aparatos basados en el movimiento de los electrones en campos eléctricos. 











Ejemplo 21.11 





Un electrón se proyecta en un campo eléctrico uniform E = (1000 N/C)Í con una velocidad 

inicial d, = (2,00 X 10* m/s)í en la dirección del campo (figura 21.26). ¿Qué distancia reco- 

rrerá el electrón antes de que momentáneamente quede en reposo? 











PLANTEAMIENTO Como la carga del electrón es negativa, la fuerza F =—eE que actúa 

sobre él posee un sentido opuesto al del campo. Como E es constante, la fuerza también lo 

es y, por lo tanto, podemos utilizar las fórmulas del movimiento con aceleración constante 

del capítulo 2, Suponemos que el campo tiene la dirección positiva de x. 





Electrón moviéndose paralelamente a un campo eléctrico uniforme 











SOLUCIÓN 





1. El desplazamiento Ax está relacionado con las 

velocidades inicial y final: 





v?=uw +29,Ax 











E —eE, 

2. La aceleración se obtiene de la segunda ley de Newton: o 

m 

2 E 

La 0% 





Campo eléctrico l: distribuciones discretas de carga 

















Dibujo esquemático de un tubo de rayos 

catódicos utilizado en la televisión de color. 

Los haces de electrones procedentes del cañón 

electrónico, a la derecha, activan sustancias 

fosforescentes sobre la pantalla de la 



uierda, dando lugara puntos brillantes 

cuyos colores dependen de la intensidad 

relativa de cada haz. Los campos eléctricos 

establecidos entre las placas deflectoras del 

cañón (o bien campos magnéticos creados por 

bobinas) desvían los haces. Éstos barren la 

pantalla siguiendo una línea horizontal, se 

desvían hacia abajo y barren otra línea. La 

pantalla entera es barrida cada 1/30 s. 

(Gentileza de Hulon Forrester/Video Display 

Corporation, Tucker Georgia.) 



































mi 



































FIGURA 21.26 





mos _ (9,11 x 107 kg)(2,00 x 10* m/s? 











3. Cuando v, = 0, el desplazamiento es: Ax = 





= 1/14 x 10m 





20, — A=cEJm) 





2eE (1,60% 109 CX1000 N/C) 























COMPROBACIÓN EL desplazamiento Ax es positivo, tal como era de esperar para cualquier objeto 





moviéndose en la dirección positiva de las x. 























Acción del campo eléctrico sobre las cargas 





SECCIÓN 21,6 





ELIANA Electrón moviéndose perpendicularmente a un campo eléctrico uniforme 











Un electrón se proyecta en el interior de un campo eléctrico uniform E = (-2,0kN/C)j 

con una velocidad inicial 3), = (1,0 X 10% m/s)í en dirección perpendicular al campo (fi- 

gura 21.27). (a) Comparar la fuerza gravitatoria que existe sobre el electrón con la fuerza 

eléctrica ejercida sobre él. (b) ¿Cuánto se habrá desviado el electrón si ha recorrido 1 cm en 

la dirección 1? 





PLANTEAMIENTO (1) Calcular la relación entre la fuerza eléctrica [E = eE y la fuerza gra- 

vitatoria mg. (b) Como mg es despreciable, la fuerza sobre el electrón es —eE verticalmente 

hacia arriba, El electrón se mueve, por lo tanto, con velocidad horizontal constante n, y se 

desvía hacia arriba una distancia Ay = af”, donde + es el tiempo invertido en recorrer 1 cm 

en la dirección x. 











FIGURA 21.27 











SOLUCIÓN 

F 9 

(a) 1. Calcular la relación entre el módulo de la fuerza a O SI 

eléctrica, F, y el módulo dela fuerza gravitatoria, E; F¿ M8 (911 10" KgJ081N/Kg) 

(b) 1. Expresar la desviación vertical en función de la ay = ae 





aceleración a y el tiempo !: 





2. El tiempo necesario para que el electrón se desplace 

una distancia x con velocidad horizontal constante 9, 

es: 

















0,010 m 











3. Para calcular Ay, usar a= eE/ m, y el valor obtenido Ay 

det: 











En 6 1 (L6 x 1071 C)(2000 N/C) 

22m 5 





9,11 x 10 kg 





( 





10% m/s 





) 











COMPROBACIÓN El resultado del paso 4 es positivo, hacia arriba, como era de esperar 

para un objeto acelerándose hacia arriba y que inicialmente se movía horizontalmente. 





OBSERVACIÓN (a) Como es usual, la fuerza eléctrica es enorme comparada con la fuerza 

gravitatoria. Así, no es necesario considerar la gravedad al diseñar un tubo de rayos ca- 

tódicos, por ejemplo, ni para calcular la desviación del electrón en el ejemplo anterior. De 

hecho, un tubo de imágenes de televisión funciona igualmente bien aunque esté inver- 

tido, como si la gravedad no existiera. (b) La trayectoria de un electrón que se mueve en 

un campo eléctrico uniforme es una parábola, análogamente a la trayectoria de una masa 

que se mueve en un campo gravitatorio uniforme. 











Ejemplo 21.13 





Campo eléctrico en una impresora de inyección 

de tinta 

















Supongamos que acabamos de imprimir un extenso trabajo (para su profesor de inglés). Una 

pregunta que podría surgirnos de inmediato sería cuál es el mecanismo con el que la impre- 

sora coloca la tinta en el lugar apropiado. Realizamos una búsqueda en Internet y encontra- 

mos un esquema similar al de la figura 21.28. En dicho esquema, se muestra que las gotas de 

tinta se cargan y se hacen pasar por el campo eléctrico uniforme generado por dos placas de 

metal que tienen cargas de signos opuestos. Con los conocimientos estudiados en este tema, 

podríamos determinar cuál debe ser el campo eléctrico necesario entre las placas de este tipo 

de impresora. Prosiguiendo un poco más la búsqueda, encontramos que las gotas de tinta, 

de 40 micras de diámetro, tienen una velocidad inicial de 40 m/s, y que cuando una de ellas 

tiene una carga 2 NC se desvía 3 mm hacia arriba en un recorrido entre las placas de 1 cm. 

Determinar el campo eléctrico despreciando los efectos de la gravedad en el movimiento de 

las gotas. 











Póngalo en su contexto 























716 CAPÍTULO 21 Campo eléctrico |: distribuciones discretas de carga 















— Deflector 











1 

1 

1 

E 













a Canal de 7 



7 recuperación 7 

Sistema de carga_--77 Movimiento 

e del cabezal 

¡Fuente presurizada e 

==--de tinta Pulveri-| Ñe 



T==-__ zador 1 ¿añ Señal 



' a” digital de 

entrada 



























FIGURA 21.28 Impresora de inyección 

de tinta. La tinta sale del pulverizador en 

pequeñas gotas bien diferenciadas. A cada una 

de estas pequeñas gotas, que formarán un 

punto en la imagen, se le introduce una 

determinada cantidad de carga. Las placas con 

cargas opuestas constituyen el mecanismo 

para desviar las gotas. Cuanto mayor sea la 

carga adquirida por las gotas mayor será la 

desviación sufrida por las mismas al pasar 

entre las placas. Las gotas que no se desvían 

hacia arriba por no haber adquirido carga se 



















drenan, retornando al depósito de tinta. 

(Gentileza de Videojet Systems International.) 





PLANTEAMIENTO El campo eléctrico E entre las placas ejerce sobre la gota de tinta una 

fuerza eléctrica constante F siendo F = qE. El objetivo es determinar E. La fuerza F queda 

fijada mediante la ley de Newton E = ná. Por cinemática se puede calcular la aceleración, 

y la masa de la gota se puede determinar considerando el valor del radio y sabiendo que la 





densidad de la tinta es de 1000 kg/m, es decir, idéntica a la del agua. 











SOLUCIÓN 





1. El campo eléctrico es igual a la fuerza dividida por la 

carga: 





2. La fuerza, dirigida hacia arriba en el sentido y, es 

igual a la masa por la aceleración: 





3. El desplazamiento vertical se obtiene mediante las 

fórmulas de la cinemática, con aceleración constante 

y velocidad inicial 9, =0: 





4. El tiempo de movimiento horizontal de la gota entre 

las placas es el que tarda en recorrer 1 cm a la 

velocidad de 40 m/s: 





5. Despejando a, se obtiene: 





6. La masa es igual a la densidad por el volumen: 





7. El módulo del campo E viene dado por: 





E= 

F= ma, 





Ay = 0)! + da f=0+ laP 





Ax =0)t = 0)! portanto, 1= Ax/o, 





2Ay  2Ay _26%Ay 





E (Ax/0? (Ap 





m=pV= pinar 











E ma_pjar203dy _ gm projAy 

a 4 q (My 3 qa 

87r (1000 kg/m*)20,0 X 1075 m)'(40,0 m/s)*(3,00 x 10m) 





3 (2,00 x< 107" CX0,0100 mP 









































COMPROBACIÓN Las unidades en la última línea del paso 7 son kg + m/(C+s?). Coincide 





con lo esperado, ya que 1N = 1kg+m/s?. 





OBSERVACIÓN El mecanismo de inyección de tinta de este ejemplo se denomina de des- 

viación múltiple continua. Se usa en algunas impresoras industriales. Las impresoras para 

ordenadores personales no usan este mecanismo de desviación de las trayectorias de las 





gotas cargadas mediante un campo eléctrico. 











Acción del campo eléctrico sobre las cargas SECCIÓN 21.6 717 





DIPOLOS ELÉCTRICOS EN CAMPOS ELÉCTRICOS 





En el ejemplo 21.9, analizamos el campo eléctrico producido por un dipolo, es 

decir, un sistema formado por dos cargas iguales y opuestas muy próximas entre 

sí. Aquí consideramos el comportamiento de un dipolo en un campo eléctrico ex- 

terno. Ciertas moléculas poseen momentos dipolares eléctricos permanentes de- 

bido a una distribución no uniforme de carga dentro de la molécula. Tales 

moléculas se llaman moléculas polares. Un ejemplo es la molécula HCl, formada 

esencialmente por un ion de hidrógeno positivo de carga +e combinado con un ion 

de cloro negativo de carga —e. El centro de carga del ion positivo no coincide con 

el centro de carga del ion negativo, de modo que la molécula posee un momento 

dipolar permanente. Otro ejemplo es el agua (figura 21.29). 



Un campo eléctrico externo uniforme no ejerce una fuerza neta sobre un dipolo, 

pero aparece un par de fuerzas que tiende a alinear el dipolo en la dirección del 

campo. En la figura 21.30, vemos que el módulo del momento de las fuerzas ejer- 

cidas sobre las cargas es F,L sen 9 = qEL sen 6 = pE sen 0.* El momento está diri- 

gido perpendicularmente al papel, hacia dentro, de tal modo que tiende a situar el 

momento dipolar ¡ en la dirección del campo eléctrico E. El momento del par 

puede escribirse convenientemente como el producto vectorial: 





pxE 21.11 











Cuando el dipolo gira un ángulo d6, el campo eléctrico realiza un trabajo 

dW = —rd0 = —pE sen0 d0 





(El signo menos es debido a que el momento tiende a disminuir 6.) Igualando 

este trabajo con la disminución de energía potencial, resulta 





dU = —dW = +pE senó dd 

e integrando, 

U = —pE cos0 + U, 





Si tomamos como cero de energía potencial la que corresponde a 6 = 90”, en- 

tonces la energía potencial del dipolo es 





U = —pEcos0 = —p+ E 21.12 





ENERGÍA POTENCIAL DE UN DIPOLO EN UN CAMPO ELÉCTRICO 





Los hornos de microondas están basados en el momento dipolar eléctrico del 

agua para cocer alimentos. Como todas las ondas electromagnéticas, las microon- 

das poseen campos eléctricos oscilantes que ejercen momentos sobre los dipolos 

eléctricos, provocando que las moléculas de agua giren con una energía cinética ro- 

tacional considerable. De este modo, se transfiere energía desde la radiación de mi- 

croondas a las moléculas de agua de la comida a gran velocidad, gracias a lo cual 

el tiempo de cocción en un horno de microondas se reduce de forma significativa. 



























































* El momento producido por dos fuerzas iguales y opuestas (sistema llamado par) es el mismo alrededor de cualquier 

punto del espacio. 

















FIGURA 21.29 Unamolécula H,O 

posee un momento dipolar eléctrico 

permanente dirigido desde el centro de la 

carga negativa al centro de la carga positiva. 











FIGURA 21.30 Undipolo en un campo 

eléctrico uniforme experimenta fuerzas 

iguales y opuestas que tienden a girar el 

dipolo, de modo que su momento dipolar j 

tiende a alinearse con el campo eléctrico E. 























718 CAPÍTULO 21 



Las moléculas no polares no poseen momento dipolar 

eléctrico permanente. Sin embargo, todas las moléculas neu- 

tras contienen cantidades iguales de carga positiva y nega- 

tiva, En presencia de un campo eléctrico externo E, las cargas 

se separan espacialmente. Las cargas positivas se mueven en 

la dirección de E y las negativas en dirección opuesta. La mo- 

lécula adquiere de este modo un momento dipolar inducido 

paralelo al campo eléctrico externo y se dice entonces que está 

polarizada. 



En un campo eléctrico no uniforme, un dipolo eléctrico ex- 

perimenta una fuerza neta, ya que el campo eléctrico tiene 

módulos distintos en los centros de la carga positiva y nega- 

tiva, La figura 21.31 muestra cómo una carga puntual positiva 

polariza a una molécula no polar y después la atrae, Un ejem- 

plo conocido es la atracción que mantiene un globo electros- 

táticamente cargado pegado contra una pared, El campo no 

uniforme producido por la carga sobre el globo polariza las 

moléculas de la pared y las atrae. Una fuerza igual y opuesta 

se ejerce por las moléculas de la pared sobre el globo. 



El diámetro de un átomo o molécula es del orden de 

107 m = 0,1 nm. Una unidad adecuada para el momento di- 

polar eléctrico de los átomos y moléculas es la carga electró- 

nica fundamental e multiplicada por la distancia de 1 pm, Por 

ejemplo, el momento dipolar del H,O en estas unidades 

posee un módulo de unos 0,04 e - pm. 





Momento de una fuerza debida al 





Ejemplo 21.14 











PLANTEAMIENTO El momento se deduce de la expresión 7 = pp X E 





tencial de U = 











campo eléctrico y energía potencial 





Un dipolo con un momento de módulo 0,02 e - pm forma un ángulo de 20? con un campo 

eléctrico uniforme de módulo 3 x 10% N/C (figura 21.32). Determinar (a) el módulo del 

momento que actúa sobre el dipolo y (b) la energía potencial del sistema. 





Campo eléctrico |: distribuciones discretas de carga 























FIGURA 21.31 Una molécula no polar en un campo eléctrico no 

uniforme creado por una carga puntual +0. La carga puntual atrae a 

las cargas negativas (los electrones) de la molécula y repele a las 

positivas (los protones). Como resultado de este hecho, el centro de 

"gravedad" de la carga —q está más próximo a la carga +Q que lo que 

está la carga positiva +q, y como consecuencia se induce un momento 

dipolar j/ paralelo al campo creado por la carga puntual +0. Como —q 

está más próximo a +0 que +q, F, es mayor que F, y la molécula es 

atraída por la carga puntual. Además, si la carga puntual fuera 

negativa, el dipolo inducido sería el inverso y la molécula sería 

también atraída por la carga puntual. 































y la energía po- 

















































FIGURA 21.32 





SOLUCIÓN 

1. Calcular el módulo del 7= |p x E| = pEsenó = (20 e» pm)X(3 < 10* N/CXsen 20) 

momento: = (0,021(1,6 x 10719 CX10-9m)(3 x 10% N/Clsen 209) 

=|33x 107N-m 

2. Calcular la energía U=-p+E= -—pEcos0 

potencial: —(0,02X1,6 x 10719 CX10-? m)(3 X 10” N/C)cos 20" 























COMPROBACIÓN El signo de la energía potencial es negativo. Esto es así porque la orien- 

















tación de referencia de la función energía potencial U = 





p*EesU =0 para 0 = 907. Para 





6 = 20? la energía potencial es menor que cero. El sistema tiene más energía potencial si 





0 = 20" que cuando 0 = 90”. 











Temas de actualidad en Física — | 719 





ETT de actualidad en Física 





Recubrimiento industrial con polvo electrostático 











Los niños de todo el mundo se han beneficiado de las pro- 

piedades triboeléctricas. La empresa americana Ohio Art 

Company lanzó al mercado el grabador de dibujos “Etch A 

Sketch” alrededor de 1960.! Las cuentas de “stirene” proveen 

de carga al polvo fino de aluminio cuando se agita. La pan- 

talla translúcida del juguete atrae al polvo cargado y con un 

punzón o estilo se puede dibujar trazando líneas sobre el 

polvo. El juguete se basa en que la pantalla y el polvo de alu- 

minio se atraen mutuamente por tener cargas opuestas. 



Aunque el polvo cargado puede ser un juguete, también 

puede servir para actividades industriales serias. Los meta- 

les tienden a corroerse si no se les proporciona protección. 

Para prevenir la corrosión, las partes metálicas de los auto- 

móviles, aparatos metálicos y otros objetos de metal deben 

ser recubiertas. En el pasado, estos recubrimientos se realiza- 

ban mediante lacas, barnices y esmaltes que se aplicaban en 

forma líquida y se dejaban secar. Estos líquidos tienen incon- 

venientes.? Los disolventes tardan tiempo en secarse y ema- 

nan fluidos volátiles indeseables. Las superficies con 

protuberancias se suelen recubrir de forma no uniforme. Los El polvo fino es atraído hacia el reverso de la pantalla por efecto 

pulverizadores producen residuos que no son fáciles de reci-— electrostático. Girando los botones se hace desaparecer el dibujo por 

clar. El recubrimiento con polvo electrostático reduce todos una pequeña barrita. (Gentileza de The Ohio Art Company.) 

estos problemas.* Este método de recubrimiento se usó por 

primera vez en la década de 1950, y actualmente es muy utlizado por los fabricantes, cada vez más comprometidos en cum- 

plir los convenios medioambientales de reducción de emisión de productos químicos volátiles. 



El polvillo protector se aplica suministrándole una carga eléctrica al objeto que se ha de recubrir.* Esto es mucho más fácil si el 

objeto a recubrir es conductor. Entonces, partículas? muy pequeñas de polvo, entre 1 um y 100 um, adquieren cargas de signo 

opuesto. Estas partículas son atraídas por el objeto que se desea cubrir, de tal forma que las partículas que quedan sueltas son fá- 

cilmente reciclables. Cuando las partículas ya están en el objeto, se fija el recubrimiento mediante luz ultravioleta o con tratamiento 

térmico, El tratamiento de fijado inmoviliza las moléculas del polvo protector y las partículas entonces pierden sus cargas. 



Las partículas se cargan mediante una descarga de corona o mediante un proceso de carga triboeléctrico.$ La descarga de co- 

rona insufla las partículas a través del plasma electrónico cargándolas negativamente. El proceso de carga tribológico aplica las 

partículas a través de un tubo construido de un material que está en el extremo opuesto del espectro triboleléctrico; con frecuen- 

cia se utiliza teflón. A las partículas de recubrimiento se les suministra carga positiva mediante un contacto rápido. Al objeto que 

hay que recubrir se le suministra carga cuyo signo depende del procedimiento seguido para recubrirlo. En función del recubri- 

miento y de los aditivos, las cargas que se suministran a los objetos varían entre 500 y 1000 .C /kg.” El proceso de fijación depende 

del material utilizado en el recubrimiento y del objeto a recubrir. El tiempo de fijado puede durar entre 1 y 30 minutos. 



Aunque el polvo del recubrimiento es económico y preserva el medio ambiente, presenta algunos inconvenientes. La capa- 

cidad de las partículas del polvo protector para mantener la carga? depende de la humedad, la cual deberá ser cuidadosamente 

controlada.!” Si el campo eléctrico creado por la descarga de corona es demasiado fuerte, el polvo se lanza demasiado rápida- 

mente hacia el objeto a recubrir, dejando motas al descubierto en el centro de círculos que dan un aspecto de “peladura de na- 

ranja”.!! El polvo electrostático puede ser juego de niños, pero también puede servir para complejos procesos de producción. 























* Grandjean, A., “Tracing Device.” ULS. Patent No. 3,055,113, Sept. 25, 1962. 



* Matheson, R. D, “20th to 21st-Century Technological Challenges in Soft Coatings.” Science, Aug, 9, 2002, Vol. 297, No. 5583, pp. 976-979. 



* Hammerton, D., and Buysens, K., “UV-Curable Powder Coatings: Benefits and Performance.” Paint and Coatings Industry, Aug, 2000, 



+ Zeren, S., and Renoux, D,, “Powder Coatings Additives.” Paint and Coatings Industry, Oct. 2002, p. 116. 



* Hemphill, R,, “Deposition of BaTiO, Nanoparticles by Electrostatic Spray Powder Charging.” Paint and Coatings Industry, Apr. 2006, pp. 74-78. 



* Cayzak, 5. ., and Williams, D, T,, “Static Electrification of Solid Particles by Spraying.” Science, Jul. 20, 1951, Vol 14, pp. 66-68. 



7 Zeren, 5,, and Renoux, D., op. 



* Hammerton, D,, and Buysens, K,, op. cit. 



* O'Konski, C. T., “The Exponential Decay Law in Spray De-electrification.” Science, Oct. 5, 1951, Vol. 114, p. 368. 



"Sharma, R, et al, “Effect of Ambient Relative Humidity and Surface ín Modification on the Charge Decay Properties of Polymer Powders in Powder Coating.” IEEE Transactions on 

Industry Applications, Jan. /Feb. 2003, Vol. 39, No. 1, pp. 87-95. 



% Wostratzky, D,, Lord, 5., and Sitzmann, E. V, “Powert” Paint and Contings Industry, Oct. 2000, p. 54. 





a 























































720 | CAPÍTULO 21 





Campo eléctrico l: distribuciones discretas de carga 





Resumen HA 





TEMA 





1. Cuantización y conservación son propiedades fundamentales de la carga eléctrica. 



2. La ley de Coulomb es la ley fundamental de la interacción entre las cargas en reposo. 



3. El campo eléctrico describe la condición establecida en el espacio por una distribución de 

cargas. 





OBSERVACIONES Y ECUACIONES RELEVANTES 











1. Carga eléctrica 





Existen dos clases de carga eléctrica, llamadas positiva y negativa. Cargas del mismo signo 

se repelen y de signo contrario se atraen, 











Cuantización 





La carga eléctrica está cuantizada: siempre se presenta por múltiplos enteros de la unidad 

fundamental de carga e. La carga del electrón es —e y la del protón +e. 











Magnitud 





e= 1,60 x 10C 











Conservación 





La carga se conserva, es decir, en cualquier proceso, la carga ni se crea ni se destruye; sim- 

plemente se transfiere, 











2. Conductores y aislantes 





En los conductores, aproximadamente un electrón por átomo posee libertad de movimiento 

en todo el material, En los aislantes, todos los electrones están ligados a los átomos próximos. 











Tierra 





Así se llama un conductor muy extenso que puede suministrar una cantidad ilimitada de 

carga (tal como el suelo terrestre). 











3. Carga por inducción 





Carga de un conductor por inducción. Se conecta a tierra el conductor, y se mantiene una 

carga externa cerca de él para atraer o repeler electrones de conducción. Seguidamente, se 

desconecta el conductor de tierra y, por último, se aleja la carga externa del conductor. 











4, Ley de Coulomb 





La fuerza ejercida por una carga q, sobre q, a una distancia 7, , viene dada por 





y kh 

BL 21.4 











la 

. 

donde f,, es un vector unitario dirigido de q, a 9. 











Constante de Coulomb 





k= 8,99 X 10% N -m?/C? 213 











5. Campo eléctrico 





El campo eléctrico debido a un sistema de cargas en un punto se define como la fuerza neta 

E, ejercida por aquellas cargas sobre una carga testigo positiva qy dividida por qy; 





21.5 











Debido a una carga puntual 





Ss 

Ep = he 





21.7 











Debido a un sistema de cargas puntuales 





El campo eléctrico debido a varias cargas es la suma vectorial de los campos debidos a las 

cargas individuales: 





E,- E» 218 











$ 





Líneas de campo eléctrico 





El campo eléctrico puede representarse mediante líneas del campo eléctrico o de fuerza que 

se originan en las cargas positivas y terminan en las cargas negativas. La intensidad del 

campo eléctrico viene indicada por la densidad de las líneas de fuerza. 











Sy 





Dipolo eléctrico 





Un dipolo eléctrico es un sistema de dos cargas iguales, pero opuestas, separadas por una 

distancia pequeña. 











Momento dipolar 





P=JL 219 





donde L apunta de la carga negativa a la positiva. 











Campo debido a un dipolo 





El campo eléctrico en un punto alejado de un dipolo es proporcional al momento dipolar y 

disminuye con el cubo de la distancia. 











Momento sobre un dipolo 





En un campo eléctrico uniforme, la fuerza neta que actúa sobre un dipolo es cero, pero existe 

un momento 7 dado por 





7=pxE 21.11 

















TEMA 





Energía potencial de un dipolo 





A A Y 





Problemas 721 





OBSERVACIONES Y ECUACIONES RELEVANTES 





U=-p-E+U, 21.12 





donde LI, suele considerarse nulo. 











8. Moléculas polares y no polares 





Las moléculas polares, tales como HO poseen momentos dipolares permanentes, ya que en 

ellas no coinciden los centros de la carga positiva y negativa. Se comportan como simples di- 

polos en un campo eléctrico. Las moléculas no polares careceh de momentos dipolares per- 

manentes, pero adquieren momentos dipolares inducidos en presencia de un campo eléctrico. 





-_E-ERÑ | 











Respuestas a las comprobaciones 

conceptuales 





21.1 (a) +20. Como las esferas son idénticas, deberán com- 

partir la carga total a partes iguales. (b) +20, que es 

necesario para satisfacer la conservación de la carga. 





21.2 Q, = +Q/2,Q, = -Q/4, y Q,= -Q/4 





Respuestas a los problemas prácticos 





211 N = Q/e = (50 X 109 C)/(1,6 x 1079 C)=3,1 x 1011, 

Ñ La cuantización de la carga no se puede detectar en 



una carga de esta dimensión; incluso añadiendo o qui- 



tando un millón de electrones no se produce un efecto 





apreciable. 

212 Alrededor de 3,5 X 10" por ciento 



213 2,25 x 107 N 



21.4 +(6,3 uN)í 



215 ho = (+ J/V2 



216 No, pero supongamos que así fuera: como la compo- 





nente x de 7, es menor que el módulo de 7, ,, tal deno- 

minador de kq,q,/3, es menor que el de kq,9p/1%,. Esto 

implicaría que la componente x de E, es mayor que el 

módulo de F,y, lo cual es imposible porque la compo- 

nente de un vector nunca puede ser mayor que su mó- 

dulo. En consecuencia, la componente x de la fuerza 













F,y = (Kg,9p/17p)í, y no es necesariamente igual a 

Eros H000/ o: E 



217 E = F/q) = (4,0 x 10'N/0)í 



218 F= (6,4 x 10-15N)Í 



21.9 x= 1,80 m 





Problemas a 





En algunos problemas se dan más datos de los realmente 

necesarios; en otros pocos, deben aportarse algunos datos a 

partir de conocimientos generales, fuentes externas o 

estimaciones lógicas. 





En los datos numéricos sin coma decimal se deben 

considerar significativos todos los dígitos, incluidos los 

ceros a la derecha del último diferente de cero. 





+ Concepto simple, un solo paso, relativamente fácil 

Nivel intermedio, puede exigir síntesis de conceptos 





Desafiante, para alumnos avanzados 











La solución se encuentra en el Manual de soluciones 





Los problemas consecutivos que están sombreados son 

problemas relacionados. 











PROBLEMAS CONCEPTUALES 

¡€_xIOOÓKAAAX,á=>> 





a; » Los objetos se componen de átomos que a su vez están com- 

puestos de partículas cargadas (protones y electrones); sin embargo, es 

rara la ocasión en la que se observa la fuerza electrostática, Explicar por 

qué no se suelen observar estos efectos. 





2 + Un átomo de carbono se convierte en ion si se le quitan uno o 

más electrones en un proceso de ionización ¿Cuál es la carga del átomo 

de carbono al que se le han quitado dos de sus electrones? (a) +e. (b) —e. 

(6) +2. (d) —2e. 



3. ** En una clase de Física, se realiza un experimento con el que, 

aparentemente, se refuta la ley de Coulomb. Se pasa un peine de goma o 

caucho por el pelo y después se observa cómo atrae pequeñas trocitos de 

papel. Entonces, quien hace la experiencia argumenta que la ley de 





Coulomb establece que para que haya fuerzas electrostáticas de atracción 

entre dos objetos, ambos tienen que estar cargados. Sin embargo, el papel 

no lo estaba y, por consiguiente, de acuerdo con la ley de Coulomb, no de- 

bería haber fuerzas atractivas entre el peine y el papel como claramente 

existían en la demostración. (a) ¿Qué hay de erróneo en esta argumenta- 

ción? (b) ¿Es necesario para que exista fuerza de atracción entre papel y 

Peine que éste tenga carga neta negativa? Explicar las respuestas. 





4_ ++ Setienen dosesferas metálicas y una barra de aislante cargada 

positivamente sobre una mesa. ¿Cómo se puede utilizar la barra para in- 

ducir sobre las esferas carga negativa? ¿Y positiva? 





5 +» Dos partículas cargadas de +4q y —3g se encuentran a una 

distancia d. Dibujar las líneas de campo en (a) las proximidades del sis- 

tema, y (b) puntos localizados a distancias de las cargas mucho mayores 

qued. 























722 CAPÍTULO 21 Campo eléctrico l: distribuciones discretas de carga 





5 +*s Secarga positivamente una esfera metálica. ¿Es posible que 

ésta atraiga a una bola cargada positivamente también? Razonar la res- 

puesta. 





7 ++ Se puede hacer una simple demostración de la fuerza atrac- 

tiva electrostática haciendo oscilar una bola de papel de aluminio arru- 

gada colgando de una cuerda y acercando una barrita cargada cerca de 

la bola. Inicialmente, la barra atraerá a la bola, pero si la bola toca a la 

barra, ésta la repelerá bruscamente. Explicar todo ello. 





8 ** Secoloca una carga puntual positiva en Y = 0,00 y otra igual 

,00 m, ambas sobre el eje x. Se pone una tercera carga puntual y 

positiva en una posición de equilibrio. (a) ¿Cuál es esa posición? (b) ¿Es 

estable dicho equilibrio si la tercera carga queda obligada a moverse, en 

su caso, paralela al eje 17 (c) ¿Y si la carga estuviera constreñida a mo- 

verse a lo largo del eje y? Explicar las respuestas. 

















9 +» Dosesferas conductoras sin carga con sus superficies con- 

ductoras en contacto, están apoyadas sobre una gran tabla de madera 

bien aislada. Una barra cargada positivamente se aproxima a una de las 

esferas por el lado opuesto a su punto de contacto con la otra esfera, 

(a) Describir las cargas inducidas sobre las dos esferas conductoras y re- 

presentar las distribuciones de carga sobre ellas. (b) Las dos 

alejan entre sí y la barra cargada se separa. Dibujar las distribuciones de 

carga sobre las esferas separadas. 























10) + Trescargas, +9, +Q y q 

=Q, se sitúan en los vértices de 



un triángulo equilátero, como 



muestra la figura 21.33. (a) ¿Cuál 



es la fuerza neta sobre la carga 



+q debida a las otras dos cargas? 



(0) ¿Cuál es la fuerza neta total 



del sistema de tres cargas? 

















" »+ Una carga positiva es 



libre de moverse en una región 



donde hay un campo eléctrico E. 



¿Cuáles de estas afirmaciones 



son ciertas? 



(a) La partícula se acelerará enla 

dirección perpendicular al campo E. 



(b) La partícula se acelerará en la dirección paralela al campo E. 



(c) Se moverá en la dirección del campo E. 



(4) Podría estar momentáneamente en reposo. 



(e), La fuerza que recibe la partícula es opuesta a la dirección del campo E. 



(P) La partícula se moverá en dirección opuesta al campo E. 











+Q -Q 





FIGURA 21.33 Problema 10 





12 ++ Sicuatrocargas están lo- 

calizadas en los vértices de un cua- 

drado, como indica la figura 21.34, 

el campo É es cero en: 





+9 





(a) Todos los puntos situados 

sobre los lados del cuadrado 

que están a mitad de camino 

entre las dos cargas. 

(6) El punto central del cuadrado. — +9 4 

(c) El punto a mitad de camino 

entre las dos cargas superiores y FIGURA 21.34 Problema 12 

en el punto a mitad de camino 

entre las dos cargas inferiores. 





13 ++ Dos partículas cargadas de + y —3g se separan una dis- 

tancia d. Dibujar las líneas de campo (a) en la proximidades del sis- 

tema y (b) en puntos localizados a distancias de las cargas mucho 

mayores que d. «eme 





14 + Tres cargas puntuales positivas están fijas en los vértices 

de un triángulo equilátero de lado a. El origen de coordenadas está 

en la mitad de un lado de un triángulo, el centro del triángulo en 





x= x, y el vértice opuesto al origen en x = x,. (a) Expresar x, y x, en 

función de a. (b) Dar una expresión del campo eléctrico en el eje x en 

el intervalo entre 0 y x,. (c) Demostrar que la expresión obtenida en 

(b) da los resultados esperados para x = 0 y x 











15 — ** Una molécula de momento dipolar eléctrico f está orientada 

de modo que ¿) forma un ángulo Y con un campo eléctrico uniforme E. El 

dipolo puede moverse libremente en respuesta a la fuerza ejercida por el 

campo. Describir el movimiento del dipolo. 





16  *» Verdadero o Íalso: 



(a) El campo eléctrico de una carga puntual tiene un sentido siempre 

de alejamiento de la carga. 



(b) La fuerza eléctrica sobre una partícula cargada en un campo eléc- 

trico tiene siempre el mismo sentido que el campo. 



(c) Las líneas de campo eléctrico nunca pueden cortarse en un punto 

del espacio. 



(d) Todas las moléculas poseen momentos dipolares eléctricos en 

presencia de un 

campo eléctrico (2) (o) 

externo. 











w  ** Dos molé- 

culas tienen momentos 



dipolares cuyos módu- 1 1 

los son iguales y cuyas 

orientaciones se mues- 

tran en la figura 21.35, 3 3 

Determinar la direc- (0) (d) 



ción del campo eléc- 



trico en cada uno de 

los puntos numerados 

en la figura. "ese 





























FIGURA 21.35 

Problema 17 























ESTIMACIONES Y APROXIMACIONES 











18 +» Hacer una estimación de la fuerza requerida para enlazar dos 

protones en un núcleo de helio. Ayuda: considerar los protones como cargas 

puntuales haciendo una estimación aproximada de la separación de ambos. 



19 — »» Una conocida demostración práctica consiste en frotar con 

un trozo de piel una varilla (mágica?) de plástico con objeto de cargarla, 

y seguidamente acercarla a una lata vacía (ver figura 21.36). Explicar 

por qué la lata rodará hacia la barra. : 





FIGURA 21.36 

Problema 19 

















20 +» Las descargas eléctricas (chispas) se producen en el aire 

cuando un campo eléctrico acelera los iones libres hasta velocidades su- 

ficientemente altas como para ionizar las moléculas de un gas mediante 

su impacto con ellas, (a) Asumiendo que cada ion, en promedio, se des- 

plaza en el gas un espacio denominado recorrido medio libre antes de cho- 

car con una molécula y que este ion necesita, aproximadamente, 1 eV de 

energía para poder ionizarla, estimar la intensidad del campo necesaria 

















para producir la rotura dieléctrica del aire, a una presión y temperatura 

de 105 N/m? y 300 K, respectivamente. Considerando que el área de la 

sección trasversal de una molécula de nitrógeno es de 0,1 nm, (b) ¿cómo 

variará el potencial de rotura dieléctrica con la temperatura? ¿Y con la 

presión? 





CARGA ELÉCTRICA 











21 + Al frotar una barra de plástico con un paño de lana, aquella 

adquiere una carga de —0,8 p¿C. ¿Cuántos electrones se transfieren del 

paño de lana a la barra de plástico? 





22 * Una carga igual a la de un número de Avogadro (N, = 

6,02 X 10”) de protones se denomina un faraday. Calcular el número de 

coulombs que hay en un faraday. 





23 * ¿Cuáleslacarga total de todos los protones de 1,00 kg de 

carbono? ss 





24 — ** Suponer un cubo de aluminio de 1,00 cm de lado que 

acumula una carga neta de +2,50 pC. (a) ¿Cuál es el porcentaje de 

electrones que se ha eliminado? (b) ¿Qué porcentaje de masa se le ha 

extraído? 





25  ** Duranteun proceso denominado efecto fotoeléctrico, se utiliza 

luz altravioleta para cargar una pieza de metal. (a) Si esa luz incide en 

una lámina de metal y los electrones son extraídos con suficiente ener- 

gía como para que salgan de la superficie del metal, ¿cuánto tiempo tar- 

dará éste en adquirir 1,5 nC si son extraídos 1,00 X 10* electrones por 

segundo? (b) Si se necesitan 1,3 eV para extraer un electrón de la super- 

ficie, ¿que potencia debe tener el rayo luminoso asumiendo que en todo 

el proceso la eficiencia es del 100%? 





LEY DE COULOMB 











25 * Unacargaq,= 40 1C está en el origen y otra carga q, 

6,0 ¡LC está sobre el eje x en el punto x = 3,0 m. (a) Hallar la fuerza ejer- 

cida sobre la carga 9,- (b) Hallar la fuerza ejercida sobre q,. (c) ¿En qué 

diferirán estas respuestas, (a) y (b), si q, vale —6,0 p.C? 

















6. pC está 

6.0 y está en 





27 + Tres cargas puntuales están en el eje x; 9, 

enx= 3,0 m, q, = 4,0 4C está en el origen y q, 

0 m. Hallar la fuerza ejercida sobre q,. ser 

















20 Dos cargas puntuales de 2 y 4 C, respectivamente, están 

separadas una distancia L. ¿Dónde se debería poner una tercera 

carga para que la fuerza eléctrica sobre ella fuera nula? 





29) == Dos cargas puntuales de —2 y 4 C, respectivamente, están 

separadas una distancia L. ¿Dónde se debería poner una tercera carga 

para que la fuerza eléctrica sobre ella fuera nula? 





30 ** Tres cargas, cada una de módulo 3 nC, están en los vértices de 

un cuadrado de lado 5 cm. Las dos cargas de los vértices opuestos son po- 

sitivas y la otra es negativa. Determinar la fuerza ejercida por estas cargas 

sobre una cuarta carga q, = + 3 nC situada en el vértice restante, 











a Una carga de 5 ¡¿C se encuentra sobre el eje y en y =3 cm y 

una segunda carga de —5,0 ¡C está sobre el eje y en y = -3 cm. 

Determinar la fuerza ejercida sobre una carga de 2 C situada sobre el 

ejexenx=8cm. 

















2 Una carga puntual de —2,5 ¡C está localizada en el origen. 

Una segunda carga puntual de 6 ¿C se encuentra en y=1 m, y = 0,5 m. 

Determinar las coordenadas x e y de la posición en la cual un electrón 

estaría en equilibrio. 





33  ** Una carga de —1,0 yC está localizada en el origen, una se- 

gunda carga de 2,0 4C está localizada en x = 0, y =0,1 m y una tercera 











Problemas 723 





de 4,0 4C en x=0,2 m, y = 0. Calcular las fuerzas que actúan sobre cada 

una de las tres cargas. 





34 ** Una carga de 5/0 pC está localizada en x = 0, y =0. Otra 

carga q está localizada en x = 4,0 cm, y =0. La fuerza que actúa sobre una 

carga de 2 4C en x= 8,0 cm, y = 0 es 19,7 N, apuntando en la dirección 

x negativa. Cuando esta carga de 2 1 se sitúa en x= 17,75 cm, y =0, la 

fuerza que actúa sobre ella es nula. Determinar el valor de la carga q. 











3 / +.» Cinco cargas iguales — Y 

Q están igualmente espacia- 



das en un semicírculo de 



radio R como indica la fi- 



gura 21.37. Determinar 



la fuerza (en función 



de k, Q y R) quese Qi 



ejerce Sobre una ls 

carga q localizada 

equidistante de las 

otras cargas en el Q 

centro del semicír- 

culo. ee 











Q 

FIGURA 21.37 

Problema 35 Q 





35 **= Laconfiguración de la molécula de amoníaco (NH) es, apro- 

ximadamente, la de un tetraedro regular con tres iones H* formando la 

base y un ion N- en el vértice del tetraedro. La longitud de cada lado es 

1,64 X 1071 m. Calcular la fuerza que actúa sobre cada ion. 





EL CAMPO ELÉCTRICO 











Ej * Una carga de 4,0 C está en el origen. ¿Cuál es el módulo 

y sentido del campo eléctrico sobre el eje x en (4) x = 6 m y (b) x = 

—10 m? (c) Hacer un esquema de la función E, respecto a x tanto 

para valores positivos como negativos de x. (Recuérdese que E, es 

negativo cuando E señala en el sentido negativo de las x.) "sen? 





38 + Doscargas puntuales, cada una de ellas de +4 4C, están 

sobre el eje x, una en el origen y la otra en x= 8 m. Hallar el campo 

eléctrico sobre el eje x en (a) x =—2 m, ()x =2 m, (c)x =6m y 

(d) x = 10 m. (e) ¿En qué punto del eje x es cero el campo eléctrico? 

(f) Hacer un esquema de E, en función de x en el intervalo 

—30m<x< 11m. 

















39 +» Cuando se coloca una carga testigo q, = 2 NC en el origen, 

experimenta la acción de una fuerza de 8,0 X 107*N en la dirección po- 

sitiva del eje de las y. (a) ¿Cuál es el campo eléctrico en el origen? 

(b) ¿Cuál sería la fuerza que se ejercería sobre una carga de 4 nC sic 

tuada en el origen? (c) Si esta fuerza fuera debida a una carga situada 

sobre el eje y en y =3 cm, ¿cuál sería el valor de dicha carga? 





40 * LaTierratiene un campo eléctrico cerca de su superficie que 

es de, aproximadamente, 150 N/C y que está dirigido hacia abajo. 

(a) Comparar la fuerza eléctrica ascendente ejercida sobre un electrón 

con la fuerza gravitatoria dirigida hacia abajo. (D) ¿Qué carga debería 

suministrarse a una moneda de 3 g para que el campo eléctrico equili- 

brase su peso cerca de la superficie de la Tierra? 





41 ++ Doscargas iguales positivas de valor q, = q, = 6,0 nC están 

sobre el eje y en puntos y, = + 3 cm e y, = —3 cm. (a) ¿Cuál es el valor 

y sentido del campo eléctrico sobre el eje y en x = 4 cm? (b) ¿Cuál es la 

fuerza ejercida sobre una tercera carga q, = 2 NC situada en el punto 

x=4cm? se 



42 — *=* Unacarga puntual de + 5 C está localizada en x = —3,0 cm 

y una segunda carga puntual de —8 ¡LC está localizada en x = + 4,0 cm. 

¿Dónde debe situarse una tercera carga de 6 4C para que el campo eléc- 

trico en x = O sea cero? 

















724 CAPÍTULO 21 





43 +» Unacarga puntual de —5 yC está localizada en x =4 m, y = 

—2 m. Una segunda carga puntual de 12 C está localizada en x =1m, 

y = 2 m. (a) Determinar el módulo, la dirección y el sentido del campo 

eléctrico en x= —1 m, y = 0. (p) Calcular el módulo, la dirección y el 

sentido de la fuerza sobre un electrón situado en x= —1m, y = 0. 





as ++ Dos cargas positivas iguales q están en el eje y; una está en 

y = y la otra en y = —a. (a) Demostrar que el campo eléctrico en el eje 

x está dirigido a lo largo de dicho eje con E, = 2kqx/(4 + ay”. 

(b) Demostrar que en las proximidades del origen, donde x es mucho 

menor que a, E, = 2kqx/a. (c) Demostrar que para x mucho mayor que a, 

E, = 2kq/x”. Explicar por qué debería esperarse este resultado incluso 

antes de ser calculado. 





45 +» Unacarga puntual de 5 C está localizada en x = 1 m, y = 

3 m y otra carga de —4 ¿¿C está localizada en x =2m, y =-2m. 

(a) Determinar el módulo, la dirección y el sentido del campo eléctrico 

1 m. (b) Determinar el módulo, la dirección y el sen- 

tido de la fuerza sobre un protón en x =—3 m, y = 1 m. 























46 ** DoscargasQ puntuales positivas están en y = +a y en y = —a. 

(a) Demostrar que el campo eléctrico para la distribución de cargas tiene 

su máximo valor en los puntos x= a/V2 y x= —a/VZ calculando 

0E,/0x y haciendo la derivada igual a cero. (6) Hacer un esquema de la 

función E, en función de x utilizando los resultados del apartado (a) de 

este problema y considerando que E, es, aproximadamente, 2kgx/a* 

cuando x << a, y que E, es, aproximadamente, 2kg/x” cuando x>> 4. 





41. ++ Dos partículas puntuales con carga q cada una de ellas se 

colocan en la base de un triángulo equilátero de lado L (figura 21.38). 

Una tercera partícula puntual de carga 2q se coloca en el otro vértice 

¿Dónde deberíamos colocar una cuarta carga puntual q para que el 

campo eléctrico en el centro del triángulo fuera cero? (El centro está 

en el plano del triángulo y equidistante de los tres vértices.) "wswe 





29 





FIGURA 21.38 

Problemas 47 y 48 — 9 q 





49 »+ Dos partículas puntuales con carga q cada una de ellas se 

colocan en la base de un triángulo equilátero de lado £ (figura 21.38). 

Una tercera partícula puntual de carga 2q se coloca en el otro vértice, 

Se coloca una cuarta carga puntual q' en el punto medio de la base, de 

tal forma que la carga eléctrica en el centro del triángulo es cero. ¿Cuál 

es el valor de q/? (El centro está en el plano del triángulo y equidis- 

tante de los tres vértices.) 





49 ++ Dos cargas positivas iguales +q están en el eje y; una de ellas 

en y = +a y la otra en y = —a. El campo eléctrico se anula en el origen. 

Una carga de prueba q, situada en el origen estará por lo tanto en equi- 

librio, (a) Estudiar la estabilidad del equilibrio para una carga de prueba 

positiva considerando desplazamientos pequeños del equilibrio a lo 

largo del eje x y desplazamientos pequeños a lo largo del eje y. (b) Repetir 

el apartado (1) para una carga de prueba negativa. (c) Hallar el valor y 

signo de una carga q, que puede situarse en el origen de modo que la 

fuerza neta sobre cada una de las tres cargas sea cero. (d) Explicar qué 

ocurre si cualquiera de las cargas se desplaza ligeramente del equilibrio. 





so  *+** Dos cargas puntuales positiva +q están sobre el eje y en y = 

+a e y = —a. Una cuenta de collar de masa 1 con una carga negativa —q 

se desliza sin rozamiento a lo largo de una cuerda situada sobre el eje x. 

(a) Demostrar que para pequeños desplazamientos x << a, la cuenta ex- 

perimenta una fuerza de restitución proporcional a x, y que, por lo 

tanto, experimenta un movimiento armónico simple. (b) Determinar el 

periodo del movimiento. 





Campo eléctrico |: distribuciones discretas de carga 





MOVIMIENTO DE CARGAS 

PUNTUALES EN CAMPOS ELÉCTRICOS 











51 + La aceleración de una partícula en un campo eléctrico de- 

pende de la relación carga / masa de la partícula. (a) Calcular e/m para 

un electrón. (b) ¿Cuál es el módulo y dirección de la aceleración de un 

electrón en un campo eléctrico uniforme de valor 100 N/C? (c) Cuando 

la velocidad de un electrón se aproxima a la velocidad de la luz c, debe 

utilizarse la mecánica relativista para determiner su movimiento; sin 

embargo, a velocidades bastante menores que c puede utilizarse la me- 

cánica newtoniana, Calcular, con la mecánica de Newton, el tiempo 

que tarda un electrón, partiendo del reposo en el interior de un campo 

eléctrico de valor 100 N/C, en alcanzar una velocidad de 0,01 c. 

(d) ¿Qué distancia recorrerá el electrón en este tiempo? «espe 





52» Laaceleración de una partícula en un campo eléctrico de- 

pende de su relación carga/masa. (a) Calcular e/m para un protón y 

hallar su aceleración en un campo eléctrico uniforme de valor 100 

N/C. (b) Hallar el tiempo que tarda un protón inicialmente en reposo 

en dicho campo en alcanzar la velocidad de 0,01c (siendo c la veloci- 

dad de la luz). (Cuando la velocidad del protón se aproxima a la de la 

luz, debe usarse la cinemática relativista para calcular el movimiento; 

sin embargo, para una velocidad 0,01c o menor, la cinemática clásica es 

tuna suficiente aproximación.) 





53 + Un electrón tiene una velocidad inicial de 2 < 10% m/s en la 

dirección del eje de las x. Entra en el interior de un campo eléctrico uni- 

forme E = (300 N/C)j que tiene la dirección y. (a) Hallar la aceleración 

del electrón. (b) ¿Cuánto tiempo tardará el electrón en recorrer 10 cm en 

la dirección x? (c) ¿Cuál será el módulo y la dirección de la desviación 

del electrón después de haber recorrido 10 cm en la dirección 12 





54 ++ Unelectrón, partiendo del reposo, se acelera por la acción de 

un campo eléctrico uniforme E = 1,50 x 107% N/Cj. Después de que 

el electrón recorra 1,0 jam, ¿cuál es su velocidad? (Despreciar la fuerza 

gravitacional sobre el electrón.) 





55 ++ Unamasade2 g localizada en una región de campo eléctrico 

uniforme E = (300 N/C)í contiene una carga O. La masa, liberada del 

reposo en y = 0, posee una energía cinética de 0,12 J en x = 0,50 m. 

Determinar la carga O. 

















ss ++ Una partícula sale del origen con una velocidad de 3 X 10% 

m/s, formando un ángulo de 35" con el eje x. Se mueve en un campo eléc- 

trico constante E = —E),¡. Determinar E, para que la partícula cruce el eje 

xen x= 1,5 cm si (a) se trata de un electrón y (b) es un protón. 





(57) +» Unelectrón parte de la posición indicada en la figura 21.39 

con una velocidad inicial 4, = 5 X 10% m/s formando un ángulo de 

45 con el eje x. El campo eléctrico tiene la dirección y positiva y su 

módulo es de 3,5 X 10* N/C. ¿Sobre qué placa y en qué lugar chocará 

el electrón? mm 

















? 





il 

my 

y 





45” 

-e 





FIGURA 21.38 Problema 57 





58  ** APLICACIÓN A LA INGENIERÍA Un electrón cuya energía 

cinética es 2 X 10716 ] se mueve hacia la derecha a lo largo del eje de 

un tubo de rayos catódicos, como se indica en la figura 21.40. En la 

región comprendida entre las placas deflectoras existe un campo 

eléctrico de valor E = (2,00 X 10! N/C)j. Fuera de esta región, 

E =0. (a) ¿A qué distancia del eje del tubo se encuentra el electrón 























cuando alcanza el extremo de las placas? (b) ¿Con qué ángulo res- 

pecto al eje se mueve el electrón? (c) ¿A qué distancia del eje se en- 

cuentra el electrón cuando choca contra la pantalla fluorescente? 





pcs deflectoras 





FIGURA 21.40 

Problema 58 











DIPOLOS 











5 + Dos cargas puntuales q, = 2,0 pC y q, = 2,0 pC están sepa- 

radas por una distancia de 4 mm. (4) ¿Cuál es el momento dipolar de este 

par de cargas? (b) Hacer un dibujo del par e indicar la dirección y sentido 

del momento dipolar. 





so * Undipolodemomento05e- nm se coloca en el interior de un 

campo eléctrico uniforme de valor 4,0 X 10*N/C. ¿Cuál es el valor del mo- 

mento ejercido sobre el dipolo cuando (a) el dipolo es paralelo al campo 

eléctrico, (D) el dipolo es perpendicular al campo eléctrico, y (c) el dipolo 

forma un ángulo de 30? con el campo eléctrico? (d) Determinar la energía 

potencial del dipolo en el campo eléctrico en cada caso. 





PROBLEMAS GENERALES 











61 + Demostrar que solamente es posible colocar un único protón 

aislado en una taza de café vacía (asumir que el protón se fija en el fondo 

de la taza). Para ello, determinar a qué distancia de este protón debería- 

mos poner un segundo protón para que se mantuviera en equilibrio este 

último. Comparar esta distancia con la profundidad de una taza ordina- 

ria de café para completar el razonamiento. sspr. 





62 +» Se colocan tres cargas puntuales de —5,00, +3,00 y 5,00 C 

sobre el eje x en los puntos x = —1,00 em, x=0 y x= +1 cm, respecti- 

vamente. Calcular el campo eléctrico en el eje x para x = 15 cm. ¿Hay 

puntos en el eje x donde el módulo del campo eléctrico es cero? Si esasí, 





¿qué puntos son? 























52 +» Secolocan dos cargas puntuales de —5 y +5 ¿Cen el eje x, en 

los puntos x = —1,00 cm y x = +1,00 cm, respectivamente. (a) Calcular 

la intensidad del campo eléctrico en x = 10,00 cm. (b) Estimar la intensi- 

dad del campo eléctrico en x = 10,00 em considerando el sistema de car- 

gas como un dipolo localizado en el origen y usando la equación 21.10, 

E = 2kp/|x[*. Comparar este resultado de (b) con el obtenido en (a) y ex- 

plicar las razones de la diferencia entre ambos resultados. 





a-=-0— 0 

+9 +29 % +49 





FIGURA 21.41 Problema 64 





654 es Trescargas, +q,+2g 

y + 4q, están conectadas por 

cuerdas del modo indicado en la 

figura 21.41. Determinar las ten- 

siones T, y 











es  +**s Unacarga positiva Q ha de dividirse en dos cargas positivas 

3: Y 9; Demostrar que, para una separación dada D, la fuerza ejercida por 

una carga sobre la otra es máxima si q, = q, =10. "sete 





ss  ** Unacarga Q está localizada en x = 0 y otra carga 4Q se en- 

cuentra en x = 12,0 cm. La fuerza ejercida sobre una carga de —24C es 

cero si ésta se encuentra en x = 4,0 cm, y es 126,4 N en la dirección po- 

sitiva de x si se sitúa en y = 8,0 cm. Determinar la carga Q. 



Unr 











Problemas 725 





67  ** Dos pequeñas esferas (cargas puntuales) separadas por una 

distancia de 0,60 m tienen una carga total de 200 ¿.C. (a) Si las dos esfe- 

ras se repelen entre sí con una fuerza de 80 N, ¿cuáles son las cargas de 

cada una de las esferas? (b) Si las dos esferas se atraen mutuamente con 

una fuerza de 80 N, ¿cuáles son las cargas de cada una de las esferas? 





68 +» Unabola de carga conocida q y masa desconocida im, inicial- 

mente en reposo, cae libremente desde una altura /1 en un campo eléc- 

trico uniforme E dirigido verticalmente hacia abajo. La bola choca 

contra el suelo a una velocidad v = 2Vgh. Determinar 1 en función de 

E-qy 8: 



ss =* Unabarra rígida de 1 m de largo puede girar alrededor de un 

pivote colocado en su centro (figura 21.42). Se coloca una carga q, de 

5 X 1077 C en un extremo de la barra y, a una distancia d = 10 em sobre la 

vertical y por debajo, se coloca otra carga q, igual en valor absoluto pero 

de signo opuesto. (a) ¿Cuál es la fuerza neta entre las dos cargas? (b) ¿Cuál 

es el momento de la fuerza con respecto al centro de la barra? (c) Como 

contrapeso de la fuerza de atracción entre las dos cargas se cuelga un blo- 

que a 25 cm del pivote en el lado opuesto de las cargas, obteniéndose el 

equilibrio en la balanza. ¿Qué masa 1 deberá tener el bloque?/(d) Si se co- 

loca el bloque a 25 cm pero en el mismo brazo de la balanza que la carga, 

manteniéndose los mismos valores de q, y d, ¿qué nuevo valor deberá 

tener q, para mantener la balanza en equilibrio? "este 











50 cm 25 cm 











pe L 

10cm %h AP 

e > 





FIGURA 21.42 Problema 69 





zo  +** Dos cargas de y 

3,0 1C están localizadas en 

x=0y=20myenx=0, 



y = —2,0 m. Otras dos cargas 



Q están localizadas en x 

40m,y=20myenx=4,0, 

y = 2.0 m (figura 21.43). El 

campo eléctrico en x = 0, 

y = 0 es (40 x 10N/OJí. 

Determinar Q. 











Osouc Oo 























O30ne Oo 





FIGURA 21.43 

Problema 70 











m ++ Dos cargas puntuales tienen una carga total igual a 

200 uC y están separadas 0,600 m. (a) Determinar la carga de cada 

una si se repelen con'úna fuerza de 120 N. (b) Calcular la fuerza 

sobre cada carga si tienen cada una 100 4C. "sen 





72 »» Dos cargas puntuales tienen una carga total igual a 

200 ¡.C y están'separadas 0,600 m. (a) Determinar la carga de cada 

una si se atraen con una fuerza de 120 N. (b) Calcular la fuerza sobre 

cada carga si tienen cada una 100 C. "seme 





73 +** Una carga de —3,0 1C está localizada en el origen; una se- 

gunda carga de 4,0 4C está localizada en x= 0,2 m, y = 0; y una tercera 

carga Q está situada en x = 0,32 m, y = 0. La fuerza que actúa sobre la 

carga de 4,0 C es 240 N, en dirección x positiva. (a) Determinar la carga 

Q. (b) Con esta configuración de tres cargas, ¿en qué punto a lo largo de 

la dirección x el campo eléctrico es cero? 





























726 CAPÍTULO 21 Campo eléctrico l: distribuciones discretas de carga 





%4) ++ Dos pequeñas esferas de masa 1 

están suspendidas de un punto común me- 

diante cuerdas de longitud L. Cuando cada una 

de las esferas tiene una carga q, cada cuerda 

forma un ángulo 0 con la vertical, como indica la 

figura 21.44. (1) Demostrar que la carga q viene 

dada por q = 2L sena V(mg/k) tg 0 donde k es 

la constante de Coulomb. (b) Determinar q si 

m= 10 g, L= 50 cm y 0 = 10%. 





75 +=» (a) Supongamos que en el problema 

74, L= 1,5 m, m = 0,01 kg y q = 0,75 mC. ¿Cuál 

es el ángulo que cada cuerda forma con la verti- 

cal? (b) Determinar el ángulo que cada cuerda 

forma con la vertical si una masa tiene una carga 

de 0,50 4C y la otra una carga de 1,0 4C. 











FIGURA 21.44 

Problema 74 











7 Cuatro cargas del mismo valor están 



dispuestas en los vértices de un cuadrado de lado 



L, según se ve en la figura 21.45. (a) Hallar el módulo, dirección y sentido 

de la fuerza ejercida sobre la carga situada en el vértice inferior izquierdo 

por las otras cargas. (b) Demostrar que el campo eléctrico debido a las cua- 

tro cargas en el punto medio de 



uno de los lados del cuadro está 1 (O) 

dirigido a lo largo de dicho lado 

hacia la carga negativa y que su 

valor Ees 





























FIGURA 21.45 Problema76 +1 Ó 9) 

71 ** La figura 21.46 muestra una palanqueta formada por dos 



masas idénticas m sujetas a los extremos de una barra delgada (sin 



masa) de longitud a con un pivote en su centro, Las masas transportan 



las cargas + q y —q, y el sistema está localizado en un campo eléctrico 



uniforme E. Demostrar que para valores pequeños del ángulo 0 



entre la dirección del dipolo y el campo eléctrico, el sistema ejecuta 



un movimiento armónico simple y deducir la expresión del periodo 



de este movimiento. «sem 





E 





FIGURA 21.46 

Problemas 77 y 78 

















'a la palanqueta de la figura 21.46, sea 1 = 0,02 kg, 

4 = 03 m y E = (600 N/C)i. Inicialmente, la palanqueta está en re- 

poso y forma un ángulo de 60? con el eje x. Se deja entonces en liber- 

tad y cuando está momentáneamente alineada con el campo eléctrico, 

su energía cinética es 5 X 107? J, Determinar el módulo de Q. 

















19  ** Unelectrón (carga —e, masa 11) y un positrón (carga + e, masa 

11) giran alrededor de su centro común de masas bajo la influencia de su 

fuerza atractiva de Coulomb. Determinar la velocidad v de cada partícula 

en función de e, m, k y su separación L. "ssp 





so *** Secoloca un péndulo simple de 1,0 m de longitud y 5 X 103 kg, 

de masa en un campo eléctrico uniforme E que se dirige verticalmente 

hacia arriba, La "lenteja" del péndulo tiene una carga de 8,0 C. El pe- 

riodo del péndulo es 1,2 s. Determinar el módulo y la dirección del 

campo eléctrico. 



81  *** Una pequeña masa (puntual) n de carga q está restringida a 

moverse verticalmente dentro de un cilindro estrecho y sin rozamiento 

(figura 21.47). En el fondo del cilindro hay una masa puntual de carga Q 





la 





de igual signo que q. (a) Demostrar que la masa mi 

estará en equilibrio a una altura y, = (KgQ/mg)'/ 4 

(b) Demostrar que si la masa m es desplazada lige- 



ramente de su posición de equilibrio y se deja en 



libertad ejecutará un movimiento armónico sime 



ple de frecuencia angular w = (2/4) 

















2 *** Dos moléculas polares neutras se | 

atraen entre sí. Supongamos que cada una de | 

ellas posee un momento dipolar ¡/ y que estos di- 1 | 



polos están alineados a lo largo del eje x y se Hg O 

tados una distancia d. Deducir una expresión F1Gura 21.47 

para la fuerza de atracción en función dep yd. — Problema 81 











83 +++ Dos cargas positivas iguales Q se en- 

cuentran sobre el eje x en y = la y x = —La. (a) Obtener una expresión 

para el campo eléctrico en función de y sobre el eje y. (b) Una bolita de 

masa 11, y carga q, se mueve sobre una barra delgada y sin rozamiento 

a lo largo del eje y. Determinar la fuerza que actúa sobre la carga q en 

función de y; determinar el signo q para que esta fuerza apunte siempre 

alejándose del origen. (c) La bolita esta inicialmente en reposo en el ori- 

gen, Si se le da un pequeño impulso en la dirección +y, ¿cómo se mo- 

verá la bolita en el instante en el que la fuerza es máxima, considerando 

despreciable la fuerza gravitatoria? 

















0 Un núcleo de oro está a 100 fm (1 fm = 10715 m) de un protón 

en reposo, Cuando se libera el protón, adquiere una velocidad debida a 

la repulsión que le produce la carga del núcleo de oro, ¿Cuál es la veloci- 

dad del protón a grandes distancias (considerar que la distancia es infi- 

nita) del núcleo? (Asumir que el núcleo de oro permanece fijo.) 











85 «es Durante el famoso experimento de Ernest Rutherford en 

1919, se lanzaron núcleos de helio doblemente ionizados (las denomina- 

das partículas er) contra una lámina de oro. Se descubrió que toda la masa 

de un átomo estaba prácticamente en el núcleo. Suponer que durante 

este experimento, una partícula ar lejos de la lámina tiene una energía ci- 

nética de 5,0 MeV. Si se dirige la partícula er hacia un núcleo de oro de la 

lámina y la única fuerza que actúa sobre él es la fuerza eléctrica de re- 

pulsión entre la partícula y el núcleo de oro, ¿cuánto se acercará la partí- 

cula ar al núcleo antes de retroceder debido a la repulsión entre ambos? 

Es decir, ¿cuál es la mínima separación entre las centros de la partícula ar 

y el núcleo de oro? "seme 





























ss +». En el experimento de Millikan, que permite determinar la 

carga del electrón, una microesfera de poliestireno se carga y se deja caer 

libremente en el aire, interaccionando con un campo eléctrico vertical co- 

nocido. La microesfera se acelera en la dirección del campo hasta que al- 

canza la velocidad límite, de tal forma que su carga queda determinada 

por esta velocidad. En este experimento cada pequeña esfera tiene un 

radio de 5,5 X 1077 m y el campo tiene una intensidad de E =6 x 101N/C. 

La fuerza de resistencia del aire sobre la esfera es F, = 67ry ru, donde v es 

la velocidad la esfera, y la viscosidad del aire (y =1,8 X 10? N - s/m?), 

y la densidad del poliestireno es de 1,05 X 10" Kg/m:. (a) Si el campo eléc- 

trico está dirigido hacia abajo y la velocidad límite con la que sube la es- 

fera es v = 1,16 X 10**, ¿cuál es el valor de la carga de la esfera? (b) ¿Cuál 

es el exceso de electrones en la misma? (c) Si se cambia la dirección del 

campo, manteniendo su módulo, ¿cuál será la velocidad límite? 





87  *** Enel problema 86, se describe el experimento de Millikan con 

objeto de determinar la carga del electrón. En este experimento, mediante 

una fuente de alimentación (conmutable), se puede cambiar el sentido del 

campo eléctrico manteniendo su módulo, de tal forma que es posible 

medir las velocidades límites de la microesfera cuando éstas tienen, de 

forma alternada, el mismo sentido y el opuesto al de la fuerza de grave- 

dad. Si v, y 1, son las velocidades límite en sentido ascendente y descen- 

dente, respectivamente, y v = v, + 0,, demostrar que v = qE/(3n 1), 

donde q es la carga neta de la microesfera. ¿Qué ventajas aporta el método 

de medir las dos velocidades, », y v,, con respecto al de medir una sola? 

Las variaciones de la velocidad v se producen en saltos discretos Av, de- 

bido a que la carga está cuantificada. Utilizando los datos del problema 

86, calcular Av, sw 









































Campo eléctrico ll: 

distribuciones 

continuas de carga 





211 Cálculo del campo eléctrico E mediante la ley de Coulomb 

222 Ley de Gauss 





223 Cálculo del campo eléctrico E con la ley de Gauss utilizando la 

simetría 





224 Discontinuidad de E, 

225 Carga y campo en la superficie de los conductores 

*225 Equivalencia de la ley de Gauss y la ley de Coulomb en Electrostática 











escala microscópica, la carga eléctrica está cuantificada. Sin embargo, con 

frecuencia se presentan situaciones en las que un gran número de cargas 

están tan próximas que la carga total puede considerarse distribuida en el 

espacio de forma continua. El concepto de densidad de carga continua 

para describir una distribución de un gran número de cargas discretas, es 

semejante al concepto de densidad de masa continua. 



Además de distribuciones de carga continua, analizamos la importancia 

de la simetría en la determinación del campo eléctrico. Los avances matemáticos de 

Carl Friedrich Gauss demostraron que el campo eléctrico mantiene las propiedades 

simétricas. El conocimiento de las propiedades de simetría de las distribuciones de 

carga facilita en muchos casos la determinación del campo eléctrico que crean. 











En este capítulo, veremos algunos ejemplos del uso de la ley de Coulomb para 

hallar el campo eléctrico debido a diversos tipos de distribuciones continuas 

de carga. Después, introduciremos la ley de Gauss, que relaciona el campo 

eléctrico que existe sobre una superficie cerrada con la carga neta incluida 

dentro de la superficie, y utilizaremos esta relación para calcular el campo eléc- 

trico en ciertas distribuciones de carga que tienen un alto grado de simetría. 





727 











Los RELÁMPAGOS SON FENÓMENOS ELÉCTRICOS. 

CUANDO SE PRODUCE UN RAYO, SETRANSFIEREN 

CARGAS ENTRE LAS NUBES Y LA TIERRA. EL 

DESTELLO LUMINOSO SE PRODUCE PORQUE 

MOLÉCULAS DE AIRE QUE ESTABAN EN ESTADOS 

EXCITADOS CAEN A ESTADOS DE MÁS BAJA 

ENERGÍA. (Photo Disc.) 











¿Cómo podríamos calcular la carga 





en la superficie de la Tierra? 

(Véase el ejemplo 22.15.) 





























728 | CAPÍTULO 22 Campo eléctrico ll: distribuciones continuas de carga 





"JAN CÁLCULO DEL CAMPO ELÉCTRICO E 

MEDIANTE LA LEY DE COULOMB 





La figura 22.1 muestra un elemento de carga dq = p dV suficientemente pequeño 

para que podamos considerarlo como una carga puntual. El elemento infinitesimal 

de carga dq es la cantidad de carga contenida en el volumen dV y p es la carga por 

unidad de volumen. El campo eléctrico dE en un punto del campo P debido a este 

elemento de carga viene dado por la ley de Coulomb: 











dE =dE, =>? 22.1a 





donde $ es un vector unitario que apunta desde el elemento a dicho punto, y dE, 

que es la componente de dE en la dirección de ? viene dada por k dq /1”. El campo 

total en P se determina integrando esta expresión para la distribución de la carga 

completa. Es decir, 





= for = E da 22.10 





CAMPO ELÉCTRICO DEBIDO A UNA DISTRIBUCIÓN CONTINUA DE CARGA 





Considerar distribuciones de carga continuas para describir un gran número de 

cargas puntuales es similar a la descripción del aire como una distribución de 

masa continua aunque se sabe que está constituido por moléculas. En ambos 

casos, se define un elemento de volumen AV que es suficientemente grande para 

contener gran cantidad de partículas cargadas pero suficientemente pequeño 

como para reemplazar AV por un diferencial de V, dV, usando el cálculo diferen- 

cial sin introducir error. Si la carga se distribuye en una línea o en una superficie, 

se utiliza dq = o dA o dq = A dL y se integra a toda la superficie o línea. (En estos 

casos, a” y A son carga por unidad de área o longitud, respectivamente.) Normal- 

mente, la integración se hace expresando F en coordenadas cartesianas e inte- 

grando componente a componente. 











ESTRATEGIA DE RESOLUCIÓN DE PROBLEMAS 

Cálculo de E utilizando las fórmulas 22.1a y 22.1b 





PLANTEAMIENTO Hacer un diagrama de la configuración de cargas junto 

con un punto genérico P denominado punto de campo que es donde se 

calcula el campo. Además, en este dibujo se señalará un incremento de carga 

dq en un punto arbitrario de la fuente de campo S. 





SOLUCIÓN 



1. Poner los ejes coordenados en el dibujo. Elegir los ejes considerando 

cualquier propiedad de simetría de la distribución de carga. Por ejemplo, 

si la carga se distribuye a lo largo de una línea recta, se selecciona esta 

línea como uno de los ejes. Se dibuja un segundo eje que pase por el 

punto P, se señala la distancia r entre los puntos P y S, y se define un 

vector unitario F cuya dirección va desde el punto S hacia el P. 



2. Para calcular el cámpo eléctrico E usando la ecuación 22.10, la expresión 

dE =dE,F se desarrolla por componentes. La componente y de dEes 

dE,= dE, P¡= AE, cos6, donde 0 es el ángulo entre £ y í (ver figura 22.2) 

y la componente y de dE esdE, = dE, F=j = dE, senó. 























* La componente de un vector en una dirección dada es igual al producto escalar del vector por el vector unidad en esta 

dirección. El producto escalar se analiza en la sección 6.3. 











FIGURA 22.1 Unelemento de carga dq 

produce un campo dE = (Kkdq/r)é en el 

punto P. El campo en P debido a la carga 

total se obtiene integrando esta expresión 

para toda la distribución de carga. 











/, donde 4 es el ángulo 



entre $ y ¡.* La componente y y la 

componente z se calculan de forma 

similar. 























Cálculo del campo eléctrico E mediante la ley de Coulomb— SECCIÓN 22.1 729 





3. Expresar E en la ecuación 22.1b en términos de sus componentes x e y. 





kdq 

= far,- f át,coso= J al cosg 

















2 

J J e 

E,= | dE,= | dE,sen0 = | ——sen8 



y y r e] 





4. Para calcular E,, expresar, según sea el caso, dq como p dV o a dV o A dL 

e integrar. Para calcular E, se sigue el mismo procedimiento que el usado 

para la componente x. 





5. Los argumentos de simetría se utilizan para demostrar que una o más 

componentes de E son cero. (Por ejemplo, en 22.5 se usa un argumento de 

simetría para demostrar que E, =0.) 





COMPROBACIÓN Si la distribución de carga se localiza en una región del 

espacio finita, la expresión del campo eléctrico en puntos alejados de la 

distribución de carga se considerará con respecto al centro de la distribución. 

Cuando existe simetría, la posición de dicho centro se determina por simple 

observación del dibujo. 























Determinar el campo eléctrico en un punto arbitrario P debido a un segmento recto de lon- 

gitud L y carga Q uniformemente distribuida cuya densidad es Q/L. 





PLANTEAMIENTO Se toma como eje y la recta que contiene a la varilla, la cual está entre 

X= X, Y X= X, y se toma como eje y aquel que pasa por el punto P. Sea y la distancia radial 

de P al eje x. Se determina el campo E en P, calculado sus componentes por separado. Utili- 

zando la ecuación 22.1, primero determinamos dE en P debido a un incremento arbitrario dq 

de la distribución de carga. A continuación, se calcula la integral de cada componente ex- 

tendida al espacio de la distribución completa. Como Q está uniformemente distribuida, la 

densidad de carga lineal A es Q/L. 

















SOLUCIÓN 





1. Dibujar la configuración de la carga del sistema, un punto arbitrario P, el eje x 

conteniendo al segmento, y el eje y que pasa por el punto P. Señalar un incremento 

arbitrario de longitud centrado en un punto $ del segmento (localizado en 5) que 

tenga longitud dx, y carga dq. Dibujar el vector dE suponiendo dq positivo (figura 22.2): 











2. E=E,¡ + E,j. Obtener las expresiones para dE, dE =dE,? 

y dE, en términos de dE, y 9, donde dE, esla 

componente de dE en la dirección del vector que 





une $ con P: 





entonces, tenemos que 





3. Primero se resuelve E,. Expresar dE, usando la 

ecuación 21.1a, donde r es la distancia desde el 

punto fuente S hasta el punto P. En la figura 22.2 

se puede ver que cos0 = |x,|/r = —x,/r. Además, 

se tiene que dq = Adx;; 











entonces, tenemos que 











dq kcos0 Adx, 

0d = 

A 

















m3 











4. Integrar el resultado del paso 3: dE / Er a 





AS 











El campo eléctrico debido a una línea cargada de longitud finita 











Véase el 

Apéndice de matemáticas 

para mayor información sobre 





Trigonometría 

















FIGURA 22.2 Geometría para el 

cálculo del campo eléctrico en un punto P 

creado por un segmento con densidad de 

carga lineal uniforme. 





























730 CAPÍTULO 22 





5. Hacer un cambio de variable, pasando de x, a 9. 

A partir de la figura 22.2, hallar la relación entre x, y 0 

y entre r y 6: 





6. Diferenciar el resultado del paso 5 para obtener la 





Campo eléctrico Il: distribuciones continuas de carga Í 



















A por tanto, x¿= pS —Yp cotO 

S: tg0 

Yo Ye 

0=*E, portanto, r="- 

seng==E,  portanto, r= 20 

d cotó 

dx = —yp Sa = y» csct0 do 





expresión de dx, y tener presente que el punto P es 

fijo y, por tanto, y, es constante: 











7. Sustituir y, cs%0 d0 por dx, e y,/senó por ren la 





integral del paso 4 y simplificar: y A ln, 





8. Resolver la integral y despejar E.; 

E 











f cos6 dx, ñ cosO yy eso do 1 

.  Yi/sento 





*cos0 do = Ptseno, — sen) = p(Y- de) 

y Yo 





% 

= =/ cosó de 





0) 

A WU, +0) 























(2-2) (1, > 0yr, > 0) 





UN 





9. Se puede determinar E, de forma análoga, con el E = 

método usado en los pasos 3-7 (ver el problema a 

22.21): 





10.Combinar los pasos 8 y 9 para obtener el campo 

eléctrico completo en P: 























cotO, cotó, 

cost, — cos0,) = ol se ) +0) 

» 





da Le 











COMPROBACIÓN Considerar el plano perpendicular al segmento y que pasa por su cen- 

tro. Por simetría vemos que el campo E, = 0 en todos los puntos de este plano. En todos 

los puntos de este plano r, = 1, El resultado del paso 8 da E, = 0 sir, = 1, como era de 

esperar. 





OBSERVACIÓN La primera expresión de E, del paso 9 es válida para cualquier punto en 

el plano xy menos en el eje x. Las dos cotangentes en la expresión de E, son: 











coto, == y coto, = 



Y Y 

y ninguna de estas dos funciones tiene valor finito en el eje x, donde y, = 0. La segunda 

expresión para E, del paso 9 se obtiene usando la ecuación 22,1a, Considerando que, en el 

eje x, ? = +í, podemos ver en la ecuación 22.1 que dE = +dEf, lo cual implica que E, = 0, 











PROBLEMA PRÁCTICO 22.1 Usar la expresión de E, obtenida en el paso 8 para demostrar 

que E, >0 en todos los puntos del eje x para x < xy. 





El campo eléctrico en un punto P en el eje z debido a la varilla uniformemente car- 

gada de la figura 22.3 viene dado por E = El k+ Ex R, donde 

















1 

nen, sed) (o = 5] (+0) y(r,40) 2220 

R a Ta 

cotó, cotó, 

cost, - cos6),) = ol q a) (R40) 22.2b 

2 1 





Estas ecuaciones se pueden deducir del ejemplo 22.1. Las expresiones para E, 

(ecuación 22.2a) son indefinidas en los extremos del segmento y las expresiones de 

Ez (ecuación 22.2b) son indefinidas en todos los puntos del eje z, donde R =0. Sin 

embargo, Ex = 0 en todos los puntos en los que R = 0. 























FIGURA 22.3 Campoeléctrico debido a 

una varilla fina uniformemente cargada. 

















Cálculo del campo eléctrico E mediante la ley de Coulomb 











y 





Sea una carga Q uniformemente distribuida a lo largo del eje z entre los puntos  = —L y 

z = +3L. Demostrar que para puntos del eje z alejados, la expresión del campo eléctrico se 

aproxima a la de una carga puntual Q colocada en el origen. 





PLANTEAMIENTO Usar la ecuación 22.2a para demostrar que para valores grandes de 2, la 

expresión del campo eléctrico del segmento de carga se aproxima al que crea una carga puntual 

colocada en el origen. 











SOLUCIÓN 





1. El campo eléctrico en el eje z tiene solamente la 

componente z, cuya expresión es la dada en la 

ecuación 22.20: 





2. Dibujar el segmento cargado. Colocar en el eje z el punto P donde se calcula el campo, y 

















sEccIÓN 22.1 | 731 





E producido por una línea cargada finita en puntos alejados de la carga 





Q Es 





PE . 

z 

” 

1 =2+3L 1,=2-3L 











FIGURA 22.4 Geometría para el 

cálculo del campo eléctrico sobre el eje de 

una carga lineal uniforme de longitud L, 

carga Q y densidad de carga lineal 4 = 

Q/L. 











3. Sustituirr, =z+3Lyr,=z-—]Lenel E 

resultado del paso 1 y simplificar: 











señalar 1, y 1, (figura 22.4): 

ol e 











4. Obtener una expresión aproximada para E. 

cuando z >> L, para lo cual se desprecia (¿LP 

frente a 2* en el resultado del paso 3: 











COMPROBACIÓN La expresión aproximada (paso 4) es inversamente proporcional al cua- 

drado de z, que es la distancia al origen. Esta expresión es la misma que la de una carga Q 

puntual que estuviera en el origen. 





PROBLEMA PRÁCTICO 22.2 El resultado del paso 3 es válido para L/2>=>=». ¿Es válido 

para —L/2<z<5L/2? Razonar la respuesta. 





E debido a una línea de carga infinita 











Determinar el campo debido a una línea uniformemente cargada infinita en ambos sentidos y 

con una densidad de-carga lineal A, 





PLANTEAMIENTO Una línea cargada infinita se considera infinita si las distancias entre los 

extremos de la distribución y el punto donde se considera el campo son mucho mayores que 

cualquiera de las distancias radiales dibujadas en la figura 22.2. Para calcular el campo eléc- 

trico debido a la línea de carga, tomamos los límites para x, >= y para x, > +=. En la fi- 

gura, vemos que debemos tomar límites para 0, —>0 y 0, en las ecuaciones 22.20 y 22.2b. 











SOLUCIÓN 





1. Considerar la primera expresión 

del campo eléctrico en cada una 

de las ecuaciones 22.2a y 22.2b: 





eno, — seno) 











k 

E= cost, — cos) 





KA ka 

g enm — sen0) = AY -0)=0 











2. Tomar límites para 9, >0 y para 

=>": 

E KA ka Ka 

a A) OS 

E, R (cos — cos0) R (LD)! R 





3. Expresar el campo eléctrico en 

forma vectorial: 

















COMPROBACIÓN El campo eléctrico en la dirección radial es tal como esperabamos; es así 

debido a la simetría. (La línea de carga es uniformemente distribuida y se extiende hasta el in- 

finito en ambos sentidos.) 





OBSERVACIÓN El módulo del campo eléctrico decrece inversamente con la distancia ra- 

dial desde la línea de carga. 



































732 | cAPÍTULO 22 Campo eléctrico Il: distribuciones continuas de carga 





El campo eléctrico debido a una línea uniformemente cargada que se extiende 



hasta el infinito en ambas direcciones viene dado por 



= _2kA 2 



E=—R 22.3 



R 



donde A es la densidad lineal de carga, R es la distancia radial de la lnea de carga 

al punto de campo y R es el vector unitario en la dirección radial. La ecuación 22.3 

se obtiene en el ejemplo 22.3. 











PROBLEMA PRÁCTICO 22.3 

Demostrar que si k, A y R se dan en unidades del SI, la ecuación 22.3 nos da el campo eléc- 

trico en N/C. 





























La constante de Coulomb se suele escribir en términos de otra constante, €y de- | 

nominada, permitividad eléctrica del vacío. ! 





1 





Are, 











k= 224 





Utilizando esta notación, la ley de Coulomb para E ecuación 21.7, se escribe 

















Ma 11, 

E=k3?= ed 22.5 

e dre, r 

y É para una línea cargada infinita (equación 22.3) con densidad de carga lineal A, 

se escribe | 

PA idas 

E= AR 22.6 

2116, R 

El valor de e, en unidades del SI es 

e = L 885 x 10-2C2/N + m) 22.7 

Ark 





Aproximación de las ecuaciones 22.2a y 22.2b a un plano de simetría 











Ejemplo 22.4 











































Una carga Q está uniformemente distribuida a lo largo del eje z desde z=—!L hasta 

2 = +3L. (a) Hallar una expresión para el campo eléctrico en función de R en el plano z =0, 

siendo R la distancia radial entre el punto en el que se desea calcular el campo y el eje z. 

(b) Demostrar que para R >> L, la expresión obtenida en la parte (a) se aproxima a la de una 

carga puntual colocada en el origen. (c) Demostrar que para R << L, la expresión del 

apartado (a) se aproxima a la de una línea de carga infinita ubicada en el eje z y con 

densidad lineal de carga A = Q/L. 

















PLANTEAMIENTO La configuración de carga es la misma que la del ejemplo 22.2 y la den- 

sidad de carga es Q/L. Dibujar la línea de carga en el eje z y poner el punto campo en el plano 

2 = 0. Entonces, las ecuaciones 22.20 y 22.2b permiten obtener la expresión del campo que 

se pide en el apartado (a). El campo eléctrico debido a una carga puntual decrece de forma 

inversamente proporcional al cuadrado de la distancia a la carga. Examinar el resultado de 

la parte (a) para ver cómo se aproxima aquél al de una carga puntual colocada en el origen 

para R >> L. El campo eléctrico debido a una línea de carga de longitud infinita decrece de 

forma inversamente proporcional a la distancia radial desde la línea (ecuación 22.3). Exami- 

nando el resultado de la parte (a) vemos cómo se aproxima la expresión a la de una línea de 

longitud infinita para R << L. 











SOLUCIÓN 





(a) 1. Elegir la primera expresión para el E,= PA (eno, — seno) 

campo eléctrico en cada una de las 

ecuaciones 22.20 y 22.2b: 











Ka 

En = — (cos, — cos0)) 





Cálculo del campo eléctrico E mediante la ley de Coulomb SECCIÓN 22.1 733 





p 





. Dibujar la configuración del sistema con la línea cargada en el eje z desdez = —1L hasta 

2 = +]L. Colocar el punto P en el plano 2 = 0 a distancia R del origen (figura 22.5): 





» 





.. En esta figura se ve como 0, + 0, = 7, de tal 

forma que sen, — sen(sr — 0,) — send, y 

c0s0, = cos(ar — 6) = —cos0, . Sustituir estos 

valores en el resultado del paso 1: 





4. Expresar cos 6, en función de R y L y sustituir 

en el resultado del paso 3: 





5. Expresar el campo eléctrico en forma vectorial y 

sustituir Q por AL: 





(b) 1. Observar el resultado del paso 5. Si R >>L, 

entonces R? + (¿LP = R?, Sustituir R? por 

R4 (Que 





2. En esta expresión aproximada vemos que el 

campo eléctrico decrece de forma inversamente 

proporcional al cuadrado de la distancia al 

origen, tal como ocurre con el campo de una 





carga puntual: 





(c) 1. Observar el resultado del paso 5 de la parte (a). 

Si R << L, entonces R? + (¿L? = (LLP. Sustituir 

(LY por R? + (¿LP. En esta expresión 

aproximada vemos que el campo eléctrico varía 

con la inversa de la distancia radial desde la 

línea de carga, tal como lo hace la línea infinita 

de carga (ecuacion 22.3): 











(send) — sent) =0 





KA 2kA 

“ c0s0 — co50,) = Tp cosO, 

















4L 

cos0, = === 

VR + (11) ] 

entonces, tenemos -L/2 0 +L/2 k 

2kA 3L KAL — es 





Re RVR.+ (Lp FIGURA 22.5 





E 











EÁ + E¿R =0É + ER 





entonces, tenemos E =E¿R = 











KQ5 

rra (R> L) 











(R<L) 

















COMPROBACIÓN Los apartados (b) y (c) demuestran que el resultado del apartado (a) es 

plausible. Así, hemos visto que el resultado del apartado (a) es válido en los casos extremos 





enqueR>>LyR<L. 





OBSERVACIÓN La figura 22.6 muestra 

el resultado exacto para la línea de carga 

de longitud L = 10 cm y una densidad de 

carga A = 4,5 nC/m. Tambien muestra 

esta figura los casos límite de una línea 

de carga infinita con la misma densidad 

de carga y una carga puntual Q =AL. 





0 10 20 30 40 

R,cm carga puntual. 















Para valores pequeños de R, 



el campo creado por un segmento 



de una línea cargada es, aproximadamente, 

el de una línea cargada infinita. 





A 





Segmento de una línea cargada 

Carga puntual 



Carga lineal infinita 

¿Para valores grandes de R, 

/ el campo creado por un 

Z” segmento de una línea 

cargada es aproximadamente 

igual al creado por una 





o 





FIGURA 22.6 Representación del módulo del campo eléctrico, en función de la distancia, 





generado por un segmento de línea cargada de 10 cm de largo, una carga puntual y una línea 

infinita de carga. 











734 |  capituto 22 





E en el eje de un anillo cargado 





Campo eléctrico ll: distribuciones continuas de carga 











Un anillo (una circunferencia) fino de radio a está uni- 

formemente cargado con una carga total Q. Determi- 

nar el campo cléctrico debido a la carga en los puntos 

del eje perpendicular al plano y que atraviesa el cen- 

tro del anillo. 





PLANTEAMIENTO Comenzamos con dE = (kdq/r)+ 

(ecuación 22.1a), para calcular el campo eléctrico en 

un punto arbitrario del eje. Dibujar el anillo cargado. 

Consideramos que el eje z coincide con el eje del ani- 

llo que se encuentra en el plano z = 0. Indicamos el 

punto de campo P y un punto fuente S en el anillo. 











SOLUCIÓN 



1. Escribir la ecuación 22.10, expresando dE= 

el campo creado por el elemento de 



carga dq: 





2. Dibujar el anillo (figura 22.74) y su eje 

(eje 2). Mostrar el vector campo 

eléctrico en el punto P debido a la carga 

dq localizada en el punto fuente S: 





3. Dibujar el anillo (figura 22.7b) y 

mostrar las componentes axial y radial 

de E para idénticos elementos en 

lugares opuestos del anillo. La 

componente radial se cancela en cada 

par de elementos dq, de tal forma que 

no queda más que la componente axial: 



4. Expresar la componente z del campo dE, 

eléctrico a partir del resultado del 

paso 1: 





5. Integrar ambos términos de la 

igualdad: 





6. Usando el teorema de Pitágoras, se 





obtiener = V2+ a: 





kdg 

A 











F 





kdg 

=A cos 





E 





Punto fuente 











_Kága_kdga 





RF 





Pp 











FIGURA 22.7 (a) Anillo cargado de 

radio a. El campo eléctrico en el punto P del 

eje x debido al elemento de carga dq posee 

una componente a lo largo del eje x y otra 

perpendicular a ese mismo eje. (b) Para cada 

elemento de carga dq, existe otro elemento 

simétrico dq,, de tal forma que la suma de las 

componentes del campo perpendiculares al 

eje x, generadas por todos los elementos del 

anillo, es cero. 

















COMPROBACIÓN Sería lógico que la dirección del campo eléctrico en puntos del eje z esté 

dirigido alejándose del origen para Q > 0. El resultado del paso 6 coincide con lo esperado 





considerando que z es positivo para +2 y nega- 

tivo para —z. Además, para z >> a, podemos es- 

perar que E decrezca inversamente con el 

cuadrado de la distancia desde el origen. El re- 

sultado del paso 6 coincide con lo esperado, 

puesto que da el resultado de E. = KQ/2? sia” es 

despreciable frente a 2. 





PROBLEMA PRÁCTICO 22.4 En la figura 22.8, 











se representa gráficamente E, versus z a lo largo 

del eje. Determinar el punto en el eje del anillo 

donde E, es máximo. Ayuda: dE./dz = 0, donde 

E, es máximo. 

















FIGURA 22.8 











Cálculo del campo eléctrico E mediante la ley de Coulomb 





Eenel eje de un anillo cargado 





Ejemplo 22.6 





En el ejemplo del anillo 22.5, ¿por qué el módulo del campo eléctrico es más pequeño cerca 

del origen, incluso aunque éste se sitúe próximo al anillo, que en cualquier atro punto del eje 

z (ver figura 22.9)? 





PLANTEAMIENTO La clave de la solución de este problema se encuentra en la figura 22.7b. 

Volver a dibujar esta figura con el punto campo P en el eje z y cerca del origen. 











SOLUCIÓN 





1. Volvera dibujar la figura 22.7b con el 

punto en el que se calcula el campo 

cerca del origen: 





2. Los campos cerca del origen debidos a 

cada uno de los elementos simétricos 

son grandes pero de igual módulo y 

direcciones casi opuestas, de tal forma 

que la suma es casi cero: 





Cerca del origen, el campo resultante es 

pequeño y axial. 











COMPROBACIÓN En el origen, los dos campos eléctricos son grandes, pero opuestos, y su 

suma es, por lo tanto, cero. Lejos del origen (|| > a), los dos campos eléctricos (figura 22.7b) 

son casi de la misma dirección y, en consecuencia, su suma no es cero. 





El campo eléctrico en el eje debido a una carga uniformemente distribuida en 

un anillo circular de radio a y carga total Q viene dado por E = Ek, donde 





- Ka 

ES apa 





La ecuación 22.8 se deduce en el ejemplo 22.5. 





22.8 





E en el eje de un disco cargado 











Considerar un disco uniformemente cargado de radio b y densidad superficial de carga o. 

(a) Determinar el campo eléctrico en todos los puntos del eje del disco, (b) Demostrar que 

para puntos del eje lejanos al disco, el campo eléctrico se aproxima al generado por una carga 

puntual igual a la del disco colocada en el origen. (c) Demostrar que para un disco unifor- 

memente cargado de radio infinito, el campo eléctrico es uniforme a través de la región en 

cualquier semiespacio a ambos lados del disco. 





PLANTEAMIENTO Calcular el campo en el eje del disco considerando el disco como un 

conjunto de anillos concéntricos uniformemente cargados. 

















dE 











FIGURA 22.9 





Apéndice de matemáticas 

para más información sobre 





Expansión binomial 











SECCIÓN 22.1 | 735 





Conceptual 











SOLUCIÓN 

(a) 1. Calcular el campo en el eje del disco. E=EÉ, dondeE, = “E — 

considerando el disco como un (24 apa 





conjunto de anillos concéntricos de 

carga. El campo de un anillo 

uniformemente cargado con carga Q y 

radio a se muestra en la ecuación 22.8: 





2. Dibujar el disco (figura 22.10) y el 

campo eléctrico dE en su eje debido a 

un anillo elemental de carga dq, radio 

a y anchura da: 

3. Sustituir dq por Q y dE, por E, en el E 8 

resultado del paso 1. Integrar ambos (24 aya 











lados dela igualdad para calcularel et 

campo resultante correspondiente al lía Dra 





disco entero, El punto donde 

calculamos el campo es fijo, de tal 

forma que z es constante: 











FIGURA 22.10 Un disco cargado 

uniformemente puede considerarse como 

una serie de cargas anulares de radio 1. 





A 

















736 CAPÍTULO 22 Campo eléctrico ll: distribuciones continuas de carga 



































4. Para resolver esta integral, hacemos un cambio de dq = 0 dA = 02mada 

variable de q por a. La carga dq = a dA, donde 5 oda 2? 

dA = 2xa da es el área de un anillo de radio a y así, tenemos que E, =wkz0 | ——= mkzo [ 0 des 

anchura da: (24 nya Ze 

donde 1 = 22 + a?; por tanto, du = 2ada 

5. Resolver la integral y simplificar el resultado: 

donde sign(=) = 2/|z|. Por definición”: 

+1 2>0 

sign()=4 0 2=0 

1 z<0 

(b) 1. Para z >> b (en el eje del disco) el campo eléctrico El primer orden de la expansión binomial es: 

decrece inversamente con 27. Para demostrar esto se usa (14 x)!=1 + nx para |x| << 1. 

la expansión binomial: 

a Ryan 16 

2. Aplicar la expansión binomial al resultado del paso 5: +) i-— 2 

Z 22 

3. Sustituir en el resultado del paso 5 y simplificar. (Para E= anto 1 - [ 2>b 

2 >> b, sign (2) = 1.) Así, la expresión aproximada para la 

el campo en puntos que cumplen >> bes la misma que. ondeQ = omb' 

el de una carga puntual Q = ob? colocada en el 

origen. 

(c) 1. Tomar límites en el resultado del paso 5 de la parte (a) E, = sign(z) «2 1- 

cuando b— <=. Este resultado es una expresión para E, 

que es uniforme, tanto en la región de z > 0 como en la 

dez<0: 

COMPROBACIÓN El campo eléctrico debería ser de dirección opuesta en cada 

lado del disco. El resultado del paso 5 de la parte (a) concuerda con lo esperado. E. 

OBSERVACIÓN Según el resultado de la parte (c), el campo eléctrico es disconti- 

nuo para z = 0 (figura 22.11) donde el campo da un salto desde —2rk0'¡ a +2rkoi 

cuando se cruza el plano 2 = 0. Hay, en consecuencia, una discontinuidad en E, cd 











con un salto de 4rka = 0/6, 





PROBLEMA PRÁCTICO 22.5 El campo eléctrico debido a una carga superficicial 

uniforme en el plano completo z = O se da en el resultado de la parte (c). ¿Qué frac- 

ción del campo en el eje z para z = a se debe a la carga superficial dentro del cír- z 

culo que tiene un radio r = 54 centrado en el origen? Sugerencia: dividir el resultado ¿ 



del paso 5 de la parte (a) por el resultado de la parte (c) y después sustituir 5a por x y a 

porz. 























—2ako 











FIGURA 22.11 Gráfico que muestra la 

discontinuidad de É en un plano cargado. ¿En qué se 

parecen este gráfico y el de la figura 22.8? 

















* Tanto el programa Excel como el Mathematica utilizan la definición de la función “sigo” propuesta aquí. La compañía Texas Instruments, sin embargo, usa la definición de la función 

"sign" de la siguiente forma: sign(0) =.+1, en lugar de 0. 











Cálculo del campo eléctrico E mediante la ley de Coulomb SECCIÓN 22.1 737 





La respuesta al problema 22.5 no depende de a sino de r/a = 5. El 80% del 

campo a una distancia a desde un plano con carga superficial uniformemente car- 

gada es debido a la carga dentro de un círculo cuyo radio es igual a 51 multiplicado 

por la distancia. 



La fórmula para el campo eléctrico en el eje x de un disco uniformemente car- 

gado, obtenida en el ejemplo 22.7, es 

















Disco cargado N 

















= si . - 200 N 

E, = sign(z)-271k0| 1 E 22.9 Plano infinito cargado 

LA 

z 150 á 

E e tus 



CAMPO ELÉCTRICO EN EL EJE DE UN DISCO E, KN/C O 



CON CARGA DISTRIBUIDA UNIFORMEMENTE 100 

donde sign(z) se define en el paso 5 del apartado (a) del 50 

ejemplo 22.7 y R es el radio del disco. El campo de un 

plano uniformemente cargado se obtiene a partir de la 0 

ecuación 22.9 haciendo que el límite R/z tienda a infi- 0 2 4 6 8 0 





nito, Entonces 2, cm 





e pa CN FIGURA 22.12 Un disco y un punto tienen cargas iguales, y un plano 

EA la) a A, 22.10 iofno el dieco fiera (puta decires de copado: Obres 

a que el campo debido al disco tiende al de una carga puntual a grandes 

CAMPO ELÉCTRICO DE UNA CARGA DISTRI- distancias y es igual al de un plano infinito cargado en el límite cuando = 

BUIDA UNIFORMEMENTE EN UN PLANO tiende a 0. 





La figura 22.12 muestra el campo eléctrico debido a una carga puntual, un disco 

con carga uniforme y un plano infinito cargado, todo ello en función de la posición, 



Según varía z sobre el eje, el campo eléctrico sufre un salto desde —2rko¡ 

a +2mkoi cuando se atraviesa el plano z = 0 (figura 22.11). Así, para z = 0, hay una 

discontinuidad en E, cuyo salto es 4rko.. 





GELUIVA OA Campo eléctrico debido a dos planos infinitos 











En la figura 22.13, un plano infinito que está en z = 0,00 m tiene densidad 

superficial de carga a = +4,5 nC/m? y otro con densidad a = 4,50 nC/m? 

en z = 2,00 m. Determinar el campo eléctrico en (a) x = 1,80 m y en (b) x = 

5,00 m. 











PLANTEAMIENTO Cada plano cargado produce un campo cuyo módulo 

es E = 0 /(2€,). Usamos el teorema de superposición para determinar el 



































campo total. Entre los planos, el módulo del campo es 0-/€, y su dirección 3 ra] 

la de las x positivas. Para x >2,00 y x <0, los dos campos son de igual mó- 

dulo y direcciones opuestas, por lo que la suma es cero. 

SOLUCIÓN 

(a) 1. Calcular el módulo del E = lo|/(2€,) 

campo producido por AN. —————— 

cada plano: =254N/C FIGURA 22.13 





2. Enx=1,80m, entrelos — Enqo = E, + E, = 254 N/C + 254 N/C 

planos, el campo generado 508 N/C 

por cada plano tiene la 





dirección de la x positivas: 











as 











738 | CAPÍTULO 22 Campo eléctrico Il: distribuciones continuas de carga 





E 











(b) En x = 5,00 m, los campos debidos a cada — Evnero 

uno de los dos planos son opuestos: 























COMPROBACIÓN Como los dos planos tienen cargas de igual valor absoluto y distinto 

signo. las líneas de campo eléctrico se originan en el plano de carga positiva y acaban en el 

de carga negativa. E es cero en todos los puntos excepto en la región entre los dos planos. 





OBSERVACIÓN Obsérvese que E, ,.., = 508 N/C no sólo para y = 1,8 m sino en cualquier 

punto entre los dos planos. La configuración de carga en este ejemplo es la de un condensa- 

dor, como el que se analiza en el capítulo 24. 





22 SITES 





La descripción cualitativa del campo eléctrico mediante las líneas de fuerza estudiadas 

en el capítulo 21 está relacionada con una ecuación matemática llamada ley de Gauss. 

La ley de Gauss es una de las ecuaciones de Maxwell, las ecuaciones fundamentales 

del electromagnetismo, que veremos en el capítulo 30. Para cargas estáticas, la ley de 

Gauss y la ley de Coulomb son equivalentes. La ley de Gauss permite calcular fácil- 

mente los campos eléctricos que resultan de distribuciones simétricas de carga, tales 

como una corteza esférica o una línea infinita. En esta sección, se presenta una argu- 

mentación sencilla de la ley de Gauss basada en las propiedades de las líneas de campo 

eléctrico. En la sección 22.6, se ofrece una deducción más rigurosa de la ley de Gauss. 



Se entiende por superficie cerrada aquella que divide el espacio en dos regiones 

diferentes, la interior y la exterior a dicha superficie. La figura 22.14 muestra una su- 

perficie de forma arbitraria que encierra un dipolo. El número de líneas de campo 

eléctrico que salen de la carga positiva y cruzan la superficie, saliendo del espacio 

limitado por ésta, depende de donde se dibuje la superficie, pero toda línea que 

cruza la superficie para salir la vuelve a cruzar para entrar. Para contar el número 

neto de líneas que salen de la superficie, cuéntese cualquier línea que la cruce desde 

el interior como +1 y cualquier penetración desde el exterior como —1. Así pues, 

para la superficie indicada (figura 22.14), el balance total de líneas que cruzan la su- 

perficie es cero. Para superficies que encierran otras distribuciones de carga, como 

ocurre en la figura 22.15, el número neto de líneas que sale por cualquier superficie que en- 

cierra las cargas es proporcional a la carga encerrada dentro de dicha superficie. Este es un 

enunciado cualitativo de la ley de Gauss. 

















FIGURA 22.14 Dipolo eléctrico encerrado en una FIGURA 22.15 Superficie de forma arbitraria que incluye las 

superficie de forma arbitraria. El número de líneas que cargas + 2q y —q. Las líneas de campo que terminan en —g o bien no 

abandonan la superficie es exactamente igual al número de pasan a través de la superficie o bien salen y vuelven a entrar. El número 

líneas que entran en ella sin que importe donde se dibuje la neto de líneas que salen y no vuelven a entrar, el mismo que 



superficie, siempre que se encierren dentro de ella ambas correspondería a una sola carga +, es proporcional a la carga neta 





cargas del dipolo. dentro de la superficie. 











Ley de Gauss 





FLUJO ELÉCTRICO 





La magnitud matemática que está relacionada con el número de líneas de campo 

que atraviesa una superficie se llama flujo eléctrico, «p. Para una superficie per- 

pendicular a E (figura 22.16), se define como el producto del módulo del campo E 

y el área Az 





$=EA 





Las unidades del flujo son N - m?/C. Como el campo eléctrico es proporcional 

al número de líneas por unidad de área, el flujo eléctrico es proporcional al número 

de líneas de campo que atraviesan el área. 



_, En la figura 22.17, la superficie de área A, no es perpendicular al campo eléctrico 

E. Sin embargo, el número de líneas que atraviesan el área A, es el mismo que el 

que atraviesa el área A,, que es perpendicular a E. Las áreas están relacionadas por 





A,cosO = A, 22.11 





donde 6 es el ángulo existente entre E y el vector unitario í perpendicular a la su- 

perficie A,, según está indicado. El flujo a través de una superficie viene definido por 





$ = E-ñA=EAcos0 =E,A 22.12 





donde E,, = E-ñesla componente de E perpendicular, o normal, a la superficie. 



La figura 22.18 muestra una superficie de forma arbitraria sobre la cual el 

campo E puede variar. Si el área AA, del elemento de área que elegimos es sufi- 

cientemente pequeño, podemos considerarlo como un plano y la variación del 

campo eléctrico a través del elemento puede despreciarse. Entonces, el flujo del 

campo eléctrico a través de este elemento es 





Ab, = E,¡ AA; = E,+ñ, AA, 





donde ñi, es el vector unitario perpendicular al elemento de área y E, ¡el campo eléc- 

trico en todo este elemento de área. Si la superficie es curva, los vectores unitarios 

de los distintos elementos tendrán direcciones diferentes. El flujo total a través de 

la superficie es la suma de Ad, extendida a todos los elementos. En el límite, 

cuando el número de elementos se aproxima a infinito y el área de cada elemento 

tiende a cero, esta suma se convierte en una integral. La definición general del flujo 

eléctrico es, por lo tanto, 





22.13 











DEFINICIÓN: FLUJO ELÉCTRICO 





donde el índice S nos recuerda que estamos integrando sobre una superficie.* El 

signo del flujo depende de la elección que hagamos de la dirección del vector uni- 

tario perpendicular al elemento de superficie %. Eligiendo ñ dirigido hacia el exte- 

rior de la superficie, podemos determinar el signo de E »Á, así como el signo del 

flujo a través de la superficie. 



En el caso del flujo del campo eléctrico a través de las superficies cerradas, existe 

el convenio de tomar siempre el vector unitario, í2, dirigido hacia el exterior de la 

superficie en cada punto de ésta. La integral extendida a toda la superficie se in- 

dica con el símbolo f. En consecuencia, el flujo neto total a través de la superficie 

cerrada S es 





Pero = ¿ E-ñdA= $ E, dA 22.14 

Ss s 











* El lujo eléctrico de un vector a través de una superficie es una operación matemática que se utiliza de forma similar 

para describir las velocidades de lujo de los fluidos y de la transferencia de calor. Además, se usa para relacionar el 

campo eléctrico con las cargas que lo producen. 





SECCIÓN 22.2 739 











FIGURA 22.16 Líneas de campo 

correspondientes a un campo eléctrico 

uniforme E que atraviesa un área A 

perpendicular al campo. El producto EA es el 

flujo 6 a través del área. 











Az 

AcosO=Ay 











FIGURA 22.17 Líneas de campo 

correspondientes a un campo eléctrico 

uniforme perpendicular al área A,, pero que 

forma un ángulo 6 con el vector unitario 4 

normal al área A,. Cuando E no es 

perpendicular al área, el flujo a través del área 

es E,A, siendo E, = E cos 0 la componente de 

E perpendicular al área. El Aujo que atraviesa 

A, es el mismo que el que pasa por A). 











FIGURA 22.18 Cuando E varía en los 

distintos lugares de la superfície, ya sea 

porque E varía o porque lo hace el ángulo 

entre É y ñ, el área se divide en elementos de 

área pequeños AA, El flujo a través del área se 

calcula sumando E, ñ, AA, para todos los 

elementos. 

















740 CAPÍTULO 22 Campo eléctrico Il: distribuciones continuas de carga 





El flujo total o neto 4,,.,, a través de la superficie cerrada es positivo o negativo 

dependiendo de que E esté dirigido predominantemente hacia fuera o hacia dentro 

de la superficie. En los puntos de la superficie en que E está dirigido hacia den- 

tro, E, es negativo. 





ENUNCIADO CUANTITATIVO DE LA LEY DE GAUSS 





La figura 22.19 muestra una superficie esférica de radio R con su centro en la carga 

puntual Q. El campo eléctrico en un punto cualquiera de la superficie es perpen- 

dicular a la superficie y tiene el módulo 





kQ 

5=E 











El flujo neto de E a través de esta superficie esférica es 





a s 





donde E, puede salir de la integral por ser constante en todos los puntos. La inte- 

gral de dA extendida a toda la superficie es precisamente el área total, igual a 4rR?, 

Con este valor y sustituyendo kQ/R? por E,, se obtiene 





Pa E Parr =4rkQ = Q/€, 22.15 



Así pues, el flujo neto a través de una superficie esférica con una carga puntual 

en el centro es independiente del radio de la esfera y es igual a 4mk veces el valor 

de dicha carga. Esto concuerda con nuestra observación previa según la cual el 

número neto de líneas que atraviesan una superficie es proporcional a la carga neta 

interior a la superficie. Este número de líneas es el mismo para cualquier superfi- 

cie que encierre a la carga, cualquiera que sea su forma. Así, el flujo neto a través 

de cualquier superficie que rodea a una carga puntual Q es igual a 4rkQ. 



Podemos ampliar este resultado a sistemas de más de una carga puntual. En la fi- 

gura 22.20, la superficie encierra dos cargas puntuales, q, y y, y existe una tercera 

carga puntual q, fuera de la superficie. Puesto que el campo eléctrico en cualquier 

punto de la superficie es el vector suma de los campos eléctricos producidos por cada 

una de las tres cargas, el flujo neto a través de la superficie es, precisamente, la suma 

de los flujos debidos a las cargas individuales, d,.,, = f5(E, + E, + E,):ñ:dA. El 

flujo originado por la carga q,, que está fuera de la superficie, es cero debido a que 

cada línea de fuerza procedente de q, que entra en la superficie en un punto aban- 

dona la misma en algún otro punto. El flujo a través de la superficie debido a la 

carga q, es 41kq, y el debido a la carga q, es 47kq,. El flujo neto a través de la su- 

perficie es igual a 4rk(q, + q,) que puede ser positivo, negativo o cero, depen- 

diendo de los signos y valores de las dos cargas. 





El flujo neto a través de cualquier superficie es igual a la carga neta dentro 

de la superficie dividida por €; 





o PErñda= pda - Queso 22.16 

Ss Ss € 





LEY DE GAUSS 





Esta es la llamada ley de Gauss. Nos indica que el campo eléctrico debido a una 

carga puntual aislada varía inversamente con el cuadrado de la distancia desde la 

carga. Esta propiedad del campo eléctrico es la que ha hecho posible dibujar un nú- 

mero fijo de líneas de fuerza desde una carga y conseguir que la densidad de líneas 

sea proporcional a la intensidad del campo. 











FIGURA 22.19 Unasuperficie esférica 

que incluye la carga puntual Q. El flujo se 

calcula fácilmente para una superficie esférica. 

Es igual al producto de E, por el área 

superficial, es decir, E, dmR?. 











FIGURA 22.20 Superficie que incluye 

las cargas puntuales q, y ,, pero no qy; El flujo 

neto a través de esta superficie es 4k(9, + q,). 





Ley de Gauss SECCIÓN 22.2 741 





La ley de Gauss es válida para todas las superficies y distribuciones de carga. 

Como veremos en la sección siguiente, puede utilizarse para calcular el campo 

eléctrico en algunas distribuciones especiales de carga con altos grados de simetría, 

En los campos eléctricos que resultan de distribuciones de carga estáticas, la ley de 

Gauss y la ley de Coulomb son equivalentes. Sin embargo, la ley de Gauss es más 

general, pues también puede aplicarse a distribuciones de carga no estáticas. 











Ejemplo 22.9 





Flujo a través de una superficie cerrada 

















Un campo eléctrico vale E = +(200 N/C)É para x>0 y E = —(200N/O)É para x<0. Un ci- 

lindro imaginario de longitud 20 cm y radio R = 5 cm tiene su centro en el origen y su eje a 

- lo largo del eje x, de modo que un extremo se encuentra en y = +10 cm y el otro en x= —10 

cm (figura 22.21). (a) ¿Cuál es el flujo neto del campo eléctrico que atraviesa la superficie 

total cerrada del cilindro? (b) ¿Cuál es la carga neta localizada en el interior del cilindro? 











PLANTEAMIENTO La superficie cerrada que se describe se compone de tres piezas: dos 

bases y una superficie curvada. Calcular el flujo de E a través de cada pieza por separado. 

Para calcular el flujo a través de una pieza, dibujar el vector % normal hacia fuera en un 

punto de la pieza elegido al azar y añadir el vector E en dicho punto, Si E, = E+ñ es el 

mismo en todos los puntos de una determinada pieza, de la superficie gausiana, entonces 

el flujo total a través de la mencionada pieza es E, A, donde A es su área. El flujo 

vés de la superficie cerrada se obtiene sumando los flujos a través de las superf 

viduales. El flujo neto a través de la superficie cerrada está relacionado con la carga neta 

interior por la ley de Gauss (ecuación 22.16). 

















SOLUCIÓN 





(a) 1. Dibujar una superficie cerrada en forma cilíndrica. Añadir el vector normal ñ en cada 

una de las partes de la superficie del cilindro, bases y superficie lateral, y el vector E 

(figura 22.21): 





2. Calcular el flujo que sale de la base derecha del cilindro, — yy = Eos "My A = Ey, ÁTR? = +(200 N/OJk - Á(rX(0,0500 m)? 

cuyo vector unitario es í = ki 











FIGURA 22.21 






