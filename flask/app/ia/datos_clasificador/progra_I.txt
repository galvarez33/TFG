Java precisamente
Peter Sestoft
La prensa del MIT
Cambridge, Massachusetts Londres, Inglaterra

Copyright © 2002 Instituto Tecnológico de Massachusetts
Reservados todos los derechos. Ninguna parte de este libro puede reproducirse de ninguna forma por ningún medio electrónico o mecánico (incluidas fotocopias, grabaciones o almacenamiento y recuperación de información) sin el permiso por escrito del editor.
Este libro fue ambientado en Times por el autor usando . Impreso y encuadernado en los Estados Unidos de América.
Datos de catalogación en publicación de la Biblioteca del Congreso Sestoft, Peter.
Precisamente Java/Peter Sestoft.
pag. cm.
Incluye referencias bibliográficas e índice.
ISBN 0-262-69276-7 (pbk.: papel alk.)

1. Java (Lenguaje de programación informática) I. Título.
QA76.73.J38 S435 2002
005.13'3—dc21 2002016516

Tabla de contenido

Prefacio
Este libro ofrece una descripción concisa del lenguaje de programación Java 2, versiones 1.3 y 1.4. Es una referencia rápida para el lector que ya ha aprendido (o está aprendiendo) Java a partir de un libro de texto estándar y que desea conocer el lenguaje con más detalle. El libro presenta todo el lenguaje de programación Java y partes esenciales de las bibliotecas de clases: las clases de colección y las clases de entrada y salida. Las reglas generales se muestran principalmente en las páginas de la izquierda, y los ejemplos correspondientes se muestran únicamente en las páginas de la derecha. Todos los ejemplos son fragmentos de programas Java legales. Los programas de ejemplo completos, listos para ejecutar, están disponibles en el sitio web del libro.
<>.
El libro no cubre la recolección de basura, la finalización y las referencias débiles, la reflexión, los detalles de los números de punto flotante IEEE754 o Javadoc.
Agradecimientos Gracias a Rasmus Lund, Niels Hallenberg, Hans Henrik Løvengreen, Christian Gram, Jan Clausen, Anders Peter Ravn, Bruce Conrad, Brendan Humphreys, Hans Rischel y Ken
Friis Larsen por sus útiles comentarios, sugerencias y correcciones. Un agradecimiento especial a Rasmus Lund por permitirme adaptar su diagrama de colecciones para este libro. Gracias también a la Real Universidad Veterinaria y Agrícola y a la Universidad TI de Copenhague, Dinamarca, por su apoyo.

Convenciones de notación

Capítulo 1: Ejecución de Java: compilación, carga y ejecución
Antes de poder ejecutar un programa Java, se debe compilar y cargar. El compilador comprueba que el programa Java sea legal: que el programa se ajuste a la sintaxis (gramática) de Java, que los operadores (como
+) son operandos aplicados (como 5 y x) del tipo correcto, y así sucesivamente. Si es así, el compilador genera los llamados archivos de clase. Luego, la ejecución comienza cargando los archivos de clase necesarios.
Por lo tanto, ejecutar un programa Java implica tres etapas: compilación (verifica que el programa esté bien formado), carga (carga e inicializa clases) y ejecución (ejecuta el código del programa).

Capítulo 2: Nombres y Nombres Reservados
Un nombre legal (de una variable, método, campo, parámetro, clase, interfaz o paquete) comienza con una letra o signo de dólar ($) o guión bajo (_) y continúa con cero o más letras o signos de dólar o guiones bajos o dígitos. (0–9). Evite los signos de dólar en los nombres de las clases. Las letras mayúsculas y minúsculas son
considerado distinto. Un nombre legal no puede ser uno de los siguientes nombres reservados:

Capítulo 3: Convenciones de nomenclatura de Java
A menudo se siguen las siguientes convenciones de nomenclatura, aunque Java no las aplica:
Si un nombre se compone de varias palabras, entonces cada palabra (excepto posiblemente la primera) comienza con una letra mayúscula. Ejemplos: setLayout, addLayoutComponent.
Los nombres de variables, campos y métodos comienzan con una letra minúscula. Ejemplos: vehículo, myVehicle.
Los nombres de clases e interfaces comienzan con una letra mayúscula. Ejemplos: Cubo, ColorCube.
Las constantes con nombre (es decir, variables y campos finales) se escriben completamente en mayúsculas y las partes de los nombres compuestos están separadas por guiones bajos (_). Ejemplos: CENTRO, MAX_VALUE.
Los nombres de los paquetes son secuencias de nombres en minúsculas separados por puntos. Ejemplo: java.awt.event. Para mayor singularidad, a menudo tienen el prefijo de nombres de dominio inversos, como en com. sun.xml.util.

Capítulo 4: Comentarios y diseño del programa
Los comentarios no tienen ningún efecto sobre la ejecución del programa, pero pueden insertarse en cualquier lugar para ayudar a los humanos a comprender el programa. Hay dos formas: comentarios de una línea y comentarios delimitados. El diseño del programa no tiene ningún efecto en la ejecución del programa por parte de la computadora, pero se utiliza para ayudar a los humanos a comprender la estructura del programa.
Ejemplo 1: comentarios

comentario de clase {

// Este es un comentario de una línea; se extiende hasta el final de la línea.

/* Este es un comentario delimitado que se extiende a lo largo de varias líneas.
*/

int /* Este comentario delimitado se extiende sobre parte de una línea */ x = 117;

}


Ejemplo 2: estilo de diseño de programa recomendado

Por razones de espacio, este estilo de diseño no siempre se sigue en este libro. Diseño de clase { // Declaración de clase
ent a;



Diseño (int a) {

esto.a = a; // cuerpo de una línea

}



int sum(int b) { // Cuerpo de varias líneas
if (a > 0) { // Declaración if
devolver a + b; // declaración única
} else if (a < 0) { // Anidado if-else, declaración de bloque int res = -a + b;
regire res * 117;
} else { // a == 0 // Terminal else, declaración de bloque int sum = 0;
for (int i=0; i<10; i++) { // Suma del bucle For += (b - i) * (b - i);
}
suma de devolución;
}
}

fecha de verificación booleana estática (int mes, int día) { int longitud;
switch (mth) { // Declaración de cambio
caso 2: // Longitud de caso único = 28; romper;

caso 4: caso 6: caso 9: caso 11: // Longitud de caso múltiple = 30; romper;
caso 1: caso 3: caso 5: caso 7: caso 8: caso 10: caso 12: longitud = 31; romper;
predeterminado: devuelve falso;
}
return (día >= 1) && (día <= duración);
}
}

Capítulo 5: Tipos
Un tipo es un conjunto de valores y operaciones sobre ellos. Un tipo es un tipo primitivo o un tipo de referencia.
Tipos primitivos
Un tipo primitivo es booleano o uno de los tipos numéricos char, byte, short, int, long, float y double. Los tipos primitivos, literales de ejemplo (es decir, constantes), tamaño en bits (donde 8 bits equivalen a 1 byte) y rango de valores, se muestran en la siguiente tabla:
Los tipos de números enteros son exactos dentro de su rango. Usan representación en complemento a 2 con signo (excepto char), por lo que cuando el número más positivo en un tipo es max, entonces el número más negativo es -max-
1. Los tipos de punto flotante son inexactos y siguen IEEE754, con el número de dígitos significativos
indicado por "sigdig". Para secuencias de escape de caracteres como \u0000, consulte la página 8.
Los literales enteros (de tipo byte, char, short, int o long) se pueden escribir en tres bases diferentes:
Para todos los tipos primitivos existen clases contenedoras correspondientes (tipos de referencia), a saber, booleano y carácter, así como byte, corto, entero, largo, flotante y doble, donde los últimos seis tienen la superclase común Número. Para usar un valor primitivo, como 17, donde se espera un objeto, use un objeto de su clase contenedora, como new Integer(17).
Tipos de referencia
Un tipo de referencia es un tipo de clase definido por una declaración de clase (sección 9.1), o un tipo de interfaz definido por una declaración de interfaz (sección 13.1), o un tipo de matriz (sección 5.3).
Un valor de tipo de referencia es nulo o una referencia a un objeto o matriz. El valor especial nulo
denota "ningún objeto". El nulo literal, que denota el valor nulo, puede tener cualquier tipo de referencia.

Tipos de matriz
Un tipo de matriz tiene la forma t[], donde t es cualquier tipo. Un tipo de matriz t[] es un tipo de referencia. Por lo tanto, un valor de tipo de matriz t[] es nulo o es una referencia a una matriz cuyo tipo de elemento es precisamente t (cuando t es un tipo primitivo), o es un subtipo de t (cuando t es un tipo de referencia).
Subtipos y compatibilidad
Un tipo t1 puede ser un subtipo de un tipo t2, en cuyo caso t2 es un supertipo de t1. Intuitivamente, esto significa que se puede utilizar cualquier valor v1 de tipo t1 cuando se espera un valor de tipo t2. Cuando t1 y t2 son tipos de referencia, t1 debe proporcionar al menos la funcionalidad (métodos y campos) proporcionada por t2. En particular, cualquier valor v1 de tipo t1 puede estar vinculado a una variable, campo o parámetro x2 de tipo t2, por ejemplo, mediante la asignación x2 = v1 o mediante el paso de parámetros. También decimos que los tipos t1 y t2 son compatibles. Las siguientes reglas determinan cuándo un tipo t1 es un subtipo de un tipo t2:
Cada tipo es un subtipo de sí mismo.
Si t1 es un subtipo de t2 y t2 es un subtipo de t3, entonces t1 es un subtipo de t3.
char es un subtipo de int, long, float y double.
byte es un subtipo de short, int, long, float y double.
short es un subtipo de int, long, float y double.
int es un subtipo de long, float y double.
long es un subtipo de float y double.
float es un subtipo de double.
Si t1 y t2 son clases, entonces t1 es un subtipo de t2 si t1 es una subclase de t2.
Si t1 y t2 son interfaces, entonces t1 es un subtipo de t2 si t1 es una subinterfaz de t2.
Si t1 es una clase y t2 es una interfaz, entonces t1 es un subtipo de t2 siempre que t1 (sea una subclase de una clase que) implemente t2 o implemente una subinterfaz de t2.
El tipo de matriz t1 [] es un subtipo del tipo de matriz t2 [] si el tipo de referencia t1 es un subtipo del tipo de referencia t2.
Cualquier tipo de referencia t, incluido cualquier tipo de matriz, también es un subtipo de clase Objeto predefinida.
Ningún tipo primitivo es un subtipo de un tipo de referencia. Ningún tipo de referencia es un subtipo de un tipo primitivo.

Firmas y Subsunción
Una firma tiene la forma m(t1,..., tn), donde m es el nombre de un método o constructor y (t1,..., tn) es una lista de tipos (ejemplo 25). Cuando el método se declara en la clase T y no se hereda de una superclase, entonces su firma extendida es m(T, t1,..., tn); esto se usa en llamadas a métodos (sección 11.11).
Decimos que una firma sig1 = m(t1,..., tn) subsume la firma sig2 = m(u1,..., un) si cada ui es un subtipo de ti. También decimos que sig2 es más específico que sig1. Tenga en cuenta que el nombre del método my el número n de tipos deben ser los mismos en las dos firmas. Dado que cada tipo ti es un subtipo de sí mismo, cada firma se subsume a sí misma. En una colección de firmas puede haber una que esté subsumida por todas las demás; dicha firma se denomina firma más específica. Ejemplos:
m (doble, doble) se subsume a sí mismo y m(doble, int) y m(int, doble) y
m(int,int).
m (doble le, int) se subsume a sí mismo y m(int, int).
m(int, double) se subsume a sí mismo y m(int, int).
m (doble, int) no incluye a m (int, doble), ni al revés.
La colección m(double, int), m(int, int) tiene la firma más específica m(int, int).
La colección m(double, int), m(int, double) no tiene una firma más específica.

Capítulo 6: Variables, parámetros, campos y alcance
Descripción general
Una variable se declara dentro de un método, constructor, bloque inicializador o declaración de bloque (sección 12.2). La variable sólo se puede utilizar en esa declaración de bloque (o método, constructor o bloque inicializador), y sólo después de su declaración.
Un parámetro es un tipo especial de variable: se declara en la lista de parámetros de un método o constructor y se le asigna un valor cuando se llama al método o constructor. El parámetro sólo se puede utilizar en ese método o constructor, y sólo después de su declaración.
Un campo se declara dentro de una clase, pero no dentro de un método, constructor o bloque inicializador de la clase. Se puede utilizar en cualquier parte de la clase, también textualmente antes de su declaración.

Valores vinculados a variables, parámetros o campos
Una variable, parámetro o campo de tipo primitivo contiene un valor de ese tipo, como el booleano falso, el entero 117 o el número de punto flotante 1. 7. Una variable, parámetro o campo de tipo de referencia t tiene el valor especial nulo o contiene una referencia a un objeto o matriz. Si es un objeto, entonces la clase de ese objeto debe ser t o una subclase de t.
Declaraciones de variables
El propósito de una variable es mantener un valor durante la ejecución de una declaración de bloque (o método, constructor o bloque inicializador). Una declaración de variable tiene una de las formas
tipo de modificador de variable varname1, varname2, ...;
tipo de modificador de variable varname1 = inicializador1, ...;
Un modificador de variable puede ser final o estar ausente. Si una variable se declara final, entonces se debe inicializar o asignar como máximo una vez en tiempo de ejecución (exactamente una vez si alguna vez se usa): es una constante con nombre. Sin embargo, si la variable tiene un tipo de referencia, entonces el objeto o matriz al que apunta la variable aún puede modificarse. Un inicializador de variable puede ser una expresión o un inicializador de matriz (sección 8.2).
La ejecución de la declaración de variable reservará espacio para la variable, luego evaluará el inicializador, si lo hay, y almacenará el valor resultante en la variable. A diferencia de un campo, a una variable no se le asigna un valor predeterminado cuando se declara, pero el compilador verifica que se le haya asignado un valor antes de usarla.

Alcance de variables, parámetros y campos
El alcance de un nombre es la parte del programa en la que el nombre es visible. El alcance de una variable se extiende desde justo después de su declaración hasta el final de la declaración del bloque más interno. El alcance de un método o parámetro de constructor es el cuerpo completo del método o constructor. Para una variable de control x declarada en una declaración for
para (int x = ...; ...; ...) cuerpo
el alcance es la declaración for completa, incluidos el encabezado y el cuerpo.
Dentro del alcance de una variable o parámetro x, no se puede redeclarar x. Sin embargo, se puede declarar una variable x dentro del alcance de un campo x, ocultando así el campo. Por lo tanto, el alcance de un campo x es toda la clase, excepto cuando esté sombreado por una variable o parámetro del mismo nombre, y excepto los inicializadores que preceden a la declaración del campo (sección 9.1).
Ejemplo 3: Declaraciones de variables public static void main(String[] args) { int a, b, c;
int x = 1, y = 2, z = 3; relación interna = z/x;
doble PI final = 3,141592653589; booleano encontrado = falso;
final int maxyz;

si (z > y) maxyz = z; de lo contrario maxyz = y;
}


Ejemplo 4: alcance de campos, parámetros y variables
Este programa declara cinco variables o campos, todos llamados x, y muestra dónde está cada uno dentro del alcance (visible). Las variables y los campos están etiquetados como #1, ..., #5 como referencia.

alcance de clase {

... //

void ml(int x) { // Declaración del parámetro x (#1)

... // x #1 en alcance

} //

... //

vacío m2(int v2) { //

... // x #5 en alcance

} //

... //

vacío m3 (int v3) { //

... // x #5 en alcance

intx; // Declaración de la variable x (#2)

... // x #2 en alcance

} //

... //

vacío m4 (int v4) { //

... // x #5 en alcance

{ //

intx; // Declaración de la variable x (#3)

... // x #3 en alcance

} //

... // x #5 en alcance

{ //

intx; // Declaración de la variable x (#4)

... // x #4 en alcance

} //

... // x #5 en alcance

} //

... //

intx; // Declaración del campo x (#5)

... // x #5 en alcance

}

Capítulo 7: Cuerdas
Una cadena es un objeto de la clase predefinida String. Un literal de cadena es una secuencia de caracteres entre comillas dobles: "Nueva York", "A38", "", etc. Internamente, un carácter se almacena como un número usando
la codificación de caracteres Unicode, cuyos códigos de caracteres del 0 al 127 coinciden con la antigua codificación de caracteres ASCII. Los literales de cadena y los literales de caracteres pueden utilizar secuencias de escape de caracteres:
Una secuencia de escape de caracteres representa un solo carácter. Dado que la letra A tiene el código 65 (decimal), que se escribe 101 en octal y0041 en hexadecimal, la cadena literal "A\101\u0041" es lo mismo que "AAA". Si s1 y s2 son expresiones de tipo String y v es una expresión de cualquier tipo, entonces
s1.length () de tipo int es la longitud de s1, es decir, el número de caracteres en s1.
s1.equals (s2) de tipo booleano es verdadero si s1 y s2 contienen la misma secuencia de caracteres y falso en caso contrario; equalsIgnoreCase es similar pero no distingue entre minúsculas y mayúsculas.
s1.charAt (i) de tipo char es el carácter en la posición i en s1, contando desde 0. Si el índice i es menor que 0, o mayor o igual que s1.length (), entonces se lanza StringIndexOutOfBoundsException.
s1.toString () de tipo String es el mismo objeto que s1.
String.valueOf (v) devuelve la representación de cadena de v, que puede tener cualquier tipo primitivo (sección 5.1) o tipo de referencia. Cuando v tiene un tipo de referencia y no es nulo, se convierte usando v.toString(); si es nulo, se convierte en la cadena "nulo". Cualquier clase C hereda de Object un método toString predeterminado que produce cadenas de la forma C@2a5734, donde 2a5734 es alguna dirección de memoria, pero toString puede anularse para producir cadenas más útiles.
s1 + s2 tiene el mismo significado que s1.concat (s2): construye la concatenación de s1
y s2, una nueva Cadena que consta de los caracteres de s1 seguidos de los caracteres de s2.
s1 + v y v + s1 se evalúan convirtiendo v en una cadena con String.valueOf (v), usando así v.toString () cuando v tiene un tipo de referencia y luego concatenando las cadenas resultantes.
s1.compareTo(s2) devuelve un entero negativo, cero o un entero positivo, según que s1 preceda, sea igual o siga a s2 en el orden lexicográfico habitual basado en la codificación de caracteres Unicode. Si s1 o s2 es nulo, se lanza la excepción NullPointerException. El método compareToIgnoreCase es similar pero no distingue entre minúsculas y mayúsculas.
Se describen más métodos String en la documentación de la biblioteca de clases Java [3].
Ejemplo 5: Igualdad de cadenas y la sutileza del operador (+)

Cadena s1 = "abc";
Cadena s2 = s1 + ""; // Nuevo objeto, pero contiene el mismo texto que s1 String s3 = s1; // Mismo objeto que s1

Cadena s4 = s1.toString(); // Mismo objeto que s1

// Las siguientes declaraciones imprimen falso, verdadero, verdadero, verdadero, verdadero: System.out.println("objetos idénticos s1 y s2: " + (s1 == s2)); System.out.println("objetos idénticos s1 y s3: " + (s1 == s3)); System.out.println("objetos idénticos s1 y s4: " + (s1 == s4)); System.out.println("s1 y s2 contienen el mismo texto: " + (s1.equals(s2))); System.out.println("s1 y s3 contienen el mismo texto: " + (s1.equals(s3)));
// Estas dos declaraciones imprimen 35A y A1025 porque (+) es asociativo por la izquierda: System.out.println(10 + 25 + "A"); // Igual que (10 + 25) + "A" System.out.println("A" + 10 + 25); // Igual que ("A" + 10) + 25

Ejemplo 6: concatenar todos los argumentos de la línea de comando
Al concatenar muchas cadenas, utilice un búfer de cadenas (capítulo 19 y ejemplo 84). público estático vacío principal (String [] argumentos) {
Cadena res = "";
for (int i=0; i<args.length; i++) res += args [i]; System.out.println(res);
}


Ejemplo 7: contar el número de e en una cadena

recuento estático (cadenas)

cuenta interna = 0;
for (int i=0; i<s.length(); i++) if (s.charAt(i) == 'e') ecount++;
cuenta de devolución;
}


Ejemplo 8: Determinar si las cadenas aparecen en orden lexicográficamente creciente

booleano estático ordenado (String[] a) para (int i=1; i<a.length; i++)
si (a[i-1].compareTo(a[i]) > 0)
falso retorno;
devolver verdadero;
}


Ejemplo 9: uso de una clase que declara un método toString
La clase Point (ejemplo 16) declara un método toString que devuelve una cadena de coordenadas del punto. El operador (+) llama implícitamente al método toString para formatear los objetos Point.

Punto p1 = nuevo Punto(10, 20), Punto p2 = nuevo Punto(30, 40);

System.out.println("p1 es " + pl); // Imprime: p1 es (10, 20) System.out.println("p2 es " + p2); // Imprime: p2 es (30, 40) p2.move(7, 7);
System.out.println("p2 es " + p2); // Imprime: p2 es (37, 47)

Capítulo 8: Matrices
Una matriz es una colección indexada de variables, llamadas elementos. Una matriz tiene una longitud determinada ℓ ≥ 0 y un tipo de elemento determinado t. Los elementos están indexados por los números enteros 0, 1,...,ℓ - 1. El valor de una expresión de tipo de matriz u[] es nulo o una referencia a una matriz cuyo tipo de elemento t es un subtipo de u. Si u es un tipo primitivo, entonces t debe ser igual a u.
Creación y acceso a matrices
Se crea (asigna) una nueva matriz de longitud ℓ con tipo de elemento t usando una expresión de creación de matriz:
nueva t[ℓ]
donde ℓ es una expresión de tipo int. Si el tipo t es un tipo primitivo, todos los elementos de la nueva matriz se inicializan a 0 (cuando t es byte, char, short, int o long) o 0.0 (cuando t es flotante o doble) o falso (cuando t es booleano). ). Si t es un tipo de referencia, todos los elementos se inicializan a nulo.
Si ℓ es negativo, se lanza la excepción NegativeArraySizeException.
Sea a una referencia del tipo de matriz u[], a una matriz con longitud ℓ y tipo de elemento t. Entonces
a.length de tipo int es el longitud ℓ de a, es decir, el número de elementos en a.
La expresión de acceso a la matriz a[i] denota el elemento número i de a, contando desde 0; este
La expresión tiene tipo u. La expresión entera i se llama índice de matriz. Si el valor de i es menor que 0 o mayor o igual que a.length, entonces se lanza la excepción ArrayIndexOutOfBoundsException.
Cuando t es un tipo de referencia, cada asignación de elemento de matriz a[i] = e verifica que el valor de e sea nulo o una referencia a un objeto cuya clase C sea un subtipo del tipo de elemento t. Si este no es el caso, se lanza la excepción ArrayStoreException. Esta verificación se realiza antes de cada asignación de elementos de la matriz en tiempo de ejecución, pero solo para los tipos de referencia.

Inicializadores de matriz
Una variable o campo de tipo matriz se puede inicializar en la declaración, utilizando una matriz existente o un inicializador de matriz para el valor inicial. Un inicializador de matriz es una lista separada por comas de cero o más expresiones encerradas entre llaves {...}:
t[] x = { expresión, ..., expresión }
El tipo de cada expresión debe ser un subtipo de t. La evaluación del inicializador provoca que se asigne una nueva matriz distinta, cuya longitud es igual al número de expresiones. Luego las expresiones se evalúan de izquierda a derecha y sus valores se almacenan en la matriz, y finalmente la matriz se vincula a x. Por lo tanto, x no puede aparecer en las expresiones: no se ha inicializado cuando se evalúan.
Los inicializadores de matrices también se pueden utilizar en relación con expresiones de creación de matrices:
nuevo t[] { expresión, ..., expresión }
Las matrices multidimensionales pueden tener inicializadores anidados (ejemplo 14). Tenga en cuenta que no hay constantes de matriz: se crea una nueva matriz distinta cada vez que se evalúa un inicializador de matriz.
Ejemplo 10: creación y uso de matrices unidimensionales

La primera mitad de este ejemplo lanza un dado mil veces y luego imprime las frecuencias de los resultados. La segunda mitad crea e inicializa una matriz de objetos String.

int[] frecuencia = nuevo int[6]; // Todo inicializado a 0
for (int i=0; i<1000; i++) { // Tira los dados, cuenta las frecuencias int die = (int) (1 + 6 * Math.random());
frecuencia[die-1] += 1;
}
para (int c=1; c<=6; c++)
System.out.println(c + " apareció " + frecuencia[c-1] + "veces");

Número de cadena [] = nueva cadena [20]; // Crea una matriz de elementos nulos
for (int i=0; i<número.longitud; i++) // Rellenar con cadenas "A0", ..., "A19" número[i] "A" + i;
for (int i=0; i<número.longitud; i++) // Imprimir cadenas

System.out.println(número[i]);


Ejemplo 11: Verificación del tipo de asignación de elementos de matriz en tiempo de ejecución
Este programa compila, pero en tiempo de ejecución a[2] =d arroja ArrayStoreException, ya que la clase del objeto vinculado a d (es decir, Doble) no es un subtipo del tipo de elemento de a (es decir, Integer).

Número[] a = nuevo entero[10]; // Longitud 10, tipo de elemento Entero Doble d = new Double(3.14); // Tipo Doble, clase Doble Entero i = new Integer(117); // Tipo Entero, clase Número Entero n = i; // Tipo Número, clase Entero
a[0] = yo; // OK, Integer es un subtipo de Integer

un[1] = norte; // OK, Integer es un subtipo de Integer

a[2] = re; // No, Doble no es subtipo de Entero


Ejemplo 12: uso de una matriz inicializada
El método checkdate aquí se comporta igual que checkdate en el ejemplo 2. La matriz debe declararse fuera del método; de lo contrario, se crea una nueva matriz distinta para cada llamada al método.

int estático [] días = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

fecha de verificación booleana estática (int mes, int día)
{ return (mes >= 1) && (mes <= 12) && (día >= 1) && (día <= días[mes-1]); }

Ejemplo 13: creación de una cadena a partir de una matriz de caracteres
Al reemplazar el carácter cl por el carácter c2 en una cadena, el resultado se puede construir en una matriz de caracteres porque se conoce su longitud. Esto es un 50 por ciento más rápido que el ejemplo 85, que utiliza un búfer de cadena.

Cadena estática reemplazarCharChar(String s, char cl, char c2) {
char[] res = nuevo char[s.length()]; para (int i=0; i<s.length(); i++)
si (s.charAt(i) == cl)
res[i] = c2; demás
res[i] = s.charAt(i);
devolver nueva cadena (res); // Una cadena que contiene los caracteres de res
}

Matrices multidimensionales
Los tipos de matrices multidimensionales se escriben t[] [], t[] [] [], etc. Se crea (asigna) una matriz rectangular de n dimensiones de tamaño ℓ1 × ℓ2 × ... × ℓn utilizando la expresión de creación de matriz
nuevo t[ℓ1] [ℓ2] ... [ℓn]
Una matriz multidimensional a de tipo t[] [] es de hecho una matriz unidimensional de matrices; su componente
las matrices tienen tipo t[]. Por lo tanto, una matriz multidimensional no tiene por qué ser rectangular y no es necesario crear todas las dimensiones a la vez. Para crear solo las primeras k dimensiones de tamaño ℓ1 × ℓ2 × ... × ℓk de una matriz de n dimensiones, deje los últimos corchetes (n – k) vacíos:
nuevo t[ℓ1] [ℓ2] ... [ℓk] [] ... []
Para acceder a un elemento de una matriz a de n dimensiones, utilice n expresiones de índice: a[i1] [i2] ... [in].

Las matrices de clase de utilidad
La clase Arrays del paquete java.util proporciona métodos de utilidad estáticos para comparar, completar, ordenar y buscar matrices, y para crear una colección (capítulo 20) a partir de una matriz. Los métodos binarioBuscar, igualar, llenar y ordenar a re sobrecargado también en matrices de tipo byte, char, short, int, long, float, double, Object; y es igual y rellena también el tipo booleano. Las versiones de Objeto de binarioSearch y sort utilizan el método compareTo de los elementos de la matriz, a menos que se proporcione un objeto Comparador explícito (sección 20.8).
Lista estática asList (Objeto [] a) devuelve una vista java.util.List de los elementos de a, en orden de índice. La lista resultante implementa RandomAccess (sección 20.2 y ejemplo 94).
static int binarioSearch (byte[] a, byte k) devuelve un índice i>=0 para el cual a[i] ==k, si corresponde; de lo contrario, devuelve i<0 de modo que (-i-1) sería la posición adecuada para k. La matriz a debe ordenarse, como por sort(a), o de lo contrario el resultado no estará definido.
static int binarioSearch(Object[] a, Object k) funciona como el método anterior, pero compara elementos de la matriz usando su método compareTo (sección 20.8 y ejemplo 94).
static int binarioSearch (Objeto[] a, Objeto k, Comparador cmp) funciona como el método anterior, pero compara elementos de matriz usando el método cmp.compare (sección 20.8).
booleano estático es igual (byte[] a1, byte[] a2) devuelve verdadero si a1 y a2 tienen la misma longitud y contienen los mismos elementos, en el mismo orden.
Los valores booleanos estáticos (Objeto[] a1, Objeto[] a2) funcionan como el método anterior, pero compara elementos de la matriz usando su método igual (sección 20.8).
El relleno vacío estático (byte[] a, byte v) establece todos los elementos de a en v.
conjuntos de relleno de vacío estático (byte[] a, int from, int to, byte v)
a[de..(a-1)] a v.
La clasificación estática estática (byte [] a) ordena la matriz mediante clasificación rápida.
static void sort (Object[] a) ordena la matriz a usando mergesort, comparando los elementos de la matriz usando su método compareTo (sección 20.8).
La clasificación estática de vacío (Objeto[] a, Comparador cmp) funciona como el método anterior, pero compara elementos de la matriz utilizando el método cmp.compare (sección 20.8).
clasificación vacía estática (byte[] a, int from, int to) ordena a[from..(to-1)].
Ejemplo 14: creación de matrices multidimensionales

Considere esta matriz rectangular de 3 por 2 y esta matriz bidimensional "irregular" (triangular inferior):

El siguiente programa muestra dos formas (r1, r2) de crear la matriz rectangular y tres formas (t1, t2, t3) de crear la matriz "irregular":

doble[][] r1 = nuevo doble [3] [2];
doble[][] r2 = nuevo doble [3] []; para (int i=0; i<3; i++)
r2[i] = nuevo doble[2];
doble[][] t1 = nuevo doble [3][]; para (int i=0; i<3; i++)
t1[i] = nuevo doble[i+1];
doble[][] t2 = { { 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0, 0.0 } };
doble[][] t3 = nuevo doble[][] { { 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0, 0.0 } };


Ejemplo 15: uso de matrices multidimensionales
El material genético de los organismos vivos se encuentra en el ADN, conceptualmente una cadena AGCTTTTCA de nucleótidos A, C, G y T. Un triple de nucleótidos, como el AGC, se denomina codón; un codón puede codificar un amino

ácido. Este programa cuenta las frecuencias de los 4∙4∙4 = 64 codones posibles, utilizando una matriz tridimensional freq. La matriz auxiliar de Nuc se traduce de las letras de nucleótidos (A,C,G,T) a los índices (0,1,2,3) utilizados en frecuencia. La matriz toNuc se traduce de índices a letras de nucleótidos al imprimir las frecuencias.
static void codonfreq(String s) { int[] fromNuc = new int[128];
for (int i=0; i<fromNuc.length; i++) fromNuc[i] = -1;
deNuc['a'] = deNuc['A'] = 0; deNuc['c'] = deNuc['C'] = 1;
deNuc['g'] = deNuc['G'] = 2; deNuc['t'] = deNuc['T'] = 3;
int[][][] frecuencia = nuevo int [4][4][4];
for (int i=0; i+2<s.length(); i+=3) { int nuc1 = fromNuc[s.charAt(i)]; int nuc2 = fromNuc[s.charAt(i+1)];
int nuc3 = fromNuc[s.charAt(i+2)]; frecuencia[nuc1][nuc2][nuc3] += 1;
}
carácter final[] toNuc = { 'A', 'C', 'G', 'T' }; para (int i=0; i<4; i++)
para (int j=0; j<4; j++) {
para (int k=0; k<4; k++)
System.out.print(" "+toNuc[i]+toNuc[j]+toNuc[k]+": " + frecuencia[i][j][k]);
Sistema.out.println();
}
}

Capítulo 9: Clases
Declaraciones de clase y órganos de clase
Una declaración de clase de clase C tiene la forma
modificadores-de-clase clase C cláusula-extendida cláusula-implementos cuerpo-clase
Una declaración de clase C introduce un nuevo tipo de referencia C. El cuerpo de la clase puede contener declaraciones de campos, constructores, métodos, clases anidadas, interfaces anidadas y bloques inicializadores. Las declaraciones de una clase pueden aparecer en cualquier orden:
{
Declaraciones de campo Declaraciones de constructor Declaraciones de método Declaraciones de clase Declaraciones de interfaz Bloques inicializadores
}
Un campo, método, clase anidada o interfaz anidada se denomina miembro de la clase. Un miembro puede ser declarado estático. Un miembro no estático también se denomina miembro de instancia.
El alcance de un miembro es el cuerpo completo de la clase, excepto cuando esté sombreado por una variable o parámetro o por un miembro de una clase o interfaz anidada. El alcance de un campo (estático) no incluye los inicializadores (estáticos) que preceden a su declaración, pero el alcance de un campo estático sí incluye todos los inicializadores no estáticos. No puede haber dos clases o interfaces anidadas con el mismo nombre, ni dos campos con el mismo nombre, pero un campo, un método y una clase (o interfaz) pueden tener el mismo nombre.
Por código estático mExpresiones y declaraciones ean en inicializadores de campos estáticos, bloques de inicializadores estáticos y métodos estáticos. Por código no estático nos referimos a expresiones y declaraciones en constructores, inicializadores de campos no estáticos, bloques inicializadores no estáticos y métodos no estáticos. El código no estático se ejecuta dentro de un objeto actual, al que se puede hacer referencia como este (sección 11.10). El código estático no puede hacer referencia a miembros no estáticos ni a this, solo a miembros estáticos.
Clases de nivel superior, clases anidadas, clases de miembros y clases locales
Una clase de nivel superior es una clase declarada fuera de cualquier otra clase o declaración de interfaz. Una clase anidada es una clase declarada dentro de otra clase o interfaz. Hay dos tipos de clases anidadas: una clase local se declara dentro de un método, constructor o bloque inicializador; una clase miembro no lo es. Una clase miembro no estática, o una clase local en un miembro no estático, se denomina clase interna, porque un objeto de la clase interna contendrá una referencia a un objeto de la clase circundante. Véase también la sección 9.11.
Modificadores de clase
Para una clase de nivel superior, los modificadores de clase pueden ser una lista pública y como máximo una lista abstracta y final. Para una clase miembro, los modificadores de clase pueden ser una lista estática, y como máximo una lista abstracta y final, y como máximo una lista privada, protegida y pública. Para una clase local, los modificadores de clase pueden ser, como máximo, abstractos y finales.
Ejemplo 16: Declaración de clase
Se declara que la clase Point tiene dos campos no estáticos x e y, un constructor y dos métodos no estáticos. Se utiliza en el ejemplo 41.

clase Punto { int x, y;


Punto(int x, int y) { this.x = x; esto.y = y; }

movimiento vacío (int dx, int dy) { x += dx; y += dy; }



public String toString() { return "(" + x + ", " + y + ")"; }

}


Ejemplo 17: Clase con miembros estáticos y no estáticos
La clase SPoint declara un campo estático allpoints y dos campos no estáticos xey. Por lo tanto, cada objeto SPoint tiene sus propios campos xey, pero todos los objetos comparten el mismo campo de todos los puntos en la clase SPoint.
El constructor inserta el nuevo objeto (this) en el objeto ArrayList allpoints (sección 20.2). El método no estático getIndex devuelve el índice del punto en la lista de la matriz. El método estático getSize devuelve el número de SPoints creados hasta el momento. El método estático getPoint devuelve el iésimo punto en la lista de matriz. La clase SPoint se utiliza en el ejemplo 48.

punto de clase {

ArrayList estático todos los puntos = nuevo ArrayList(); entero x, y;


SPoint(int x, int y) { allpoints.add(this); esto.x = x; esto.y = y; } movimiento vacío (int dx, int dy) { x += dx; y += dy; }
cadena pública toString() { return "(" + x + ","+ y + ")"; } int getIndex() { return allpoints.indexOf(esto); }
static int getSize() { { return allpoints.size(); }

Punto estático getPoint(int i) { return (Punto)todos los puntos.get(i); }

}


Ejemplo 18: Clases de nivel superior, miembros y locales
Véanse también los ejemplos 31 y 36.

clase TLC { // clase de nivel superior TLC clase estática SMC { ... } // clase de miembro estático


clase NMC {...} // Clase de miembro no estático (interno)



void nm() { // Método no estático en TLC

clase NLC {...} // Clase local (interna) en el método

}

static void sm() { // Método estático en TLC

clase SLC {...} // Clase local en el método

}

}


Los modificadores de clase público, final, resumen
Si una clase C de nivel superior se declara pública, entonces se puede acceder a ella fuera de su paquete (capítulo 17).
Si una clase C se declara final, no se pueden declarar subclases de C y, por lo tanto, no se puede anular ningún método declarado en C. Esto es útil para evitar que subclases maliciosas violen las invariantes de representación de datos.
Si una clase C se declara abstracta, entonces no se puede crear instancias de ella, pero sí se pueden crear instancias de subclases no abstractas de C. Una clase abstracta puede declarar constructores y tener inicializadores que se ejecutarán al crear instancias de subclases no abstractas. Una clase abstracta puede declarar métodos abstractos y no abstractos; una clase no abstracta no puede declarar métodos abstractos. Una clase no puede ser abstracta y final al mismo tiempo, porque no se pueden crear objetos a partir de esa clase.
Subclases, superclases, jerarquía de clases, herencia y anulación
Una clase C puede declararse como subclase de la clase B mediante una cláusula ampliada de la forma
la clase C extiende B {...}
En este caso, C es una subclase y por tanto un subtipo (sección 5.4) de B y sus supertipos. La clase C hereda todos los métodos y campos (incluso los privados, aunque no son accesibles en la clase C), pero no los constructores, de B.
La clase B se denomina superclase inmediata de C. Una clase puede tener como máximo una superclase inmediata. La clase predefinida Objeto es una superclase de todas las demás clases; El objeto de clase no tiene superclase. Por lo tanto, las clases forman una jerarquía de clases en la que cada clase es descendiente de su superclase inmediata, excepto Objeto, que está en la cima.
Para realizar alguna inicialización, un constructor de la subclase C puede, como primera acción, llamar explícitamente a un constructor de la superclase inmediata B, utilizando esta sintaxis:
super(lista-real);
Puede aparecer una llamada de constructor de superclase super(...) en ly al comienzo de un constructor. Si un constructor C(...) en la subclase C no llama explícitamente a super(...) como su primera acción, entonces implícitamente llama al constructor predeterminado sin argumentos B() en la superclase B como su primera acción, como si fuera por
súper(). En este caso, B debe tener un constructor B() no privado y sin argumentos. Por el contrario, si no hay un constructor sin argumentos B() en B, entonces C(...) en C debe usar super(...) para llamar explícitamente a algún otro constructor en B.
La declaración de C puede anular (redeclarar) cualquier método no final m heredado de B declarando un nuevo método m con exactamente la misma firma. Un método B anulado m puede denominarse super.m dentro de los constructores, métodos no estáticos e inicializadores no estáticos de C.
El método primordial m en C
debe ser al menos tan accesible (sección 9.7) como el método anulado en B;
debe tener la misma firma y tipo de retorno que el método anulado en B;
debe ser estático si y sólo si el método anulado en B es estático;
o no tiene una cláusula de lanzamiento o tiene una cláusula de lanzamiento que no cubre más clases de excepción que la cláusula de lanzamiento (si la hay) del método anulado en B.
Sin embargo, la declaración de una clase C no puede volver a declarar un campo f heredado de B, sino sólo declarar un campo adicional con el mismo nombre (sección 9.6). El campo B anulado puede denominarse super.f dentro de los constructores, métodos no estáticos e inicializadores no estáticos de C.
Ejemplo 19: clases abstractas, subclases y anulaciones
La clase abstracta Vessel modela la noción de un recipiente (para contener líquidos): tiene un contenido de campo que representa su contenido real, un método abstracto de capacidad para calcular su capacidad máxima y un método para llenar más, pero solo hasta su capacidad. (el exceso se perderá). La clase abstracta tiene

subclases Tanque (un recipiente rectangular), Cubo (un recipiente cúbico, subclase de Tanque) y Barril (un recipiente cilíndrico).
Las subclases implementan el método de capacidad, heredan el campo de contenido y el método de llenado de la superclase y anulan el método toString (heredado de la clase Objeto) para imprimir cada objeto de recipiente de manera apropiada.

buque de clase abstracta { contenido doble;
capacidad doble abstracta();

relleno vacío (doble cantidad) { contenido = Math.min(contenido + cantidad, capacidad()); }

}

clase Tanque extiende Recipiente { doble largo, ancho, alto;
Tanque (doble largo, doble ancho, doble altura)

{ this.length = longitud; this.width = ancho; this.height = altura; } doble capacidad() { retorno largo * ancho * alto; }
cadena pública a cadena ()

{ return "tanque (" + largo + ", " + ancho + ", " + alto + ")"; }

}

clase Cubo extiende Tanque {

Cubo(doble cara) { super(lado, lado, lado);

public String toString() { return "cubo (" + longitud + ")"; }

}

clase Barril extiende Vaso { radio doble, altura;
Barril(doble radio, doble altura) { this.radius = radio; this.height = altura; doble capacidad() { altura de retorno * Math.PI * radio * radio; }
public String toString() { return "barril (" + radio + ", " + altura + ")"; }

}


Ejemplo 20: uso de la jerarquía de embarcaciones del ejemplo 19
La llamada vs[i].capacity() es legal sólo porque el método capacidad, aunque abstracto, se declara en la clase Vessel (ejemplo 19):

public static void main(String[] args) { Vessel vl = new Barrel(3, 10);

Buque v2 = tanque nuevo (10, 20, 12); Buque v3 = nuevo Cubo(4); Buque[] vs = {vl, v2, v3};
v1.relleno(90); v1.rellenar(10); v2.rellenar(100); v3.rellenar(80);

doble suma = 0;
for (int i=0; i<vs.length; i++) suma += vs [i] .capacity();
System.out.println("La capacidad total es " + suma);
for (int i=0; i<vs.length; i++) System.out.println("número de embarcación " + i + ": " + vs[i]);
}

Declaraciones de campo en clases
El propósito de un campo es contener un valor dentro de un objeto (si no estático) o una clase (si es estático). Un campo debe declararse en una declaración de clase. Una declaración de campo tiene una de las formas
modificadores de campo tipo fieldnamel, fieldname2,...; modificadores de campo tipo fieldnamel = inicializador1,...;
Los modificadores de campo pueden ser una lista de los modificadores estático, final, transitorio (sección 21.11) y volátil y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7). Si un campo f en la clase C se declara estático, entonces f está asociado con la clase C y se puede hacer referencia a él independientemente de cualquier objeto de la clase C. El campo se puede denominar C.f o o.f, donde o es una expresión de tipo C, o, en la declaración de C, como f. Si un campo f en la clase C no se declara estático, entonces f se asocia con un objeto (también llamado instancia) de la clase C, y cada instancia tiene su propia instancia del campo. Se puede hacer referencia al campo como o.f, donde o es una expresión de tipo C, o, en código no estático en la declaración de C, como f.
Si un campo f en la clase C se declara final, el campo no se puede modificar después de la inicialización. Si f tiene un tipo de referencia y apunta a un objeto o matriz, los campos del objeto o los elementos de la matriz aún pueden modificarse. La inicialización debe ocurrir en el d declaración o en un bloque inicializador (sección 9.10), o (si el campo no es estático) precisamente una vez en cada constructor de la clase C.
Un inicializador de campo puede ser una expresión o un inicializador de matriz (sección 8.2). Un inicializador de campo estático sólo puede hacer referencia a miembros estáticos de C y no puede generar excepciones marcadas (capítulo 14).
A un campo se le asigna un valor inicial predeterminado dependiendo de su tipo t. Si t es un tipo primitivo, el campo se inicializa a 0 (cuando t es byte, char, short, int o long) o 0,0 (cuando t es flotante o doble) o falso (cuando t es booleano). Si t es un tipo de referencia, el campo se inicializa a nulo.
Los campos estáticos se inicializan cuando se carga la clase. Primero, a todos los campos estáticos se les dan sus valores iniciales predeterminados, luego se ejecutan los bloques inicializadores estáticos (sección 9.10) y los inicializadores de campos estáticos, en orden de aparición en la declaración de clase.
Los campos no estáticos se inicializan cuando se llama a un constructor, momento en el cual todos los campos estáticos ya se han inicializado (sección 9.9).
Si una clase C declara un campo no estático f, y C es una subclase de una clase B que tiene un campo no estático f, entonces cada objeto de la clase C tiene dos campos, ambos llamados f: uno es el campo B f declarado en el superclase B, y uno es el campo C f declarado en el propio C. A qué campo se hace referencia mediante un acceso al campo o.f está determinado por el tipo de o (sección 11.9).
Los modificadores de acceso de miembros privado, protegido, público
Un miembro (campo o método o clase o interfaz anidada) siempre es accesible en la clase en la que está declarado, excepto cuando esté sombreado por una variable, parámetro o campo (de una clase anidada). Los modificadores de acceso privado, protegido y público determinan dónde más se puede acceder al miembro.
Si un miembro se declara privado en la clase de nivel superior C o en una clase anidada dentro de C, es accesible en C y sus clases anidadas, pero no en sus subclases fuera de C ni en otras clases. Si un miembro de la clase C se declara protegido, es accesible en todas las clases del mismo paquete (capítulo 17) que C y en las subclases de C, pero no en las que no son subclases de otros paquetes. Si un miembro de la clase C no se declara privado, protegido o público, tiene acceso al paquete, o acceso predeterminado, y sólo es accesible en clases dentro del mismo paquete que C, no en clases de otros paquetes. Si un miembro de la clase C es

declarado público, es accesible en todas las clases, incluidas las clases de otros paquetes. Así, en orden de accesibilidad creciente, tenemos acceso privado, acceso a paquetes (o predeterminado), acceso protegido y acceso público.
Ejemplo 21: Declaraciones de campo
La clase SPoint (ejemplo 17) declara un campo estático todos los puntos y dos campos no estáticos x e y. El ejemplo 30 declara un campo estático ps de tipo de matriz double[]. Su inicializador de campo asigna una matriz de seis elementos y la vincula a ps, y luego el bloque inicializador (sección 9.10) almacena algunos números en la matriz. La clase Barrel en el ejemplo 80 declara dos campos no estáticos, radio y altura. Los campos son definitivos y por tanto deben inicializarse (lo cual se hace en el constructor).


Ejemplo 22: Varios campos con el mismo nombre
Un objeto de clase C aquí tiene dos campos no estáticos llamados vf, uno declarado en la superclase B y otro declarado en el propio C. De manera similar, un objeto de clase D tiene tres campos no estáticos llamados vf. La clase B y la clase C tienen cada una un campo estático llamado sf. La clase D no declara un campo estático sf, por lo que en la clase D el nombre sf se refiere al campo estático sf en la superclase C. Los ejemplos 35 y 45 utilizan estas clases.

clase B // Un campo no estático vf, un sf estático

{ int vf; estático int sf; B(int yo) { vf = yo; sf = i+1; } }



la clase C extiende B // Dos campos no estáticos vf, uno estático sf

{ int vf; estático int sf; C(int i) { super(i+20); vf = yo; sf = i+2; } }



la clase D extiende C // Tres campos no estáticos vf

{ int vf; D(int i) { super(i+40); vf = yo; sf = i+4; } }


Ejemplo 23: Modificadores de acceso de miembros
La jerarquía de embarcaciones en el ejemplo 19 no es satisfactoria porque todos pueden leer y modificar los campos de un objeto de embarcación. El ejemplo 80 presenta una versión mejorada de la jerarquía en la que (1) el campo de contenido en Vessel se hace privado para evitar modificaciones, (2) un nuevo método público getContents permite leer el campo y (3) los campos de Tank y Barrel son declarado protegido para permitir el acceso desde subclases declaradas en otros paquetes.
Dado que el contenido del campo en Vessel es privado, no es accesible en las subclases (Tank, Barrel, ...), pero las subclases aún heredan el campo. Por lo tanto, cada objeto de subclase de recipiente tiene espacio para almacenar el campo, pero puede cambiarlo y acceder a él sólo utilizando los métodos fill y getContents heredados de la superclase abstracta.


Ejemplo 24: Accesibilidad de miembros privados

Se puede acceder a un miembro privado en cualquier lugar dentro de la clase de nivel superior adjunta (y solo allí). acceso a clase {
int estático privado x; clase estática SI {
privado estático int y = x; // Accede al privado x desde la clase adjunta

}

vacío estático m() {

int z = SI.y; // Accede al privado y desde la clase anidada

}

}


Declaraciones de métodos
Se debe declarar un método dentro de una clase. Una declaración de método que declara el método m tiene la forma
modificadores-de-método tipo-de-retorno m (lista-formal) arroja-cláusula-cuerpo-del-método
La lista formal es una lista separada por comas de cero o más declaraciones de parámetros formales, de la forma
modificador-parámetro tipo nombre-parámetro
El modificador de parámetro puede ser final, lo que significa que el parámetro no se puede modificar dentro del método o puede estar ausente. El tipo es cualquier tipo. El nombre del parámetro es cualquier nombre, pero los nombres de los parámetros deben ser distintos. Un parámetro formal es una variable inicializada; su alcance es el cuerpo del método.
El nombre del método m junto con la lista t1,..., tn de tipos de parámetros declarados en la lista formal
determine la firma del método m(t1,..., tn). El tipo de retorno no forma parte de la firma del método.
Una clase puede declarar más de un método con el mismo nombre de método, siempre que tengan firmas de método diferentes. Esto se llama sobrecarga del nombre del método.
El cuerpo del método es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. En particular, el cuerpo del método puede contener declaraciones de retorno. Si el tipo de retorno es nulo, el método no devuelve un valor y ninguna declaración de retorno en el cuerpo del método puede tener un argumento de expresión. Si el tipo de retorno no es nulo sino un tipo, el método debe devolver un valor: no debe ser posible que la ejecución llegue al final del cuerpo del método sin ejecutar una declaración de retorno. Además, cada declaración de retorno debe tener un argumento de expresión cuyo tipo sea un subtipo del tipo de retorno.
Los modificadores de método pueden ser abstractos o una lista de estáticos, finales, sincronizados (sección 15.2) y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7).
Si un método m en la clase C se declara estático, entonces m está asociado con la clase C; se puede hacer referencia a él sin ningún objeto. El método puede llamarse como C.m(...) o como o.m(...), donde o es una expresión cuyo tipo es un subtipo de C, o, dentro de los métodos, constructores, inicializadores de campo y bloques inicializadores en C, simplemente como m(...). Un método estático sólo puede hacer referencia a campos y métodos estáticos de la clase.
Si un método m en la clase C no se declara estático, entonces m está asociado con un objeto (instancia) de la clase
C. Fuera de la clase, el método debe llamarse como o.m(...), donde o es un objeto de clase C o una subclase, o, dentro de métodos no estáticos, inicializadores de campos no estáticos y bloques de inicializadores no estáticos en C, simplemente como metro(...). Un método no estático puede hacer referencia a todos los campos y métodos de la clase C, sean estáticos o no.
Si un método m en la clase C se declara final, no se puede anular (redefinir) en las subclases.
Si un método m en la clase C se declara abstracto, la clase C debe ser abstracta (y por lo tanto no se puede crear una instancia). Un método abstracto no puede ser estático, final ni sincronizado, y su declaración tiene esta forma, sin un cuerpo de método:
modificadores de métodos abstractos tipo de retorno m (lista-formal) cláusula de lanzamiento;
La cláusula throws de un método o constructor tiene la forma
lanza E1, E2, ...
donde El, E2,... son los nombres de los tipos de excepción que cubren todas las excepciones marcadas que el método o constructor puede generar. Si la ejecución puede generar la excepción e, entonces e es una excepción no verificada (capítulo 14) o una excepción verificada cuya clase es un subtipo de uno de El, E2,...
Ejemplo 25: Sobrecarga de nombres de métodos y firmas
Esta clase declara cuatro métodos sobrecargados m cuyas firmas (sección 5.5) son m(int) y m(boolean) y m(int, double) y m(double, double). Algunos de los métodos sobrecargados son estáticos, otros no. Los métodos sobrecargados pueden tener diferentes tipos de retorno, como se muestra aquí.
El ejemplo 50 explica las llamadas a métodos.
Sería legal declarar un método adicional con la firma m(double, int), pero entonces la llamada al método m(10, 20) se volvería ambigua e ilegal. Es decir, no hay forma de determinar si llamar a m(int, double) o m(double, int).

sobrecarga de clase {

doble m(int i) { return i; }

booleano m(booleano b) { return !b; }

estático doble m(int x, doble y) { return x + y + 1; } estática doble m(doble x, doble y) { return x + y + 3; }



}

}


Ejemplo 26: Anulación de método
En la jerarquía de embarcaciones (ejemplo 19), las clases Tank y Barrel anulan el método toString heredado de la superclase universal Object, y la clase Cube anula toString heredado de la clase Tank.


Ejemplo 27: Anulación y sobrecarga de métodos
La clase C1 declara el método sobrecargado ml con firmas ml(double) y ml(int), y el método m2 con firma m2(int). La subclase C2 oculta el método ml(double) de C1 y sobrecarga m2 declarando una variante adicional. Las llamadas a estos métodos se muestran en el ejemplo 51.

clase Cl {

ml vacío estático (doble d) { System.out.println("lld"); } void ml(int i) { System.out.println("lli"); }
void m2(int i) { System.out.println("12i"); }

}



clase C2 extiende C1 {

estadoy; // Accede al privado y desde la clase anidada

}

}


Declaraciones de métodos
Se debe declarar un método dentro de una clase. Una declaración de método que declara el método m tiene la forma
modificadores-de-método tipo-de-retorno m (lista-formal) arroja-cláusula-cuerpo-del-método
La lista formal es una lista separada por comas de cero o más declaraciones de parámetros formales, de la forma
modificador-parámetro tipo nombre-parámetro
El modificador de parámetro puede ser final, lo que significa que el parámetro no se puede modificar dentro del método o puede estar ausente. El tipo es cualquier tipo. El nombre del parámetro es cualquier nombre, pero los nombres de los parámetros deben ser distintos. Un parámetro formal es una variable inicializada; su alcance es el cuerpo del método.
El nombre del método m junto con la lista t1,..., tn de tipos de parámetros declarados en la lista formal
determine la firma del método m(t1,..., tn). El tipo de retorno no forma parte de la firma del método.
Una clase puede declarar más de un método con el mismo nombre de método, siempre que tengan firmas de método diferentes. Esto se llama sobrecarga del nombre del método.
El cuerpo del método es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. En particular, el cuerpo del método puede contener declaraciones de retorno. Si el tipo de retorno es nulo, el método no devuelve un valor y ninguna declaración de retorno en el cuerpo del método puede tener un argumento de expresión. Si el tipo de retorno no es nulo sino un tipo, el método debe devolver un valor: no debe ser posible que la ejecución llegue al final del cuerpo del método sin ejecutar una declaración de retorno. Además, cada declaración de retorno debe tener un argumento de expresión cuyo tipo sea un subtipo del tipo de retorno.
Los modificadores de método pueden ser abstractos o una lista de estáticos, finales, sincronizados (sección 15.2) y como máximo uno de los modificadores de acceso privado, protegido y público (sección 9.7).
Si un método m en la clase C se declara estático, entonces m está asociado con la clase C; se puede hacer referencia a él sin ningún objeto. El método puede llamarse como C.m(...) o como o.m(...), donde o es una expresión cuyo tipo es un subtipo de C, o, dentro de los métodos, constructores, inicializadores de campo y bloques inicializadores en C, simplemente como m(...). Un método estático sólo puede hacer referencia a campos y métodos estáticos de la clase.
Si un método m en la clase C no se declara estático, entonces m está asociado con un objeto (instancia) de la clase
C. Fuera de la clase, el método debe llamarse como o.m(...), donde o es un objeto de clase C o una subclase, o, dentro de métodos no estáticos, inicializadores de campos no estáticos y bloques de inicializadores no estáticos en C, simplemente como metro(...). Un método no estático puede hacer referencia a todos los campos y métodos de la clase C, sean estáticos o no.
Si un método m en la clase C se declara final, no se puede anular (redefinir) en las subclases.
Si un método m en la clase C se declara abstracto, la clase C debe ser abstracta (y por lo tanto no se puede crear una instancia). Un método abstracto no puede ser estático, final ni sincronizado, y su declaración tiene esta forma, sin un cuerpo de método:
modificadores de métodos abstractos tipo de retorno m (lista-formal) cláusula de lanzamiento;
La cláusula throws de un método o constructor tiene la forma
lanza E1, E2, ...
donde El, E2,... son los nombres de los tipos de excepción que cubren todas las excepciones marcadas que el método o constructor puede generar. Si la ejecución puede generar la excepción e, entonces e es una excepción no verificada (capítulo 14) o una excepción verificada cuya clase es un subtipo de uno de El, E2,...
Ejemplo 25: Sobrecarga de nombres de métodos y firmas
Esta clase declara cuatro métodos sobrecargados m cuyas firmas (sección 5.5) son m(int) y m(boolean) y m(int, double) y m(double, double). Algunos de los métodos sobrecargados son estáticos, otros no. Los métodos sobrecargados pueden tener diferentes tipos de retorno, como se muestra aquí.
El ejemplo 50 explica las llamadas a métodos.
Sería legal declarar un método adicional con la firma m(double, int), pero entonces la llamada al método m(10, 20) se volvería ambigua e ilegal. Es decir, no hay forma de determinar si llamar a m(int, double) o m(double, int).

sobrecarga de clase {

doble m(int i) { return i; }

booleano m(booleano b) { return !b; }

estático doble m(int x, doble y) { return x + y + 1; } estática doble m(doble x, doble y) { return x + y + 3; }



}

}


Ejemplo 26: Anulación de método
En la jerarquía de embarcaciones (ejemplo 19), las clases Tank y Barrel anulan el método toString heredado de la superclase universal Object, y la clase Cube anula toString heredado de la clase Tank.


Ejemplo 27: Anulación y sobrecarga de métodos
La clase C1 declara el método sobrecargado ml con firmas ml(double) y ml(int), y el método m2 con firma m2(int). La subclase C2 oculta el método ml(double) de C1 y sobrecarga m2 declarando una variante adicional. Las llamadas a estos métodos se muestran en el ejemplo 51.

clase Cl {

ml vacío estático (doble d) { System.out.println("lld"); } void ml(int i) { System.out.println("lli"); }
void m2(int i) { System.out.println("12i"); }

}



clase C2 extiende C1 {

estadoc void ml(doble d) { System.out.println("21d"); } void ml(int i) { System.out.println("21i"); }
void m2(doble d) { System.out.println("22d"); }

}

Declaraciones de constructor
El propósito de un constructor en la clase C es inicializar nuevos objetos (instancias) de la clase. A
La declaración del constructor en la clase C tiene la forma.
modificadores-constructor C(lista-formal) lanza-cláusula cuerpo-constructor
Los modificadores del constructor pueden ser una lista de, como máximo, privado, protegido y público (sección 9.7); un constructor no puede ser abstracto, final o estático. Un constructor no tiene tipo de retorno.
Los constructores se pueden sobrecargar de la misma manera que los métodos: la firma del constructor (una lista de los tipos de parámetros en la lista formal) se usa para distinguir los constructores en la misma clase. Un constructor puede llamar a otro constructor sobrecargado en la misma clase usando la sintaxis:
esto (lista-real)
pero un constructor no puede llamarse a sí mismo, directa o indirectamente. Una llamada a this(...) a otro constructor, si está presente, debe ser la primera acción de un constructor, antes de cualquier declaración o declaración.
El cuerpo del constructor es una declaración de bloque (sección 12.2) y por lo tanto puede contener declaraciones así como declaraciones de variables y clases locales. El cuerpo del constructor puede contener declaraciones de retorno, pero ninguna declaración de retorno puede tomar un argumento de expresión.
Una clase que no declara explícitamente un constructor declara implícitamente un valor predeterminado público y sin argumentos.
constructor cuya única acción (implícita) es llamar al constructor de la superclase (sección 9.5):
público C() { super(); }
La cláusula throws del constructor especifica las excepciones marcadas que puede lanzar el constructor, de la misma manera que para los métodos (sección 9.8).
Cuando new crea un nuevo objeto en la memoria (sección 11.7), los campos no estáticos del objeto reciben valores iniciales predeterminados según su tipo. Luego se llama a un constructor para inicializar aún más el objeto, y sucede lo siguiente: primero, se llama a algún constructor de superclase (explícita o implícitamente, consulte los ejemplos 29 y 52) exactamente una vez, luego los inicializadores de campos no estáticos y los bloques de inicializadores no estáticos se ejecutan una vez por semana. orden de aparición en la declaración de clase y, finalmente, se ejecuta el cuerpo del constructor (excepto la llamada explícita al constructor de la superclase, si corresponde). La llamada a un constructor de superclase provocará una llamada a un constructor de su superclase, y así sucesivamente, hasta llegar a Object().
Bloques inicializadores, inicializadores de campo e inicializadores
Además de los inicializadores de campo (sección 9.6), una clase puede contener bloques de inicializador. Los bloques inicializadores se pueden utilizar cuando los inicializadores o constructores de campos no son suficientes. Usamos el término inicializador para referirnos a inicializadores de campo así como a bloques de inicializador. Un bloque inicializador estático tiene la forma
declaración de bloque estático
Los bloques inicializadores estáticos y los inicializadores de campos estáticos se ejecutan, en orden de aparición en la declaración de clase, cuando se carga la clase. Un bloque inicializador no estático es simplemente una declaración de bloque independiente. Los bloques inicializadores no estáticos se ejecutan después del constructor cuando se crea un objeto (sección 9.9).
Un inicializador no puede lanzar una excepción marcada (capítulo 14). Si la ejecución de un inicializador estático genera una excepción (no marcada) durante la carga de la clase, esa excepción se descarta y en su lugar se genera la excepción ExceptionInInitializerError.
Ejemplo 28: Sobrecarga del constructor; Llamar a otro constructor
Agregamos un nuevo constructor a la clase Point (ejemplo 16), sobrecargando así sus constructores. El antiguo constructor tiene la firma Punto(int, int) y el nuevo Punto(Punto). El nuevo constructor hace una copia del punto p llamando al antiguo constructor usando la sintaxis this(p.x, p.y).
clase Punto { int x, y;


Punto(int x, int y) // Constructor sobrecargado

{ esto.x = x; esto.y = y; }

Punto(Punto p) // Constructor sobrecargado

{ this(p.x, py); } // Llama al primer constructor



movimiento vacío (int dx, int dy)

{ x += dx; y += dy; }



cadena pública a cadena ()

{ return "(" + x + ", " + y + ")"; }

}


Ejemplo 29: Llamar a un constructor de superclase
El constructor de la subclase ColoredPoint (ejemplo 71) llama al constructor de su superclase usando la sintaxis super(x, y).

Ejemplo 30: Inicializadores de campo y bloques de inicializador
Aquí el inicializador de campo estático asigna una matriz y la vincula al campo ps. El bloque inicializador estático llena la matriz con una secuencia creciente de números pseudoaleatorios, luego los escala para que el último número sea 1,0 (esto es útil para generar tiradas de un dado cargado aleatoriamente). Esto no se puede hacer utilizando únicamente el inicializador de campo.
Se podrían eliminar las dos apariciones de static para obtener otro ejemplo, con un campo no estático ps, un inicializador de campo no estático y un bloque inicializador no estático. Sin embargo, es más común que un constructor inicialice los campos no estáticos.

clase EjemploInicializador {

doble estático [] ps = nuevo doble [6];



static { // Bloque inicializador estático

doble sum = 0;
for (int i=0; i<ps.length; i++) // Rellenar con números aleatorios crecientes ps[i] = suma += Math.random();
for (int i=0; i<ps.length; i++) // Escala para que el último elemento ps sea 1,0 ps[i] /= sum;
}
...
}

Clases anidadas, clases de miembros, clases locales y clases internas
Una clase anidada no estática, es decir, una clase miembro no estática NMC o una clase local NLC en un miembro no estático, se denomina clase interna. Un objeto de una clase interna siempre contiene una referencia a un objeto de la clase envolvente C, llamado objeto envolvente. Se puede hacer referencia a ese objeto como C.this (ejemplo 36), por lo que se puede hacer referencia a un miembro no estático x del objeto circundante como C.this.x.
Una clase interna o clase local no puede tener miembros estáticos. Más precisamente, todos los campos estáticos también deben ser finales, y los métodos y clases anidadas en una clase interna o local deben ser no estáticos.
Una clase anidada estática, es decir, una clase miembro estática SMC o una clase local en un miembro estático, no tiene ningún objeto envolvente y no puede hacer referencia a miembros no estáticos de la clase envolvente C. Esta es la restricción estándar para los miembros estáticos de una clase ( apartado 9.1). Una clase de miembro estático puede tener a su vez miembros estáticos y no estáticos.
Si una clase local hace referencia a variables o parámetros formales en el método, constructor o inicializador adjunto, esas variables o parámetros deben ser finales.

Clases anónimas
Una clase anónima es un tipo especial de clase local; por lo tanto, debe declararse dentro de un método, constructor o inicializador. Se puede declarar una clase anónima y crear exactamente una instancia, utilizando la sintaxis de expresión especial.
nuevo cuerpo de clase C (lista real)
donde C es un nombre de clase. Esto crea una subclase anónima de la clase C, con el cuerpo de clase dado (sección 9.1). Además, crea un objeto de esa subclase anónima y llama al constructor de C apropiado con los argumentos en lista-actual, como si fuera super(lista-actual). Una clase anónima no puede declarar sus propios constructores.
Cuando I es el nombre de una interfaz, la sintaxis de expresión similar
nuevo yo()
cuerpo de clase
crea una clase local anónima, con el cuerpo de clase dado (sección 9.1), que debe implementar la interfaz I, y también crea un objeto de esa clase anónima. Tenga en cuenta que la lista de parámetros después de I debe estar vacía.
Ejemplo 31: Clases miembro y clases locales class TLC { // Clase de nivel superior static int sf;
int nf;

clase estática SMC { // Clase de miembro estático static int ssf = sf + TLC.sf; // puede tener miembros estáticos
int snf = sf + TLC.sf; // no se pueden utilizar miembros TLC no estáticos

}

clase NMC { // clase de miembro no estático (interno)

int nnf1 = sf + nf; // puede usar miembros TLC no estáticos int nnf2 = TLC.sf + TLC.this.nf; // no puede tener miembros estáticos
}

void nm() { // Método no estático en TLC

clase NLC { // Clase local (interna) en el método

int m(int p) { return sf+nf+p; } // puede usar miembros TLC no estáticos

} } }


Ejemplo 32: un iterador como clase local
Los sufijos del método devuelven un objeto de la clase local SuffixIterator, que implementa la interfaz Iterator (sección 20.7) para enumerar los sufijos no vacíos de la cadena s:

clase LocalInnerClassExample { public static void main(String[] args) { Iterador seq = sufijos(args[0]);
mientras (seq.hasNext()) System.out.println(seq.next());
}

Sufijos de iterador estático (cadena final s) { clase SuffixIterator implementa Iterador {
int índice inicial=0;
public boolean hasNext() { return startindex < s.length (); } objeto público siguiente() { return s.substring(startindex++); }
public void remove() { lanzar nueva UnsupportedOperationException(); }
}
devolver nuevo SuffixIterator();
}
}


Ejemplo 33: un iterador como clase local anónima
Alternativamente, podemos usar una clase local anónima en los sufijos de métodos: sufijos de iterador estáticos (cadenas finales) {
devolver

nuevo iterador () {

int índice inicial=0;
public boolean hasNext() { return startindex < s.length (); } objeto público siguiente() { return s.substring (startindex+ + ); }
public void remove() { lanzar nueva UnsupportedOperationException(); }
};
}

Capítulo 10: Clases y objetos en la computadora
¿Qué es una clase?
Conceptualmente, una clase representa un concepto, una plantilla para crear instancias (objetos). En la computadora, una clase es un trozo de memoria, que se reserva una vez, cuando la clase se carga en tiempo de ejecución. Una clase tiene las siguientes partes:
El nombre de la clase.
Espacio para todos los miembros estáticos de la clase.
Una clase se puede dibujar como un cuadro. La clase de encabezado SPoint proporciona el nombre de la clase y el cuadro en sí contiene los miembros estáticos de la clase:

¿Qué es un objeto?
Conceptualmente, un objeto es una instancia de un concepto (una clase). En la computadora, un objeto es un trozo de memoria, reservado por una expresión de creación de objeto new C(...); ver sección 11.7. Cada evaluación de una expresión de creación de objetos new C(...) crea un objeto distinto, con su propia porción de memoria de la computadora. Un objeto tiene las siguientes partes:
Una referencia a la clase C del objeto; esta es la clase C utilizada al crear el objeto.
Espacio para todos los miembros no estáticos del objeto.
Un objeto se puede dibujar como una caja. . El encabezado: SPoint proporciona la clase del objeto (subrayada) y el resto del cuadro contiene los miembros no estáticos del objeto:

Objetos internos
Cuando NIC es una clase interna (una clase miembro no estática o una clase local en código no estático) en una clase C, entonces un objeto de clase NIC es un objeto interno. Además de la clase del objeto y los campos no estáticos, un objeto interno siempre contendrá una referencia a un objeto envolvente, que es un objeto de la clase envolvente más interna C. La referencia del objeto envolvente se puede escribir C.this en programas Java.
Por otro lado, un objeto de una clase anidada estática no contiene ninguna referencia a un objeto circundante.
Ejemplo 34: Objetos y Clases
Esta es la memoria de la computadora al final del método principal en el ejemplo 48, usando la clase SPoint del ejemplo 17. Las variables p y s se refieren al mismo objeto, la variable q es nula y la variable r se refiere al objeto más a la derecha. Ninguna variable se refiere al objeto del medio; será eliminado por el recolector de basura.



Ejemplo 35: Objetos con múltiples campos del mismo nombre
Esta es la memoria de la computadora al final del método principal en el ejemplo 45, usando las clases del ejemplo 22. Las clases B y C tienen cada una un único campo estático sf; la clase D no tiene ninguno. Los dos objetos de

cada uno de la clase C tiene dos campos no estáticos vf (llamados B/vf y C/vf a continuación), y el objeto de clase D tiene tres campos no estáticos vf.



Ejemplo 36: Objetos internos
El ejemplo 31 declara una clase TLC con un miembro no estático (interno) de clase NMC y un miembro estático de clase SMC. Si creamos un objeto TLC, dos objetos NMC y un objeto SMC,

TLC oo = nuevo TLC();

TLC.NMC iolio1 = oo.nuevo NMC(), io2 = oo.nuevo NMC(); TLC.SMC sio = nuevo TLC.SMC();
entonces la memoria de la computadora contendrá estos objetos (las clases no se muestran)


Capítulo 11: Expresiones
Descripción general
Se evalúa una expresión para obtener un valor (como 117). Además, la evaluación de una expresión puede cambiar el estado de la computadora: los valores de las variables, campos y elementos de la matriz, el contenido de los archivos, etc. Más precisamente, la evaluación de una expresión.
termina normalmente, produciendo un valor; o
termina abruptamente lanzando una excepción; o
no termina en absoluto (por ejemplo, porque llama a un método que no termina). Las expresiones se crean a partir de literales (constantes anónimas), variables, campos, operadores, llamadas a métodos, accesos a matrices, expresiones condicionales, el nuevo operador, etc.; consulte la tabla de formas de expresión en la página opuesta.
Se debe distinguir el tipo en tiempo de compilación de una expresión de la clase en tiempo de ejecución de un objeto. Una expresión tiene un tipo (capítulo 5) inferido por el compilador. Cuando se trata de un tipo de referencia t y el valor de la expresión es un objeto o, entonces la clase del objeto o será un subtipo de t pero no necesariamente igual a t. Por ejemplo, la expresión (Número) (nuevo Integer (2) ) tiene tipo Número, pero su valor es un objeto cuya clase es Integer, una subclase de Número.


Tabla de formas de expresión
La tabla de formas de expresión muestra la forma, el significado, la asociatividad, los tipos de argumentos (operandos) y los tipos de resultados de las expresiones. Las expresiones se agrupan según la precedencia, como lo indican las reglas horizontales, desde la precedencia alta hasta la precedencia baja. Los formularios de mayor prioridad se evalúan antes que los de menor prioridad. Se pueden utilizar paréntesis para enfatizar o forzar un orden particular de evaluación.
Cuando un operador (como +) es asociativo por la izquierda, una secuencia el + e2 + e3 de operadores se evalúa como si estuviera entre paréntesis (el + e2) + e3. Cuando un operador (como =) es asociativo por la derecha, una secuencia el = e2 = e3 de operadores se evalúa como si estuviera entre paréntesis el = (e2 = e3).
En las columnas de tipo de argumento y tipo de resultado de la tabla, el número entero representa cualquiera de char, byte, short, int o long; y numérico significa entero, flotante o doble.
Para un operador con un operando entero o numérico, el tipo de promoción es doble si el operando tiene tipo doble; es flotante si el operando es de tipo flotante; es largo si el operando es de tipo largo; en caso contrario es int (es decir, si el operando es de tipo byte, char, short o int).
Para un operador con dos operandos enteros o numéricos (excepto los operadores de turno; sección 11.4), el tipo de promoción es doble si algún operando tiene tipo doble; de lo contrario, es flotante si algún operando tiene tipo flotante; de lo contrario, es largo si algún operando tiene el tipo largo; de lo contrario es int.
Antes de realizar la operación, los operandos se promocionan, es decir, se convierten al tipo de promoción.
mediante una conversión de tipo ensanchado (sección 11.12.1).
Si el tipo de resultado también se proporciona como numérico, es igual al tipo de promoción. Por ejemplo, 10/3 tiene tipo
int, mientras que 10/3.0 tiene tipo double y c + (byte)1 tiene tipo int cuando c tiene tipo char.

Tabla de formas de expresión

Tabla de formas de expresión


Operadores aritméticos
El valor de la expresión postincremento x++ es el de x, y su efecto es incrementar x en 1; y de manera similar para el postdecremento x--. El valor de la expresión de preincremento. ++x es el de x+1, y su efecto es incrementar x en 1; y de manera similar para el predecremento --x.
La división de enteros el/e2 se trunca, es decir, se redondea hacia cero, por lo que 10/3 es 3 y (-10)/3 es -3. El resto entero x%y es igual a x-(x/y)*y cuando y es distinto de cero; tiene el mismo signo que x. La división de enteros o el resto por cero genera la excepción ArithmeticException. El desbordamiento de enteros no genera una excepción, sino que se ajusta. Por lo tanto, en el tipo int, la expresión 2147483647+1 se evalúa como - 2147483648 y la expresión -2147483648-1 se evalúa como 2147483647.
El resto de punto flotante x%y es aproximadamente igual a x- (((int) (x/y))*y cuando y es distinto de cero. La división de punto flotante por cero y el desbordamiento de punto flotante no generan excepciones, pero producen valores especiales IEEE754. (de tipo flotante o doble) como Infinity o NaN ("no es un número").

Operadores logicos
Los operadores == y ! = requieren que los tipos de operandos sean compatibles: uno debe ser un subtipo del otro. Dos valores de tipo primitivo son iguales (por = =) si representan el mismo valor después de la conversión a su supertipo común. Por ejemplo, 10 y 10,0 son iguales. Dos valores de tipo de referencia son iguales (por ==) si ambos son nulos, o ambos son referencias al mismo objeto o matriz, creado por la misma ejecución del nuevo operador. Por lo tanto, no utilice == o ! = para comparar cadenas: dos cadenas s1 y s2 pueden contener la misma secuencia de caracteres y, por lo tanto, ser iguales en s1.equals (s2), pero ser objetos distintos y, por lo tanto, desiguales en s1==s2 (ejemplo 5).
Los operadores lógicos && y || realizar una evaluación abreviada: si e1 se evalúa como verdadero en el&&e2, entonces se evalúa e2 para obtener el valor de la expresión; de lo contrario, se ignora e2 y el valor de la expresión es falso. Por el contrario, si e1 se evalúa como falso en e1 || e2, luego se evalúa e2 para obtener el valor de la expresión; de lo contrario, se ignora e2 y el valor de la expresión es verdadero. Por
Por el contrario, los operadores & (lógico estricto y) y ^ (lógico estricto exclusivo-o) y | (lógico estricto o) siempre evalúa ambos operandos, independientemente del valor del operando de la izquierda. Generalmente el atajo
operadores && y || son preferibles.

Operadores bit a bit y operadores de turno
Los operadores ~ (complemento bit a bit) y & (bit a bit y) y ^ (bit a bit exclusivo-o) y | (bit a bit o) se puede utilizar en operandos de tipo entero. Los operadores trabajan en paralelo en todos los bits de la representación en complemento a 2 de los operandos. Por lo tanto, ~n es igual a (-n) -1 y también es igual a (-1) ^n.
Los operadores de desplazamiento << y >> y >>> desplazan los bits de la representación en complemento a 2 del primer argumento. Los dos operandos se promocionan (sección 11.1) por separado y el tipo de resultado es el tipo de promoción (int o long) del primer argumento. Por lo tanto, la operación de cambio siempre se realiza en un
Valor de 32 bits (int) o de 64 bits (long). En el primer caso, la duración del desplazamiento está entre 0 y 31 según lo determinado por los cinco bits menos significativos del segundo argumento; en el último caso, está entre 0 y 63 según lo determinado por los seis bits menos significativos del segundo argumento.
El desplazamiento a la izquierda n<<s es igual a n*2*2* ... *2 donde hay s multiplicaciones. El desplazamiento a la derecha con signo n>>s de un n no negativo es igual a n/2/2/.../2 donde hay s divisiones; el desplazamiento a la derecha con signo de un n negativo es igual a ~((~n)>>s). El desplazamiento a la derecha sin signo n>>>s de un n no negativo es igual a n>>s; el desplazamiento a la derecha con signo de un n negativo es igual a (n>>s) + (2<<~s) si n tiene el tipo int, y (n>>s) + (2L<<~s) si tiene el tipo long, donde 2L es la constante larga con valor 2. Véase el ejemplo 68 para un uso inteligente y complejo de operadores bit a bit: buen estilo en un pequeño procesador integrado, pero no en general.
Ejemplo 37: Operadores aritméticos

public static void main(String[] args) { int max = 2147483647;
int mínimo = -2147483648;

println(max+1) // Impresiones: -2147483648

println(min-1) // Impresiones: 2147483647

imprimirln(-min); // Impresiones: -2147483648 print( 10/3); println(10/(-3)); // Imprime: 3 -3 print((-10)/3); println((-10)/(-3)); // Impresiones: -3 3 imprimir( 10%3); println(10%(-3)); // Imprime: 1 1 print((-10)%3); println((-10)%(-3)); // Impresiones: -1 -1
}

impresión vacía estática (int i) { System.out.print(i + " "); } static void println(int i) { System.out.println(i + " "); }
Ejemplo 38: Operadores lógicos
Debido a la evaluación abreviada de &&, esta expresión del ejemplo 12 no evalúa los días de acceso a la matriz [mes-1] a menos que 1 ≤ mes ≤ 12, por lo que el índice nunca está fuera de los límites:
(mes >= 1) && (mes <= 12) && (día >= 1) && (día <= días[mes-1])
Este método devuelve verdadero si y es un año bisiesto, es decir, si y es múltiplo de 4 pero no de 100, o es un múltiplo
de 400:

año bisiesto booleano estático (int y)
{ devolver y % 4 == 0 && y % 100 != 0 || y % 400 ==0; }

Ejemplo 39: Operadores bit a bit y operadores de turno

clase bit a bit {

public static void main (String [] args) lanza una excepción {

}
static void println4(int n) { para (int i=3; i>=0; i--)
System.out.print(n >> i & 1);
Sistema.out.println();
}
}

Expresiones de asignación
En la tarea expresa ion x = e, el tipo de e debe ser un subtipo del tipo de x. El tipo de expresión es el mismo que el tipo de x. La asignación se ejecuta evaluando la expresión x y luego e, y almacenando el valor de e en la variable x, después de una conversión ampliada (sección 11.12) si es necesario.
Cuando e es una constante de tiempo de compilación de tipo byte, char, short o int, y x tiene el tipo byte, char o short, se realiza automáticamente una conversión estrecha, siempre que el valor de e esté dentro del rango representable en x ( apartado 5.1). El valor de la expresión x = e es el de x después de la asignación.
El operador de asignación es asociativo derecho, por lo que la asignación múltiple x = y = e tiene el mismo significado que x = (y = e), es decir, evalúa la expresión e, asigna su valor a y y luego a x. Cuando e tiene un tipo de referencia (tipo de objeto o tipo de matriz), solo se almacena una referencia al objeto o matriz en
X. Por tanto, la asignación x = e no copia el objeto o matriz (ejemplo 41).
Cuando x y e tienen el mismo tipo, la asignación compuesta x += e es equivalente a x = x + e; sin embargo, x se evalúa solo una vez, por lo que en a[i++] += e la variable i se incrementa solo una vez. Cuando el tipo de x es t, diferente del tipo de e, entonces x += e es equivalente a x = (t) (x + e), en el cual el resultado intermedio (x + e) se convierte al tipo t ( sección 11.12); nuevamente x se evalúa solo una vez. Los otros operadores de asignación compuestos -=, *=, etc., son similares.
Dado que la asignación se asocia a la derecha, y el valor de suma += e es el de la suma después de la asignación, se puede escribir ps[i] = suma += e para incrementar primero la suma en e y luego almacenar el resultado en ps[i ] (ejemplo 30).

Expresiones condicionales
La expresión condicional e1 ? e2: e3 es legal si e1 tiene tipo booleano, y e2 y e3 tienen tipos numéricos, o ambos tienen tipo booleano, o ambos tienen tipos de referencia compatibles. La expresión condicional se evalúa evaluando primero el. Si e1 se evalúa como verdadero, entonces se evalúa e2 (y no e3); de lo contrario se evalúa e3. El valor resultante es el valor de la expresión condicional.

Expresiones de creación de objetos
La expresión de creación de objetos.
nueva C (lista real)
crea un nuevo objeto de clase C y luego llama a ese constructor en clase C cuya firma coincide con los argumentos en la lista actual. La lista real se evalúa de izquierda a derecha para obtener una lista de valores de argumentos. Estos valores de argumento están vinculados a los parámetros del constructor, se crea un objeto de la clase en la memoria, los campos no estáticos reciben valores iniciales predeterminados según su tipo, se llama explícita o implícitamente a un constructor de superclase (ejemplos 29 y 52), todo Los inicializadores de campo no estáticos y los bloques inicializadores se ejecutan en orden de aparición y, finalmente, se ejecuta el cuerpo del constructor para inicializar el objeto. El valor de la expresión de llamada al constructor es el objeto recién creado, cuya clase es C.
Cuando C es una clase interna en la clase D, y o se evalúa como un objeto de clase D, entonces se puede crear un objeto C dentro de o usando la sintaxis o.new C (lista-actual); ver ejemplo 36.

Expresiones de prueba de instancia
La prueba de instancia e instancia de t se evalúa evaluando e a un valor v. Si v no es nulo y es una referencia a un objeto de clase C, donde C es un subtipo de t, el resultado es verdadero; de lo contrario falso.
Ejemplo 40: Ampliación, reducción y truncamiento en asignaciones
La asignación d = 12 realiza una ampliación de 12 de int a double. Las asignaciones b = 123 y b2 = 123+1 realizan una reducción implícita de int a byte, porque los lados derechos son constantes de tiempo de compilación. La asignación b2 = b1+1 sería ilegal porque b1+1 no es una constante de tiempo de compilación. La asignación b2 = 123+5 sería ilegal porque, aunque 123+5 es una constante de tiempo de compilación, su valor no se puede representar como un byte (cuyo rango es —128..127).
doble d;

d = 12; // Ampliación de la conversión de int a doble byte b1 = 123; // Reducir la conversión de int a byte byte b2;
b2 = 123 + 1; // Legal: 123+1 es una constante de tiempo de compilación b2 = (byte)(b1 + 1); // Legal: (byte)(b1 + 1) tiene tipo byte
int x = 0;

x+= 1,5; // Equivalente a: x = (int) (x + 1,5); por lo tanto suma 1 a x


Ejemplo 41: La tarea no copia objetos
Este ejemplo utiliza la clase Punto del ejemplo 16. La asignación (y el paso de parámetros) copia solo la referencia, no el objeto:

Punto p1 = nuevo Punto(10, 20);

System.out.println("p1 es " + p1); // Imprime: p1 es (10, 20) Punto p2 = p1; // p1 y p2 se refieren al mismo objeto p2.move (8, 8);
System.out.println("p2 es " + p2); // Imprime: p2 es (18, 28) System.out.println("p1 es " + p1); // Imprime: p1 es (18, 28)

Ejemplo 42: Operadores de asignación compuestos
Calcule el producto de todos los elementos de la matriz xs:

multiplicación doble estática (doble [] xs) {

doble pinchazo = 1,0;
para (int i=0; i<xs.length; i++)
prod *= xs[i]; // Equivalente a: prod = prod * xs[i]
devolver el empujón;
}


Ejemplo 43: expresión condicional
Devuelve el valor absoluto de x (siempre no negativo):

estática doble absoluta (doble x)
{ return (x >= 0 ? x : -x); } Ejemplo 44: Creación de objetos y prueba de instancia

Número n1 = nuevo entero(17); Número n2 = nuevo Doble(3.14);
// Se imprimen las siguientes declaraciones: falso, verdadero, falso, verdadero. System.out.println("n1 es un Doble: " + (n1 instancia de Doble)); System.out.println("n2 es un Doble: " + (n2 instancia de Doble)); System.out.println("nulo es un Doble: " + (instancia nula de Doble)); System.out.println("n2 es un Número: " + (n2 instancia de Número));
Expresiones de acceso a campos
Un acceso al campo debe tener una de estas tres formas: f
C.f.
de
donde C es una clase y o una expresión de tipo de referencia.
Una clase puede tener varios campos con el mismo nombre f (sección 9.6, ejemplo 22 y ejemplo 45).
Ejemplo 45: Acceso al campo
Aquí ilustramos el acceso a campos estáticos y no estáticos en las clases B, C y D del ejemplo 22. Tenga en cuenta que el campo al que hace referencia una expresión de forma o.vf u o.sf está determinado por el tipo de expresión o, no por el clase del objeto al que o evalúa.

público estático vacío principal (String[] args) {

C c1 = nuevo C(100); // c1 tiene tipo C; el objeto tiene clase C B b1 = c1; // b1 tiene tipo B; El objeto tiene clase C.
imprimir(C.sf, B.sf); // Impresiones: 102 121

imprimir(c1.sf, b1.sf); // Impresiones: 102 121

imprimir(c1.vf, b1.vf); // Impresiones: 100 120

C c2 = nuevo C(200); // c2 tiene tipo C; el objeto tiene clase C B b2 = c2; // b2 tiene tipo B; El objeto tiene clase C.
imprimir(c2.sf, b2.sf); // Impresiones: 202 221

imprimir(c2.vf, b2.vf); // Impresiones: 200 220

imprimir(c1.sf, b1.sf); // Impresiones: 202 221

imprimir(c1.vf, b1.vf); // Impresiones: 100 120

D d3 = nuevo D(300); // d3 tiene tipo D; el objeto tiene clase D C c3 = d3; // c3 tiene tipo C; el objeto tiene clase D
B b3 = d3; // b3 tiene tipo B; el objeto tiene clase D print(D.sf, C.sf, B.sf); // Impresiones: 304 304 361
imprimir(d3.sf, c3.sf, b3.sf); // Impresiones: 304 304 361

imprimir(d3.vf, c3.vf, b3.vf); // Impresiones: 300 340 360

}

impresión vacía estática (int x, int y) { System.out.println(x+" "+y); }

impresión vacía estática (int x, int y, int z) { System.out.println(x+" "+y+" "+z); }


Un acceso a campo f debe hacer referencia a un campo estático o no estático declarado o heredado por una clase cuya declaración encierra la expresión de acceso al campo (cuando f no ha sido sombreada por un campo en una clase envolvente anidada, o por una variable o parámetro de la mismo nombre). La clase que declara el campo es la clase objetivo TC.
Un acceso a campo C.f debe hacer referencia a un campo estático en la clase C o una superclase de C. Esa clase es la clase objetivo TC.
Un acceso al campo of, donde la expresión o tiene tipo C, debe hacer referencia a un campo estático o no estático en la clase C o una superclase de C. Esa clase es la clase objetivo TC. Para evaluar el acceso al campo se evalúa la expresión o para obtener un objeto. Si el campo es estático, el objeto se ignora y el valor de o.f es el campo TC f. Si el campo no es estático, el valor de o no debe ser nulo y el valor de o.f se encuentra como el valor del campo TC f en el objeto o.
Es informativo contrastar un acceso a un campo no estático y una llamada a un método no estático (sección 11.11):
En un acceso de campo no estático, el campo al que se hace referencia está determinado por el tipo (en tiempo de compilación)
de la expresión objeto o.
En una llamada no estática a un método no privado o.m(...), el método llamado está determinado por la clase (en tiempo de ejecución) del objeto de destino: el objeto al que se evalúa o.

El objeto actual hace referencia a esto
El nombre puede usarse en código no estático para referirse al objeto actual (sección 9.1). Cuando se ejecuta código no estático en un objeto determinado, la referencia del objeto se refiere al objeto en su conjunto. Por lo tanto, cuando f es un campo y m es un método (declarado en la clase envolvente más interna), entonces this.f significa lo mismo que f (cuando f no ha sido sombreado por una variable o parámetro del mismo nombre), y this .m(...) significa lo mismo que m(...).
Cuando C es una clase interna en una clase D adjunta, entonces dentro de C la notación D. Esto se refiere al objeto D que encierra el objeto C interno. Vea el ejemplo 31 donde TLC.this.nf se refiere al campo nf de la clase adjunta TLC.
Ejemplo 46: Usar esto al hacer referencia a campos sombreados

Un uso común de esto es referirse a campos (this.x y this.y) que han sido sombreados por parámetros (x e y), especialmente en constructores; vea la clase Punto (ejemplo 16):

clase Punto { int x, y;
Punto(int x, int y) { this.x = x; esto.y = y; }

... }


Ejemplo 47: Usar esto para pasar el objeto actual a un método
En la clase SPoint (ejemplo 17), la referencia del objeto actual this se usa en el constructor para agregar el objeto recién creado a la lista de matriz allpoints, y se usa en el método getIndex para buscar el objeto actual en la lista de matriz:

punto de clase {

ArrayList estático todos los puntos = nuevo ArrayList(); entero x, y;
SPoint(int x, int y) { allpoints.add(this); esto.x = x; esto.y = y; } int getIndex() { return allpoints.indexOf(esto); }
... }


Expresiones de llamada a métodos
Una expresión de llamada a un método, o invocación de un método, debe tener una de estas cinco formas:
m(lista-actual) super.m(lista-actual) C.m(lista-actual) C.super.m (lista-actual)
o.m(lista-actual)
donde m es el nombre de un método, C es el nombre de una clase y o es una expresión de tipo de referencia. La lista real es una lista de expresiones posiblemente vacía separada por comas, denominada argumentos o parámetros reales. La firma de llamada es csig = m(t1,..., tn), donde (t1,..., tn) es la lista de tipos de los n argumentos en la lista real.
Determinar qué método se llama realmente mediante una llamada a un método es complicado porque (1) los nombres de los métodos pueden estar sobrecargados y cada versión del método tiene una firma distinta; (2) los métodos pueden anularse, es decir, reimplementarse en subclases; (3) los métodos que son tanto no estáticos como no privados se llaman mediante envío dinámico, dado un objeto de destino; y (4) una llamada a un método en una clase anidada puede llamar a un método declarado en alguna clase adjunta.
La sección 11.11.1 describe la evaluación de argumentos y el paso de parámetros, suponiendo el caso simple en el que está claro qué método m se está llamando. La sección 11.11.2 describe cómo determinar qué método se llama en el caso general.

Llamada al método: paso de parámetros
Esta sección considera la evaluación de una llamada a un método m (lista real) cuando está claro qué método m se llama y se centra en el mecanismo de paso de parámetros.
La llamada se evalúa evaluando las expresiones en la lista real de izquierda a derecha para obtener los valores de los argumentos. Estos valores de argumentos luego se vinculan a los parámetros correspondientes en la lista formal del método, en orden de aparición. Se produce una conversión ampliada (sección 11.12) si el tipo de una expresión de argumento es un subtipo del tipo de parámetro correspondiente del método.

Java usa llamada por valor para vincular valores de argumentos a parámetros formales, por lo que el parámetro formal contiene una copia del valor del argumento. Por tanto, si el método cambia el valor de un parámetro formal, este cambio no afecta al argumento. Para un argumento de tipo de referencia, el parámetro contiene una copia de la referencia del objeto o de la referencia de matriz y, por lo tanto, el parámetro se refiere al mismo objeto o matriz que la expresión del argumento real. Por lo tanto, si el método cambia ese objeto o matriz, los cambios serán visibles después de que el método regrese (ejemplo 49).
Se debe llamar a un método no estático con un objeto de destino, por ejemplo como o.m (lista-actual), donde el objeto de destino es el valor de o, o como m(lista-actual), donde el objeto de destino es la referencia del objeto actual. . En cualquier caso, durante la ejecución del cuerpo del método, éste estará vinculado al objeto de destino.
Un método estático no se llama con un objeto de destino y es ilegal usar el identificador this dentro del cuerpo de un método estático.
Cuando los valores de los argumentos se han vinculado a los parámetros formales, se ejecuta el cuerpo del método. El valor de la expresión de llamada al método es el valor devuelto por el método si su tipo de retorno no es nulo; de lo contrario, la expresión de llamada al método no tiene valor. Cuando el método regresa, se descartan todos los parámetros y variables locales del método.
Ejemplo 48: Llamar a métodos no sobrecargados ni anulados
Este programa utiliza la clase SPoint del ejemplo 17. Los métodos estáticos getSize y getPoint se pueden llamar anteponiéndolos con el nombre de clase SPoint o una expresión de tipo SPoint, como q. Se les puede llamar antes de que se haya creado cualquier objeto. El método no estático getIndex debe llamarse con un objeto, como en r.getIndex(); luego, el método se ejecuta con la referencia del objeto actual vinculada a r.

System.out.println("Número de puntos creados: " + SPoint.getSize ()); PuntoP = nuevo PuntoP(12, 123);
PuntoPunto q = nuevo PuntoPunto(200, 10); PuntoPunto r = nuevo PuntoPunto(99, 12); Punto s = p;
q = nulo;

System.out.println("Número de puntos creados: " + SPoint.getSize());
System.out.println("Número de puntos creados: " + q.getSize ()); System.out.println("r es el número de punto " + r.getIndex());
para (int i=0; i<SPoint.getSize(); i++)
System.out.println("El número de punto " + i + " es " + Punto.getPoint(i));


Ejemplo 49: El paso de parámetros copia referencias, no objetos ni matrices
En la llamada al método m(p, d, a) que se muestra aquí, la referencia del objeto contenida en p se copia al parámetro pp de m, por lo que p y pp se refieren al mismo objeto, el número entero contenido en d se copia a dd, y la referencia de matriz contenida en a se copia a aa. Al final del método m, el estado de la memoria de la computadora es el siguiente:

Cuando regresa el método m, sus parámetros pp, dd y aa se descartan. Las variables p, d y a no se modifican, pero el objeto y la matriz a la que apuntan p y a sí se modifican.

public static void main(String[] args) { Punto p = nuevo Punto(10, 20);
int[] a = nuevo int [5];

int d = 8;

System.out.println("p es " + p); // Imprime: p es (10, 20)

System.out.println("a[3] es " + a[3]); // Imprime: a[3] es 0 m (p, d, a);
System.out.println("p es " + p); // Imprime: p es (18, 28) System.out.println("d es " + d); // Imprime: d es 8 System.out.println("a[3] es " + a[3]); // Imprime: a[3] es 22
}

vacío estático m(Punto pp, int dd, int[] aa) { pp.move(dd, dd);
dd = 117;

aa[3] = 22;

}



Llamada al método: determinar qué método se llama
En general, los métodos pueden estar sobrecargados y sobrecargados. dden. La sobrecarga se resuelve en tiempo de compilación encontrando la firma del método aplicable y accesible más específica para la llamada. La anulación (para métodos no estáticos) se maneja en tiempo de ejecución buscando en la jerarquía de clases hacia arriba, comenzando con la clase del objeto en el que se llama el método.
En tiempo de compilación: determine el tipo de destino y la firma
Encuentre el tipo de objetivo TC. Si la llamada al método tiene la forma m(lista-actual), el tipo de destino TC es la clase envolvente más interna que contiene un método llamado m que es visible (no sombreado por un método m, independientemente de la firma, en una clase intermedia). Si la llamada al método tiene la forma super.m(lista-actual), el tipo de destino TC es la superclase de la clase envolvente más interna. Si la llamada al método tiene la forma C.super.m(lista-actual), el tipo de destino TC es la superclase de la clase envolvente C. Si la llamada al método tiene la forma C.m(lista-actual), entonces TC es C. Si la llamada al método tiene la forma o.m(lista-actual), entonces TC es el tipo de expresión o.
Encuentra la firma del objetivo tsig. Un método de la clase TC es aplicable si su firma incluye la firma de llamada csig (sección 5.5). Si un método es accesible está determinado por sus modificadores de acceso (sección 9.7). Considere el conjunto de métodos de CT que son aplicables y accesibles. La llamada es ilegal (método desconocido) si no existe tal método. La llamada es ilegal (ambigua) si hay más de un método cuya firma extendida m(T, u1,..., un) es más específica, es decir, uno cuya firma extendida está incluida en todas las demás. Así, si la llamada es legal, hay exactamente una firma extendida más específica; de ahí obtenemos la firma objetivo tsig = m(u1,..., un).
Determine si el método llamado es estático. Si la llamada al método tiene la forma C.m(lista-actual), el método llamado debe ser estático. Si la llamada al método tiene la forma m(lista-actual) u o.m(lista-actual) o super.m(lista-actual) o C.super.m(lista-actual), usamos el tipo de destino TC y la firma tsig para determinar si el método llamado es estático o no estático.
En tiempo de ejecución: determine el objeto de destino (si no estático) y ejecute el método
Si el método es estático, no se necesita ningún objeto de destino: el método a llamar es el método con firma tsig en la clase TC. Sin embargo, cuando m es estático en una llamada al método o.m(lista-actual), la expresión o debe evaluarse de todos modos, pero su valor se ignora.

Si el método no es estático, determine el objeto de destino; estará vinculado al objeto que hace referencia a this durante la ejecución del método. En el caso de m(lista-actual), el objeto de destino es this (si TC es la clase más interna que incluye la llamada al método), o TC.this (si TC es una clase externa que contiene la llamada al método). En el caso de super.m (lista-actual), el objeto de destino es este. En el caso de C.super.m(actual-list), el objeto de destino es C.this. En el caso o.m(lista-actual), la expresión o debe evaluarse como una referencia de objeto. Si no es nulo, ese objeto es el objeto de destino; de lo contrario, se lanza la excepción NullPointerException. Si el método no es privado, se busca en la jerarquía de clases para determinar qué método llamar, comenzando con la clase RTC del objeto de destino. Si no se encuentra un método con firma tsig en la clase RTC, entonces se busca la superclase inmediata de RTC, y así sucesivamente. Este procedimiento de búsqueda se denomina despacho dinámico. Si el método es privado, debe estar en la clase de destino TC y no es necesaria ninguna búsqueda.
Cuando se ha determinado el método, los argumentos se evalúan y vinculan como se describe en la sección 11.11.1.
Ejemplo 50: Llamar a métodos sobrecargados
Aquí llamamos a los métodos sobrecargados m declarados en el ejemplo 25. La llamada m(10, 20) tiene la firma de llamada m(int, int) y por lo tanto llama al método con la firma m(int, double), que es el más específico aplicable. . Por lo tanto, las dos primeras líneas llaman al método con firma m(int, double), y las dos últimas llaman al método con firma m(double, double).

System.out.println(m(10, 20)); // Impresiones: 31,0

System.out.println(m(10, 20.0)); // Impresiones: 31,0

System.out.println(m(10.0, 20)); // Impresiones: 33,0

System.out.println(m(10.0, 20.0)); // Impresiones: 33,0


Ejemplo 51: Llamar a métodos anulados y sobrecargados
Aquí usamos las clases C1 y C2 del ejemplo 27. El tipo de destino de c1.m1(i) es la clase C1, que tiene un método no estático con firma m1(int), por lo que la llamada es a un método no estático; el objeto de destino tiene clase C2, por lo que el método llamado es m1(int) en C2; y de manera bastante similar para c2.m1(i). El tipo de destino para c1.m1(d) es la clase C1, que tiene un método estático con firma m1(double), por lo que la llamada es a un método estático y el objeto vinculado a c1 no importa. De manera similar, para c2.m1(d), cuyo tipo de destino es C2, llama a m1(doble) en C2, que anula m1(doble) en C1.
La llamada c1.m2(i) tiene tipo de destino C1 y llama a m2(int). Sin embargo, una llamada c2.m2(i), cuya clase objetivo es C2, sería ambigua e ilegal: las firmas extendidas aplicables son m2(C1, int) y m2(C2, double), ninguna de las cuales es mo re específico que el otro.

int yo = 17; doble d = 17,0;
C2 c2 = nuevo C2(); // Tipo C2, clase de objeto C2 C1 c1 = c2; // Tipo C1, clase de objeto C1
c1.m1(i); c2.m1(i); c1.m1(d); c2.m1(d); // Impresiones: 21i 21i 11d 21d c1.m2(i); // Impresiones: 12i
Ejemplo 52: Llamar a métodos anulados desde un constructor
Si d2 es un objeto de la clase D2, entonces llamar a d2.m2() llamará al método m2 heredado de la superclase D1. La llamada m1() en m2 es equivalente a this.m1(), donde esto es igual a d2, por lo que se llama al método m1 declarado en la clase D2. Por lo tanto, la llamada d2.m2() imprimirá D1.m2 y luego D2.m1:7. Imprime 7 porque el campo f se inicializa a 7 en el constructor D2().
Quizás lo más sorprendente es que la creación d2 = new D2() de un objeto de clase D2 imprimirá D1.m2 y luego D2.m1:0. ¿Por qué imprime 0 y no 7? La primera acción del constructor D2() es hacer una llamada implícita al constructor de la superclase D1(), incluso antes de ejecutar la asignación f = 7. Por lo tanto, f seguirá

tiene su valor predeterminado 0 cuando el método m1 en D2 se llama desde el método m2 en D1, que a su vez se llama desde el constructor D1().

clase D1 { D1() { m2(); }
void ml () { System.out.println("D1.m1 "); }

void m2 () { System.out.print("D1.m2 "); m1 () ; }

}



clase D2 extiende D1 { int f;
D2() { f = 7; }

void m1() { System.out.println("D2.m1:" + f); }

}



Escriba expresiones de conversión y conversión de tipos
Una conversión de tipo convierte un valor de un tipo a otro. Una conversión ampliada convierte de un tipo a un supertipo. Una conversión de restricción convierte de un tipo a otro tipo. Esto requiere una conversión de tipo explícita (excepto en una asignación x = e o inicialización donde e es una constante entera en tiempo de compilación; consulte la sección 11.5).

Tipo de conversión entre tipos primitivos
Cuando e es una expresión de tipo primitivo y t es un tipo primitivo, entonces se realiza una conversión de tipos de e a t usando la expresión
(t)e
Esta expresión, cuando es legal, tiene tipo t. Las conversiones de tipos legales entre tipos primitivos se muestran en la siguiente tabla, donde C marca una conversión de estrechamiento que requiere una conversión de tipo (t)e, W marca una conversión de ampliación que preserva el valor y L marca una conversión de ampliación que puede causar una pérdida de precisión.

Una conversión de enteros estrechada descarta aquellos bits (más significativos) que no pueden representarse en el tipo de entero más pequeño. La conversión de un tipo entero a un tipo de punto flotante (flotante o doble) produce una aproximación de punto flotante del valor entero. La conversión de un tipo de punto flotante a un tipo entero descarta la parte fraccionaria del número; es decir, se redondea hacia cero. Al convertir un número de punto flotante demasiado grande a long o int, el resultado es la mejor aproximación (es decir, el mayor número representable positivo o negativo del tipo); La conversión a byte, short o char se realiza convirtiendo a int y luego al tipo solicitado. El tipo primitivo booleano no se puede convertir a ningún otro tipo. Una conversión de tipos entre tipos primitivos nunca falla en tiempo de ejecución.

Tipo de conversión entre tipos de referencia
Cuando e es una expresión de tipo de referencia y t es un tipo de referencia (clase o interfaz o tipo de matriz), a
el tipo de conversión de e a t se realiza usando la expresión
(t)e
Esta expresión tiene tipo t. Se evalúa evaluando e con un valor v. Si v es nulo o es una referencia a un objeto o matriz cuya clase es un subtipo de t, entonces la conversión de tipos se realiza correctamente con el resultado v; de lo contrario, se lanza la excepción ClassCastException. La conversión de tipos es ilegal cuando no es posible que tenga éxito en tiempo de ejecución, por ejemplo, cuando e tiene el tipo Doble y t es booleano: ninguna de estas clases es un subtipo de la otra.

Capítulo 12: Declaraciones
Descripción general
Una declaración puede cambiar el estado de la computadora: el valor de las variables, los campos, los elementos de la matriz, el contenido de los archivos, etc. Más precisamente, la ejecución de una declaración.
termina normalmente (lo que significa que la ejecución continuará con la siguiente declaración, si corresponde); o
termina abruptamente lanzando una excepción; o
sale ejecutando una declaración de retorno (si está dentro de un método o constructor); o
sale de un interruptor o bucle ejecutando una instrucción break (si está dentro de un interruptor o bucle); o
sale de la iteración actual de un bucle y comienza una nueva iteración ejecutando un continuar
declaración (si está dentro de un bucle); o
no termina en absoluto, por ejemplo, ejecutando while (true) {}.

Declaraciones de expresión
Una declaración de expresión es una expresión seguida de un punto y coma:
expresión ;
Se ejecuta evaluando la expresión e ignorando su valor. Las únicas formas de expresión que pueden usarse legalmente de esta manera son expresiones de asignación (sección 11.5), expresiones de incremento y decremento (sección 11.2), expresiones de llamada a métodos (sección 11.11) y expresiones de creación de objetos (sección 11.7).
Por ejemplo, una declaración de asignación x=e; es una expresión de asignación x=e seguida de un punto y coma.
De manera similar, una declaración de llamada a un método es una expresión de llamada a un método seguida de un punto y coma. El valor devuelto por el método, si lo hubiera, se descarta; El método se ejecuta sólo por su efecto secundario. t.


Declaraciones de bloque
Una declaración de bloque es una secuencia de cero o más declaraciones o declaraciones de variables o declaraciones de clases, en cualquier orden, encerradas entre llaves:
{
declaraciones
declaraciones-de-clase declaraciones-variables
}

12.2 Declaraciones de bloque
Una declaración de bloque es una secuencia de cero o más declaraciones o declaraciones de variables o declaraciones de clases, en cualquier orden, encerradas entre llaves:
{
declaraciones
declaraciones-de-clase declaraciones-variables
}

Declaraciones de elección
La declaración si
Una declaración if tiene la forma
si (condición)
verdadera rama

La condición debe ser de tipo booleano y truebranch es una declaración. Si la condición se evalúa como verdadera, entonces se ejecuta truebranch; de lo contrario, no.

La declaración si-si no
Una declaración if-else tiene la forma:
si (condición)
verdadera rama
demás
rama falsa
La condición debe ser de tipo booleano y truebranch y falsebranch son declaraciones. si condición
se evalúa como verdadero, luego se ejecuta truebranch; de lo contrario, se ejecuta falsebranch.

La declaración de cambio
Una declaración de cambio tiene la forma
cambiar (expresión) { caso constante1: rama1 caso constante2: rama2
...
predeterminado: rama
}
La expresión debe ser de tipo int, short, char o byte. Cada constante debe ser una expresión constante en tiempo de compilación, que consta únicamente de literales, variables finales, campos finales declarados con inicializadores de campo explícitos y operadores. No pueden haber dos constantes que tengan el mismo valor. El tipo de cada constante debe ser un subtipo del tipo de expresión.
Cada rama está precedida por una o más cláusulas case y es una secuencia posiblemente vacía de declaraciones, generalmente terminada por break o return (si está dentro de un método o constructor) o continue (dentro de un bucle). La cláusula por defecto puede omitirse.
La instrucción de cambio se ejecuta de la siguiente manera: La expresión se evalúa para obtener un valor v. Si v es igual a una de las constantes, entonces se ejecuta la rama correspondiente. Si v no es igual a ninguna de las constantes, entonces se ejecuta la rama siguiente al valor predeterminado; si no hay una cláusula predeterminada, no se ejecuta nada. Si no se sale de una rama mediante interrupción, retorno o continuación, entonces la ejecución continúa con la siguiente rama en el cambio independientemente de las cláusulas case, hasta que salga una rama o finalice el cambio.
Ejemplo 53: Declaraciones de bloque
Todos los cuerpos de los métodos y los cuerpos de los constructores son declaraciones de bloque. En el método sum del ejemplo 2, la rama verdadera de la segunda declaración if es una declaración de bloque. El método m4 en el ejemplo 4 contiene dos declaraciones de bloque, cada una de las cuales contiene una declaración (local) de la variable x.


Ejemplo 54: Declaración única if-else
Este método se comporta igual que el absoluto en el ejemplo 43:
estática doble absoluta(doble x) {si (x >= 0)
devolver x;
demás
devolver -x;
}


Ejemplo 55: Secuencia de declaraciones if-else
No podemos usar un modificador aquí, porque un modificador solo puede funcionar en tipos de números enteros (incluido char): static int wdaynol(String wday) {
si (wday.equals("lunes")) devuelve 1;

de lo contrario, si (wday.equals("Martes")) devuelve 2; de lo contrario, si (wday.equals ("miércoles")) devuelve 3; de lo contrario, si (wday.equals ("jueves")) devuelve 4; de lo contrario, si (wday.equals("Viernes")) devuelve 5; de lo contrario, si (wday.equals("Sábado")) devuelve 6; de lo contrario, si (wday.equals("Domingo")) devuelve 7;
de lo contrario, devuelve -1; // Aquí solía significar "no encontrado"

}


Ejemplo 56: Una declaración de cambio
Aquí podríamos haber usado una secuencia de sentencias if-else, pero un cambio es más rápido y claro: static String findCountry(int prefix) {
cambiar (prefijo) {

caso 1: devolver "América del Norte"; caso 44: devolver "Gran Bretaña"; caso 45: devolver "Dinamarca"; caso 299: devolver "Groenlandia"; caso 46: devolver "Suecia";
caso 7: devolver "Rusia"; caso 972: devolución de "Israel"; predeterminado: devolver "Desconocido";
}

}


Declaraciones de bucle
La declaración para
Una declaración for tiene la forma
para (inicialización; condición; paso) cuerpo
donde inicialización es una declaración de variable (sección 6.2) o una expresión, condición es una expresión de tipo booleano, paso es una expresión y cuerpo es una declaración. De manera más general, la inicialización y el paso también pueden ser listas de expresiones separadas por comas; las expresiones en dicha lista se evalúan de izquierda a derecha cuando se evalúa la lista. La inicialización, la condición y el paso pueden estar vacíos. Una condición vacía es equivalente a verdadera. Por lo tanto, para (;;) cuerpo significa "ejecutar siempre el cuerpo". La declaración for se ejecuta de la siguiente manera:
Se ejecuta la inicialización.
Se evalúa la condición. Si es falso, el ciclo termina.
Si es verdad, entonces

El cuerpo es ejecutado.
El paso se ejecuta. c.La ejecución continúa en (2).

La declaración while
Una declaración while tiene la forma
mientras (condición)
cuerpo
donde condición es una expresión de tipo booleano y cuerpo es una declaración. Se ejecuta de la siguiente manera:
Se evalúa la condición. Si es falso, el ciclo termina.
Si es cierto, entonces a. Se ejecuta el cuerpo.
b.La ejecución continúa en (1).

La declaración de hacer mientras
Una declaración do- while tiene la forma
hacer
cuerpo
mientras (condición);
donde condición es una expresión de tipo booleano y cuerpo es una declaración. El cuerpo se ejecuta al menos una vez, porque la instrucción do- while se ejecuta de la siguiente manera:
El cuerpo es ejecutado.
Se evalúa la condición. Si es falso, el ciclo termina.
Si es cierto, entonces la ejecución continúa en (1).
Ejemplo 57: bucles for anidados
Este programa imprime un triángulo de asteriscos de cuatro líneas (*): for (int i=1; i<=4; i++) {
for (int j=1; j<=i; j++) System.out.print("*");
Sistema.out.println();
}


Ejemplo 58: Búsqueda de matriz usando un bucle while
Este método se comporta igual que wdayno1 en el ejemplo 55: static int wdayno2(String wday) {
int i=0;
while (i < días_días.longitud && ! días.equals(días_días[i])) i++;
// Ahora i >= wdays.length o wday igual a wdays[i] if (i < wdays.length)
devolver i+1;
demás
devolver -1; // Aquí solía significar "no encontrado"
}

cadena final estática [] wdays =
{ "Lunes martes Miércoles Jueves Viernes Sábado Domingo" };


Ejemplo 59: Bucle infinito debido a un punto y coma mal colocado
Aquí, un punto y coma mal colocado (;) crea una declaración de cuerpo de bucle vacío, donde el incremento i++ no es parte del bucle. Por lo tanto, no terminará sino que se repetirá para siempre.

int i=0;

mientras (i<10); yo ++;


Ejemplo 60: uso de do- while
Tira un dado y calcula la suma hasta que salga 5 o 6. Aquí podemos usar do- while pero while suele ser más seguro porque prueba la condición del bucle antes de ejecutar el cuerpo del bucle.

static int suma de espera() { int suma = 0, ojos; hacer {
ojos = (int) (1 + 6 * Math.random());

suma += ojos;
} mientras (ojos < 5); suma de devolución;
}

Devoluciones, declaraciones etiquetadas, salidas y excepciones
La declaración de devolución
La forma más simple de declaración de devolución, sin un argumento de expresión, es
devolver;
Esa forma de declaración de retorno debe ocurrir dentro del cuerpo de un método cuyo tipo de retorno sea nulo, o dentro del cuerpo de un constructor. La ejecución de la declaración de retorno sale del método o constructor y continúa la ejecución en el lugar desde donde se llamó al método o constructor.
Alternativamente, una declaración de devolución puede tener un argumento de expresión:
expresión de retorno;
Esa forma de declaración de retorno debe ocurrir dentro del cuerpo de un método (no constructor) cuyo tipo de retorno sea un supertipo del tipo de expresión. La declaración de retorno se ejecuta de la siguiente manera: Primero, la expresión se evalúa con algún valor v. Luego sale del método y continúa la ejecución en la expresión de llamada al método que llamó al método; el valor de esa expresión será v.

Declaraciones etiquetadas
Una declaración etiquetada tiene la forma
etiqueta: declaración
donde etiqueta es un nombre. El alcance de la etiqueta es declaración, donde se puede usar en pausa (sección 12.6.3) y continuar (sección 12.6.4). La etiqueta no se puede reutilizar dentro de una declaración, excepto dentro de una clase local.

La declaración de ruptura
Una declaración de interrupción es legal sólo dentro de un interruptor o bucle y tiene una de las formas
romper;
romper etiqueta;
La ejecución de la interrupción sale del interruptor o bucle más interno y continúa la ejecución después de ese interruptor o bucle. La ejecución de romper etiqueta sale de la declaración adjunta que tiene etiqueta etiqueta y continúa la ejecución después de esa declaración. Dicha declaración debe existir en el método, constructor o bloque inicializador más interno.

La declaración de continuación
Una declaración de continuación es legal sólo dentro de un bucle y tiene una de las formas
continuar;

continuar etiqueta;
La ejecución de continuar finaliza la iteración actual del bucle envolvente más interno y continúa la ejecución en el paso de los bucles for (sección 12.5.1) o la condición en los bucles while y do- while (secciones 12.5.2 y 12.5.3). La ejecución de continuar etiqueta finaliza la iteración actual del bucle circundante que tiene etiqueta etiqueta y continúa la ejecución en el paso o la condición. Debe haber dicho bucle en el método, constructor o bloque inicializador más interno.
Ejemplo 61: Uso de return para finalizar un bucle antes
Este método se comporta igual que wdayno2 en el ejemplo 58:

estático int wdayno3 (cadena wday) {
for (int i=0; i < wdays.length; i++) if (wday.equals(wdays[i]))
devolver i+1;
devolver -1; // Aquí solía significar "no encontrado"
}


Ejemplo 62: Uso de break para finalizar un bucle antes de tiempo

doble pinchazo = 1,0;
for (int i=0; i<xs.length; i++) { prod *= xs[i];
si (prod == 0.0) romper;
}


Ejemplo 63: Usar continuar para iniciar una nueva iteración
Este método decide si la consulta es una subcadena del objetivo. Cuando se encuentra una discrepancia entre las cadenas, continuar inicia la siguiente iteración del bucle for externo, incrementando así j:
subcadena booleana estática1 (consulta de cadena, destino de cadena) { siguiente posición:
for (int j=0; j<=target.length()-query.length(); j++) { for (int k=0; k<query.length(); k++)
si (destino.charAt(j+k)! = consulta.charAt(k))
continuar con la siguiente posición; devolver verdadero;
}
falso retorno;
}


Ejemplo 64: Uso de break para salir de un bloque de declaración etiquetado
Este método se comporta como la subcadena1 del ejemplo 63. Utiliza break para salir del bloque de declaración completo etiquetado como esta posición, omitiendo así la primera declaración de retorno e iniciando una nueva iteración del bucle for externo:

subcadena booleana estática2 (consulta de cadena, destino de cadena) {
para (int j=0; j<=target.length()-query.length(); j++) esta posición: {
para (int k=0; k<query.length(); k++)
si (destino.charAt(j+k) != consulta.charAt(k))
romper esta posición; devolver verdadero;
}
falso retorno;
}

La declaración de lanzamiento
Una declaración de lanzamiento tiene la forma
lanzar expresión;
donde el tipo de expresión debe ser un subtipo de clase Throwable (capítulo 14). La declaración de lanzamiento se ejecuta de la siguiente manera: La expresión se evalúa para obtener un objeto de excepción v. Si es nulo, entonces se lanza una NullPointerException; de lo contrario, se lanza el objeto de excepción v. Por tanto, una excepción lanzada nunca es nula. En cualquier caso, la declaración de bloque adjunta termina abruptamente (capítulo 14). La excepción lanzada puede quedar atrapada en una declaración try-catch que la incluye dinámicamente (sección 12.6.6). Si no se detecta la excepción, se cancelará toda la ejecución del programa y la información de la excepción se imprimirá en la consola (por ejemplo, en el símbolo del sistema o en la consola Java dentro de un navegador web).

La declaración try-catch-finally
Una declaración try-catch se utiliza para detectar excepciones (particulares) generadas por la ejecución de un bloque de código. Tiene la siguiente forma:
intentar
cuerpo
atrapar (El x1) catchbody1
atrapar (E2 x2) cuerpo receptor2
...
finalmente finalmente cuerpo
donde E1, E2, ... son nombres de tipos de excepción, x1, x2, ... son nombres de variables y body, catchbodyi y finalmentebody son declaraciones de bloque (sección 12.2). Puede haber cero o más cláusulas catch y la cláusula finalmente puede estar ausente, pero debe estar presente al menos una cláusula catch o finalmente.
Decimos que Ei coincide con el tipo de excepción E si E es un subtipo de Ei (posiblemente igual a Ei).
La declaración try-catch-finally se ejecuta ejecutando el cuerpo. Si la ejecución del cuerpo termina normalmente, o sale por retorno, interrupción o continuación (cuando está dentro de un método, constructor, conmutador o bucle), entonces las cláusulas catch se ignoran. Si el cuerpo termina abruptamente lanzando la excepción e de clase E, entonces se ubica el primer Ei coincidente (si lo hay), la variable xi se vincula a e y se ejecuta el catchbodyi correspondiente. El catchbodyi puede terminar normalmente, o hacer un bucle, o salir ejecutando return o break o continue, o lanzar una excepción (posiblemente xi); si no hay una cláusula finalmente, esto determina cómo termina toda la declaración try-catch. Una excepción e lanzada nunca es nula (sección 12.6.5), por lo que se garantiza que xi tampoco será nula. Si no hay ningún Ei coincidente, entonces toda la declaración try-catch termina abruptamente con la excepción e.
Si hay una cláusula finalmente, finalmente el cuerpo se ejecutará independientemente de si la ejecución del cuerpo terminó normalmente, independientemente de si el cuerpo salió ejecutando return o break o continue (cuando está dentro de un método o constructor o interruptor o bucle), independientemente de si cualquier excepción lanzada por el cuerpo fue capturada por una cláusula catch, e independientemente de si la cláusula catch salió ejecutando return o break o continue o lanzando una excepción. Si la ejecución definallybody termina normalmente, entonces todo el try-catch-finally termina según lo determine body (o catchbodyi, si uno se ejecutó y terminó abruptamente o salió). Si la ejecución de finalmente cuerpo termina abruptamente, eso determina cómo termina todo el intento-catch-finalmente (ejemplo 74).
Ejemplo 65: Lanzar una excepción para indicar un error
En lugar de devolver el valor de error falso -1 como en el método wdayno3 (ejemplo 61), lanza una excepción WeekdayException (ejemplo 73). Tenga en cuenta la cláusula throws (sección 9.8) en el encabezado del método.
static int wdayno4(String wday) lanza WeekdayException { para (int i=0; i < wdays.length; i++)
si (wday.equals(wdays[i]))
devolver i+1;
lanzar una nueva excepción de día semanal (wday);
}

Ejemplo 66: una declaración try-catch
Este ejemplo llama al método wdayno4 (ejemplo 65) dentro de una declaración try-catch que detecta excepciones de la clase WeekdayException (ejemplo 73) y su superclase Exception. La segunda cláusula catch se ejecutará (por ejemplo) si los argumentos de acceso a la matriz [0] fallan porque no hay un argumento de línea de comando (ya que ArrayIndexOutOfBoundsException es una subclase de Exception). Si se detecta una excepción, se vincula a la variable x y se imprime mediante una llamada implícita (capítulo 7) al método toString de la excepción.

público estático vacío principal (String [] args) { intentar {
System.out.println(args[0] + " es el número del día de la semana " + wdayno4(args[0]));

} catch (WeekdayException x) { System.out.println("Problema del día de la semana: " + x);
} catch (Excepción x) { System.out.println("Otro problema: " + x);
}

}


Ejemplo 67: una declaración de prueba final
Este método intenta leer tres líneas de un archivo de texto (sección 21.4), cada una de las cuales contiene un único número de punto flotante. Independientemente de si algo sale mal durante la lectura (fin de archivo prematuro, número mal formado), la cláusula final cerrará los lectores antes de que regrese el método. Lo haría incluso si la declaración de devolución estuviera dentro del bloque try.

static double[] readRecord(String filename) lanza IOException { Reader freader = new FileReader(filename); BufferedReader empanizador = nuevo BufferedReader(freader); doble[] res = nuevo doble[3];
intentar {

res[0] = nuevo D doble(breader.readLine()).doubleValue(); res[1] = nuevo Double(breader.readLine()).doubleValue(); res[2] = nuevo Double(breader.readLine()).doubleValue();
} finalmente { Breader.close();
}

devolver resolución;

}

La declaración de afirmación
La declaración de afirmación tiene una de las siguientes formas:
afirmar expresión-booleana;
afirmar expresión-booleana: expresión;
La expresión booleana debe ser de tipo booleano. La expresión debe ser de tipo booleano, char, double, float, int, long u Object.
Bajo la ejecución normal de un programa, una declaración de afirmación no tiene ningún efecto. Sin embargo, las aserciones se pueden habilitar en tiempo de ejecución especificando la opción -ea o -enableassertions al ejecutar un programa C (capítulo 16):
java -enableassertions C
Cuando las aserciones están habilitadas en tiempo de ejecución, cada ejecución de la declaración de aserción evaluará la expresión booleana. Si el resultado es verdadero, la ejecución del programa continúa normalmente. Si el resultado es falso, la afirmación falla y se generará un AssertionError; además, en la segunda forma de la declaración de afirmación, la expresión se evaluará y su valor se pasará al constructor AssertionError apropiado. Por lo tanto, el valor de la expresión se informará junto con la excepción en caso de que falle la aserción. Esto simplifica la resolución de problemas en un programa que no funciona correctamente.
Un AssertionError señala el fallo de una suposición fundamental en el programa y no debe ser detectado por una declaración try-catch en el programa; se le debe permitir propagarse al nivel superior. Una declaración de afirmación puede tener dos propósitos: documentar la suposición del programador sobre el estado en un determinado punto del programa y verificar (en tiempo de ejecución) que esa suposición se cumpla (siempre que el programa se ejecute usando la opción enableassertions).
Se puede poner una declaración de afirmación después de un fragmento de código particularmente complicado, para comprobar que ha logrado lo que se suponía que debía hacer (ejemplo 68).
Ejemplo 68: uso de afirmar para especificar y verificar el resultado de un algoritmo
La raíz cuadrada entera de x ≥ 0 es un número entero y tal que y2 ≤ x y (y + 1)2 > x. La condición previa x ≥ 0 siempre se verifica mediante una declaración if. La poscondición en y se especifica mediante una declaración de afirmación, y
comprobó si las afirmaciones están habilitadas en tiempo de ejecución, lo cual es tranquilizador, dado que la corrección no es demasiado obvia. La afirmación utiliza conversiones largas para evitar el desbordamiento aritmético.
static int sqrt(int x) { // Algoritmo de Borgerding, Hsieh, Ulery if (x < 0)
lanzar nueva IllegalArgumentException("sqrt: argumento negativo");
temperatura int, y = 0, b = 0x8000, bshft = 15, v = x;; hacer {
if (v >= (temp = (y<<1)+b << bshft--)) { y += b; v-= temperatura;
}
} mientras ((b >>= 1) > 0);
afirmar (largo)y * y <= x && (largo)(y+1)*(y+1) > x; devolver y;
}


En una clase que tiene una invariante de representación de datos, se puede afirmar la invariante al final de cada método de la clase (ejemplo 69).
Ejemplo 69: uso de afirmar para especificar y verificar invariantes
Una lista de palabras es una secuencia de palabras que se formatean como una línea de texto. Su longitud es el número mínimo de caracteres necesarios para formatear las palabras y los espacios entre palabras, es decir, la longitud de las palabras más el número de palabras menos 1. Los métodos que cambian la lista de palabras utilizan declaraciones de afirmación para especificar la invariante de longitud. y verifíquelo si las afirmaciones están habilitadas en tiempo de ejecución.

clase Lista de palabras {

cadenas de LinkedList privadas = nueva LinkedList();

longitud int privada = -1; // Invariante: es igual a la longitud de las palabras más los espacios entre palabras

public int longitud() { longitud de retorno; }



public void addLast(String s) { cadenas.addLast(s);
longitud += 1 + s.longitud();

afirmar longitud == calcularLongitud() + cadenas.tamaño() - 1;

}



cadena pública eliminarPrimero() {

Cadena res = (Cadena)cadenas.removeFirst(); longitud -= 1 + res.longitud();
afirmar longitud == calcularLongitud() + cadenas.tamaño() - 1; devolver resolución;
}

private int computeLength() { ... } // Para comprobar solo el invariante

}


No se deben usar declaraciones de afirmación para verificar la validez de la entrada del usuario o los argumentos de métodos o constructores públicos, porque la verificación se realizaría solo si las afirmaciones están habilitadas en tiempo de ejecución. En su lugar, utilice sentencias if ordinarias y genere una excepción en caso de error.
La declaración de afirmación se introdujo en Java 2, versión 1.4, y no se puede utilizar en compiladores de Java anteriores. Un programa que utilice la declaración de afirmación debe compilarse (sección 16) con la opción - fuente 1.4, de la siguiente manera:
javac -source 1.4 miprog.java
Un algoritmo para formatear una secuencia de palabras en un texto con un margen derecho recto debe producir líneas de una longitud especificada lineWidth, a menos que solo haya una palabra en la línea o que la línea sea la última. Este requisito se puede expresar y verificar mediante una declaración de afirmación (consulte el archivo de ejemplo para obtener detalles sobre el algoritmo de formato):
afirmar res.length()==lineWidth || número de palabras==1 || !wordIter.hasNext();

Capítulo 13: Interfaces
Declaraciones de interfaz
Una interfaz describe campos y métodos pero no los implementa. Una declaración de interfaz puede contener Contiene descripciones de campos, descripciones de métodos, declaraciones de clases y declaraciones de interfaces, en cualquier orden.
interfaz-modificadores interfaz I extiende-cláusula {
descripciones de campos descripciones de métodos declaraciones de clases declaraciones de interfaz
}
Una interfaz puede declararse en el nivel superior o dentro de una clase o interfaz, pero no dentro de un método, constructor o inicializador. En el nivel superior, los modificadores de interfaz pueden ser públicos o estar ausentes. También se puede acceder a una interfaz pública fuera de su paquete. Dentro de una clase o interfaz, los modificadores de interfaz pueden ser estáticos (siempre entendidos implícitamente) y, como máximo, públicos, protegidos o privados.
La cláusula de extensión puede estar ausente o tener la forma
extiende I1, I2, ...
donde I1, I2, ... es una lista no vacía de nombres de interfaces. Si la cláusula de extensión está presente, entonces la interfaz I describe todos los miembros descritos por I1, I2,..., y la interfaz I es una subinterfaz (y por lo tanto un subtipo) de I1, I2,. Interfaz Puedo describir campos y métodos adicionales pero no puedo anularlos
miembros heredados.
Una descripción de campo en una interfaz declara una constante con nombre y debe tener la forma
modificadores de descripción de campo tipo f = inicializador;
donde modificadores de descripción de campo es una lista de elementos estáticos, finales y públicos, ninguno de los cuales necesita darse explícitamente, ya que todos se entienden implícitamente. El inicializador de campo debe ser una expresión que incluya únicamente literales y operadores, y miembros estáticos de clases e interfaces.
Una descripción de método para el método m debe tener la forma
modificadores-desc-método tipo-retorno m (lista-formal) cláusula-lanzamientos;
donde modificadores-desc-método es una lista de abstractos y públicos, los cuales se entienden y no es necesario proporcionarlos explícitamente.
Una declaración de clase dentro de una interfaz siempre es implícitamente estática y pública.

Clases que implementan interfaces
Se puede declarar que una clase C implementa una o más interfaces mediante una cláusula de implementación: la clase C implementa I1, I2, ...
cuerpo de clase
En este caso, C es un subtipo (sección 5.4) de I1, I2, etc., y C debe declarar todos los métodos descritos por I1, I2. con exactamente las firmas prescritas y los tipos de devolución. Una clase puede implementar
cualquier número de interfaces. Campos, clases e interfaces declarados en I1, I2. Se puede utilizar en clase C.
Ejemplo 70: Tres declaraciones de interfaz
La interfaz Colored describe el método getColor, la interfaz Drawable describe el método draw y Coloured-Drawable describe ambos. Los métodos son implícitamente públicos.

importar java.awt.*;

interfaz Coloreada { Color getColor(); } interfaz dibujable { void draw(Gráficos g); }
interfaz ColouredDrawable extiende Colored, Drawable {}


Ejemplo 71: Clases que implementan interfaces
Los métodos getColor y draw deben ser públicos como en las declaraciones de la interfaz (ejemplo 70).

clase ColoredPoint extiende Point implementa Colored { Color c;
ColoredPoint(int x, int y, Color c) { super(x, y); esto.c = c; } Color público getColor() { return c; }
}



clase ColoredDrawablePoint extiende ColoredPoint implementa ColoredDrawable { Color c;
ColoredDrawablePoint(int x, int y, Color c) { super(x, y, c); } public void draw(Gráficos g) { g.fillRect(x, y, 1, 1); }
}



clase ColoredRectangle implementa ColoredDrawable {

entero x1, x2, y1, y2; // (x1, y1) esquina superior izquierda, (x2, y2) esquina inferior derecha Color c;


ColoredRectangle(int x1, int y1, int x2, int y2, Color c)

{ esto.x1 = x1; esto.y1 = y1; esto.x2 = x2; esto.y2 = y2; esto.c = c; } Color público getColor() { return c; }
dibujo vacío público (Gráficos g) { g.drawRect(x1, y1, x2-x1, y2-y1; }

}


Ejemplo 72: Uso de interfaces como tipos
Un valor coloreado tiene un método getColor; un valor ColoredDrawable tiene un método getColor y un
método de dibujo:
colores de impresión vacíos estáticos (Colored[] cs) { for (int i=0; i<cs.length; i++)
System.out.println(cs[i].getColor().toString());
}
dibujo vacío estático (Gráficos g, ColoredDrawable[] cs) { for (int i=0; i<cs.length; i++) {
g.setColor(cs[i] getColor());
cs[i].draw(g);
}
}

Capítulo 14: Excepciones, marcadas y no marcadas
Una excepción es un objeto de un tipo de excepción: una subclase de la clase Throwable. Se utiliza para señalar y describir una situación anormal durante la ejecución del programa. La evaluación de una expresión o la ejecución de una declaración puede terminar abruptamente al generar una excepción, ya sea ejecutando una declaración de lanzamiento (sección 12.6.5) o ejecutando una operación primitiva, como la asignación a un elemento de matriz, que puede generar un excepción.
Una excepción lanzada puede quedar atrapada en una declaración try-catch que la incluye dinámicamente (sección 12.6.6). Si no se detecta la excepción, se cancelará toda la ejecución del programa y la información de la excepción se imprimirá en la consola. Lo que se imprime está determinado por el método toString de la excepción.
Hay dos tipos de excepciones: marcadas (aquellas que deben declararse en la cláusula throws de un método o constructor; consulte la sección 9.8) y no marcadas (aquellas que no necesitan ser declaradas). Si la ejecución de un método o del cuerpo del constructor puede generar una excepción marcada de la clase E, entonces la clase E o un supertipo de E deben decretarse. indicado en la cláusula throws del método o constructor.
La siguiente tabla muestra parte de la jerarquía de clases de excepción.

Ejemplo 73: Declaración de una clase de excepción marcada
Esta es la clase de excepciones lanzadas por el método wdayno4 (ejemplo 65). Pasar una cadena al constructor de la superclase (es decir, la clase Exception) hace que el método toString agregue esa cadena al nombre de la excepción.

class WeekdayException extiende Exception { public WeekdayException(String wday) { super("Día de la semana ilegal: " + wday);
}

}


Ejemplo 74: Todas las rutas a través de una declaración try-catch-finally
Para ejercitar las 18 rutas a través de la instrucción try-catch-finally (sección 12.6.6) en el método m del siguiente programa, ejecútelo con cada uno de estos argumentos de línea de comando: 101 102 103 201 202 203 301 302
303 411 412 413 421 422 423 431 432 433. La cláusula try termina normalmente en los argumentos 1yz, sale por retorno en 2yz y genera una excepción en 3yz y 4yz. La cláusula catch ignora las excepciones lanzadas en 3yz pero captura aquellas lanzadas en 4yz; la cláusula catch termina normalmente en 41z, sale por retorno en 42z y genera una excepción en 43z. La cláusula finalmente termina normalmente en xy1, sale por retorno en xy2 y genera una excepción en xy3.
Las salidas mediante declaraciones break y continue se manejan de manera similar al retorno; Se podría construir un ejemplo más complicado para ilustrar su interacción.

clase TryCatchFinalmente {

public static void main (String[] args) lanza una excepción

{ System.out.println(m(Integer.parseInt(args[0] ))); }



Cadena estática m (int a) lanza excepción {intenta {
System.out.print("intentar...");

if (a/100 == 2) devuelve "devuelto del intento";

if (a/100 == 3) lanza una nueva excepción ("lanzada por intento");

if (a/100 == 4) throw new RuntimeException("lanzado por intento");

} catch (RuntimeException x) { System.out.print("catch...");
if (a/10%10 == 2) devuelve "regresado de la captura";

if (a/10%10 == 3) lanza una nueva excepción ("lanzada por captura");

} finalmente { System.out.println("finalmente");
if (a%10 == 2) return "regresó finalmente";

if (a%10 == 3) lanza una nueva excepción ("lanzada por finalmente");

}

retorno "terminado normalmente con " + a;

}

}

Capítulo 15: Subprocesos, ejecución simultánea y sincronización
Hilos y ejecución concurrente
Los capítulos anteriores describieron la ejecución secuencial de programas, en los que se evalúan expresiones y se ejecutan declaraciones una tras otra: consideraron solo un único hilo de ejecución, donde un hilo es una actividad secuencial independiente. Un programa Java puede ejecutar varios subprocesos al mismo tiempo, es decir, potencialmente superponiéndose en el tiempo. Por ejemplo, una parte de un programa puede continuar computando mientras otra parte está bloqueada esperando una entrada (ejemplo 75).
Ejemplo 75: múltiples subprocesos
El programa principal crea un nuevo hilo, lo vincula a u y lo inicia. Ahora se ejecutan dos subprocesos al mismo tiempo: uno ejecuta main y otro ejecuta run. Mientras el método principal está bloqueado esperando la entrada del teclado, el nuevo hilo sigue incrementando i. El nuevo hilo ejecuta rendimiento() para asegurarse de que el otro hilo pueda ejecutarse (cuando no esté bloqueado).

class Incrementer extiende Thread { public int i;
ejecución pública vacía() {

Para Siempre

yo ++; // incremento i

producir();

}

} }



clase ThreadDemo {

public static void main(String[] args) lanza IOException { Incrementer u = new Incrementer();
u.start();

System.out.println("Presione Enter repetidamente para obtener el valor actual de i:"); para (;;) {
Sistema.en.read(); // Espere la entrada del teclado System.out.println(u.i);
} } }


Un hilo se crea y controla utilizando un objeto de la clase Thread que se encuentra en el paquete java.lang. Un hilo ejecuta el método public void run() en un objeto de una clase que implementa la interfaz Runnable, que también se encuentra en el paquete java.lang. Para cada hilo (actividad secuencial independiente) hay un objeto Thread controlador único, por lo que a menudo se piensa que los dos son idénticos.
Una forma de crear y ejecutar un hilo es declarar una clase U como una subclase de Thread, sobrescribiendo su (trivial) método de ejecución. Luego cree un objeto u de clase U y llame a u.start(). Esto permitirá que el hilo ejecute u.run() simultáneamente con otros hilos (ejemplo 75).

Alternativamente, declare una clase C que implemente Runnable, cree un objeto o de esa clase, cree un objeto de hilo u = new Thread(o) de o y ejecute u.start (). Esto permitirá que el hilo ejecute o.run() simultáneamente con otros hilos (ejemplo 79).
Los subprocesos pueden comunicarse entre sí a través de un estado compartido, es decir, mediante el uso y la asignación de campos estáticos, campos no estáticos, elementos de matriz y tuberías (sección 21.15). Según el diseño de Java, los subprocesos no pueden utilizar variables locales ni parámetros de métodos para la comunicación.
Estados y transiciones de estado de un hilo
Un hilo está vivo si se ha iniciado y no ha muerto. Un hilo muere al salir de su método run(), ya sea regresando o lanzando una excepción. Un hilo activo se encuentra en uno de los estados Habilitado (listo para ejecutarse), Ejecutando (realmente ejecutándose), Suspendido (wesperando un tiempo de espera), Unirse (esperando a que muera otro hilo), Bloqueando (intentando obtener el bloqueo en el objeto o) o Esperando (para recibir una notificación sobre el objeto o). Las transiciones de estado del hilo se muestran en la siguiente tabla y en la figura de la página opuesta:
Estados y transiciones de estado de un hilo. La transición de un hilo de un estado a otro puede ser causada por una llamada a un método realizada por el propio hilo (que se muestra en la fuente monoespaciada), por una llamada a un método posiblemente realizada por otro hilo (que se muestra en la fuente monoespaciada inclinada); y por tiempos de espera y otras acciones.




Bloqueos y la declaración sincronizada
Los subprocesos concurrentes se ejecutan de forma independiente. Por lo tanto, cuando varios subprocesos simultáneos acceden a los mismos campos o elementos de matriz, existe un riesgo considerable de crear un estado inconsistente (ejemplo 77). Para evitar esto, los subprocesos pueden sincronizar el acceso al estado compartido, como objetos y matrices. Se asocia un único candado con cada objeto, matriz y clase. Un candado puede ser mantenido por como máximo un hilo a la vez. Un hilo puede solicitar explícitamente el bloqueo de un objeto o matriz ejecutando una declaración sincronizada, que tiene esta forma:
declaración de bloque sincronizada (expresión)
La expresión debe tener tipo de referencia. La expresión debe evaluarse como una referencia no nula o; de lo contrario, se lanza una NullPointerException. Después de la evaluación de la expresión, el hilo se bloquea en el objeto o; vea la figura en la página anterior. Cuando el hilo obtiene el bloqueo en el objeto o (si es que alguna vez lo hace), el hilo pasa a estar Habilitado y puede pasar a Ejecutarse, por lo que se ejecuta la declaración de bloqueo. Cuando la declaración de bloque termina o se sale mediante return, break, continue o lanzando una excepción, entonces se libera el bloqueo en o.
Una declaración de método no estático sincronizado (sección 9.8) es una abreviatura de un método cuyo cuerpo tiene la forma
sincronizado (esto)
cuerpo del método
Es decir, el hilo ejecutará el cuerpo del método sólo cuando haya obtenido el bloqueo en el objeto actual. Liberará el bloqueo cuando abandone el cuerpo del método.
Una declaración de método estático sincronizado (sección 9.8) en la clase C es una abreviatura de un método cuyo cuerpo tiene la forma
sincronizado (clase C)
cuerpo del método
Es decir, el hilo ejecutará el cuerpo del método solo cuando haya obtenido el bloqueo en el objeto C.class, que es el objeto único de la clase Class asociado con la clase C. Mantendrá el bloqueo hasta que abandone el cuerpo del método. y suéltelo en ese momento.
Los constructores e inicializadores no se pueden sincronizar.
La exclusión mutua solo se garantiza si todos los subprocesos que acceden a un objeto compartido lo bloquean antes de su uso. Por ejemplo, si agregamos un método roguetransfer no sincronizado a un objeto bancario (ejemplo 77), ya no podemos estar seguros de que un subproceso que llama al método sincronizado transfer tenga acceso exclusivo al objeto bancario: cualquier número de subprocesos podría estar ejecutando roguetransfer en al mismo tiempo.

Un monitor es un objeto cuyos campos son privados y son manipulados únicamente por métodos sincronizados del objeto, de modo que todo acceso a los campos está sujeto a sincronización (ejemplo 78).
Si un hilo u necesita esperar a que alguna condición se cumpla, o que un recurso esté disponible, puede liberar temporalmente su bloqueo en el objeto o llamando a o.wait(). El hilo debe mantener el bloqueo en el objeto o; de lo contrario, se lanza la excepción IllegalMonitorStateException. El hilo u se agregará al conjunto de espera de o, es decir, el conjunto de hilos que esperan notificación sobre el objeto o. Esta notificación debe provenir de otro hilo que haya obtenido el bloqueo en o y que ejecute o.notify() u o.notifyAll(). El hilo de notificación no libera su bloqueo en o. Después de recibir la notificación, debe volver a bloquear o antes de poder continuar. Por lo tanto, cuando regrese la llamada de espera, el subproceso u mantendrá el bloqueo en o tal como antes de la llamada (ejemplo 78).
Para conocer las reglas detalladas que rigen el comportamiento de subprocesos Java no sincronizados, consulte el capítulo 17 de la Especificación del lenguaje Java [1].
Ejemplo 76: Exclusión mutua
Un hilo de impresora imprime siempre un (-) seguido de un (/). Si creamos y ejecutamos dos subprocesos de impresora simultáneos usando new Printer().start() y new Printer().start(), entonces solo uno de los subprocesos puede mantener el bloqueo en el objeto mutex a la vez, por lo que ningún otro símbolo puede hacerlo. imprimirse entre (-) y (/) en una iteración del bucle for. Por lo tanto, el programa debe imprimir -/-/-/-/-/-/-/ y así sucesivamente. Sin embargo, si se elimina la sincronización, es posible que se imprima --//--/-/-//--// y así sucesivamente. La llamada Util.pause(n) pausa el hilo durante 200 ms, mientras que Util.pause (100, 300) lo pausa entre 100 y 300 ms. Esto se hace sólo para hacer más fácilmente observable la no determinación inherente de la concurrencia no sincronizada.

La impresora de clase extiende el hilo {

Objeto estático mutex = nuevo Objeto(); ejecución pública vacía() {
para (;;) {

sincronizado (mutex) { System.out.print("-"); Util.pausa(100, 300); System.out.print("/");
}

Util.pausa(200);

} } }


Ejemplo 77: Métodos sincronizados en un objeto

El objeto Banco aquí tiene dos cuentas. El dinero se repite y ser transferido de una cuenta a otra por empleados. Es evidente que la cantidad total de dinero debería permanecer constante (en 30 euros). Esto es válido cuando el método de transferencia se declara sincronizado, porque sólo un empleado puede acceder a las cuentas a la vez. Si se elimina la declaración sincronizada, la suma será diferente de 30 la mayor parte del tiempo, porque es probable que un empleado sobrescriba los depósitos y retiros del otro.

banco de clase {

cuenta privada int1 = 10, cuenta2 = 20; transferencia nula pública sincronizada (monto int) { int nuevo1 = cuenta1 - monto;

Util.pausa(10);

cuenta1 = nueva1; cuenta2 = cuenta2 + monto; System.out.println("La suma es " + (cuenta1+cuenta2));
} }



class Clerk extiende Thread { banco privado banco;
Secretario público(Banco banco) { this.bank = banco; } ejecución pública vacía() {
Para Siempre

transferencia.bancaria(Util.random(-10, 10)); // transferir dinero Util.pause(200, 300); // entonces tómate un descanso
} } }



... Banco banco = nuevo Banco();

... nuevo Empleado(banco).start(); nuevo Empleado(banco).start();


Operaciones en hilos
El hilo actual, cuyo estado es En ejecución, puede llamar a estos métodos, entre otros. Se describen más métodos Thread en la documentación de la biblioteca de clases Java [3].
Thread.yield() cambia el estado del subproceso actual de En ejecución a Habilitado y, por lo tanto, permite que el sistema programe otro subproceso habilitado, si lo hubiera.
Thread.sleep(n) duerme durante n milisegundos: el hilo actual pasa a Dormir y después de n milisegundos se habilita. Puede generar InterruptedException si el hilo se interrumpe mientras duerme.
Thread.currentThread() devuelve el objeto del hilo actual.
Thread.interrupted() devuelve y borra el estado de interrupción del hilo actual: verdadero si no ha habido ninguna llamada a Thread.interrupted() y no se ha lanzado ninguna InterruptedException desde la última interrupción; de lo contrario falso.
Sea u un hilo (un objeto de una subclase de Thread). Entonces
u.start() cambia el estado de u a Habilitado para que se llame a su método de ejecución cuando un procesador esté disponible.
u.interrupt() interrumpe el hilo u: si u está en ejecución, habilitado o bloqueado, entonces su estado de interrupción se establece en verdadero. Si está durmiendo o uniéndose, se habilitará, y si está esperando, se bloqueará; en estos casos, lanzará InterruptedException cuando se convierta en Ejecución (y el estado de interrupción se establezca en falso).
u.isInterrupted() devuelve el estado interrumpido de u (y no lo borra).
u.join() espera a que muera el hilo u; puede generar InterruptedException si el hilo actual se interrumpe mientras se espera.
u.join(n) funciona como u. join() pero se agota el tiempo de espera y regresa después de n milisegundos como máximo. No hay indicación de si la llamada se devolvió debido a un tiempo de espera o porque usted murió.

Operaciones sobre objetos bloqueados
Un hilo que mantiene el bloqueo de un objeto o puede llamar a los siguientes métodos, heredados por o de la clase Objeto.
o.wait() libera el bloqueo en o, cambia su propio estado a Esperando y se agrega al conjunto de subprocesos que esperan notificación en o. Cuando se le notifica (si es que alguna vez lo hace), el hilo debe obtener el bloqueo en o, de modo que cuando regresa la llamada de espera, nuevamente mantiene el bloqueo en o. Puede generar InterruptedException si el hilo se interrumpe mientras se espera.
o.wait(n) funciona como o.wait() excepto que el hilo cambiará de estado a Bloqueo después de n milisegundos, independientemente de si ha habido una notificación en o. No hay indicación de si el cambio de estado fue causado por un tiempo de espera o por una notificación.
o.notify () elige un hilo arbitrario entre los hilos que esperan notificación en o (si corresponde) y cambia su estado a Bloqueo. El hilo elegido en realidad no puede obtener el bloqueo en o hasta que el hilo actual lo haya liberado.
o.notifyAll() funciona como o.notify(), excepto que cambia el estado a Bloqueo para todos los subprocesos que esperan notificación en o.
Ejemplo 78: Productores y consumidores comunicándose a través de un monitor
Un búfer tiene espacio para un número entero y tiene un método put para almacenar en el búfer (si está vacío) y un método get para leer desde el búfer (si no está vacío); es un monitor (sección 15.2). Un hilo que llama a get debe obtener el bloqueo en el búfer. Si encuentra que el búfer está vacío, llama a esperar para (liberar el bloqueo y) esperar hasta que se haya puesto algo en el búfer. Si otro subproceso llama a put y, por lo tanto, notifica, entonces el subproceso receptor comenzará a competir por el bloqueo del búfer nuevamente y, si lo obtiene, continuará ejecutándose. Aquí hemos utilizado una declaración sincronizada en el cuerpo del método (en lugar de sincronizar el método, como es normal para un monitor) para enfatizar que la sincronización, esperar y notificar a todos los trabajos en el mismo objeto de búfer.

búfer de clase

contenidos privados int;

booleano privado vacío = verdadero; public int get() { sincronizado (esto) {
mientras (vacío)

prueba { this.wait(); } captura (Excepción interrumpida x) {}; vacío = verdadero;
this.notificar(); devolver contenidos;
} }

public void put(int v) { sincronizado (esto) { mientras (!vacío)
prueba { this.wait(); } captura (Excepción interrumpida x) {} ; vacío = falso;
contenido = v;

this.notificar();

} }

}


Ejemplo 79: Animación gráfica utilizando la interfaz ejecutable
La clase AnimatedCanvas aquí es una subclase de Canvas y, por lo tanto, no puede ser también una subclase de Thread. En su lugar, declara un método de ejecución e implementa la interfaz Runnable. El constructor crea un objeto Thread u a partir del objeto AnimatedCanvas this y luego inicia el hilo. El nuevo hilo ejecuta el método de ejecución, que duerme y repinta repetidamente, creando así una animación.

clase AnimatedCanvas extiende Canvas implementa Runnable { AnimatedCanvas() { Thread u = new Thread(this); u.start(); }


public void run() { // Desde la interfaz Ejecutable para (;;) { // Dormir y repintar para siempre
prueba { Thread.sleep(100); } captura (Excepción interrumpida e) { }

...

repintar();

}

}



pintura vacía pública (Gráficos g) {...} // De la clase Canvas

...

}

Capítulo 16: Compilación, archivos fuente, nombres de clases y archivos de clases
Un programa Java consta de uno o más archivos fuente (con el sufijo de nombre de archivo .java). Un archivo fuente puede contener una o más declaraciones de clase o interfaz. Un archivo fuente puede contener como máximo una declaración de una clase o interfaz pública de nivel superior, que luego debe tener el mismo nombre que el archivo (menos el sufijo del nombre del archivo). Un compilador de Java compila un archivo fuente myprog.java en archivos de clase Java (con el sufijo de nombre de archivo .class):
javac miprog.java
Esto crea un archivo de clase para cada clase o interfaz declarada en el archivo fuente myprog.java. Una clase o interfaz C declarada en una declaración de nivel superior produce un archivo de clase llamado C.class. Una clase anidada o interfaz D declarada dentro de la clase C produce un archivo de clase llamado C$D.class. Una clase D local declarada dentro de un método en la clase C produce un archivo de clase llamado C$1$D.class o similar.
Una clase C de Java que declara el método public static void main(String[] args) se puede ejecutar utilizando el sistema de tiempo de ejecución de Java escribiendo una línea de comando del formulario
JavaCarg1arg2...
Esto ejecutará el cuerpo del método main con los argumentos de la línea de comando arg1, arg2,... vinculados a los elementos de la matriz args[0], args[1],... dentro del método main (ejemplos 6 y 84).

Capítulo 17: Paquetes y archivos Jar
Los archivos fuente de Java se pueden organizar en paquetes. Cada archivo fuente en el paquete p debe comenzar con la declaración
paquete p;
y debe almacenarse en un subdirectorio llamado p. Una clase declarada en un archivo fuente sin declaración de paquete pertenece al paquete predeterminado anónimo. Un archivo fuente que no pertenece al paquete p puede hacer referencia a la clase C del paquete p utilizando el nombre calificado p. C, en el que el nombre de clase C tiene el prefijo del nombre del paquete. Para evitar el uso del prefijo del nombre del paquete, el archivo fuente puede comenzar con una declaración de importación (posiblemente después de una declaración de paquete) de una de estas formas:
importar pc; importar p.*;
El primero permite que C se use sin calificar, sin el nombre del paquete, y el segundo permite que todos
Las clases e interfaces accesibles en el paquete p se utilizarán sin calificar. El paquete de biblioteca de clases Java java. lang se importa implícitamente en todos los archivos fuente, como si se importara java. lang.*, por lo que todo java. Las clases lang se pueden utilizar sin calificar en archivos fuente de Java. Tenga en cuenta que java. lang es un nombre de paquete compuesto, por lo que la clase java. idioma. La cadena se declara en el archivo java/lang/String. Java.
Los archivos en p y sus subdirectorios se pueden colocar en un archivo jar llamado p. jar usando el programa jar:
jar vcf p.jar p
Los paquetes en un archivo jar pueden estar disponibles para otros programas Java moviendo el archivo al directorio /usr/java/j2sdk1.4.0/jre/lib/ext o similar en Unix, o al directorio c:\jdk1.4 \jre\lib\ext o similar en MS Windows. El archivo jar puede contener más de un paquete; sólo necesita contener archivos de clase (no archivos fuente); y su nombre no es significativo.
Ejemplo 80: La jerarquía de embarcaciones como paquete
El barco del paquete contiene aquí parte de la jerarquía de barcos (ejemplo 19). Los campos de las clases Tanque y Barril son definitivos, por lo que no se pueden modificar después de la creación del objeto. Están protegidos, por lo que se puede acceder a ellos en subclases declaradas fuera del paquete del buque, como se muestra en el archivo Usevessels.java, que se encuentra en el paquete predeterminado anónimo, no en el paquete del buque.
El archivo buque/Vessel.java

buque de carga;

clase abstracta pública Buque {contenido doble privado;
capacidad doble abstracta pública(); Relleno público de vacío final (cantidad doble)
{ contenido = Math.min(contenido + cantidad, capacidad()); } public final double getContents() { devolver contenido; }
}
El archivo buque/Tank.java

buque de carga;

El tanque de clase pública extiende el recipiente {protegido final doble largo, ancho, alto;
Tanque público (doble l, doble w, doble h) { longitud = 1; ancho = ancho; altura = h; } public double capacidad() { return largo * ancho * alto; }
cadena pública a cadena ()

{ return "tanque (l,w,h) = (" + largo + ", " + ancho + ", " + alto + ")"; }

}
El archivo buque/Barrel.java

buque de carga;

clase pública Barril extiende Vasija {protegido doble radio final, altura;
Barril público (doble r, dou ble h) { radio = r; altura = h; }

capacidad doble pública() { altura de retorno * Math.PI * radio * radio; }

public String toString() { return "barril (r, h) = (" + radio + ", " + altura + ")"; }

}
El archivo Usevessels.java
La subclase Cube de la clase Tank puede acceder a la longitud del campo porque ese campo está declarado protegido en Tank arriba. El método principal no se modifica respecto del ejemplo 20.

buque de importación.*;

clase Cubo extiende Tanque {

Cubo público (doble cara) { super(lado, lado, lado); }

public String toString() { return "cubo(s) = (" + longitud + ")"; }

}

buques de uso de clase {

público estático vacío principal (String[] args) {...}

}

Capítulo 18: Funciones matemáticas
Class Math proporciona métodos estáticos para calcular funciones matemáticas estándar. Los números de coma flotante (dobles y flotantes) incluyen infinitos positivos y negativos, así como no números (NaN), siguiendo el estándar IEEE754 [6]. También hay una distinción entre cero positivo y cero negativo, que aquí se ignora.
Los métodos matemáticos devuelven números no numéricos (NaN) cuando se aplican a argumentos ilegales y devuelven infinitos en caso de desbordamiento; no lanzan excepciones. Además, los métodos devuelven NaN cuando se aplican a argumentos NaN, excepto donde se indique, y se comportan de manera sensata cuando se aplican a infinitos positivos o negativos.
Los ángulos se dan y devuelven en radianes, no en grados. Los métodos que redondean al entero más cercano redondearán al entero par más cercano en caso de empate.
Los métodos abs, min y max también están sobrecargados con argumentos float, int y long.
El doble estático E es la constante e ≈ 2,71828, la base del logaritmo natural.
El doble PI estático es la constante π ≈ 3,14159, la circunferencia de un círculo con diámetro 1.
abs doble estático (doble x) es el valor absoluto: x si x>=0 y -x si x<0.
acos doble estático (doble x) es el arco coseno de x, en el rango [0,π], para - 1<=x<=1.
asin doble estático (doble x) es el arco seno de x, en el rango [—π/2,π/2], para - 1<=x<=1.
atan doble estático (doble x) es el arco tangente de x, en el rango [—π/2,π/2].
El doble atan2 estático (doble y, doble x) es el arco tangente de y/x en el
cuadrante del punto (x, y), en el rango ] — π,π]. Cuando x es 0, el resultado es π/2 con el mismo signo que y.
techo doble estático (doble x) es el valor doble integral más pequeño>=x.
cos doble estático (doble x) es el coseno de x, en el rango [—1,1].
exp doble estática (doble x) es el exponencial de x, es decir, e elevado a x.
piso doble estático (doble x) es el valor doble integral más grande <= x.
IEEEremanente doble estático (doble x, doble y) es el resto de x/y,
es decir, x-y*n, donde n es el entero matemático más cercano a x/y.
El doble registro estático (doble x) es el logaritmo natural (en base e) de x, para x>=0.
El máximo doble estático (doble x, doble y) es el mayor de x e y.
static double min(doble x, doble y) es el más pequeño de xey.
potencia doble estática(doble x, doble y) es x elevado a la potencia y, es decir, xy. Si y es 0,
entonces el resultado es 1,0. Si y es 1, entonces el resultado es x. Si x<0 e y no son integrales, entonces el resultado es NaN.
static double random() devuelve un número pseudoaleatorio distribuido uniformemente en [0,1[.
rint doble estático (doble x) es el valor doble integral más cercano a x.
ronda larga estática (doble x) es el valor largo más cercano a x.
static int round(float x) es el valor int más cercano a x.
El doble pecado estático (doble x) es el seno de x radianes.
static double sqrt(doble x) es la raíz cuadrada positiva de x, para x>=0.
La doble tangente estática (doble x) es la tangente de x radianes.
static double toDegrees(doble r) es el número de grados correspondientes a r
radianes.
doble estático a Radianes (doble d) es el número de radianes correspondientes a d
grados.
Ejemplo 81: Factorial de punto flotante
Este método calcula la función factorial n! = 1∙2∙3∙∙∙(n—1)∙n usando logaritmos. doble hecho estático (int n) {

doble resolución = 0,0;
para (int i=1; i<=n; i++)

res += Math.log(i); devolver Math.exp(res);
}


Ejemplo 82: Generación de números pseudoaleatorios gaussianos
Este ejemplo utiliza la transformación de Box-Muller para generar N números pseudoaleatorios gaussianos, o normalmente distribuidos, con media 0 y desviación estándar 1.
para (int i=0; i<N; i+=2) {
doble x1 = Math.random(), x2 = Math.random();
print(Math.sqrt(-2 * Math.log (x1)) * Math.cos(2 * Math.PI * x2)); print(Math.sqrt (-2 * Math.log(x1)) * Math.sin(2 * Math.PI * x2));
}


Ejemplo 83: Funciones matemáticas: infinitos, NaN y casos especiales
print("Argumentos ilegales, resultados NaN:"); imprimir(Math.sqrt(-1)); //NaN
print(Math.log(-1)); // NaN print(Math.pow(-1, 2.5)); // NaN print(Math.acos(1.1)); // NaN print("Resultados infinitos:"); imprimir(Math.log(0)); // -Infinidad
print(Math.pow(0, -1)); // Impresión infinita(Math.exp(1000.0)); // Infinito (desbordamiento) print("Argumentos infinitos:");
doble infinito = Doble.POSITIVE_INFINITY; print(Math.sqrt(infinito)); // Impresión infinita(Math.log(infinito)); // Impresión infinita(Math.exp(-infinity)); // 0.0 print("Argumentos NaN y casos especiales:"); doble nan = Math.log(-1); pagrint(Math.sqrt(nan)); //NaN
print(Math.pow(nan, 0)); // 1.0 (caso especial)

imprimir(Math.pow(0, 0)); // 1.0 (caso especial) print(Math.round(nan)); // 0 (caso especial)
print(Matemáticas.ronda(1E50)); // 9223372036854775807 (Largo.MAX_VALUE)

// Para todo (x, y) excepto (0.0, 0.0):
// signo(cos(atan2(y, x))) == signo(x) && signo(sin(atan2(y, x))) == signo(y) for (doble x=-100; x<= 100;x+=0,125) {

for (doble y=-100; y<=100; y+=0,125) { doble r = Math.atan2(y, x);
if (!(signo(Math.cos(r))==signo(x) && signo(Math.sin(r))==signo(y))) print("x = " + x + "; y = " + y);
}
}

Capítulo 19: Búfers de cadena
Un objeto String s1, una vez creado, no se puede modificar. Usando s1 + s2 se puede agregar otra cadena s2 a s1, pero eso crea un nuevo objeto de cadena, copiando todos los caracteres de s1 y s2; no hay forma de extender s1 agregándole más caracteres. Así para concatenar n
cadenas cada una de longitud k mediante concatenación repetida de cadenas (+), copiamos k+2k+3k+∙∙∙∙∙+nk = kn(n+ 1)/2 caracteres, y el tiempo requerido para hacer esto es proporcional a kn2, que crece rápidamente a medida que n crece.
Los buffers de cadenas, que son objetos de la clase predefinida StringBuffer, proporcionan cadenas extensibles y modificables. Se pueden agregar caracteres a un búfer de cadena sin copiar los caracteres que ya están en el búfer de cadena; el búfer de cadena se amplía de forma automática y eficiente según sea necesario. Para concatenar n cadenas, cada una de ellas de longitud k utilizando un búfer de cadenas, solo se requiere un tiempo proporcional a kn, considerablemente más rápido que kn2 para n grande. Por lo tanto, para construir gradualmente una cadena, utilice un búfer de cadena. Esto es
sólo es necesario para la concatenación repetida en un bucle, como en el ejemplo 6. La expresión s1 + ∙∙∙ + sn es eficiente; en realidad significa new StringBuffer() .append(s1) ∙∙∙ append (sn)
.Encadenar().
Sea sb un StringBuffer, s un String y v una expresión de cualquier tipo. Entonces
new StringBuffer() crea un nuevo buffer de cadena vacío.
sb.append(v) agrega la representación de cadena del valor v al búfer de cadena, convirtiendo v mediante String.valueOf(v), consulte el capítulo 7. Extiende sb según sea necesario. Devuelve alguien
sb.charAt(int i) devuelve el carácter número i (contando desde cero) en el búfer de cadena.
Lanza String-IndexOutOfBoundsException si i<0 o i>=sb.length().
sb.delete(from, to) elimina los caracteres con índice from.. (to-1) del
búfer de cadena, reduciendo su longitud en caracteres de destino. Lanza
StringlndexOutOfBoundsException si desde<0 o desde>hacia o hacia>sb.length(). Devuelve alguien
sb.insert(from, v) inserta la representación de cadena de v obtenida por String.valueOf(v) en el búfer de cadena, comenzando en la posición from y extendiendo sb según sea necesario. Devuelve alguien Lanza StringlndexOutOf-BoundsException si es de <0 o de> sb.length().
sb.length() de tipo int es la longitud de sb, es decir, la cantidad de caracteres actualmente
en alguien
sb.replace(from, to, s) reemplaza los caracteres con índice from.. (to-1) en el búfer de cadena por la cadena s, extendiendo sb si es necesario. Lanza StringlndexOutOfBoundsException si desde<0 o desde>hacia o desde>sb.length().
Devuelve alguien
sb.reverse() invierte la secuencia de caracteres en el búfer de cadena. Devuelve alguien
sb.setCharAt(i, c) establece el carácter en el índice i a c. Lanza
StringlndexOutOfBoundsException si i<0 o i>=sb.length().
sb.toString() de tipo String es una nueva cadena que contiene los caracteres actualmente en sb.
El método de agregar es rápido, pero eliminar, insertar y reemplazar puede ser lento cuando sea necesario.
para mover grandes partes del búfer de cadena, cuando desde y hacia son mucho más pequeños que
longitud().
Las operaciones en un objeto StringBuffer son seguras para subprocesos: varios subprocesos simultáneos (capítulo 15) pueden modificar el mismo búfer de cadena sin que su estado interno sea inconsistente.
Se describen más métodos StringBuffer en la documentación de la biblioteca de clases Java [3].
Ejemplo 84: Concatenar eficientemente todos los argumentos de la línea de comando
Cuando hay muchos (más de 50) argumentos de línea de comando, esto es mucho más rápido que el ejemplo 6.
público estático vacío principal (String [] argumentos) {

StringBuffer res = nuevo StringBuffer();
for (int i=0; i<args.length; i++) res.append(args[i]); System.out.println(res.toString());
}

Ejemplo 85: Reemplazo de apariciones de un carácter por una cadena
Para reemplazar las apariciones del carácter c1 con la cadena s2 en la cadena s, es mejor usar un búfer de cadena para el resultado, ya que el tamaño de la cadena resultante no se conoce de antemano. Esto también funciona bien cuando se reemplaza un carácter cl con otro carácter c2, pero en ese caso la longitud del resultado se conoce de antemano (es igual a la longitud de s) y se puede usar una matriz de caracteres en su lugar (ejemplo 13). Resolver este problema mediante la concatenación repetida de cadenas (usando res += s2) sería muy lento. Cadena estática reemplazarCharString(String s, char c1, String s2) {
StringBuffer res = nuevo StringBuffer(); para (int i=0; i<s.length(); i++)
si (s.charAt(i) == cl)
res.append(s2); demás
res.append(s.charAt(i)); devolver res.toString();
}


Ejemplo 86: Reemplazo ineficiente de apariciones de un carácter por una cadena
El problema del ejemplo 85 también se puede resolver destructivamente mmodificando un búfer de cadena con reemplazo. Sin embargo, usar reemplazar repetidamente es ineficaz: para una cadena de 200.000 caracteres aleatorios, este método es aproximadamente 100 veces más lento que el del ejemplo 85.
vacío estático reemplazarCharString (StringBuffer sb, char cl, String s2) {

int yo = 0; // Ineficiente
while (i < sb.length()) { // Ineficiente
if (sb.charAt(i) == cl) { // Ineficiente
sb.replace(i, i+1, s2); // Ineficiente
yo += s2.longitud(); // Ineficiente
} else // Ineficiente
yo += 1; // Ineficiente
} } // Ineficiente


Ejemplo 87: Rellenar una cadena a un ancho determinado
Una cadena s puede rellenarse con espacios para asegurarse de que tenga un ancho mínimo determinado. Esto resulta útil para alinear números en columnas cuando se utiliza una fuente de paso fijo (ejemplo 103).
padLeft de cadena estática (cadena s, ancho int) {

StringBuffer res = nuevo StringBuffer();
for (int i=ancho-s.longitud(); i>0; i--) res.append(' ');
devolver resolución.Ejemplo 87: Rellenar una cadena a un ancho determinado
Una cadena s puede rellenarse con espacios para asegurarse de que tenga un ancho mínimo determinado. Esto resulta útil para alinear números en columnas cuando se utiliza una fuente de paso fijo (ejemplo 103).
padLeft de cadena estática (cadena s, ancho int) {

StringBuffer res = nuevo StringBuffer();
for (int i=ancho-s.longitud(); i>0; i--) res.append(' ');
devolver res.append(s).toString();
}

Capítulo 20: Colecciones y mapas
Descripción general
El paquete de biblioteca de clases Java java.util proporciona clases de colección y clases de mapas:
Una colección, descrita por la interfaz Colección (sección 20.1), se utiliza para agrupar y manejar muchos elementos distintos como un todo.
Una lista, descrita por la interfaz Lista (sección 20.2), es una colección cuyos elementos se pueden recorrer en orden de inserción. Implementado por las clases LinkedList (para listas enlazadas, colas de dos extremos y pilas) y ArrayList (para matrices y pilas dinámicamente extensibles).
Un conjunto, descrito por la interfaz Conjunto (sección 20.3), es una colección que no puede contener elementos duplicados. Implementado por las clases HashSet y LinkedHashSet.
Un conjunto ordenado, descrito por la interfaz SortedSet (sección 20.4), es un conjunto cuyos elementos están ordenados: o los elementos implementan el método compareTo especificado por la interfaz Comparable, o el orden del conjunto viene dado explícitamente por un objeto de tipo Comparador (sección 20.8). Implementado por la clase TreeSet.
Un mapa, descrito por la interfaz Mapa (sección 20.5), representa un mapeo de una clave a como máximo un valor para cada clave. Implementado por las clases HashMap, IdentityHashMap y LinkedHashMap.
Un mapa ordenado, descrito por la interfaz SortedMap (sección 20.6), es un mapa cuyas claves están ordenadas, como para SortedSet. Implementado por la clase TreeMap.
Las relaciones entre las interfaces estándar y las clases de implementación concretas y las clases abstractas intermedias se muestran en la siguiente figura. Las clases de implementación definidas por el usuario se pueden definir convenientemente como subclases de las clases abstractas; consulte la documentación de la biblioteca de clases Java en el paquete java.util [3]. Las flechas continuas indican las relaciones de subinterfaz y subclase, y las flechas discontinuas indican la relación de "implementos" entre una clase y una interfaz.

Ejemplo 88: uso de la colección concreta y las clases de mapas
Aquí creamos instancias de cinco clases de colección concretas y les agregamos algunos elementos String. Para cada colección, llamamos al método transversal en el ejemplo 91 para imprimir sus elementos.
También creamos instancias de tres clases de mapas concretas y les agregamos algunas entradas. Para cada mapa, nosotros
llame a atravesar por separado en el conjunto de claves y la colección de valores de ese mapa.
Tenga en cuenta que TreeSet, que implementa SortedSet, garantiza que los elementos se recorrerán en el orden especificado por el método compareTo (sección 20.8) de los elementos, y LinkedHashSet garantiza que los elementos se recorrerán en orden de inserción, mientras que HashSet no proporciona tal garantía. .
De manera similar, un TreeMap garantiza el recorrido en el orden de las claves y LinkedHashMap garantiza el recorrido en el orden de inserción de las claves, mientras que HashMap no garantiza ningún orden en particular.

importar java.util.*;



colección de clasesTodos {

público estático vacío principal (String [] argumentos) {

Lista /* de String */ list1 = new LinkedList();

lista1.add("lista"); list1.add("dup"); lista1.add("x"); list1.add("dup"); atravesar(lista1); // Debe imprimir: lista dup x dup
Lista /* de String */ list2 = new ArrayList();

lista2.add("lista"); list2.add("dup"); lista2.add("x"); list2.add("dup"); atravesar(lista2); // Debe imprimir: lista dup x dup
Conjunto /* de String */ set1 = new HashSet();

set1.add("conjunto"); set1.add("dup"); set1.add("x"); set1.add("dup"); atravesar(conjunto1); // Puede imprimir: x dup set
SortedSet /* de String */ set2 = new TreeSet();

set2.add("conjunto"); set2.add("dup"); set2.add("x"); set2.add("dup"); atravesar(conjunto2); // Debe imprimir: dup set x LinkedHashSet /* of String */ set3 = new LinkedHashSet(); set3.add("conjunto"); set3.add("dup"); set3.add("x"); set3.add("dup"); atravesar(conjunto3); // Debe imprimir: configurar dup x
Mapa /* de cadena a cadena */ ml = new HashMap();

m1.put("mapa", "J"); ml.put("dup", "K"); m1.put("x", "M"); m1.put("dup", "L"); atravesar(m1.keySet()); // Puede imprimir: x dup map traverse(m1.values()); // Puede imprimir: M L J
SortedMap /* de cadena a cadena */ m2 = new TreeMap();

m2.put("mapa", "J"); m2.put("dup", "K"); m2.put("x", "M"); m2.put("dup", "L"); atravesar(m2.keySet()); // Debe imprimir: dup map x traverse(m2.values()); // Debe imprimir: L J M
LinkedHashMap /* de cadena a cadena */ m3 = new LinkedHashMap(); m3.put("mapa", "J"); m3.put("dup", "K"); m3.put("x", "M"); m3.put("dup", "L"); atravesar(m3.keySet()); // Debe imprimir: map dup x traverse(m3.values()); // Debe imprimir: J L M
}



recorrido vacío estático (coll colección) {...}

}

La interfaz de colección
La interfaz de Colección describe los siguientes métodos:
boolean add(Object o) agrega el elemento o a la colección; devuelve verdadero si se agregó el elemento, falso si la colección no permite duplicados y contiene un elemento iguala o ya.
boolean addAll(Collection coll) agrega todos los elementos de coll a la colección; devoluciones
Es cierto si se agregó algún elemento.
void clear() elimina todos los elementos de la colección.
boolean contiene (Objeto o) devuelve verdadero si algún elemento de la colección es igual a o.
boolean containsAll(Collection coll) devuelve verdadero si la colección contiene todos los elementos de coll.
boolean isEmpty() devuelve verdadero si la colección no tiene elementos.
Iterator iterator() devuelve un iterador (sección 20.7) sobre los elementos de la colección.
boolean remove(Object o) elimina una única instancia del elemento o de la colección; devuelve verdadero si la colección contenía dicho elemento.
boolean removeAll(Collection coll) elimina todos aquellos elementos que también están en coll; devuelve verdadero si se eliminó algún elemento. Ningún elemento de la colección resultante es igual a un elemento de coll.
boolean retenciónAll(Collection coll) retiene sólo aquellos elementos que también están en
colear; devuelve verdadero si se eliminó algún elemento.
int size() devuelve el número de elementos de la colección.
Object[] toArray() devuelve una matriz de todos los elementos de la colección.
Object[] toArray(Object[] a) funciona como el anterior, pero el tipo de elemento de la matriz es el de a.
Los elementos de una colección y las claves y valores de un mapa deben ser objetos o matrices. Para elementos de tipo primitivo, como int, utilice una clase contenedora como Integer (sección 5.1).
Cuando se inserta un elemento de clase C en una colección, se convierte al tipo Objeto, y cuando se extrae nuevamente, (generalmente) se vuelve a convertir al tipo C. Estas conversiones se verifican solo en tiempo de ejecución, no por el compilador. por lo tanto, los programas que utilizan colecciones se escriben esencialmente de forma dinámica: el compilador de Java no le impedirá agregar una cadena a un conjunto de objetos enteros. Por esta razón, se recomienda documentar los tipos de elementos de colección previstos mediante comentarios del programa y utilizar conversiones explícitas (sección 11.12) siempre que se extraiga un elemento de una colección o mapa.
Una vista de una colección co1 es otra colección co2 que hace referencia a la misma estructura de datos subyacente. Como consecuencia, las modificaciones de co1 afectan al co2 y las modificaciones del co2 afectan al co1.
Una colección no modificable no admite modificación: las operaciones agregar, borrar, eliminar, establecer, etc. arrojan UnsupportedOperationException. La clase de utilidad Colecciones (sección 20.9) proporciona métodos estáticos para crear una vista no modificable de una colección determinada.
Una colección sincronizada es segura para subprocesos: varios subprocesos simultáneos pueden acceder a ella y modificarla de forma segura. Por motivos de eficiencia, las clases de colección estándar no están sincronizadas, por lo que la modificación simultánea de una colección puede hacer que su estado interno sea inconsistente. La clase de utilidad Colecciones (sección 20.9) proporciona métodos estáticos para crear una vista sincronizada de una colección determinada. Todo acceso simultáneo a una colección debe pasar por su vista sincronizada. Un iterador (sección 20.7) obtenido de una colección sincronizada no proporciona automáticamente una iteración sincronizada; se debe usar sincronizado (coll) {...} para garantizar explícitamente el acceso exclusivo a la colección durante la ejecución del bloque {...} que realiza la iteración.


La interfaz List y las implementaciones LinkedList y ArrayList
La interfaz Lista amplía la interfaz Colección con operaciones para acceso basado en posición usando índices 0,1,2,... y proporciona especificaciones más precisas de algunos métodos:
void add(int i, Object o) agrega el elemento o en la posición i, aumentando el índice de cualquier
elemento a la derecha por 1. Lanza IndexOutOfBoundsException si i<0 o i>size ().
boolean addAll(int i, Collection coll) agrega todos los elementos de coll a la lista,
comenzando en la posición i; devuelve verdadero si se agregó algún elemento. Lanza IndexOutOfBoundsException si i<0 o i>size().

booleano igual (Objeto o) devuelve verdadero si o es una Lista con elementos iguales en el mismo orden.
El objeto get(int i) devuelve el elemento en la posición i; lanza IndexOutOfBoundsException si i<0 o i>=size().
int hashCode() devuelve el código hash de la lista, que es una función de los códigos hash de
los elementos y su orden en la lista.
int indexOf(Object o) devuelve el menor índice i para el cual el elemento en la posición i
es igual a o; devuelve —1 si la lista no contiene dicho elemento.
int lastIndexOf(Object o) devuelve el mayor índice i para el cual el elemento en
la posición i es igual a o; devuelve —1 si la lista no contiene dicho elemento.
ListIterator listIterator() devuelve un iterador de lista, que es un iterador bidireccional.
Object remove(int i) elimina el elemento en la posición i y lo devuelve; lanza IndexOutOfBoundsException si i<0 o i>=size().
Conjunto de objetos (int i, Objeto o) establece el elemento en la posición i a o y devuelve el
elemento previamente en la posición i; lanza IndexOutOfBoundsException si i<0 o i>=size ().
List subList(int from, int to) devuelve una lista de los elementos en posiciones desde...(a-1), como una vista de la lista subyacente. Lanza IndexOutOfBoundsException si es de <0 o de> ao a>tamaño().
La clase LinkedList implementa todas las operaciones descritas por la interfaz List y tiene lo siguiente
constructores. La implementación es una lista doblemente enlazada, por lo que se puede acceder, agregar y eliminar elementos de manera eficiente en cualquier extremo de la lista. Por lo tanto, proporciona métodos adicionales para obtener, agregar y eliminar basados en la posición llamados addFirst, addLast, getFirst, getLast, removeFirst y removeLast. Los últimos cuatro arrojan NoSuchElementException si la lista está vacía.
LinkedList() crea una nueva LinkedList vacía.
LinkedList(Collection coll) crea una nueva LinkedList de los elementos proporcionados por
iterador de coll.
La clase ArrayList implementa todas las operaciones descritas por la interfaz List y tiene los siguientes constructores. La implementación utiliza una matriz subyacente (ampliada según sea necesario para contener los elementos), que permite un acceso eficiente basado en la posición en cualquier lugar de la lista. La clase ArrayList implementa la interfaz RandomAccess solo para indicar que se garantiza que el acceso a los elementos por índice será rápido, a diferencia de LinkedList. La clase ArrayList proporciona toda la funcionalidad proporcionada originalmente por la clase Vector (que es una subclase de AbstractList e implementa List y RandomAccess).
ArrayList() crea una nueva lista vacía.
ArrayList(Collection coll) crea una nueva ArrayList de los elementos proporcionados por
iterador de coll.

La interfaz Set y las implementaciones HashSet y LinkedHashSet
La interfaz Set describe los mismos métodos que la interfaz Collection. Los métodos add y addAll deben asegurarse de que un conjunto no contenga duplicados: no hay dos elementos iguales y como máximo un elemento nulo. Además, los métodos equals y hashCode tienen especificaciones más precisas para los objetos Set:
booleano igual (Objeto o) devuelve verdadero si o es un conjunto con el mismo número de elementos y cada elemento de o también está en este conjunto.
int hashCode() devuelve el código hash del conjunto: la suma de los códigos hash de sus elementos no nulos.
Para los argumentos de conjunto, addAll calcula la unión del conjunto, containsAll calcula la inclusión del conjunto, removeAll
calcula la diferencia de conjuntos y retenerTodo calcula la intersección de conjuntos (ejemplo 97).
La clase HashSet implementa la interfaz Set y tiene los siguientes constructores. Las operaciones en un Hash-Set se basan en los métodos iguales y hashCode de los objetos elemento.
HashSet() crea un conjunto vacío.
HashSet(Collection coll) crea un conjunto que contiene los elementos de coll, sin duplicados.

La clase LinkedHashSet es una subclase de HashSet y funciona de la misma manera, pero además garantiza que su iterador atraviesa los elementos en orden de inserción (en lugar del orden impredecible proporcionado por HashSet). Fue introducido en Java 2, versión 1.4.


La interfaz SortedSet y la implementación TreeSet
La interfaz SortedSet amplía la interfaz Set. Las operaciones en un SortedSet se basan en el orden natural de los elementos definidos por su método compareTo, o en un objeto Comparador explícito proporcionado cuando se creó el conjunto (sección 20.8), como para TreeSet a continuación.
Comparator comparador() devuelve el comparador asociado con este conjunto ordenado, o
nulo si utiliza el orden natural (sección 20.8) de los elementos.
El objeto primero() devuelve el menor elemento; lanza NoSuchElementException si el conjunto está vacío.
SortedSet headSet(Objeto a) devuelve el conjunto de todos los elementos estrictamente menores que a. El conjunto resultante es una vista del conjunto subyacente.
El objeto last() devuelve el elemento más grande; lanza NoSuchElementException si el conjunto está vacío.
SortedSet subSet(Objeto de, Objeto a) devuelve el conjunto de todos los elementos mayores o iguales a desde y estrictamente menores que a. El conjunto resultante es una vista del conjunto subyacente.
SortedSet tailSet(Objeto de) devuelve el conjunto de todos los elementos mayores o iguales a desde. El conjunto resultante es una vista del conjunto subyacente.
La clase TreeSet implementa la interfaz SortedSet y tiene los siguientes constructores. La implementación utiliza árboles binarios equilibrados, por lo que se garantiza que todas las operaciones serán eficientes.
TreeSet() crea un conjunto vacío y ordena los elementos utilizando su método compareTo.
TreeSet(Collection coll) crea un conjunto que contiene los elementos de coll, sin duplicados, ordenando los elementos usando su método compareTo.
TreeSet(Comparator cmp) crea un conjunto vacío y ordena elementos usando cmp.
TreeSet(SortedSet s) crea un conjunto que contiene los elementos de s, ordenando los elementos como en s.

La interfaz del mapa y la implementación de HashMap
La interfaz del Mapa describe los siguientes métodos. Un mapa puede considerarse una colección de entradas, donde una entrada es un par (k, v) de una clave k y un valor v, los cuales deben ser objetos o matrices. Por lo tanto, para utilizar valores de tipo primitivo, como int, como claves o valores, se debe utilizar la clase contenedora correspondiente, como Integer (sección 5.1). Un mapa no puede contener dos entradas con la misma clave.
void clear() elimina todas las entradas de este mapa.
boolean containsKey(Object k) devuelve verdadero si el mapa tiene una entrada con la clave k.
boolean containsValue(Object v) devuelve verdadero si el mapa tiene unn entrada con valor v.
Set EntrySet() devuelve una vista establecida de las entradas del mapa; cada entrada tiene tipo Map.Entry
(vea abajo).
booleano igual a (Objeto o) devuelve verdadero si o es un mapa con el mismo conjunto de entradas.
Object get(Object k) devuelve el valor v en la entrada (k, v) con la clave k, si corresponde; de lo contrario nulo.
int hashCode() devuelve el código hash del mapa, calculado como la suma de los códigos hash de las entradas devueltas por EntrySet().
boolean isEmpty() devuelve verdadero si este mapa no contiene entradas, es decir, size() es cero.
Set keySet() devuelve una vista establecida de las claves en el mapa.
Object put(Object k, Object v) modifica el mapa para que contenga la entrada (k, v); devuelve el valor previamente asociado con la clave k, si corresponde; de lo contrario devuelve nulo.
void putAll(Mapa mapa) copia todas las entradas del mapa a este mapa.
Object remove(Object k) elimina la entrada de la clave k del mapa, si corresponde; devuelve el valor previamente asociado con k, si lo hubiera; de lo contrario devuelve nulo.
int size() devuelve el número de entradas, que es igual al número de claves, en el mapa.
Valores de colección() devuelve una vista de colección de los valores en el mapa. La interfaz Map.Entry (ejemplo 92) describe operaciones en las entradas del mapa:
El objeto getKey() devuelve la clave en esta entrada.

El objeto getValue() devuelve el valor de esta entrada.
La clase HashMap implementa la interfaz Map y tiene los siguientes constructores. Las operaciones en un HashMap se basan en los métodos iguales y hashCode de los objetos clave.
HashMap() crea un HashMap vacío.
HashMap (mapa de mapa) crea un HashMap que contiene el mapa de entradas.
La clase LinkedHashMap es una subclase de HashMap y funciona de la misma manera, pero además garantiza que su iterador recorra las entradas en el orden de inserción de claves (en lugar del orden impredecible proporcionado por HashMap). Fue introducido en Java 2, versión 1.4.
La clase IdentityHashMap implementa la interfaz Map pero compara claves usando igualdad de referencia (==) en lugar del método igual. Fue introducido en Java 2, versión 1.4.

La interfaz SortedMap y la implementación de TreeMap
La interfaz SortedMap amplía la interfaz Map. Las operaciones en un SortedMap se basan en el orden natural de las claves definidas por su método compareTo o en un objeto Comparador explícito proporcionado cuando se creó el mapa (sección 20.8), como para TreeMap a continuación.
Comparator comparador() devuelve el comparador asociado con este mapa ordenado, o
nulo si utiliza el orden natural (sección 20.8) de las claves.
El objeto firstKey() devuelve la menor clave en este mapa ordenado; lanza NoSuchElementException si el mapa está vacío.
SortedMap headMap(Objeto a) devuelve el mapa ordenado de todas las entradas cuyas claves son estrictamente menores que a. El mapa resultante es una vista del mapa subyacente.
El objeto lastKey() devuelve la clave más grande en este mapa ordenado; lanza NoSuchElementException si el mapa está vacío.
SortedMap subMap(Object from, Object to) devuelve el mapa ordenado de todas las entradas cuyas claves son mayores o iguales que from y estrictamente menores que to. El mapa resultante es una vista del mapa subyacente.
SortedMap tailMap(Object from) devuelve el mapa ordenado de todas las entradas cuyas claves son mayores o iguales que from. El mapa resultante es una vista del mapa subyacente.
La clase TreeMap implementa la interfaz SortedMap y tiene los siguientes constructores. La implementación utiliza árboles binarios ordenados equilibrados, por lo que se garantiza que todas las operaciones serán eficientes.
TreeMap() crea un mapa vacío y ordena las entradas utilizando el método compareTo de las claves.
TreeMap(Mapa mapa) crea un mapa que contiene las entradas del mapa, ordenando las entradas usando el
método compareTo de las claves.
TreeMap(Comparator cmp) crea un mapa vacío y ordena las entradas usando cmp en las claves.
TreeMap(SortedMap s) crea un mapa que contiene las entradas de s, ordenando las entradas como en
s.
Ejemplo 89: Construyendo una concordancia
Este método lee palabras (tokens alfanuméricos) de un archivo de texto y crea una concordancia, que muestra para cada palabra los números de línea de sus apariciones. El índice de concordancia resultante es un SortedMap de String a SortedSet of Integer.
static SortedMap buildIndex (nombre de archivo de cadena) lanza IOException { Reader r = new BufferedReader (new FileReader (nombre de archivo)); StreamTokenizer stok = nuevo StreamTokenizer(r); stok.quoteChar('"'); stok.ordinaryChars('!', '/');
stok.nextToken();

Índice de SortedMap = nuevo TreeMap(); // Asignar de cadena a conjunto de enteros while (stok.ttype != StreamTokenizer.TT_EOF) {

if (stok.ttype == StreamTokenizer.TT_WORD) { SortedSet ts;
if (index.containsKey(stok.sval)) // Si la palabra tiene un conjunto, obtenlo ts = (SortedSet)index.get(stok.sval);
demás {

ts = nuevo TreeSet(); // De lo contrario, crea uno index.put(stok.sval, ts);
}

ts.add(new Integer(stok.lineno()));

}

stok.nextToken();

}

índice de retorno;

}


Ejemplo 90: Almacenamiento del resultado de una consulta de base de datos
Este método ejecuta una consulta a la base de datos, utilizando clases del paquete java.sql. Devuelve el resultado de la consulta como ArrayList con un elemento por cada fila del resultado. Cada fila se almacena como un HashMap, asignando un resultado fnombre de campo a un objeto (por ejemplo, un número entero o una cadena) que contiene el valor de ese campo en esa fila. Esta es una forma sencilla y útil de separar la consulta de la base de datos del procesamiento del resultado de la consulta (pero puede resultar demasiado ineficaz si el resultado de la consulta es muy grande).

ArrayList estático getRows (conexión de conexión, consulta de cadena) lanza SQLException {
Declaración stmt = conn.createStatement(); ResultSet rset = stmt.executeQuery(consulta); ResultSetMetaData rsmd = rset.getMetaData(); int recuento de columnas = rsmd.getColumnCount();
ArrayList queryResult = nuevo ArrayList(); // Lista de mapas de cadena a objeto while (rset.next()) {
Fila del mapa = nuevo HashMap();
for (int i=1; i<=columncount; i++) row.put(rsmd.getColumnName(i), rset.getObject(i)); queryResult.add(fila);
}
devolver resultado de la consulta;
}

Pasando por una colección: iterador
La interfaz Iterator proporciona una forma estandarizada de revisar los elementos de las colecciones. Un iterador normalmente se crea y utiliza como se muestra en el ejemplo 91. El cuerpo del bucle while no debe modificar el iterador ni la colección subyacente; si es así, el resultado es impredecible. De hecho, las clases concretas ArrayList, LinkedList, HashMap, HashSet, TreeMap y TreeSet producen iteradores rápidos: si la colección subyacente se modifica estructuralmente (excepto mediante el método remove del iterador) después de que se ha obtenido un iterador, entonces se genera una excepción ConcurrentModificationException. arrojado. La interfaz Iterator describe los siguientes métodos:
Ejemplo 91: iteración sobre una colección
Este método imprime los elementos de la colección dada; se llama en el ejemplo 88. Esta es la forma prototípica de iterar sobre una colección. La declaración de elem y el tipo emitido inmediatamente dentro del bucle while muestra que esperamos que los elementos de la colección tengan la clase String.

recorrido vacío estático (coll de colección) { Iterador iter = coll.iterator();
mientras (iter.hasNext()) {

Elemento de cadena = (Cadena)iter.next(); System.out.print(elem + " ");
}

Sistema.out.println();

}


boolean hasNext() devuelve verdadero si una llamada a next() devolverá un nuevo elemento.
Object next() devuelve el siguiente elemento y avanza más allá de ese elemento, si lo hay; lanza NoSuchElementException si no hay ningún elemento siguiente.
void remove() elimina el último elemento devuelto por el iterador; Lanza IllegalStateException si el iterador aún no ha devuelto ningún elemento o si el elemento ya se ha eliminado. Lanza UnsupportedOperationException si no se admite la eliminación.
Un iterador obtenido de una Lista recorrerá los elementos en el orden de la lista. Un iterador obtenido de SortedSet, o de las claves o valores de un SortedMap, recorrerá los elementos en el orden de los elementos del conjunto o de las claves del mapa. Un iterador obtenido de un HashSet recorrerá los elementos en un orden impredecible. Un iterador proporciona toda la funcionalidad proporcionada originalmente por la interfaz de enumeración, pero tiene nombres de método diferentes (más cortos).


Códigos de igualdad, comparación y hash
Los elementos de una colección deben tener el método igual. Si los elementos tienen un método hashCode, se pueden utilizar como elementos HashSet o claves HashMap. Si tienen el método compareTo descrito por la interfaz java.lang.Comparable, se pueden utilizar como elementos TreeSet o claves TreeMap. Las clases contenedoras de tipo primitivo (sección 5.1) y la clase String tienen métodos iguales, hashCode y compareTo.
booleano igual (Objeto o) determina la igualdad de dos objetos. Lo utilizan ArrayList, LinkedList, HashSet y HashMap. Debería satisfacer o.equals(o); si o1.equals(o2), entonces también o2.equals(o1); y si o1.equals(o2) y o2.equals(o3), entonces también o1.equals(o3) para o1, o2 y o3 no nulos.
int hashCode() devuelve el código hash de un objeto. Es utilizado por HashSet y HashMap. Debería satisfacer que si o1.equals(o2), entonces o1.hashCode () ==o2.hashCode().
int compareTo(Object o), descrito por la interfaz Comparable, realiza una comparación de tres vías de dos objetos: o1.compareTo(o2) es negativo si o1 es menor que o2, cero si o1 y o2 son iguales, y positivo si o1 es mayor que o2. se llama natural

ordenamiento de elementos y lo utilizan, por ejemplo, TreeSet y TreeMap, a menos que se haya proporcionado un Comparador cuando se creó el conjunto o mapa. Debe satisfacer que o01.compareTo(o2) ==0 siempre que o1.equals(o2).
int compare(Objeto o1, Objeto o2), descrito por la interfaz Comparador, realiza una comparación de tres vías de dos objetos: es negativo si o1 es menor que o2, cero si o1 y o2 son iguales, y positivo si o1 es mayor que o2. Se puede utilizar para definir ordenamientos de elementos no estándar al crear TreeSets y TreeMaps (ejemplo 95). Debe satisfacer que compare(o1, o2) ==0 siempre que o1.equals(o2).
Ejemplo 92: Impresión de una concordancia
Se supone que el índice del mapa es una concordancia creada en el ejemplo 89. El método imprime una lista alfabética de las palabras y, para cada palabra, sus números de línea. Se crea un iterador para recorrer las palabras y, para cada palabra, se crea un iterador independiente para recorrer las palabras.los números de línea.

static void printIndex(SortedMap index) { Iterador wordIter = index.entrySet().iterator(); mientras (palabraIter.hasNext()) {
Map.Entry entrada = (Map.Entry)wordIter.next(); System.out.print((String)entry.getKey() + ": "); SortedSet lineNoSet = (SortedSet)entry.getValue(); Iterador lineNoIter = lineNoSet.iterator();
mientras (lineNoIter.hasNext()) System.out.print((Integer)lineNoIter.next() + " "); Sistema.out.println();
} }


Ejemplo 93: Una clase que implementa comparable
Un objeto Hora representa la hora del día entre 00:00 y 23:59. La llamada al método t1.compareTo(t2) devuelve un número negativo si t1 es anterior a t2, un número positivo si t1 es posterior a t2 y cero si son al mismo tiempo. Los métodos compareTo, equals y hashCode satisfacen los requisitos de la sección 20.8.

clase Tiempo implementa Comparable {privado int hh, mm; // Reloj de 24 horas
Tiempo público (int hh, int mm) { this.hh = hh; esto.mm = mm; }



public int compareTo(Objeto o) { Tiempo t = (Tiempo)o;
devolver hh != t.hh ? hh - t.hh : mm - t.mm;

}



booleano público es igual (Objeto o) {

Tiempo t = (Tiempo)o;
return hh == t.hh && mm == t.mm;
}
public int hashCode() { return 60 * hh + mm; }
}

Las colecciones de clases de servicios públicos
Las colecciones de clases proporcionan métodos de utilidad estáticos. Los métodos binarioSearch, max, min y sort.
También tenemos versiones que toman un argumento Comparador adicional y lo usan para comparar elementos.
Existen métodos estáticos similares a sincronizadoList y unmodifiableList para crear una vista sincronizada o no modificable (sección 20.1) de una Colección, Conjunto, SortedSet, Mapa o SortedMap.
static int binarioSearch(List lst, Object k) devuelve un índice i>=0 para el cual lst.get(i) es igual a k, si corresponde; de lo contrario, devuelve i<0 de modo que (-i-1) sería la posición adecuada para k. Esto es rápido para ArrayList pero lento para LinkedList. La lista lista debe estar ordenada, como por clasificación (lst).
La copia vacía estática (List dst, List src) agrega todos los elementos de src a dst, en orden.
La enumeración de enumeración estática (coll de colección) devuelve una enumeración sobre coll.
relleno vacío estático (Lista lst, Objeto o) establece todos los elementos de lst en o.
static Object max(Collection coll) devuelve el mayor elemento de coll. Lanza NoSuchElementException si coll está vacío.
static Object min(Collection coll) devuelve el menor elemento de coll. Lanza NoSuchElementException si coll está vacío.
Lista estática nCopies(int n, Object o) devuelve una lista no modificable con n copias de
o.
static void reverse(List lst) invierte el orden de los elementos en lst.
static Comparator reverseOrder() devuelve un comparador que es el inverso del orden natural implementado por el método compareTo de elementos o claves.
static void shuffle (List lst) permuta aleatoriamente los elementos de lst.
static boolean replaceAl(List lst, Object o1, Object o2) reemplaza todos los elementos iguales a o1 por o2 en lst; devuelve verdadero si se reemplazó un elemento.
static void rotar (Lista lista, int d) gira la lista a la derecha en d posiciones, por lo que -1
gira una posición hacia la izquierda. Gira una sublista si se aplica a una vista de sublista (sección 20.2).
static void shuffle(List lst, Random rnd) permuta aleatoriamente los elementos de
Por último estoy usando rnd para generar números aleatorios.
static Set singleton(Object o) devuelve un conjunto no modificable que contiene solo o.
Lista estática singletonList(Object o) devuelve una lista no modificable que contiene solo o.
static Map singletonMap(Object k, Object v) devuelve un mapa no modificable que contiene solo la entrada (k, v).
Lista estática lista sincronizada (Lista lst) devuelve una vista sincronizada de lst.
static void sort(List lst) ordena lst usando mergesort y el ordenamiento natural de elementos. Esto es rápido en todas las listas.
static void swap(List lst, int i, int j) intercambia los elementos de la lista en las posiciones i y j. Lanza IndexOutOfBoundsException a menos que 0 <= i, j and i, j
< lst.tamaño().
Lista estática unmodifiableList(List lst) devuelve una vista no modificable de lst.
Ejemplo 94: Establecer prueba de membresía usando HashSet o búsqueda binaria
Imagine que queremos excluir los nombres reservados de Java (capítulo 2) de la concordancia creada en el ejemplo 89, por lo que necesitamos una forma rápida de reconocer dichos nombres. El método isKeyword1 usa un HashSet creado a partir de una matriz de 52 elementos de palabras clave Java, mientras que el método isKeyword2 usa una búsqueda binaria en la matriz ordenada. El HashSet es en este caso de dos a cinco veces más rápido.

clase Establecer membresía {

cadena estática final [] matriz de palabras clave =

{ "resumen", "afirmar", "booleano", "romper", "byte", ..., "mientras" };

palabras clave estáticas finales = new HashSet(Arrays.asList(keywordarray));



booleano estático esPalabraClave1 (ID de cadena)

{ return palabras clave.contiene(id); }



booleano estático isKeyword2 (ID de cadena)
{ return Arrays.binarySearch(keywordarray, id) >= 0; }
}


Ejemplo 95: un comparador de cadenas explícito
La concordancia producida en el ejemplo 89 utiliza el método compareTo integrado de String, que ordena todas las letras mayúsculas antes que todas las minúsculas. Por lo tanto, colocaría la cadena "Crear" antes de "agregar" antes de "crear". La clase Comparador declarada aquí es mejor porque ordena las cadenas para que aparezcan una al lado de la otra si difieren.ffer solo en caso de que: pondría "agregar" antes de "Crear" antes de "crear". Para usarlo en el ejemplo 89, el nuevo TreeMap() en ese ejemplo debe reemplazarse por el nuevo TreeMap(nuevo IgnoreCaseComparator()).

clase IgnoreCaseComparator implementa Comparador { public int comparar(Objeto o1, Objeto o2) {
Cadena sl = (Cadena)o1, s2 = (Cadena)o2; int res = s1.compareToIgnoreCase(s2); si (res! = 0)
devolver resolución; demás
devolver s1.compareTo(s2);

} }


Ejemplo 96: Obtención de un submapa
Una agenda es un mapa ordenado cuyas claves son objetos de tiempo (ejemplo 93). Podemos extraer esa parte de la agenda que se refiere a las horas a partir de las 12:00:00:

Agenda SortedMap = new TreeMap(); // Mapa de hora a cadena datebook.put(new Time(12, 30), "Almuerzo");
datebook.put(new Time(15, 30), "Pausa para el café de la tarde"); agenda.put(nueva Hora( 9, 0), "Conferencia"); datebook.put(new Time(13, 15), "Reunión de la junta directiva"); SortedMap pm = agenda.tailMap(nueva hora(12, 0)); Iterador iter = pm.entrySet().iterator();

mientras (iter.hasNext()) {

Map.Entry entrada = (Map.Entry)iter.next(); System.out.println((Time)entry.getKey() + " " + (String)entry.getValue());
}


Elegir la clase de colección o clase de mapa adecuada
La elección adecuada de una colección o clase de mapa depende de las operaciones que necesita realizar en ella y de la frecuencia de esas operaciones. No existe una mejor opción universal.
Se deben utilizar LinkedList (sección 20.2) o ArrayList (sección 20.2 y ejemplo 90) para recopilar elementos para iteración secuencial en orden de índice, permitiendo duplicados.
HashSet (sección 20.3 y ejemplo 94) y HashMap (sección 20.5 y ejemplo 90) son buenas opciones predeterminadas cuando se necesita acceso aleatorio por elemento o clave, y no se necesita acceso secuencial en orden de elementos o claves. LinkedHashSet y LinkedHashMap garantizan adicionalmente el acceso secuencial (utilizando sus iteradores) en el orden de inserción de elementos o claves.
TreeSet (sección 20.4 y ejemplo 89) o TreeMap (sección 20.6 y ejemplo 89) deben usarse para acceso aleatorio por elemento o clave, así como para iteración en orden de elemento o clave.
LinkedList, no ArrayList, debe usarse para algoritmos de listas de trabajo (ejemplo 97), colas, colas de doble extremo y pilas.
Ejemplo 97: un algoritmo de lista de trabajo
Algunos algoritmos utilizan la llamada lista de trabajo, que contiene subproblemas aún por resolver. Por ejemplo, dado un conjunto SS de conjuntos de enteros, calcule su cierre de intersección, es decir, el conjunto mínimo TT tal que SS sea un subconjunto de TT y tal que para dos conjuntos cualesquiera T1 y T2 en TT, su intersección T1 ⋂ T2 también está en TT. Por ejemplo, si SS es {{2,3},{1,3},{1,2}}, entonces TT es
{{2,3},{1,3},{1,2},{3},{2},{1},{}}.
El conjunto TT se puede calcular poniendo todos los elementos de SS en una lista de trabajo, luego seleccionando repetidamente un elemento S de la lista de trabajo, agregándolo a TT, y para cada conjunto T que ya está en TT, agregando la intersección de S y T a la lista de trabajo. si aún no está en TT. Cuando la lista de trabajo está vacía, TT está cerrada por la intersección.
El cierre épsilon de un estado de un autómata finito no determinista (NFA) se puede calcular utilizando el mismo enfoque; consulte el texto completo del programa subyacente al ejemplo 98.
estático Establecer intersecciónCerrar(Establecer SS) { Lista de trabajo LinkedList = nueva LinkedList(SS); Establecer TT = nuevo Hashset();
mientras (!lista de trabajo.isEmpty()) {
Establecer S = (Establecer)lista de trabajo.removeLast(); Iterador TTIter = TT.iterador();
mientras (TTIter.hasNext()) {
Establecer TS = nuevo TreeSet((Set)TTIter.next()); TS.retenerTodo(S); // Intersección de T y S if (!TT.contains(TS))
lista de trabajo.add(TS);
} TT.añadir(S);

}
volver TT;
}

ArrayList, no LinkedList, debe usarse para acceso aleatorio get(i) o set(i, o) por índice.
HashSet o HashMap deben usarse para conjuntos o mapas cuyos elementos o claves son colecciones, porque las clases de colección implementan métodos hashCode útiles (ejemplo 98).
Ejemplo 98: Uso de conjuntos como claves en un HashMap
El algoritmo estándar para convertir un autómata finito no determinista (NFA) en un autómata finito determinista (DFA) crea estados de autómata compuestos que son conjuntos de números enteros. Es preferible sustituir dichos estados compuestos por números enteros simples. Este método toma como argumento una colección de estados compuestos y devuelve un renombrador, que es un mapa de nombres de estados compuestos (Conjuntos de enteros) a nombres de estados simples (Enteros).
Mapa estático mkRenamer (estados de colección) { Renombrador del mapa = new HashMap();
Iterador iter = estados.iterador(); mientras (iter.hasNext()) {
Establecer k = (Establecer)iter.next();
renamer.put(k, nuevo entero(renamer.size()));
}
cambio de nombre de retorno;
}

Para mapas cuyas claves son pequeños enteros no negativos, utilice matrices ordinarias (capítulo 8).
El tiempo de ejecución o la complejidad temporal de una operación en una colección generalmente se da en notación O, como función del tamaño n de la colección. Así, O(1) significa tiempo constante, O(logn) significa tiempo logarítmico (tiempo proporcional al logaritmo de n) y O(n) significa tiempo lineal (tiempo proporcional a n). Para acceder, agregar o eliminar un elemento, estos corresponden aproximadamente a muy rápido, rápido y lento.
En la siguiente tabla, n es el número de elementos de la colección, i es un índice entero y d esla distancia desde un índice i hasta el extremo más cercano de una lista, es decir, min(i,n-i). Por lo tanto, agregar o eliminar un elemento de una LinkedList es rápido cerca de ambos extremos de la lista, donde d es pequeño, pero para una ArrayList es rápido solo cerca del final, donde n-i es pequeño. El subíndice a indica complejidad amortizada: en una larga secuencia de operaciones, el tiempo promedio por operación es O(1), aunque cualquier operación individual podría tomar un tiempo O(n).


Capítulo 21: Entrada y salida
Descripción general
La entrada y salida secuencial utiliza objetos llamados flujos. Hay dos tipos de flujos: flujos de caracteres y flujos de bytes, también llamados flujos de texto y flujos binarios. Los flujos de caracteres se utilizan para la entrada de archivos de texto y la salida legible por humanos a archivos de texto, impresoras, etc., utilizando caracteres Unicode de 16 bits. Los flujos de bytes se utilizan para la entrada y salida compacta y eficiente de datos primitivos (int, double, ...), así como de objetos y matrices, en formato legible por máquina.
Hay clases separadas para manejar flujos de caracteres y flujos de bytes. Las clases para la entrada y salida de caracteres se denominan Lectores y Escritores. Las clases para entrada y salida de bytes se denominan InputStreams y OutputStreams. Este capítulo describe la entrada y salida utilizando el paquete java.io. Java 2, versión 1.4, proporciona funciones adicionales en el paquete java.nio, que no se describen aquí.
Se pueden crear subclases de las clases de flujo, anulando los métodos heredados para obtener clases de flujo especializadas. No discutiremos más cómo hacerlo aquí.
Las cuatro jerarquías de clases de flujo se muestran en la siguiente tabla, y las clases de entrada y salida relacionadas se muestran en la misma línea. La tabla muestra, por ejemplo, que BufferedReader y FilterReader son subclases de Reader y que LineNumberReader es una subclase de BufferedReader. Las clases de resúmenes se muestran en cursiva.

Las clases DataInputStream, ObjectInputStream y RandomAccessFile implementan la interfaz Datalnput, y las clases DataOutputStream, ObjectOutputStream y RandomAccessFile implementan la interfaz DataOutput (sección 21.10).
La clase ObjectInputStream implementa la interfaz ObjectInput y la clase ObjectOutputStream implementa la interfaz ObjectOutput (sección 21.11).


Crear transmisiones a partir de otras transmisiones
Una secuencia se puede crear directamente (por ejemplo, se puede crear un FileInputStream y asociarlo con un archivo con nombre en el disco, para leerlo desde ese archivo) o se puede crear a partir de una secuencia existente para proporcionar funciones adicionales (por ejemplo, se puede crear un BufferedInputStream). creado en términos de FileInputStream, para una entrada más eficiente). En cualquier caso, un flujo de entrada o un lector tiene una fuente subyacente de datos para leer, y un flujo de salida o un escritor tiene un sumidero de datos subyacente para escribir. La siguiente figura muestra cómo se pueden definir los flujos en términos de flujos existentes o en términos de otros datos.
Las clases de flujo se dividen en dos líneas: flujos de caracteres (arriba) frente a flujos de bytes (abajo) y flujos de entrada (izquierda) frente a flujos de salida (derecha). Las flechas muestran qué secuencias se pueden crear a partir de otras secuencias. Por ejemplo, la flecha de InputStream a InputStreamReader muestra que se puede crear un InputStreamReader a partir de un InputStream. La flecha de Reader a BufferedReader muestra que se puede crear un BufferedReader a partir de un Reader. Dado que un InputStreamReader es un lector, se puede crear un BufferedReader a partir de un InputStream existente (como System.in) en dos pasos, como se muestra en el ejemplo 99. Por otro lado, no hay forma de crear un PipedOutputStream a partir de un archivo o un nombre de archivo; Se debe crear un PipedOutputStream directamente, o a partir de un PipedInputStream existente, y de manera similar para otras tuberías (sección 21.15).
Ejemplo 99: Un ejemplo completo de entrada y salida

importar java.io.*;

clase Ejemplo BásicoIO {

public static void main (String[] args) lanza IOException {

BufferedReader r = nuevo BufferedReader (nuevo InputStreamReader (System.in)); recuento int = 0;
Cadena s = r.readLine();
while (s != null && !s.equals ("")) { recuento++;
s = r.readLine();
}
System.out.println("Ingresó " + recuento + "líneas no vacías");
} }




Tipos de métodos de entrada y salida
La siguiente tabla resume las convenciones de nomenclatura para los métodos de las clases de entrada y salida, así como sus características principales, como su comportamiento al final del flujo.

Importaciones, excepciones, seguridad de subprocesos
Un programa que utiliza las clases de entrada y salida debe contener la declaración de importación import java.io.*;
La mayoría de las operaciones de entrada y salida pueden generar una excepción de la clase IOException o una de sus subclases, todas las cuales son excepciones verificadas (capítulo 14). Por lo tanto, un método que realiza entrada o salida debe hacerlo en un bloque try-catch (sección 12.6.6) o debe contener la declaración throws IOException (sección 9.8).
La implementación estándar de entrada-salida es segura para subprocesos: múltiples subprocesos simultáneos (capítulo 15) pueden leer o escribir de forma segura en el mismo flujo sin corromperlo. Sin embargo, la documentación de la biblioteca de clases Java no es explícita sobre este punto, por lo que probablementeDeberíamos evitar usar la misma secuencia de múltiples subprocesos o sincronizar explícitamente en la secuencia.
Ejemplo 100: Entrada-Salida: Doce ejemplos en uno

Este ejemplo ilustra la entrada y salida con archivos de texto legibles por humanos; entrada y salida de valores primitivos con archivos binarios; entrada y salida de arrays y objetos con archivos binarios; entrada y salida de valores primitivos con archivos binarios de acceso aleatorio; entrada y salida utilizando cadenas y buffers de cadenas; salida a salida estándar y error estándar; y entrada desde entrada estándar.
Aunque estos breves ejemplos no utilizan el almacenamiento en búfer, la entrada y salida de archivos, sockets, etc., deben utilizar el almacenamiento en búfer para mayor eficiencia (sección 21.12).

// Escribe números y palabras en el archivo "f.txt" en formato legible por humanos: PrintWriter pwr = new PrintWriter(new FileWriter("f.txt")); pwr.print(4711); pwr.print(' '); pwr.print("genial"); pwr.cerrar();
// Lee números y palabras del archivo de texto legible por humanos "f.txt": StreamTokenizer stok = new StreamTokenizer(new FileReader("f.txt")); int tok = stok.nextToken();
mientras (tok! = StreamTokenizer.TT_EOF)

{ System.out.println(stok.sval); tok = stok.nextToken (); }

// Escribe valores primitivos en un archivo binario "p.dat":

DataOutputStream dos = new DataOutputStream(new FileOutputStream("p.dat")); dos.writeInt(4711); dos.writeChar(' '); dos.writeUTF("genial"); dos.cerrar();
// Leer valores primitivos del archivo binario "p.dat":

DataInputStream dis = nuevo DataInputStream(nuevo FileInputStream("p.dat")); System.out.println(dis.readInt()+"|"+dis.readChar()+"|"+ dis.readUTF());
// Escribe un objeto o matriz en el archivo binario "o.dat":

ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("o.dat")); oos.writeObject(nuevo int[] { 2, 3, 5, 7, 11 }); oos.cerrar();
// Leer objetos o matrices del archivo binario "o.dat":

ObjectInputStream ois = new ObjectInputStream(new FileInputStream("o.dat")); int[] ia = (int[])(ois.readObject());

System.out.println(ia[0]+","+ia[1]+","+ia[2]+","+ia[3]+","+ia[4]);

// Lee y escribe partes del archivo "raf.dat" en orden arbitrario:

RandomAccessFile raf = new RandomAccessFile("raf.dat", "rw"); raf.writeDouble(3.1415); raf.writeInt(42);
raf.seek(0); System.out.println(raf.readDouble() + " " + raf.readInt());

// Lee desde un String s como si fuera un archivo de texto:

Lector r = nuevo StringReader("abc");

System.out.println("abc: " + (char)r.read() + (char)r.read() + (char)r.read());

// Escribe en un StringBuffer como si fuera un archivo de texto:

Escritor sw = nuevo StringWriter(); sw.write('d'); sw.write('e'); sw.write('f'); System.out.println(sw.toString());
// Escribe caracteres en salida estándar y error estándar:

System.out.println("salida estándar"); System.err.println("error estándar");

// Leer caracteres de la entrada estándar (el teclado):

System.out.print("Escriba algunos caracteres y presione Enter: ");

BufferedReader bisr = nuevo BufferedReader (nuevo InputStreamReader (System.in)); Respuesta de cadena = bisr.readLine();
System.out.println("Escribiste: '" + respuesta + "'");

// Lee un byte de la entrada estándar (el teclado):

System.out.print("Escriba un carácter y presione Enter: "); byte b = (byte)System.in.read();
System.out.println("El primer byte de su entrada es: " + b);


Entrada secuencial de caracteres: lectores
La clase abstracta Reader y sus subclases (todas con nombres que terminan en Reader) se utilizan para la entrada secuencial orientada a caracteres. Además de las clases que se muestran aquí, consulte BufferedReader (sección 21.12) y LineNumber-Reader (ejemplo 105). La clase Reader tiene los siguientes métodos:
void close() vacía y cierra la secuencia y cualquier secuencia subyacente. Cualquier operación posterior, excepto cerrar, generará IOException.
void mark(int limt) marca la posición de entrada actual, permitiendo al menos limt
caracteres que se leerán antes de llamar a restablecer.
boolean markSupported() es verdadero si el lector admite la configuración de marcas y el restablecimiento a la última marca.
int read() lee un carácter (con código 0... 65535) y lo devuelve. Se bloquea hasta que la entrada esté disponible, o se alcance el final de la secuencia (y luego devuelva -1), o se produzca un error (y luego genere IOException).

int read(char[] b) lee como máximo caracteres b.length en b y devuelve el número de caracteres leídos. Devuelve inmediatamente si b.length es 0; de lo contrario, se bloquea hasta que al menos un carácter esté disponible; devuelve -1 al final de la transmisión.
int read(char[] b, int i, int n) funciona como el anterior, pero se lee en buf[i..(i+n-1)]. Lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.
boolean ready() devuelve verdadero si la siguiente lectura u omisión no se bloquea.
void reset() restablece la secuencia a la posición de la última llamada a marcar.
int skip (int n) omite como máximo n caracteres y devuelve el número de caracteres omitidos; devuelve 0 al final de la transmisión.

Lectura de caracteres de una secuencia de bytes: InputStreamReader
Un InputStreamReader es un lector (un flujo de entrada de caracteres) que lee un flujo de entrada de bytes y ensambla bytes en caracteres mediante una codificación de caracteres. Realiza una entrada almacenada en búfer desde el flujo subyacente. Un InputStreamReader tiene la sAlgunos métodos como Lector (sección 21.4), y también este constructor y método:
InputStreamReader(InputStream is) crea un flujo de entrada de caracteres (un lector) a partir del flujo de entrada de bytes, utilizando la codificación de caracteres estándar de la plataforma.
String getEncoding() devuelve el nombre canónico de la codificación de caracteres utilizada por este InputStreamReader, por ejemplo, "IS08859_1" o "Cp1252".

Entrada secuencial de caracteres desde un archivo: FileReader
Un FileReader es un flujo de entrada de caracteres almacenado en búfer asociado con un archivo (secuencial) y equivalente a un InputStreamReader creado a partir de un FileInputStream. Tiene los mismos métodos que InputStreamReader y estos constructores:
FileReader (nombre de cadena) crea un flujo de entrada de caracteres asociado con el archivo nombrado en el sistema de archivos. Lanza FileNotFoundException si el archivo nombrado no existe, es un directorio o no se puede abrir por algún otro motivo.
FileReader (archivo de archivo) crea una secuencia de entrada de caracteres a partir del archivo dado en el sistema de archivos.
FileReader (FileDescriptor fd) crea un flujo de entrada de caracteres a partir del descriptor de archivo.


Salida de caracteres secuenciales: escritores
La clase abstracta Writer y sus subclases (todas con nombres que terminan en Writer) se utilizan para salida secuencial orientada a caracteres. Tienen los siguientes métodos:
void close() vacía y cierra la secuencia.
void Flush() en realidad escribe datos en la secuencia o archivo subyacente y luego los vacía.
escritura vacía (char[] b) escribe el contenido de la matriz de caracteres b.
escritura vacía (char[] b, int i, int n) escribe n caracteres desde b comenzando en la posición
i; lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.
void write (int c) escribe un solo carácter, es decir, los dos bytes de orden inferior de c.
escritura nula (String s) escribe la cadena s.
escritura nula (String s, int i, int n) escribe n caracteres desde s comenzando en la posición
i; lanza StringIndexOutOfBoundsException si i<0 o n<0 o i+n>s.length.
Escribir caracteres en una secuencia de bytes: OutputStreamWriter
Un OutputStreamWriter es un escritor (flujo de salida de caracteres) que escribe en un flujo de salida de bytes, convirtiendo caracteres en bytes mediante una codificación de caracteres. Realiza una salida almacenada en búfer al flujo subyacente. Un OutputStreamWriter tiene los mismos métodos que un Writer (sección 21.5), y además estos constructores y método:
OutputStreamWriter (OutputStream os) crea un OutputStream Writer que escribe en el sistema operativo de transmisión utilizando la codificación de caracteres predeterminada de la plataforma.
OutputStreamWriter (OutputStream os, String enc) crea un OutputStreamWriter que escribe en el sistema operativo de transmisión utilizando la codificación de caracteres especificada por enc.

String getEncoding() devuelve el nombre canónico de la codificación de caracteres utilizada por este OutputStreamWriter, por ejemplo, "IS08859_1" o "Cp1252".

Salida secuencial de caracteres a un archivo: FileWriter
Un FileWriter es un flujo de salida de caracteres almacenado en búfer asociado con un archivo (secuencial), equivalente a un OutputStreamWriter creado a partir de un FileOutputStream. Tiene los mismos métodos que OutputStreamWriter y estos constructores:
FileWriter (nombre de cadena) crea un flujo de salida de caracteres y lo asocia con el archivo nombrado en el sistema de archivos. Si el archivo existe, lo trunca; de lo contrario, intenta crear un nuevo archivo vacío. Lanza FileNotFoundException si el archivo nombrado es un directorio o no se puede abrir o crear por algún otro motivo.
FileWriter (archivo de cadena, anexo booleano) funciona como el método anterior, pero si agregar es verdadero, no trunca el archivo: en lugar de eso, la salida se agregará al contenido del archivo existente.
FileWriter (archivo) funciona como el método anterior, pero crea el escritor a partir del archivo.
FileWriter (FileDescriptor fd) funciona como el método anterior, pero crea el escritor a partir de fd.


Impresión de datos primitivos en una secuencia de caracteres: PrintWriter
La clase PrintWriter se utiliza para generar datos primitivos en archivos de texto en formato legible por humanos. A diferencia de los métodos de otros escritores, los de PrintWriter nunca arrojan IOException sino que establecen el estado de error. La clase PrintWriter tiene todos los métodos de Writer y además estos constructores y métodos:
PrintWriter(OutputStream os) crea un PrintWriter que imprime en el sistema operativo de transmisión, sin autoflush.
PrintWriter(OutputStream os, boolean flush) crea un PrintWriter que imprime en el sistema operativo de flujo de salida; si vaciar es verdadero, entonces vacía al escritor después de cada llamada a println.
PrintWriter(Writer wr) crea un PrintWriter que imprime en el escritor wr, sin autoflush.
PrintWriter(Writer wr, boolean flush) crea un PrintWriter que imprime en el escritor wr; si vaciar es verdadero, entonces vacía al escritor después de cada llamada a println.
boolean checkError() vacía la secuencia y luego devuelve verdadero si alguna vez ocurrió un error.
void print (boolean b) imprime el booleano b, es decir, verdadero o falso.
void print (char c) imprime el carácter c.
void print (char[] s) imprime los caracteres en s.
void print (doble d) imprime la doble d.
void print (float f) imprime el float f.
void print (int i) imprime el número entero i.
impresión vacía (largal) imprime el número entero largo l.
void print (Object obj) imprime el objeto usando obj.toString().
void print (String s) imprime la cadena s.
void println() imprime una sola nueva línea.
void println(e) funciona como print (e) seguido de println ().

Salida estándar: System.out y System.err son PrintStreams
El flujo de salida estándar System.out y el flujo de error estándar System.err son PrintStreams. PrintStream es una subclase de OutputStream pero además tiene métodos print y println para salida basada en caracteres, al igual que PrintWriter. Estos métodos convierten caracteres a bytes utilizando la codificación predeterminada; para usar otra codificación enc, escriba en su lugar en un PrintWriter creado por new PrintWriter(new OutputStreamWriter(System.out), enc). Los métodos de PrintStream nunca arrojan IOException, pero establecen el estado de error; utilice checkError() para probar el estado del error.

Formato de números para salida de caracteres: formato decimal
El diseño adecuado del texto impreso con PrintWriter requiere un control de formato detallado. El formato de los números se puede controlar utilizando la clase DecimalFormat del paquete java.text. La tabla de la página opuesta muestra algunos patrones de formato decimal y sus efectos.
Hay muchas otras funciones para formatear la salida de texto en el paquete java.text. A diferencia de lenguajes como C, C#, Fortran y Pascal, Java no tiene un mecanismo estándar para alinear números y palabras en columnas. Estos mecanismos producen el resultado deseado sólo con fuentes de paso fijo. En el ejemplo 103 se muestra un método sencillo para rellenar una cadena a la izquierda (para alineación a la derecha).
Ejemplo 101: Imprimir números en un archivo de texto
Simule 1000 tiradas de un dado e imprima el resultado en el archivo de texto dice.txt, 20 números por línea:
PrintWriter pw = nuevo PrintWriter(nuevo FileWriter("dice.txt")); para (int i=1; i<=1000; i++) {
int morir = (int)(1 + 6 * Math.random());
pw.print(morir); pw.print(' ');
si (yo % 20 == 0) pw.println();
}
pw.println();
pw.cerrar(); // Sin esto, el archivo de salida puede estar vacío


Ejemplo 102: Imprimir una tabla HTML
Este ejemplo genera una tabla de conversión de temperatura en HTML. La temperatura Fahrenheit f
corresponde a la temperatura Celsius c = 5•(f - 32)/9. El número de dígitos fraccionarios está controlado por un objeto DecimalFormat. La etiqueta HTML TABLE se utiliza para controlar la alineación de números en columnas.

PrintWriter pw = nuevo PrintWriter(nuevo FileWriter("temperatura.html"));
DecimalFormat ff = nuevo formato Decimal("#0"), cf = nuevo formato Decimal("0.0"); pw.println("<TABLE BORDER><TR><TH>Fahrenheit<TH>Celsius</TR>"); para (doble f=100; f<=400; f+=10) {
doble c = 5 * (f - 32) / 9;
pw.println("<TR ALIGN=RIGHT><TD>" + ff.format(f) + "<TD>" + cf.format(c));
}
pw.println("</TABLE>");
pw.cerrar(); // Sin esto, el archivo de salida puede estar vacío


Ejemplo 103: Imprimir una tabla de texto
Para imprimir una tabla de conversión en formato de texto en una fuente de paso fijo, reemplace la segunda llamada a pw.println en el ejemplo 102 por pw.println(padLeft(ff.format(f), 10) + padLeft(cf.format(c) , 10)), que utiliza el método padLeft del ejemplo 87 para alinear números a la derecha.

Algunos patrones de formato decimal y su efecto




Lectura de datos primitivos de una secuencia de caracteres: StreamTokenizer
Leer palabras y números de una secuencia de caracteres es más complicado que imprimirlos, por lo que no existe una contraparte de entrada de texto para PrintWriter. En su lugar, cree un StreamTokenizer desde un Reader.
Un StreamTokenizer recopila caracteres en tokens. Los caracteres se clasifican como espacios en blanco (que separan fichas), caracteres numéricos (que forman una ficha numérica), caracteres de palabras (que forman una ficha de palabra),

comillas (que delimitan un token de cadena), caracteres de comentario de final de línea (que inician un comentario que se extiende hasta el final de línea) o caracteres comunes (ninguno de los anteriores).
Se puede crear y configurar un StreamTokenizer utilizando este constructor y estos métodos y campos:
StreamTokenizer (Reader r) crea un StreamTokenizer que lee desde la secuencia r.
void commentChar (int ch) le dice al tokenizador que ch es un carácter de comentario de final de línea.
void eolIsSignificant (boolean b) le dice al tokenizador que considere la nueva línea como un token separado de tipo TT_EOL, no como un espacio en blanco, si b es verdadero.
void ordinariaChars (int c1, int c2) le dice al tokenizador que cualquier carácter en el rango c1..c2 (inclusive) es un carácter ordinario: un token de un solo carácter, con ttype establecido en el código del carácter.
void parseNumbers() le dice al tokenizador que reconozca tokens numéricos. Una ficha numérica es una "palabra" que comienza con un dígito decimal (0..9) o un punto decimal (.) o un signo menos (-), y que consta únicamente de estos tres tipos de caracteres, por lo que los números en notación científica 6.02 e23 no se reconocen. Un token numérico tiene el tipo TT_NUMBER.
void quoteChar(int ch) le dice al tokenizador que el carácter ch es un delimitador de cadena. Cuando se encuentra este carácter, ttype se establece en ch y sval se establece en el contenido de la cadena: los caracteres estrictamente entre ch y la siguiente aparición de ch, nueva línea o fin de secuencia.
void resetSyntax() hace que todos los caracteres sean normales; ver ordinarioChars.
void whitespaceChars (int c1, int c2) le dice al tokenizador que todos los caracteres en el rango c1..c2 (inclusive) también son espacios en blanco, es decir, separadores de tokens.
void wordChars (int c1, int c2) le dice al tokenizador que todos los caracteres en el rango
c1..c2 (inclusive) también son caracteres de palabras.
Class StreamTokenizer tiene estos métodos y campos para leer valores:
int lineno() devuelve el número de línea actual, contando desde 1.
int nextToken() lee el siguiente (o primer) token y devuelve su tipo.
double nval es el valor numérico del token numérico actual (cuando ttype es
TT_NÚMERO).
String sval es el valor de cadena del token de palabra actual (cuando ttype es TT_WORD), o el cuerpo de la cadena del token de cadena actual (cuando ttype es un carácter de comillas).
int ttype es el tipo de token actual. El tipo puede ser StreamTokenizer.TT_NUMBER, que indica un número, o StreamTokenizer.TT_WORD, que indica una palabra, o StreamTokenizer.TT_EOL, que indica una nueva línea, o StreamTokenizer.TT_EOF, que indica el final de la transmisión (no más tokens), o una cita. carácter, que indica una cadena (entre comillas), o cualquier otro carácter, que indica ese carácter como un token en sí mismo.
Si bien un StreamTokenizer es útil para leer archivos de texto bastante simples, los archivos de texto más estructurados deben leerse utilizando un lexer y analizador adecuado (consulte los libros de texto comunes para cursos de compilación) o bibliotecas de propósito especial (por ejemplo, para archivos XML o flujos XML).
Ejemplo 104: leer números de un archivo de texto
Se crea un stok StreamTokenizer a partir de un lector de archivos almacenado en búfer y se le indica que reconozca tokens numéricos. Los tokens se leen hasta el final del flujo y los tokens numéricos se suman, mientras que los tokens no numéricos se imprimen en la salida estándar. El almacenamiento en búfer es importante: hace que el programa sea más de 20 veces más rápido.

archivo de suma vacío estático (nombre de archivo de cadena) lanza IOException { Reader r = new BufferedReader (new FileReader (nombre de archivo)); StreamTokenizer stok = nuevo StreamTokenizer(r); stok.parseNumbers();
doble suma = 0; stok.nextToken() ;

mientras (stok.ttype != StreamTokenizer.TT_EOF) {

if (stok.ttype == StreamTokenizer.TT_NUMBER) suma += stok.nval;
demás

System.out.println("No número: " + stok.sval); stok.nextToken();
}

System.out.println("La suma del archivo es " + suma);

}


Ejemplo 105: Leer números de un archivo de texto, línea por línea
Se crea un stok StreamTokenizer a partir de un LineNumberReader y se le dice que reconozca tokens numéricos y nuevas líneas. Los tokens se leen hasta el final de la transmisión y la suma del número de tokens se calcula línea por línea. El número de línea está configurado para contar desde 1 (el valor predeterminado es 0). La clase LineNumberReader es una subclase de BufferedReader y, por lo tanto, ya está almacenada en el búfer. Usar un LineNumberReader es algo redundante, ya que el propio StreamTokenizer proporciona un método lineno().
líneas de suma vacías estáticas (nombre de archivo de cadena) lanza IOException {

LineNumberReader lnr = nuevo LineNumberReader (nuevo FileReader (nombre de archivo)); lnr.setLineNumber(1);
StreamTokenizer stok = nuevo StreamTokenizer(lnr); stok.parseNumbers();
stok.eolIsSignificant(verdadero); stok.nextToken();
while (stok.ttype != StreamTokenizer.TT_EOF) { int lineno = lnr.getLineNumber();
doble suma = 0;

mientras (stok.ttype! = StreamTokenizer.TT_EOL) {

if (stok.ttype == StreamTokenizer.TT_NUMBER) suma += stok.nval;
stok.nextToken();

}

System.out.println("La suma de la línea " + lineno + " es " + suma); stok.nextToken();
}

}

Entrada de bytes secuenciales: InputStream
La clase abstracta InputStream y sus subclases (cuyos nombres terminan en InputStream) se utilizan para la entrada secuencial orientada a bytes. Tienen los siguientes métodos:
int disponible() devuelve el número de bytes que se pueden leer u omitir sin bloquear.
void close() cierra la transmisión.
void mark(int limt) marca la posición de entrada actual, lo que permite leer al menos limt bytes antes de llamar a reset.
boolean markSupported() devuelve verdadero si la secuencia admite marcar y restablecer.
int read() lee un byte (0...255) y lo devuelve, bloqueándolo hasta que la entrada esté disponible; devuelve - 1 al final de la transmisión.
int read (byte[] b) lee como máximo b.length bytes en b, bloqueando hasta que haya al menos un byte disponible; luego devuelve el número de bytes realmente leídos. Devuelve -1 al final de la transmisión.
int read(byte[] b, int i, int n) lee como máximo n bytes en b en la posición i, bloqueando hasta que haya al menos un byte disponible y devuelve el número de bytes realmente leídos. Devuelve -1 al final de la transmisión. Lanza IndexOutOfBoundsException si i<0 o n<0 o
i+n>b. longitud.
void reset() reposiciona la secuencia a la posición en la que se llamó por última vez al método de marca.
long skip (long n) omite como máximo n bytes, se bloquea hasta que hay un byte disponible y devuelve el número de bytes realmente omitidos. Devuelve 0 si se alcanza el final de la secuencia antes de que la entrada esté disponible.
La entrada estándar System.in es un InputStream; para leer caracteres del mismo, cree un InputStreamReader usando el nuevo InputStreamReader (System.in); ver ejemplo 100.

Entrada secuencial de bytes desde archivo: FileInputStream
Un FileInputStream es un InputStream que lee secuencialmente desde un archivo existente en el sistema de archivos.em. Tiene los mismos métodos que InputStream (sección 21.8), y estos constructores y métodos adicionales:
FileInputStream (nombre de cadena) crea un flujo de entrada de bytes y lo asocia con el nombre del archivo en el sistema de archivos. Lanza FileNotFoundException si el archivo no existe, es un directorio o no se puede abrir.
FileInputStream (archivo) funciona como el anterior, pero asocia la secuencia con el archivo.
FileInputStream (FileDescriptor fd) funciona como el anterior, pero asocia la secuencia con fd.
FileDescriptor getFD() devuelve el descriptor de archivo asociado con esta secuencia.

Entrada binaria secuencial de datos primitivos: DataInputStream
La clase DataInputStream proporciona métodos para la entrada binaria secuencial independiente de la máquina de tipos primitivos de Java como int y double. La clase implementa la interfaz DataInput (sección 21.10) y además proporciona este constructor y método estático:
DataInputStream (InputStream es) crea un DataInputStream que lee desde la secuencia.
static String readUTF (DataInput di) lee una cadena codificada en Java UTF-8 de la secuencia di.
La clase DataInputStream también tiene un método readLine, que está en desuso. Para leer líneas de texto de un DataInputStream, cree un InputStreamReader (sección 21.4.1) a partir de él.


Salida de bytes secuenciales: OutputStream
La clase abstracta OutputStream y sus subclases (cuyos nombres terminan en OutputStream) se utilizan para salida secuencial orientada a bytes. Tiene los siguientes métodos:
void close() cierra el flujo de salida.
void flush() vacía el flujo de salida y fuerza que los bytes de salida almacenados en el búfer se escriban en el flujo o archivo subyacente, luego lo vacía.

escritura vacía (byte [] b) escribe b.length bytes de b en el flujo de salida.
escritura vacía (byte[] b, int i, int n) escribe n bytes desde b comenzando en el desplazamiento i en el flujo de salida. Lanza IndexOutOfBoundsException si i<0 o n<0 o i+n>b.length.
void write (int b) escribe el byte b(0...255) en el flujo de salida.

Salida secuencial de bytes a un archivo: FileOutputStream
Un FileOutputStream es un OutputStream que escribe secuencialmente en un archivo en el sistema de archivos. Tiene los mismos métodos que OutputStream (sección 21.9) y estos constructores y un método adicional:
FileOutputStream (nombre de cadena) crea un flujo de salida de bytes y lo asocia con el archivo nombrado en el sistema de archivos. Si el archivo existe, lo trunca; de lo contrario, intenta crear el archivo. Lanza FileNotFoundException si el archivo es un directorio o no se puede abrir o crear por algún otro motivo.
FileOutputStream (nombre de cadena, anexo booleano) funciona como el anterior, pero si agregar es verdadero, no trunca el archivo: en su lugar, la salida se agregará al contenido del archivo existente.
FileOutputStream (archivo) funciona como el anterior, pero asocia la secuencia con el archivo.
FileOutputStream(FileDescriptor fd) funciona como el anterior, pero asocia la secuencia con fd.
FileDescriptor getFD() devuelve el descriptor de archivo asociado con esta secuencia.

Salida binaria secuencial de datos primitivos: DataOutputStream
La clase DataOutputStream proporciona métodos para la salida binaria secuencial independiente de la máquina de tipos primitivos de Java como int y double. La clase implementa la interfaz DataOutput (sección 21.10) y proporciona este constructor y método:
DataOutputStream (OutputStream os) crea un DataOutputStream que escribe en el sistema operativo de flujo.
int size() devuelve el número de bytes escritos en este DataOutputStream.

Entrada-Salida Binaria de Datos Primitivos: DataInput y DataOutput
Las interfaces DataInput y DataOutput describen operaciones para entrada y salida orientada a bytes de valores de tipo primitivo, como booleano, int y double. Por lo tanto, el método readInt() de DataInput es adecuado para leer números enteros escritos utilizando el método writeInt (int) de DataOutput. El formato de datos es independiente de la plataforma.
La interfaz DataInput describe los siguientes métodos. Los métodos de lectura y omisión se bloquean hasta que la cantidad requerida de bytes esté disponible y lanzan una excepción EOFException si se llega primero al final de la secuencia.
boolean readBoolean() lee un byte de entrada y devuelve verdadero si es distinto de cero, falso
de lo contrario.
byte readByte() lee un byte de entrada y devuelve un byte en el rango -128...127.
char readChar() lee dos bytes y devuelve un carácter en el rango 0...65535.
double readDouble() lee ocho bytes y devuelve un doble.
float readFloat() lee cuatro bytes y devuelve un flotante.
void readFully (byte[] b) lee exactamente b.length bytes en el búfer b.
void readFully (byte[] b, int i, int n) lee exactamente n bytes en b[i..(i+n- 1)].
int readInt() lee cuatro bytes y devuelve un número entero.
String readLine() lee una línea de caracteres de un byte en el rango 0...255 (no Unicode).
long readLong() lee ocho bytes y devuelve un número entero largo.
short readShort() lee dos bytes y devuelve un entero corto -32768...32676.
int readUnsignedByte() lee un byte y devuelve un número entero en el rango 0...255.
int readUnsignedShort() lee dos bytes y devuelve un número entero en el rango 0...65535.
Cadena readUTF() lee una cadena codificada utilizando el formato UTF-8 modificado de Java.
int skipBytes(int n) omite exactamente n bytes de datos y devuelve n.

La interfaz DataOutput describe los siguientes métodos. Tenga en cuenta que writeInt (i) escribe cuatro bytes que representan el entero Java i, mientras que write(i) escribe un byte que contiene los ocho bits de orden inferior de i.
void write(byte[] b) escribe todos los bytes de la matriz b.
void write(byte[] b, int i, int n) escribe n bytes de la matriz b[i..(i+n-1)].
void write(int v) escribe los ocho bits de orden inferior del byte v.
void writeBoolean(boolean v) escribe un byte: 1 si v es verdadero, en caso contrario 0.
void writeByte(int v) escribe el byte de orden inferior (ocho bits de orden inferior) del entero v.
void writeBytes(String s) escribe el byte de orden inferior de cada carácter en s (no Unicode).
void writeChar(int v) escribe dos bytes (de orden superior, de orden inferior) que representan v.
void writeChars(String s) escribe la cadena s, dos bytes por carácter.
void writeDouble (doble v) escribe ocho bytes que representan v.
void writeFloat(float v) escribe cuatro bytes que representan v.
void writeInt(int v) escribe cuatro bytes que representan v.
void writeLong (long v) escribe ocho bytes que representan v.
void writeShort(int v) escribe dos bytes que representan v.
void writeUTF(String s) escribe dos bytes de información de longitud (bytes), seguidos de la representación UTF-8 modificada por Java de cada carácter en la cadena s.
Ejemplo 106: Entrada y salida binaria de datos primitivos
El método writedata demuestra todas las formas de escribir datos primitivos en una secuencia DataOutput (una secuencia de clase DataInputStream o RandomAccessFile). De manera similar, el método readdata demuestra todas las formas de leer valores primitivos de una secuencia DataInput (una secuencia de clase DataOutputStream o RandomAccessFile). Los métodos se complementan entre sí, por lo que después de escribir una secuencia con writedata, se puede leer usando readdata.

public static void main (String[] args) lanza IOException {

DataOutputStream daos = new DataOutputStream(new FileOutputStream("tmpl.dat")); escribir datos (daos); daos.cerrar();
DataInputStream dais = new DataInputStream(new FileInputStream("tmp1.dat")); leerdatos(estrado);
RandomAccessFile raf = new RandomAccessFile("tmp2.dat", "rw"); escribir datos (raf); raf.seek(0); leerdatos(raf);
}

static void writedata (Salida de datos) lanza IOException {out.writeBoolean(true); // Escribe 1 byte
salida.writeByte(120); // Escribe 1 byte

out.writeBytes("foo"); // Escribe 3 bytes

out.writeBytes("fo"); // Escribe 2 bytes

out.writeChar('A'); // Escribe 2 bytes

out.writeChars("foo"); // Escribe 6 bytes

out.writeDouble(300.1); // Escribe 8 bytes

out.writeFloat(300.2F); // Escribe 4 bytes

salida.writeInt(1234); // Escribe 4 bytes.writeLong(12345L); // Escribe 8 bytes
out.writeShort(32000); // Escribe 2 bytes

out.writeUTF("foo"); // Escribe 2 + 3 bytes
out.writeUTF("Ródano"); // Escribe 2 + 6 bytes out.writeByte(-1); // Escribe 1 byte
out.writeShort(-1); // Escribe 2 bytes
}
datos de lectura vacíos estáticos (entrada de datos) lanza IOException { byte[] buf1 = nuevo byte[3];
System.out.print( in.readBoolean()); // Leer 1 byte System.out.print(" " + in.readByte()); // Leer 1 byte in.readFully(buf1); // Leer 3 bytes
en.readFully(buf1, 0, 2); // Leer 2 bytes System.out.print(" " + in.readChar()); // Leer 2 bytes System.out.print(" " + in.readChar()+in.readChar()+in.readChar()); System.out.print(" " + in.readDouble()); // Leer 8 bytes System.out.print(" " + in.readFloat()); // Leer 4 bytes System.out.print(" " + in.readInt()); // Leer 4 bytes System.out.print(" " + in.readLong()); // Leer 8 bytes System.out.print(" " + in.readShort()); // Leer 2 bytes System.out.print(" " + in.readUTF()); // Leer 2 + 3 bytes System.out.print(" " + in.readUTF()); // Leer 2 + 6 bytes System.out.print(" " + in.readUnsignedByte()); // Leer 1 byte System.out.print(" " + in.readUnsignedShort()); // Leer 2 bytes System.out.println();
}

Serialización de objetos: ObjectInput y ObjectOutput
Las interfaces ObjectInput y ObjectOutput describen operaciones para entrada y salida orientada a bytes de valores de tipo de referencia, es decir, objetos y matrices. Esto también se llama serialización.
Un objeto o matriz se puede serializar (convertir en una secuencia de bytes) si su clase y todas las clases de las que depende el objeto o matriz se han declarado para implementar la interfaz Serializable. La interfaz Serializable no declara ningún método; sólo sirve para mostrar que la clase admite serialización.
Serialización de un objeto o escribe los campos no estáticos (instancia) del objeto, excepto aquellos declarados transitorios, en la secuencia. Cuando se deserializa el objeto, un campo transitorio obtiene el valor predeterminado para su tipo (falso o 0 o 0.0 o nulo). Los campos de clase (campos estáticos) no están serializados.
La serialización a un ObjectOutputStream preserva el intercambio entre los objetos escritos en él y, de manera más general, preserva la forma del gráfico de referencia del objeto. Por ejemplo, si los objetos o1 y o2 se refieren a un objeto común c (entonces o1.c == o2.c), y o1 y o2 están serializados en ObjectOutputStream oos, entonces el objeto c se serializa solo una vez en oos. Cuando o1 y o2 se restauran nuevamente desde oos, entonces c también se restaura, exactamente una vez, por lo que o1.c == o2.c se mantiene como antes. Si o1 y o2 se serializan en dos ObjectOutputStreams diferentes, entonces la restauración de o1 y o2 producirá dos copias distintas de c, por lo que o1.c ! = o2.c. Por lo tanto, el intercambio entre objetos no se conserva en múltiples ObjectOutputStreams. La interfaz ObjectInput tiene todos los métodos especificados por DataInput y los siguientes adicionales. La clase ObjectInputStream implementa ObjectInput. Los métodos disponibles(), close(), read(byte[]), read(byte[], int, int) y skip(int) se comportan como los de la clase InputStream (sección 21.8).
int disponible() devuelve el número de bytes que se pueden leer u omitir sin bloquear.
void close() cierra la transmisión, como en InputStream.
int read() lee un byte, como en InputStream.
int read(byte[] b) lee bytes en b, como en InputStream.
int read(byte[] b, int i, int n) lee en b[i..(i+n-1)], como en InputStream.

El objeto readObject() lee, deserializa y devuelve un objeto, que debe haber sido serializado previamente. Lanza ClassNotFoundException si no se puede encontrar la declaración (archivo de clase) de un objeto que se está deserializar. Lanza ObjectStreamException o una de sus subclases si no se puede leer ningún objeto de la secuencia, por ejemplo, si se encuentra el final de la secuencia antes de que se complete el objeto.
long skip (long n) salta n bytes, como en InputStream.
La interfaz ObjectOutput tiene todos los métodos de la interfaz DataOutput (sección 21.10) y la siguiente. La clase ObjectOutputStream implementa ObjectOutput.
void writeObject(Object obj) escribe el objeto mediante serialización. Todas las clases que se serializan deben implementar la interfaz Serializable; de lo contrario, se lanza NotSerializableException.
Interface Externalizable es una subinterfaz de Serializable que pueden implementar clases que necesitan control total sobre la serialización y deserialización de sus objetos.
Ejemplo 107: La serialización al mismo ObjectOutputStream conserva el uso compartido
Los objetos o1 y o2 se refieren a un objeto compartido c de clase SC. Serializamos o1 y o2 en el mismo archivo usando un único ObjectOutputStream, por lo que obtenemos una única copia del objeto compartido. Cuando deserializamos los objetos y los vinculamos a las variables o1i y o2i, también obtenemos una única copia del objeto SC compartido:

clase SC implementa Serializable { int ci; } clase SO implementa Serializable {
ent i; SCc;

SO(int i, SC c) { this.i = i; esto.c = c; }

void cprint() { System.out.print("i" + i + "c" + c.ci + " "); }

}

...

Archivo f = nuevo Archivo("objetos.dat");

// Crea los objetos y escríbelos en el archivo. SC c = nuevo SC();
SO o1 = nuevo SO(1, c), o2 = nuevo SO(2, c);

o1.c.ci = 3; o2.c.ci = 4; // Actualiza el c compartido dos veces o1.cprint(); o2.cprint(); // Imprime: i1c4 i2c4 OutputStream os = new FileOutputStream(f); ObjectOutputStream oos = nuevo ObjectOutputStream(os); oos.writeObject(o1); oos.writeobject(o2); oos.cerrar();
// Lee los objetos del archivo. InputStream es = nuevo FileInputStream(f);
ObjectInputStream ois = nuevo ObjectInputStream(es);

SO o1i = (SO)(ois.readObject()), o2i = (SO)(ois.readObject()); o1i.cprint(); o2i.cprint(); // Impresiones: i1c4 i2c4
o1i.c.ci = 5; o2i.c.ci = 6; //Actualiza la c compartida dos veces

o1i.cprint(); o2i.cprint(); // Impresiones: i1c6 i2c6


Ejemplo 108: La serialización en ObjectOutputStreams distintos no conserva el uso compartido
Si serializamos los objetos o1 y o2 del ejemplo 107 en el mismo archivo usando dos ObjectOutputStreams diferentes, cada flujo de objetos escribirá una copia del objeto compartido. Cuando deserializamos los objetos, obtenemos dos copias del objeto SC previamente compartido:

// Crea los objetos (como en el ejemplo anterior) y escríbelos en un archivo. ObjectOutputStream oos1 = nuevo ObjectOutputStream(os); oos1.writeObject(o1); oos1.flush();
ObjectOutputStream oos2 = nuevo ObjectOutputStream(os); oos2.writeObject(o2); oos2.cerrar();
// Lee los objetos del archivo, no compartido c. InputStream es = nuevo FileInputStream(f); ObjectInputStream ois1 = nuevo ObjectInputStream(es); SO o1i = (SO)(ois1.readObject());
ObjectInputStream ois2 = nuevo ObjectInputStream(es); Entonces o2i = (SO)(ois2.readObject());
o1i.cprint(); o2i.cprint(); // Impresiones: i1c4 i2c4

o1i.c.ci = 5; o2i.c.ci = 6; // Actualiza dos c diferentes o1i.cprint(); o2i.cprint(); // Impresiones: i1c5 i2c6
Entrada y salida almacenadas en búfer
Escribir un byte o carácter a la vez en un archivo o conexión de red es muy ineficiente. Es mejor recopilar los bytes o caracteres en un búfer y luego escribir todo el búfer en una sola operación. Lo mismo se aplica a la lectura de un archivo o una conexión de red. Sin embargo, el almacenamiento en búfer no acelerará la entrada y salida a matrices de bytes, matrices de caracteres, cadenas o búferes de cadenas.
Para almacenar en buffer un flujo de entrada simple, cree un BufferedInputStream desde is y lea desde ese flujo; y de manera similar para flujos de salida, lectores y escritores.
La operación flux() se puede utilizar en una secuencia almacenada en búfer para solicitar que la salida realmente se escriba.es a la corriente subyacente. Una secuencia almacenada en búfer debe cerrarse correctamente mediante una llamada a close() para garantizar que todos los datos escritos en el búfer finalmente se escriban en la secuencia subyacente.
La clase BufferedReader tiene todos los métodos de la clase Reader (sección 21.4) y estos constructores y métodos:
BufferedReader(Reader rd) crea un lector almacenado en búfer que lee desde rd.
BufferedReader(Reader rd, int sz) crea un lector almacenado en búfer con un búfer de tamaño sz.
Lanza IllegalArgumentException si sz <= 0.
String readLine() lee una línea de texto. Una línea termina con un avance de línea ("\n") o
retorno de carro ("\r") o retorno de carro y avance de línea ("\r\n"). Devuelve la línea sin ningún carácter de terminación de línea; devuelve nulo al final de la secuencia.
La clase BufferedWriter tiene todos los métodos de Writer (sección 21.5) y también estos constructores y métodos:
BufferedWriter (Writer wr) crea un escritor almacenado en búfer que escribe en la secuencia wr.

BufferedWriter (Writer wr, int sz) crea un escritor almacenado en búfer con un búfer de tamaño
talla Lanza IllegalArgumentException si sz <= 0.
void newLine() escribe un separador de línea, como "\n" o "\r\n", según la plataforma.
La clase BufferedInputStream es una subclase de FilterInputStream. Tiene los mismos métodos que InputStream (sección 21.8) y estos constructores:
BufferedInputStream(InputStream is) crea un BufferedInputStream que lee desde la secuencia.
BufferedInputStream(InputStream es, int sz) crea un BufferedInputStream
con tamaño de buffer sz; lanza IllegalArgumentException si sz <= 0.
La clase BufferedOutputStream es una subclase de FilterOutputStream. Tiene los mismos métodos que
OutputStream (sección 21.9) y estos constructores:
BufferedOutputStream (OutputStream os) crea un BufferedOutputStream que escribe en el sistema operativo de transmisión.
BufferedOutputStream (OutputStream os, int sz) crea un
BufferedOutputStream con un búfer de tamaño sz; lanza IllegalArgumentException si sz <= 0.
Ejemplo 109: Búfer de salida

El almacenamiento en búfer puede acelerar las escrituras en FileOutputStream en gran medida. Almacenar en búfer las escrituras en un FileWriter tiene menos efecto, porque un FileWriter es un OutputStreamWriter, que almacena en búfer los bytes convertidos a partir de caracteres escritos antes de escribirlos en un FileOutputStream subyacente. En un experimento, el almacenamiento en búfer hizo que las escrituras en FileOutputStream fueran 18 veces más rápidas y las escrituras en FileWriter solo dos o tres veces más rápidas.

public static void main(String[] args) lanza IOException { OutputStream os1 = new FileOutputStream("tmp1.dat"); writeints("Sin búfer: ", 1000000, os1);
OutputStream os2 = new BufferedOutputStream(new FileOutputStream("tmp2.dat")); writeints("En buffer: ", 1000000, os2);
Escritor wr1 = new FileWriter("tmp1.dat"); writeints("Sin búfer: ", 1000000, wr1);
Escritor wr2 = nuevo BufferedWriter(nuevo FileWriter("tmp2.dat")); writeints("Almacenado en buffer: ", 1000000, wr2);
}



escrituras vacías estáticas (mensaje de cadena, recuento int, sistema operativo OutputStream) lanza IOException {

Temporizador t = nuevo temporizador();
for (int i=0; i<count; i++) os.write(i & 255);
os. cerca();
System.out .println (msg + t.check());
}
escrituras vacías estáticas (mensaje de cadena, recuento int, sistema operativo del escritor) lanza IOException { Timer t = new Timer();
for (int i=0; i<count; i++) os.write(i & 255);

os.cerrar();
System.out.println(msg + t.check());
}


Para lograr eficiencia, normalmente se deben envolver flujos almacenados en búfer alrededor de flujos de archivos y flujos de socket de la siguiente manera:


Archivos de acceso aleatorio: RandomAccessFile
La clase RandomAccessFile se utiliza para la entrada y salida de los llamados archivos de acceso aleatorio. Se puede acceder a los datos de un archivo de acceso aleatorio en cualquier orden, a diferencia de los flujos, que sólo se pueden leer y escribir secuencialmente desde el principio. Por tanto, un archivo de acceso aleatorio es similar a una matriz de bytes extensible almacenada en el sistema de archivos. Un archivo de acceso aleatorio tiene un puntero de archivo asociado, que determina dónde comenzará la siguiente operación de lectura o escritura. Configurar el puntero del archivo permite el acceso aleatorio a todas las partes del archivo (aunque miles o millones de veces más lento que a una matriz de bytes almacenada en la memoria). El puntero del archivo está desplazado desde el principio del archivo; el primer byte del archivo tiene un desplazamiento 0, el último byte del archivo raf tiene un desplazamiento raf.length()-1. La llamada al método seek(pos) establece el puntero del archivo para que apunte al número de byte pos.
La clase RandomAccessFile implementa las interfaces DataInput y DataOutput (sección 21.10) y tiene los siguientes constructores y métodos adicionales. Los métodos read(), read(byte[]) y read (byte[], int, int) se comportan como en InputStream (sección 21.8); en particular, devuelven —1 al final-
del archivo y bloquear hasta que al menos un byte de entrada esté disponible. Los métodos readt() , donde t es un tipo,
comportarse como en DataInput (sección 21.10); en particular, lanzan EOFException al final del archivo.
RandomAccessFile (nombre de cadena, modo de cadena) crea una nueva secuencia de archivos de acceso aleatorio y la asocia con un archivo del nombre indicado en el sistema de archivos. Inicialmente, el puntero del archivo está en el desplazamiento 0. Lanza IOException si el nombre indica un directorio. El modo debe ser "r" para r.sólo lectura o "rw" para lectura y escritura; de lo contrario, se lanza IllegalArgumentException. Si el archivo no existe en el sistema de archivos y el modo es "r", entonces se lanza FileNotFoundException, pero si el modo es "rw", entonces se crea un nuevo archivo vacío si es posible. Si el modo es "r", cualquier llamada a los métodos de escritura generará IOException.
RandomAccessFile (archivo de archivo, modo cadena) funciona como el anterior, pero asocia la secuencia del archivo de acceso aleatorio con el archivo.
void close() cierra la secuencia del archivo.
FileDescriptor getFD() devuelve el descriptor de archivo asociado con la secuencia.
long getFilePointer() devuelve el valor actual del puntero del archivo.
long length() devuelve la longitud del archivo en bytes.
int read() lee un byte, como en InputStream.
int read (byte[] b) lee en la matriz b, como en InputStream.
int read(byte[] b, int i, int n) lee como máximo n bytes en b, como en InputStream.

void seek (pos larga) establece el puntero del archivo en el número de byte pos. Lanza IOException si
pos<0. El puntero del archivo se puede establecer más allá del final del archivo; una escritura posterior ampliará la longitud del archivo.
void setLength(long newlen) establece la longitud del archivo truncándolo o extendiéndolo (al final); en el caso de la extensión, el contenido de la extensión no está definido.
Ejemplo 110: Organización de un archivo de matriz de cadenas para acceso aleatorio

Este ejemplo muestra una manera de implementar el acceso aleatorio a una gran cantidad de textos, como millones de páginas web almacenadas en caché o millones de secuencias de ADN. Definimos un archivo de matriz de cadenas para que tenga tres partes: (1) una secuencia de cadenas, cada una de las cuales está en formato UTF-8 modificado por Java; (2) una secuencia de números enteros largos, que representan los desplazamientos iniciales de las cadenas; y (3) un número entero, que es el número de cadenas en el archivo. (Tenga en cuenta que Java limita la longitud de cada cadena codificada en UTF; usando una representación un poco más complicada en el archivo, podríamos eliminar esta restricción).

Al colocar el número de cadenas y la tabla de desplazamiento de cadenas al final del archivo en lugar de al principio, no necesitamos saber el número de cadenas o la longitud de cada cadena antes de escribir el archivo. Las cadenas se pueden escribir en el archivo de forma incremental y la única estructura que debemos mantener en la memoria es la tabla (ArrayList) de longitudes de cadenas.

static void writeStrings (nombre de archivo de cadena, iterador strIter) lanza IOException {
RandomAccessFile raf = nuevo RandomAccessFile(nombre de archivo, "rw"); raf.setLength(0); // Truncar el archivo ArrayList offsettable = new ArrayList(); // Contiene Longs while (strIter.hasNext()) {
offsettable.add(new Long(raf.getFilePointer())); // Almacenar el desplazamiento de la cadena raf.writeUTF( (String)strIter.next()); // Escribir cadena
}

Iterador iter = offsettable.iterator();

while (iter.hasNext()) // Escribir compensaciones de cadena raf.writeLong(((Long)iter.next()).longValue()); raf.writeInt(offsettable.size()); // Escribe el recuento de cadenas raf.close();
}


Ejemplo 111: Lecturas de acceso aleatorio desde un archivo de matriz de cadenas
La llamada al método readOneString (f, i) lee la cadena número i de un archivo de matriz de cadenas f (ejemplo 110) en tres etapas, utilizando tres llamadas para buscar. Primero, lee la longitud N de la tabla de desplazamiento de los últimos 4 bytes del archivo. En segundo lugar, dado que un int toma 4 bytes y un long toma 8 bytes (sección 5.1), la tabla de desplazamiento de cadena debe comenzar en la posición length()-4-8*N, por lo que el desplazamiento si del número de cadena i se puede leer desde longitud de posición()-4-8*N+8*i. En tercer lugar, la cadena en sí se lee desde el desplazamiento si.

cadena estática readOneString (nombre de archivo de cadena, int i) lanza IOException { final int INTSIZE = 4, LONGSIZE = 8;

RandomAccessFile raf = new RandomAccessFile(nombre de archivo, "r"); raf.seek(raf.length() - INTSIZE);
int N = raf.readInt();

raf.seek(raf.length() - INTSIZE - LONGSIZE * N + LONGSIZE * i); largo si = raf.readLong();
raf.seek(si);

Cadena s = raf.readUTF(); raf.cerrar();
devoluciones;

}

Archivos, directorios y descriptores de archivos
Nombres de ruta en un sistema de archivos: archivo de clase
Un objeto de clase Archivo representa un nombre de ruta, es decir, una ruta de directorio/archivo en el sistema de archivos. El nombre de la ruta puede indicar un directorio, un archivo de datos o nada en absoluto (si no existe ningún archivo o directorio con ese nombre). Incluso si el nombre de la ruta indica un archivo o directorio, un programa determinado puede carecer del permiso para leer o escribir ese archivo o directorio. Estos son algunos de los constructores y métodos de la clase Archivo:
El archivo (cadena pname) crea un nombre de ruta correspondiente a la cadena pname.
boolean existe() devuelve verdadero si existe un archivo o directorio indicado por este nombre de ruta.
String getName() devuelve el nombre de esta ruta como una cadena.
boolean isDirectory() prueba si el archivo indicado por este nombre de ruta es un directorio.
boolean isFile() prueba si el archivo indicado por este nombre de ruta es un archivo normal.
long length() devuelve la longitud del archivo en bytes, o 0 si el archivo no existe.
File[] listFiles() devuelve los archivos y directorios en el directorio indicado por el nombre de la ruta; devuelve nulo en caso de error o si el nombre de la ruta no indica un directorio.
boolean mkdir() crea el directorio nombrado por este nombre de ruta.

Archivo SyObjetos madre: clase FileDescriptor
Un objeto de clase FileDescriptor es un descriptor de archivo, una representación interna de un objeto del sistema de archivos activo, como un archivo abierto o un socket abierto. Se puede obtener un descriptor de archivo de FileInputStream (sección 21.8) o FileOutputStream (sección 21.9). La clase tiene este método:
void sync() solicita que todos los buffers del sistema estén sincronizados con los dispositivos físicos subyacentes; bloques hasta que esto se haya hecho. Lanza SyncFailedException si no se puede hacer.
La clase tiene campos estáticos in, out y err, que son los descriptores de archivos asociados con las secuencias de entrada estándar (System.in), salida estándar (System.out) y error estándar (System.err).


Comunicación de subprocesos: PipedInputStream y PipedOutputStream
Los subprocesos (capítulo 15) se ejecutan simultáneamente y pueden comunicarse de forma asincrónica mediante tuberías internas. Una tubería es un par de PipedInputStream y PipedOutputStream, o un par de PipedReader y PipedWriter. Por el contrario, la comunicación con otros procesos o con ordenadores remotos utiliza InputStreams y OutputStreams, posiblemente obtenidos de sockets del sistema operativo, descritos brevemente en la sección 21.16.

Para crear una tubería, cree un extremo con outpipe = new PipedOutputStream(), luego úselo para crear y conectar el otro extremo con inpipe = new PipedInputStream (outpipe). Cualquiera de los extremos puede crearse primero. Un extremo de tubo sólo se puede conectar una vez.
Un subproceso productor escribe en un PipedOutputStream (o PipedWriter) y un subproceso consumidor lee desde un PipedInputStream (o PipedReader) asociado con PipedOutputStream (o PipedWriter). Si el hilo del productor es rápido y la tubería se llena, entonces la siguiente operación de escritura se bloquea hasta que haya espacio para datos en la tubería. Si el subproceso del consumidor es rápido y no hay datos disponibles en la canalización, la siguiente operación de lectura se bloquea hasta que los datos estén disponibles. Cuando el consumidor o el productor muere y un extremo de la tubería se destruye, la siguiente escritura (o lectura) en el otro extremo de la tubería genera una IOException.
Ejemplo 112: Lectura e impresión de una jerarquía de directorios
La llamada showDir(0, nombre de ruta) imprimirá el nombre de la ruta, y si el nombre de la ruta existe y es un directorio, entonces showDir imprime recursivamente todos sus subdirectorios y archivos. Debido a que la sangría aumenta con cada llamada recursiva, el diseño refleja la estructura del directorio.
showDir vacío estático (int sangría, archivo de archivo) lanza IOException {para (int i=0; i<sangría; i++)
System.out.print('-');
System.out.println(file.getName()); si (archivo.isDirectory()) {
Archivo[] archivos = file.listFiles();
for (int i=0; i<files.length; i++) showDir(sangría+4, archivos[i]);
}
}


Ejemplo 113: Tuberías internas entre roscas

El subproceso productor escribe la secuencia infinita de números primos 2, 3, 5, 7,11,13,... en un PipedOutputStream, mientras que el consumidor (el subproceso principal) lee desde un PipedInputStream conectado a PipedOutputStream. En realidad, el productor escribe en un DataInputStream creado sobre PipedOutputStream, y el consumidor lee desde un DataInputStream creado sobre PipedInputStream, porque queremos enviar números enteros, no solo bytes, a través de la tubería.

PipedOutputStream salida = nuevo PipedOutputStream(); PipedInputStream tubería de entrada = nueva PipedInputStream(salida);
salidas finales de DataOutputStream = nuevo DataOutputStream (salida);

DataInputStream inds = nuevo DataInputStream(tubería de entrada);
// Este hilo genera números primos en outds -> outpipe -> inpipe -> inds: class Producer extends Thread {
ejecución pública vacía() { intentar {
outds.writeInt(2);
for (int p=3; verdadero; p+=2) { int q=3;
mientras (q*q <= p && p%q != 0) q+=2;
si (q*q > p)
{ outds.writeInt(p); System.out.print("."); }
}
} catch (IOException e) { System.out.println("<terminado>: " + e); }
}
}

nuevo Productor().start();
Para Siempre

for (int n=0; n<10; n++) // salida 10 números primos System.out.print(inds.readInt() + " "); // y System.in.read(); // esperar a entrar
}

Comunicación de enchufe
Mientras que un par de subprocesos de Java pueden comunicarse a través de una tubería local (por ejemplo, PipedInputStream), un par de procesos distintos pueden comunicarse a través de sockets. Los procesos pueden estar en la misma máquina o en diferentes máquinas conectadas por una red.
Los sockets se utilizan a menudo en arquitecturas cliente/servidor, donde el proceso del servidor crea un socket de servidor que escucha las conexiones de los clientes. Cuando un cliente se conecta al socket del servidor, se crea un socket nuevo en el lado del servidor y se conecta al socket que el cliente utilizó al conectarse al servidor. La conexión de socket se utiliza para la comunicación bidireccional entre el cliente y el servidor; ambos extremos pueden obtener un flujo de entrada y un flujo de salida del socket.
Aquí hay un constructor y algunos métodos de la clase ServerSocket en el paquete java.net:
ServerSocket (puerto int) crea un socket de servidor en el puerto dado.
Socket Accept() escucha una conexión y la bloquea hasta que se establece una conexión. Crea y devuelve un nuevo Socket cuando se realiza una conexión. Si se establece un tiempo de espera, se lanza la llamada para aceptarInterruptedIOException cuando expira el tiempo de espera.
void close() cierra el socket del servidor.
void setSoTimeout(int tmo) establece el tiempo de espera para que una llamada para aceptar expire después de tmo milisegundos, si es positivo. Desactiva el tiempo de espera (el valor predeterminado) si tmo es cero.
Aquí hay un constructor y algunos métodos de la clase Socket en el paquete java .net:
Socket (String host, int port) crea un socket de cliente y se conecta a un puerto determinado en el host determinado. El host puede ser un nombre ("localhost") o una dirección IP ("127.0.0.1").
void close() cierra el socket.
InetAddress getInetAddress() devuelve la dirección a la que está conectado este socket, como un objeto de la clase java.net.InetAddress; Los métodos getHostName() y getHostAddress() se pueden utilizar para convertir esta dirección en una cadena.
InputStream getInputStream() devuelve el flujo de entrada asociado con este socket.
OutputStream getOutputStream() devuelve el flujo de salida asociado con este socket.
void setSoTimeout (int tmo) establece el tiempo de espera para que una llamada para leer en el flujo de entrada obtenido de este socket expire después de tmo milisegundos, si es positivo. Si tmo es cero, entonces el tiempo de espera está deshabilitado (el valor predeterminado). Si se establece un tiempo de espera, una llamada a lectura arroja InterruptedIOException cuando expira el tiempo de espera.
Las clases Socket y ServerSocket se declaran en el paquete de biblioteca de clases Java java.net. La documentación de la biblioteca de clases Java [3] proporciona más información sobre sockets y sockets de servidor.
Ejemplo 114: Comunicación de socket entre procesos
Este programa de ejemplo se ejecuta como un proceso de servidor o como un proceso de cliente, dependiendo del primer argumento de la línea de comando. El servidor y el cliente pueden ejecutarse en la misma máquina o en diferentes máquinas que se comunican a través de una red. Varios clientes pueden conectarse al mismo servidor. El servidor crea un socket de servidor que acepta conexiones en el puerto 2357. Cuando un cliente se conecta, se crea un nuevo socket de cliente y se recibe un número entero en ese socket. Si el número entero es primo, el servidor responde verdadero en el mismo socket; en caso contrario, falso.
Cada proceso cliente pregunta al servidor sobre la primalidad de los números del 1 al 999 e imprime los que son primos.
Es bastante ineficiente para el cliente crear un nuevo socket para cada solicitud al servidor, pero es suficiente para este ejemplo. Además, almacenar en búfer los flujos de entrada y salida puede acelerar la comunicación del socket (sección 21.12).

importar java.io.*; importar java.net.*;

clase Prueba de socket {

PUERTO int estático final = 2357;



public static void main (String[] args) lanza IOException {
servidor booleano = args.length == 1 && args[0].equals("servidor"); cliente booleano = args.length == 2 && args[0].equals("cliente");
if (servidor) { // Servidor: acepta preguntas sobre primalidad
ServerSocket serversock = nuevo ServerSocket(PUERTO); para (;;) {
Calcetín de enchufe = serversock.accept();
DataInputStream dis = nuevo DataInputStream(sock.getInputStream()); DataOutputStream dos = nuevo DataOutputStream(sock.getOutputStream()); consulta int = dis.readInt();
dos.writeBoolean(isprime(consulta)); revelar(); dos.cerrar();
}
} else if (cliente) { // Cliente: hacer preguntas sobre primalidad
para (int i=1; i<1000; i++) {
Calcetín de socket = nuevo Socket(args[1], PUERTO);
DataOutputStream dos = nuevo DataOutputStream(sock.getOutputStream()); DataInputStream dis = nuevo DataInputStream(sock.getInputStream()); dos.writeInt(i);
if (dis.readBoolean()) System.out.print(i + " ");
dos.cerrar(); revelar();
}
} else { ... } // Ni servidor ni cliente
}
estático booleano isprime(int p) { ... devuelve verdadero si p es primo ... }
}

Referencias
La referencia autorizada sobre el lenguaje de programación Java es J. Gosling, B. Alegría, G. Steele y G. Bracha, La especificación del lenguaje Java, 2ª ed. (Bostón: Addison Wesley, 2000). Busque o descargue en HTML (573 KB) en <>.



Una introducción a todos los aspectos de la programación Java es K. Arnold,J. Gosling y D. Holmes, El lenguaje de programación Java, 3ª ed. (Bostón: Addison Wesley, 2000).

Las bibliotecas de clases Java (o Java Core API) se describen en dos volúmenes de The Java Class Libraries, segunda edición (Boston: Addison Wesley, 1997/98). Volumen 1, por P. Chan, R. Lee y D. Kramer cubren java.io, java.lang, java.math, java.net, java.text y java.util. Volumen 2, por P. Chan y
R. Lee, cubre java.applet, java.awt y java.beans. También está disponible P. Chan, R. Lee y D. Kramer, The Java Class Libraries: 1.2 Suplemento (Boston: Addison Wesley, 1999).

La documentación de la biblioteca de clases se puede descargar (22 MB) en <> o explorar en
<>.

Una guía compacta sobre el estilo de programación Java es The Elements of Java Style (Cambridge: Cambridge University Press, 2000) de A. Vermeulen et al.

La codificación de caracteres Unicode (<>) corresponde a parte del Conjunto de Caracteres Universal (UCS), que es el estándar internacional ISO 10646-1:2000. La UTF-8 es una codificación de longitud variable de UCS, en la que los caracteres ASCII de siete bits se codifican como ellos mismos, descritos en el Anexo R de esta norma.

La aritmética de coma flotante se describe en el estándar ANSI/IEEE para aritmética binaria de coma flotante (IEEENorma 754-1985).
EloperadordeString+ ................................................
Pequeños fallos frecuentes al usar operadores ........................
Operadores de conversión .........................................
Java no tiene "tamaño de" ................................................ .
Volver a hablar acerca de la precedencia................................
Un compendio de operadores .........................................
Control de ejecución ................................................
Verdadero y falso ................................................. ...
Si no ................................................. ..........
devolver ................................................. .......
Iteración................................................. .....
hacer mientras................................................. ........
para ................................................. ..........
romper y continuar ................................................. .
cambiar ................................................. ....... Resultado ................................................ .........
Ejercicios ................................................. ..
4: Inicialización y limpieza .................................
Inicialización garantizada con el constructor ........................
Sobrecargademétodos ........................................ Distinguir métodos sobrecargados ...... ............................
Sobrecarga con tipos primitivos .................................
Sobrecarga en los valores de retorno ................................
Constructores por defecto .........................................
La palabra clave this .......................................... Limpieza: finalización y recolección de basura ....................... ¿Para qué sirve finalizar( )? ........................................
Hay que llevar a cabo la limpieza .................................
La condición de muerto .................................................
Cómo funciona un recolector de basura ................................
Inicialización de miembros ........................................ Especificación de la inicialización ..... ................................
Inicialización de constructores .........................................
Inicialización de arrays ......................................... Arrays multidimensionales .... .................................
Resumen ................................................. .. Ejercicios ................................................ ....
5: Ocultar la implementación ...................................
El paquete: la unidad de biblioteca ................................ Creando nombres de paquete único ...... .........................
Una biblioteca de herramientas a medida .................................
Utilizar el comando import para cambiar el comportamiento ...............
Advertencias relativas al uso de paquetes .................................
índice de contenido xi
Modificadores de acceso en Java ................................. "Amistoso" ("Friendly") .... .........................................
público: acceso a interfaces ........................................
privado: jeso no se toca! ..........................................
protected: "un tipo de amistad" .................................
Interfaz e implementación ........................................ Acceso a clases ...... ........................................ Resumen ......... ..........................................
Ejercicios ................................................. ..
6: Reutilizando clases .........................................
Sintaxis de la composición ........................................
Sintaxis de la herencia ......................................... Inicializando la clase base . ........................................
Combinando la composición y la herencia .......................... Garantizar una buena limpieza .............. ........................
Ocultación de nombres ................................................
Elcción entre composición y herencia ............................. Protegido (protected) ............ .................................Desaerrollo incremental.................. ...................... Conversión hacia arriba ......................... ...............
¿Por qué "conversión hacia arriba"? .................................
Lapalabraclavefinal .......................................... Paradatos ...... .................................................
Métodos constantes................................................
Clases constantes .................................................
Precaución con constantes .........................................
Carga de clases e inicialización .................................
Inicialización con herencia .........................................
Resumen ................................................. .. Ejercicios ................................................ ....
De nueva la conversión hacia arriba ................................
Olvidando el tipo de objetoeto ........................................
El cambio ................................................. .. La ligadura en las llamadas a métodos ................................
Produciendo el comportamiento adecuado ................................
Extensibilidad................................................. .
Superposición frente a sobrecarga ................................ Clases y métodos abstractos ........... .......................... Clases y métodos abstractos .................... ................
Orden de llamadas a constructores .................................
Herencia y finahe( ) .................................................
Comportamiento de métodos polimórficos dentro de constructores .........
xii Piensa en Java
Diseñoconherencia ........................................... Herencia pura frente a extensión . ...................................
Conversión hacia abajo e identificación de tipos en tiempo de ejecución ......
Resumen ................................................. .. Ejercicios ................................................ ....
8: Interfaces y clases internas .................................
Interfaces................................................. .. "Herencia múltiple" en Java .........................................
Extender una interfaz con herencia .................................
Constantes de agrupamiento ........................................
Iniciando atributos en interfaces .................................
Interfaces anidadas ................................................
Clases internas .................................................
Clases internas y conversiones hacia arriba ................................
Ámbitos y clases internas en métodos ................................
Clases internas anónimas .........................................
El enlace con la clase externa .................................
Clases internas estáticas ................................................
Referirse al objeto de la clase externa ................................. Acceso desde una clase múltiplemente anidada ..... ....................
Heredar de clases internas .........................................
¿Pueden superponerse las clases internas? ............................
Identificadores de clases internas ................................
¿Por qué clases internas? ..........................................
Clases internas y sistema de control .................................
Resumen ................................................. ........
Ejercicios ................................................. .......
9: Guardar objetos ................................................
Matrices ................................................. ..........
Los arrays son objetos de primera clase .................................
Devolverunarray................................................
LaclaseArrays.................................................
Rellenarunarray................................................
Copiarunarray.................................................
Comparar matrices ................................................
Comparaciones de elementos de arrays .................................
Ordenar una matriz ................................................. ...
Buscar en un array ordenado ........................................
Resumen de matrices ................................................
Introduccion a los contenedores .................................
Visualizar contenedores................................................
Rellenar contenedores ................................................
Desventaja de los contenedores: tipo desconocido ........................
índice de contenido xiii
En ocasiones funciona de cualquier modo .................................
Hacer un ArrayList consciente de los tipos .................
Iteradores ................................................. .......
Taxonomía de contenedores ........................................
Funcionalidad de la Colección ................................................
Lista de funcionalidades de la interfaz ........................................
Construir una pila a partir de un objeto LinkedList ....................
Construir una cola a partir de un objeto LinkedList ....................
Funcionalidad de la interfaz Set....................................
Conjunto ordenado (SortedSet) .................................
Mapa de Funcionalidad................................................
Mapa ordenado (Sorted Map) ........................................ Hashing y códigos de hash . .........................................
Superponer el método hashCode( ) .................................
Guardar referencias ................................................
El nhjetn HasMap dkhil (WeakHashMa~) .................
Revisando los iteradores ................................................
Elegir una implementación ..........................................
Elegir entre listas ................................................
elegir entreConjuntos .................................................
Elegir entre mapas ................................................
Ordenar y buscar elementos en Listas .................................
Utilidades................................................. .......
Hacer inmodificable una Colección o un Mapa ........................
Sincronizar una Colección o Mapa .................................
Operaciones no soportadas ........................................
Contenedores de Java 1.0/1.1 ........................................
Enumeración de vectores y ................................................
Tabla de picadillo ................................................. ....
Pila(Pila) ................................................ ......
Conjunto de bits (BitSet) ................................................
Resumen ................................................. ........
Ejercicios ................................................. .......
10: Manejo de errores con excepciones ..........................
Excepciones básicas .................................................
Parámetros de las excepciones .................................... . . Capturarunaexcepción................................................
Elbloqueo................................................. ..
Manejadores de excepciones ..................................
Crear sus propias excepciones ........................................
La especificación de excepciones ....................................
Capturar cualquier excepción ........................................
Relanzarunaexcepción................................................
ExcepcionesestándardeJava .................................
xiv Piensa en Java
El caso especial de RuntimeException ................................
Limpiando con finalmente................................................
~¿Paraqué servir finalmente? .........................................
Peligro: la excepción perdida .........................................
Restricciones a las excepciones .........................................
Constructores................................................. ....
Emparejamiento de excepciones ....................................
Guías de cara a las excepciones ....................................
Resumen ................................................. ........
Ejercicios ................................................. .......
11: El sistema de E/S de Java .................................
Archivo de la clase ................................................. ....... Un generador de listados de directorio .................................
Comprobando y creando directorios ................................. Entradaysalida ............ ....................................
TiposdeInputStream................................................
TiposdeOutputStream................................................
Añadir atributos e interfaces útiles ...................................
Leer un InputStream con un FilterInputStream ....................
Escribir en un OutputStream con FilterOutputStream .................
Lectores y escritores .................................................
Fuentes y consumidores de datos ...................................
Modificar el comportamiento del flujo ................................
Clases no cambiadas ................................................
Por sí mismo: RandomAccessFile .................................
Usos típicos de flujos de E/S ........................................
Flujosdeentrada................................................
Flujosdesalida.................................................
¿Unerror? ................................................. ...
Flujosentubados................................................
E/Sestándar ................................................. ......
Leerdelaentradaestándar .........................................
Convirtiendo System.out en un PrintWriter ........................
RedingiendolaE/Sestándar .................................
Compresión................................................. .....
Compresión sencilla con GZIP .................................
Almacenamiento múltiple con ZIP ...................................
Archivos Java UAR) .................................................
Serialización de objetos .................................................
Encontrarlaclase................................................
Controlar la serialización................................................
Utilizar la persistencia................................................
Identificar símbolos de una entrada .................................
StreamTokenizer................................................
índice de contenido xv
StringTokenizer .................................................
Comprobar el estilo de escritura de mayúsculas ........................
Resumen ................................................. ........
Ejercicios ................................................. .......
12: Identificación de tipos en tiempo deejecución ...................
La necesidad de RTTI ................................................
ElobjetoClase .................................................
Comprobar antes de una conversión .................................
Sintaxis RTTI ................................................ .....
Reflectividad: información de clases en tiempo de ejecución ..............
Un extractor de métodos de clases ...................................
Resuinen ................................................. ........
Ejercicios ................................................. .......
13: Crear ventanas y subprogramas .................................
El subprograma básico ................................................. ....
Restricciones de subprogramas ................................................
Ventajas de los applets................................................
Marcos de trabajo de aplicación .................................
Ejecutar applets dentro de un navegador web....................
Utilizar Appletviewer ................................................
Probarapplets ................................................. .
Ejecutar applets desde la línea de comandos .................
Un marco de trabajo de visualización .................................
Usar el Explorador de Windows .................................
Hacer un botón ................................................. ....
Capturarunevento................................................
Áreas de texto ................................................. .....
Controlar la disposición ................................................
Borde hyout ................................................. ..
Flowhyout ................................................. ...
Gridhyout ................................................. ....
Diseño de bolsa de cuadrícula................................................
Posicionamiento absoluto................................................
Boxhyout................................................ ....
¿El mejorenfoque? ................................................
El modelo de eventos de Swing .................................
Tipos de eventos y oyentes .........................................
Seguimiento de múltiples eventos .................................
Un catálogo de componentes Swing .................................
Botones ................................................. ......
Iconos ................................................ .......
Etiquetas de aviso................................................
Camposdetexto................................................
xvi Piensa en Java
Bordes ................................................. .......
JScrollPanes ................................................ ..
Desminieditor ................................................. .
Casillas de verificación................................................
Botonesdeopción................................................
Cuadros combinados (listas desplegables) .................................
Listas ................................................. ........
Paneles Tabulados .................................................
Cajas demensajes ................................................
Menús ................................................. .......
Menús emergentes ................................................
Generacióndedibujos................................................
Cajasdediálogo ................................................
Diálogos de archivo ................................................
Componentes HTMLSwing ................................................
Deslizadores y barras de progreso .................................
Arboles ................................................. ...... Tablas ................................................. .............
Seleccionar Apariencia................................................
El portapapeles ................................................
Empaquetando un applet en un fichero JAR .................
Técnicas de programación................................................
Correspondencia dinámica de objetos ................................
Separar la lógica de negocio de la lógica IU ...........................
Una forma canónica ................................................
Programación visual y Beans .........................................
~QuéesunBean? .................................................
Extraer BeanInfo con el Introspector .................................
Un frijol más cómodo ........................................
Frijol Empaquetarun ................................................
Soporte a Beans más complejo .................................
MássobreFrijoles ................................................
Resumen ................................................. ........
Ejercicios ................................................. .......
14: Hilos múltiples ................................................
Interfaces de respuesta de usuario rápida .......................... HeredardeThread .ejecución ...................
La necesidad de RTTI ................................................
ElobjetoClase .................................................
Comprobar antes de una conversión .................................
Sintaxis RTTI ................................................ .....
Reflectividad: información de clases en tiempo de ejecución ..............
Un extractor de métodos de clases ...................................
Resuinen ................................................. ........
Ejercicios ................................................. .......
13: Crear ventanas y subprogramas .................................
El subprograma básico ................................................. ....
Restricciones de subprogramas ................................................
Ventajas de los applets................................................
Marcos de trabajo de aplicación .................................
Ejecutar applets dentro de un navegador web....................
Utilizar Appletviewer ................................................
Probarapplets ................................................. .
Ejecutar applets desde la línea de comandos .................
Un marco de trabajo de visualización .................................
Usar el Explorador de Windows .................................
Hacer un botón ................................................. ....
Capturarunevento................................................
Áreas de texto ................................................. .....
Controlar la disposición ................................................
Borde hyout ................................................. ..
Flowhyout ................................................. ...
Gridhyout ................................................. ....
Diseño de bolsa de cuadrícula................................................
Posicionamiento absoluto................................................
Boxhyout................................................ ....
¿El mejorenfoque? ................................................
El modelo de eventos de Swing .................................
Tipos de eventos y oyentes .........................................
Seguimiento de múltiples eventos .................................
Un catálogo de componentes Swing .................................
Botones ................................................. ......
Iconos ................................................ .......
Etiquetas de aviso................................................
Camposdetexto................................................
xvi Piensa en Java
Bordes ................................................. .......
JScrollPanes ................................................ ..
Desminieditor ................................................. .
Casillas de verificación................................................
Botonesdeopción................................................
Cuadros combinados (listas desplegables) .................................
Listas ................................................. ........
Paneles Tabulados .................................................
Cajas demensajes ................................................
Menús ................................................. .......
Menús emergentes ................................................
Generacióndedibujos................................................
Cajasdediálogo ................................................
Diálogos de archivo ................................................
Componentes HTMLSwing ................................................
Deslizadores y barras de progreso .................................
Arboles ................................................. ...... Tablas ................................................. .............
Seleccionar Apariencia................................................
El portapapeles ................................................
Empaquetando un applet en un fichero JAR .................
Técnicas de programación................................................
Correspondencia dinámica de objetos ................................
Separar la lógica de negocio de la lógica IU ...........................
Una forma canónica ................................................
Programación visual y Beans .........................................
~QuéesunBean? .................................................
Extraer BeanInfo con el Introspector .................................
Un frijol más cómodo ........................................
Frijol Empaquetarun ................................................
Soporte a Beans más complejo .................................
MássobreFrijoles ................................................
Resumen ................................................. ........
Ejercicios ................................................. .......
14: Hilos múltiples ................................................
Interfaces de respuesta de usuario rápida .......................... HeredardeThread .................................................
Hilos para una interfaz con respuesta rápida .................
Combinar el hilo con la clase principal ................................
Construir muchos hilos ................................................
Hilosdemonio ................................................. .
Compartir recursos limitados ........................................
Acceder a los recursos de forma inadecuada ...........................
Cómo compartir Java los recursos ...................................
índice de contenido xvii
Revisar los JavaBeans ................................................
Bloqueo ................................................. .......
Bloqueándose................................................. .
Interbloqueo................................................. ..
Prioridades ................................................. ......
Leer y establecer prioridades ........................................
Gruposdehilos.................................................
Volver a visitar Runnable ................................................
Hilos demasiados ................................................
Resumen ................................................. ........
Ejercicios ................................................. .......
15: Computación distribuida ...................................
Programación en rojo ................................................
Identificar una máquina ........................................
Enchufes ................................................. ......
Servir a múltiples clientes ........................................
Datagramas ................................................. ...
Utilizar URL en un subprograma .........................................
Más aspectos de redes.................................................
Conectividad a Bases de Datos de Java (JDBC) ........................
Hacer que el ejemplo funcione ...................................
Una versión con IGU del programa de búsqueda .................
Por qué el API JDBC parece tan complejo .................
Un ejemplo más cómodo ........................................
Servlets ................................................. .........
El servlet básico ................................................ .
Servlets y multihilo ................................................
Gestionar sesiones con servlets.................................
Ejecutar los ejemplos de servlets.................................
Páginas del servidor Java ................................................. ..
Objetos implícitos ................................................
Directivas JSP ................................................ ..
Elementos de escritura de guiones JSP .................................
Campos y valores adicionales ................................................
Atributos JSP de página y su ámbito .................................
Sesiones manuales en JSP .........................................
Crear y modificar cookies ........................................
ResumendeJSP ................................................ RMI (Método remoto de invocación) ...................................
Interfaces remotas .................................................
Implementar la interfaz remota ...................................
Crearstubsyskeletons ................................................ Utilizar el objeto remoto .. ........................................
CORBA ................................................. ...
xviii Piensa en Java
FundamentosdeCORBA................................................ 773
Unejemplo................................................. ... 775
Applets de Java y CORBA ......................................... 780
CORBAfrenteaRMI ................................................ 780
JavaBeans empresariales ................................................ 780
JavaBeans frente a EJB................................................ 781
La especificación EJB ................................................ 782
ComponentesEJB ................................................ 783
Las partes de un componente EJB ................................ 784
Funcionamiento de un EJB ........................................ 785
TiposdeEJB ................................................ .. 785
Desarrollar un EJB................................................ 786
ResumendeEJB ................................................ 791
Jini: servicios distribuidos................................................ 791
Jini en contacto ................................................. .. 791
¿Qué es Jini? ................................................. .792
Cómo funciona Jini ................................................ 792
El proceso de descubrimiento................................................ 793
El proceso de unirse ................................................. ... 793
El proceso de búsqueda.................................. 794
Separación de interfaz e implementación ................................795
Abstraer sistemas distribuidos ................................................ 796
Resumen ................................................. ..... 796
Ejercicios ................................................. ..... 796
R: Paso y Retorno de Objetos ...........
Pasando referencias ................................................
Usodealias ................................................. ...
Haciendo copias locales ................................................
Paso por valor................................................. .
Clonandoobjetos................................................
Añadiendo a una clase la capacidad de ser clonable..................
Clonación con éxito ................................................
El efecto de Object.clone( ) .........................................
Clonando un objeto compuesto .................................
Una copia en profundidad con ArrayList .................................
Copia en profundidad vía serialización ................................
Añadiendo "clonabilidad" a lo largo de toda una jerarquía .................
{¿Por qué un diseño tan extraño? .................................
Controlando la "clonabilidad" .........................................
Elconstructordecopias................................................
Clases de sólo lectura ................................................
Creando clases de sólo lectura ....................................
Los inconvenientes de la inmutabilidad ................................
Cadenas inmutables ................................................
índice de contenido xix
Las clases String y StringBuffer .................................
Los Strings son especiales .........................................
Resumen ................................................. ........
Ejercicios ................................................. .......
B . La interfaz nativa Java (JNI1) ................................
Invocando a un método nativo .........................................
El generador de cabeceras de archivo: javah .................................
renombrado de nombres y firmas de funciones ........................
Implementando la DLL ................................................
Accediendo a funciones JNI: el parámetro JNIEnv ....................
Accediendo a Strings Java .........................................
Pasando y usando objetos Java .................................
JNI y las excepciones Java .................................
JNIyloshilos ................................................. .
Usando un código base preexistente ................................
Información adicional................................................
C: Guías de programación Java ................................
Diseño ................................................. ..........
Implementación................................................
D: Recursos Software................................................
Libros................................................ ..........
Análisis y Diseño ................................................. ...
Pitón ................................................. ..........
Mi propia lista de libros ................................................
E: Correspondencias español-inglés de clases. bases de datos. tablas
y campos del CD ROM que acompaña al libro ...................

prólogo
Sugerí a mi hermano Todd, que está dando el
ción, que la siguiente gran revolución será en
salto del hardware a la programaingeniería genética.
Tendremos microbios diseñados para hacer comida, combustible y plástico; limpiarán la contaminación y
en general, nos permitirán dominar la manipulación del mundo físico por una fracción de lo que
cuesta ahora. De hecho yo afirmé que la revolución de los computadores parecería pequeña en comparación.
Después, me di cuenta de que estaba cometiendo un error frecuente en los escritores de ciencia ficción: perderme en la tecnología (lo que por supuesto es fácil de hacer en ciencia ficción). Un escritor experimentado sabe que la historia nunca tiene que ver con los elementos, sino con la gente. La
genética tendrá un gran impacto en nuestras vidas, pero no estoy seguro de que haga sombra a la
revolución de los computadores (que hace posible la revolución genética) -o al menos la revolución de la información. La información hace referencia a comunicarse con otros: sí, los coches, los
zapatos y especialmente la terapia genética son importantes, pero al final, esto no son más que adornos. Lo que verdaderamente importa es cómo nos relacionamos con el mundo. Y cuanto de eso es
comunicación.
Este libro es un caso. La mayoría de los colegas pensaban que estaba un poco loco al poner todo en la
Web. "¿Por qué lo compraría a alguien?", se preguntaban. Si hubiera sido de naturaleza más conservadora no lo habría hecho, pero lo que verdaderamente no quería era escribir más libros de computación al estilo tradicional. No sabía qué pasaría pero resultó que fue una de las cosas más inteligentes que he hecho con unlibro.
Por algún motivo, la gente empezó a mandar correcciones. Éste ha sido un proceso divertido, porque todo el mundo ha recorrido el libro y ha detectado tanto los errores técnicos como los gramaticales, y ha podido eliminar errores de todos los tipos que de otra forma se habrían quedado ahí. La
gente ha sido bastante amable con esto, diciendo a menudo "yo no quiero decir esto por criticar...",
y tras darme una colección de errores estoy seguro de que de otra forma nunca los hubiera encontrado. Siento que éste ha sido un tipo de grupo de procesos que ha convertido el libro en algo especial.
Pero cuando empecé a oír: "De acuerdo, bien, está bien que hayas puesto una versión electrónica,
pero quiero una copia impresa proveniente de una auténtica editorial", puse mi mayor empeño en
facilitar que todo se imprima con adecuado, pero eso no frenó la demanda de una versión publicada. La mayoría de la gente no quiere leer todo el libro en pantalla, y merodear por un
conjunto de papeles, sin que importen cuán bien impresos estén, simplemente no era suficiente.
(Además, tampoco creo que resulte tan barato en términos de tóner para impresora láser.) Parece
que a fin de cuentas, la revolución de los computadores no conseguirá dejar sin trabajo a las editoriales. Sin embargo, un alumno me sugirió que éste podría ser un modelo para publicaciones finales: los libros se publicarán primero en la Web, y sólo si hay el suficiente interés, merecerá la pena.
pasar el libro a papel. Actualmente, la gran mayoría de libros conllevan problemas financieros, y quizás este nuevo enfoque pueda hacer que el negocio de la publicación sea más beneficioso. Este li-
xxii Piensa en Java
hermano se convirtió en una experiencia reveladora para mí de otra forma. Originalmente me acerqué a
Java como "simplemente a otro lenguaje de programación", lo que en cierto sentido es verdad. pero
a medida que pasaba el tiempo y lo estudiaba más en profundidad, empecé a ver que la intención
fundamental de este lenguaje es distinta de la de otros lenguajes que he visto.
La programación está relacionada con gestionar la complejidad: la complejidad del problema que se
quiere solucionar, que yace sobre la complejidad de la máquina en que se soluciona. Debido a esto
complejidad, la mayoría de nuestros proyectos fallan. Y lo que es más, de todos los lenguajes de programación de los que soy consciente, ninguno se ha lanzado completamente decidiendo que la meta
de diseño principal fuera conquistar la complejidad del desarrollo y mantenimiento de programas1.
Por supuesto, muchas decisiones de diseño de lenguajes se hicieron sin tener en mente la complejidad, pero en algún punto había siempre algún otro enfoque que se consideraba esencial añadirlo.
al conjunto. Inevitablemente, estos otros aspectos son los que hacen que generalmente los programadores "se den con la pared" contra ese lenguaje. Por ejemplo, C++ tenía que ser compatible con
C (para permitir la migración fácil a los programadores de C), además de eficiente. Estas metas hijo
ambas muy útiles y aportan mucho al éxito de Ctt, pero también exponen la complejidad extra que
evita que los proyectos se acaben (ciertamente, se puede echar la culpa a los programadores y la
gestión, pero si un lenguaje puede ayudar 'a capturar los errores, ¿por qué no hacer uso de ello?).
Como otro ejemplo, Visual Basic (VB) estaba atado a BASIC, que no estaba diseñado verdaderamente para ser un lenguaje ampliable, por lo que todas las aplicaciones que se apilaban sobre VB.
producían sintaxis verdaderamente horribles e inmantenibles. Perl es retrocompatible con Awk,
Sed, Grep y otras herramientas Unix a las que iba a reemplazar, y como resultado se le acusa a menudo, de producir "código de sólo escritura" (es decir, código que tras unos pocos meses no hay
quien lea). Por otro lado, C++, VB, Perl y otros lenguajes como Smalltalk han visto cómo algunos
de sus esfuerzos de diseño se centran en el aspecto de la complejidad y como resultado son remarcadamente exitosos para solucionar ciertos tipos de problemas.
Lo que más me impresionó es que llegó a entender que Java parece tener el objetivo de reducir la complejidad para el programador. Como si se dijera "no nos importa nada más que reducir el
tiempo y la dificultad para producir un código robusto". En los primeros tiempos, esta meta llevaba
a un código que no se ejecutaba muy rápido (aunque se habían hecho promesas sobre lo rápido que
se ejecutaría Java algún día), pero sin duda ha producido reducciones sorprendentes de tiempo de
desarrollo; la mitad o menos del tiempo que lleva crear un programa C++ equivalente. Este resultado sólo puede ahorrar cantidades increíbles de tiempo y dinero, pero Java no se detiene ahí. Envuelve todas las tareas complejas que se han convertido en importantes, como el multihilo y la programación en red, en bibliotecas o aspectos del lenguaje que en ocasiones pueden convertir esas
tareas en triviales. Y finalmente, asume muchos problemas de complejidad grande: programas multiplataforma, cambios dinámicos de código, e incluso seguridad, cada uno de los cuales pueden encajar dentro de un espectro de complejidades que oscila en el rango de "impedimento" a "motivos
de cancelación". Por tanto, a pesar de los problemas de rendimiento que se han visto, la promesa
de Java es tremenda: puede convertirnos en programadores significativamente más productivos.
Uno de los sitios en los que veo el mayor impacto de esto es en la Web. La programación en red
siempre ha sido complicado, y Java la convierte en fácil. O los diseñadores el lenguaje Java están
Esto lo retomo de la 2." edición: creo que el lenguaje Python se acerca aún más a esto. Ver http://www.Python.org.
Prefacio XXIII
trabajando en facilitarla aún más). La programación en red es como hablar simultáneamente de forma efectiva y de forma más barata de lo que nunca se logró con teléfonos (sólo el correo electrónico ya ha revolucionado muchos negocios). Al intercomunicarnos más, empezarán a pasar cosas.
divertidas, probablemente mucho más interesantes que las que pasarán con la ingeniería genética.
De todas formas -al crear los programas, trabajar para crear programas, construir interfaces para
los programas, de forma que éstos se puedan comunicar con el usuario, ejecute los programas en
distintos tipos de máquinas, y escribir de forma sencilla programas que pueden comunicarse a través de Internet-Java incrementa el ancho de banda de comunicación entre la gente. Creo que quizás los resultados de la revolución de la comunicación no se contemplarán por lo que conlleva el
transporte de grandes cantidades de bits; Veremos la auténtica revolución porque podremos comunicarnos con mayor facilidad: de uno en uno, pero también en grupos y, como planeta. He oído la
sugerencia de que la próxima revolución es la formación de cierto tipo de mente global para suficiente gente y suficiente nivel de interconectividad. Puede decirse que Java puede fomentar o no esa
revolución, pero al menos la mera posibilidad me ha hecho sentir como si estuviera haciendo algo
lleno de sentido al intentar enseñar ese lenguaje.
Prólogo a la 2.a edición
La gente ha hecho muchos, muchos comentarios maravillosos sobre la primera edición de este libro, cosa que ha sido para mí muy, pero que muy, placentero. Sin embargo, en todo momento habrá quien tenga quejas, y por alguna razón una queja que suele aparecer periódicamente es que "el
libro es demasiado grande". Para mí, esto no es verdaderamente una queja, si se reduce a que "tiene demasiadas páginas". (Uno se acuerda de las quejas del Emperador de Austria sobre el trabajo
de Mozart: "¡Demasiadas páginas!", y no es que me esté intentando comparar con Mozart de ninguna forma). Además, sólo puedo asumir que semejante queja puede provenir de gente que no tiene aún una idea clara de la vasta extensión del propio lenguaje Java en sí, y que no ha visto el resto de libros sobre la materia -por ejemplo, mi referencia favorita es el Core Java de Cay Horstmann
& Cary Cornell (Prentice-Hall), que creció tanto que hubo que dividirlo en dos tomos. A pesar de
Esto, una de las cosas que intentó hacer en esta edición es eliminar las puertas que se han vuelto obsoletas o al menos no esenciales. Me siento a gusto haciendo esto porque el material original.
sigue en la Web y en el CD ROM que acompaña al libro, en la misma forma de descarga gratuita
que la primera edición del libro (en http://www.BruceEckel.com). Si se desea el material antiguo,
Sigue ahí, y esto es algo maravilloso para un autor. Por ejemplo, puede verse que el último capítulo
original, "Proyectos", ya no está aquí; dos de los proyectos se han integrado en los otros capítulos,
y el resto ya no son adecuados. También el capítulo de "Patrones de diseño" se volvió demasiado
extenso y ha sido trasladado a un libro que versa sobre ellos (descargable también en el sitio web).
Por tanto, el libro debería ser más fino.
Pero no lo es.
El aspecto mayor es el continuo desarrollo del lenguaje Java en sí, y en particular las API que se expanden, y prometen proporcionar interfaces estándar para casi todo lo que se desea hacer (y no me
sorprendería ver aparecer la API "JTostadora"). Cubrir todas estas API se escapa por supuesto del
ámbito de este libro, y es una tarea relegada a otros autores, pero algunos aspectos no pueden ignorarse.
xxiv Piensa en Java
norarse. El mayor de estos incluye el servidor Java de lado (principalmente Servlets y Java Server
Pages o JSP), que es verdaderamente una solución excelente al problema de la World Wide Web,
donde se descubrió que las distintas plataformas de navegadores web no son lo suficientemente consistentes como para soportar programación en el lado cliente. Además, está todo el problema de
crear de forma sencilla aplicaciones que interactúen de forma sencilla con bases de datos, transacciones, seguridad y semejantes, cubiertos gracias a los Enterprise Java Beans (EJB). Estos temas están desarrollados en el capítulo que antes se llamaba "Programación de red" y ahora "Computación
distribuido", un tema que se está convirtiendo en esencial para todo el mundo. También se verá que
se ha compilado este capítulo para incluir un repaso de Jini (pronunciado "yeni", y que no es un
acrónimo, sino sólo un nombre), que es una tecnología emergente que permite que cambiemos la
forma de pensar sobre las aplicaciones interconectadas. Y por supuesto, el libro se ha cambiado para
usar la biblioteca IGU Swing a lo largo de todo el mismo. De nuevo, si se desea el material Java
1.0/1.1 antiguo, es posible conseguirlo gratuitamente del libro de descarga gratuita de
http:llwww.BruceEckel.corn (también está incluido en el nuevo CD ROM de esta edición, que se adjunta al mismo; hablaré más de él un poco más adelante).
Además de nuevas características del lenguaje añadidas a Java 2, y varias correcciones hechas a lo
largo de todo el libro, el otro cambio principal está en el capítulo de colecciones que ahora se centra en las colecciones de Java 2, que se usan a lo largo de todo el libro. También he mejorado ese
capítulo para que entre más en profundidad en algunos aspectos importantes de las colecciones, en
particular, en cómo funcionan las funciones de hash (de forma que se puede saber cómo crear
una adecuadamente). Ha habido otros movimientos y cambios, incluida la reescritura del Capítulo
1, y la eliminación de algunos apéndices y de otros materiales que ya no se consideran necesarios
para el libro impreso, que son un montón de ellos. En general, intentó recorrer todo, eliminar
de la 2." edición lo que ya no es necesario (pero que sigue existiendo en la primera edición electrónica), incluir cambios y mejorar todo lo que he podido. A medida que el lenguaje continúa cambiando -aunque no a un ritmo tan frenético como antiguamente- no cabe duda de que habrá más
ediciones de este libro.
Para aquellos de vosotros que siguen sin poder soportar el tamaño del libro, pido perdón. Lo creáis
o no, trabajó duro para que se mantenga lo menos posible. A pesar de todo, creo que hay bastantes alternativas que pueden satisfacer a todo el mundo. Además, el libro está disponible electrónicamente (en idioma inglés desde el sitio web y desde el CD ROM que acompaña al libro), por lo
que si se dispone de un ordenador de bolsillo, se puede disponer del libro sin tener que cargar un
gran peso. Si sigue interesado en tamaños menores, ya existen de hecho versiones del libro para
Piloto de palma. (Alguien me dijo en una ocasión que leería el libro en la cama en su Palm, con la luz encendida a la espalda para no molestar a su mujer. Sólo espero que le ayude a entrar en el mundo de
los sueños.) Si se necesita en papel, sé de gente que lo va imprimiendo capítulo a capítulo y se lo
Lee en el tren.
Java 2
En el momento de escribir el libro, es inminente el lanzamiento del Java Development Kit UDK) 1.3
de Sun, y ya se ha publicado los cambios propuestos para JDK 1.4. Aunque estos números de versión se corresponden aún con los "unos", la forma estándar de referenciar a las versiones posteriores.
Prefacio xxv
res a la JDK 1.2 es llamarles "Java 2". Esto indica que hubo cambios muy significativos entre el "viejo Java" -que tenía muchas pegas de las que ya me quejé en la primera edición de este libro- y
esta nueva versión más moderna y mejorada del lenguaje, que tiene menos pegas y más adiciones
y buenos diseños.
Este libro está escrito para Java 2. Tengo la gran ventaja de librarme de todo el material y escribir.
sólo para el nuevo lenguaje ya mejorado porque la información vieja sigue existiendo en la l." versión
electrónica disponible en la Web y en el CD-ROM (que es a donde se puede ir si se desea obcecarse
en el uso de versiones anteriores a Java 2 del lenguaje). También, y dado que cualquiera puede descargarse
gratuitamente el JDK de http://java.sun.com, se supone que por escribir para Java 2, no estoy imponiendo ningún criterio financiero o forzando a nadie a hacer una actualización del software.
Hay, sin embargo, algo que reseñar. JDK 1.3 tiene algunas mejoras que realmente me gustaría usar, pero la versión de Java que está siendo actualmente distribuida para Linux es la JDK 1.2.2
(ver http://www.Linux.org). Linux es un desarrollo importante en combinación con Java, porque es
rápido, robusto, seguro, está bien mantenido y es gratuito; una auténtica revolución en la historia de
la computación (no creo que se hayan visto todas estas características unidas en una única herramienta anteriormente). Y Java ha encontrado un nicho muy importante en la programación en el
lado servidor en forma de Serulets, una tecnología que es una grandísima mejora sobre la programación tradicional basada en CGI (todo ello cubierto en el capítulo "Computación Distribuida").
Por tanto, aunque me gustaría usar sólo las nuevas características, es crítico que todo se recopile
bajo Linux, y por tanto, cuando se desempaquete el código fuente y se compila bajo ese SO (con el
último JDK) se verá que todo compilara. Sin embargo, verás que he puesto notas sobre características de JDK 1.3 en muchos lugares.
El CD-ROM
Otro bono con esta edición es el CD ROM empaquetado al final del libro. En el pasado me resistió a poner CD ROM al final de mis libros porque pensaba que no estaba justificada una carga
de unos pocos Kbytes de código fuente en un soporte tan grande, prefiriendo en su lugar permitir
a la gente descargar los elementos desde el sitio web. Sin embargo, pronto se verá que este CD
ROM es diferente.
El CD contiene el código fuente del libro, pero también contiene el libro en su integridad, en varios
formatos electrónicos. Para mí, el preferido es el formato HTML porque es rápido y está completamente indexado -simplemente se hace clic en una entrada del índice o tabla de contenidos y estará inmediatamente en esa parte del libro.
La carga de más de 300 Megabytes del CD, sin embargo, es un curso multimedia denominado Thinking in C: Foundations for C++ & Java. Originalmente encargué este seminario en CD ROM a Chuck
Allison, como un producto independiente, pero decidió incluirlo con la segunda edición tanto de Thinking in C++ como de Piensa en Java, gracias a la consistente experiencia de haber tenido gente viniendo a los seminarios sin la requerida experiencia en C. El pensamiento parece aparentemente
ser: "Soy un programador inteligente y no deseo aprender C, y sí C++ o Java, por lo que me saltaré
C e iré directamente a C++/Java." Tras llegar al seminario, todo el mundo va comprendiendo que el
xxvi Piensa en Java
prerrequisito de aprender C está ahí por algo. Incluyendo el CD ROM con el libro, se puede asegurar que todo el mundo atienda al seminario con la preparación adecuada.
El CD también permite que el libro se presente para una audiencia mayor. Incluso aunque el Capítulo 3 («Controlando el flujo del programa») cubre los aspectos fundamentales de las partes de Java
que provienen de C, el CD es una introducción más gentil, y supone incluso un trasfondo de C menor que el que supone el libro. Espero que al introducir el CD sea más la gente que se acerca a
la programación en Java.
Prólogo a la edición
en español
Java se convierte día a día en un lenguaje de programación universal; es decir, ya no sólo sirve como
lenguaje para programar en entornos de Internet, sino que se está utilizando cada vez más como herramienta de programación orientada a objetos y también como herramienta para cursos específicos de programación o de estructuras de datos, aprovechando sus características de lenguaje "multiparadigma". Por estas razones, los libros que abordan temas completos y amplios sobre los
temas anteriores siempre serán bienvenidos. Si, además de reunir estos requisitos, el autor es uno
de los más galardonados por sus obras anteriores, nns nos enfrentamos ante iin reto considerable: "la
posibilidad de encontrarnos" ante un gran libro, de esos que hacen "historia". Éste, pensamos, es el
caso del libro que tenemos entre las manos. ¿Por qué pensamos así?
El libro como referencia obligada a Java
Piensa en Java introduce todos los fundamentos teóricos y prácticos del lenguaje Java, tratando de
Explicar con claridad y rigor no sólo lo que hace el lenguaje sino también el porqué. Eckel presenta
los fundamentos de objetos y cómo los utiliza Java. Éste es el caso del estudio que hace de la ocultación de las implementaciones, reutilización de clases y polimorfismo. Además, estudia en profundidad propiedades y características tan importantes como AWT, programación concurrente (multihilo, multithreading2), programación en red, e incluso diseño de patrones.
Es un libro que puede servir para iniciarse en Java y llegar hasta un nivel avanzado. Pero, en realidad se sacará el máximo partido al libro si se conoce otro lenguaje de programación, o al menos técnicas de programación (como haber seguido un curso de Fundamentos de Programación, Metodología de la Programación, Algoritmos, o cursos similares) y ya se puede apostar por un alto y eficiente
rendimiento si la migración a Java se hace desde un lenguaje orientado a objetos, como C++.
El libro como formación integral de programador.
Una de las fortalezas más notables del libro es su contenido y la gran cantidad de temas importantes cubiertos con toda claridad y rigor, y con gran profundidad. El contenido es muy amplio y sobre.
todo completo. Eckel prácticamente ha tocado casi todas las técnicas existentes y utilizadas hoy día
en el mundo de la programación y de la ingeniería del software. Algunos de los temas más sobresalientes analizados en el libro son: fundamentos de diseño orientado a objetos, implementación de
herencia y polimorfismo, manejo de excepciones, multihilo y persistencia, Java en Internet, recolección de basura, paquetes Java, diseño por reutilización: composición, herencia, interfaces y clases internas, arrays y contenedores de clases, clases de E/S Java, programación de redes con sockets, JDBC para bases de datos, JSPs (JavaServer Pages), RMI, CORBA, EJBs (Entesorpresa
JauaBeans) y Jini, JNI (Java Native Interface).
xxviii Piensa en Java
El excelente y extenso contenido hacen al libro idóneo para la preparación de cursos de nivel medio
y avanzado de programación, tanto a nivel universitario como profesional. Asimismo, por el enfoque
Masivamente profesional que el autor da al libro, puede ser una herramienta muy útil como referencia básica o complementaria para preparar los exámenes de certificación Java que la casa Sun
Microsystems otorga tras la superación de las correspondientes pruebas. Esta característica es una
valor añadido muy importante, al facilitar considerablemente al lector interesado las directrices técnicas necesarias para la preparación de la citada certificación.
Recursos gratuitos en línea
Si las características citadas anteriormente son de por sí lo suficientemente atractivas para la lectura del libro, es sin duda el excelente sitio en Internet del autor otro valor añadido difícil de medir,
por no decir inmedible y valiosísimo. La generosidad del autor -y, naturalmente, de Pearson-, que
ofrece a cualquier lector, sin necesidad de compra previa, todo el contenido en línea, junto a las frecuentes revisiones de la obra y soluciones a ejercicios seleccionados, con la posibilidad de descargarse gratuitamente todo este inmenso conocimiento incluido en el libro, junto al conocimiento complementario ofertado (ejercicios, revisión, actualizaciones...), hacen que esta experiencia sea innovadora
del autor digna de los mayores agradecimientos por parte del cuerpo de programadores noveles o
profesionales de cualquier lugar del mundo donde se utilice Java (que hoy es prácticamente "todo
el mundo mundial", que dirían algunos periodistas).
De igual forma es de agradecer el CD kOM que acompaña al libro y la oferta de un segundo CD.
gratuito que se puede conseguir siguiendo las instrucciones incluidas en el libro con el texto completo de la versión original en inglés y un gran número de ejercicios seleccionados resueltos y recursos Java de todo tipo.
Para facilitar al lector el uso del CD ROM incluido en el libro, el equipo de revisión técnica ha realizado el Apéndice E: Correspondencias español-inglés de clases, bases de datos, tablas y campos del CD.
ROM que acompaña al libro, a fin de identificar el nombre asignado en la traducción al español, con
el nombre original en inglés de dichas clases.
Unas palabras todavía más elogiosas
Para las personas que, como el autor de este prólogo, llevamos muchos años (ya décadas) dedicándonos a programar computadoras, enseñar a programar y escribir sobre programación, un libro.
como éste sólo nos trae pensamientos elevados y elogiosos. Consideramos que es un libro magnífico, maduro, consistente, intelectualmente honesto, bien escrito y preciso. Sin duda, como lo demuestra su larga lista de premios y sus numerosas y magníficas cualidades, Piensa en Java, no sólo
es una excelente obra para aprender y llegar a dominar el lenguaje Java y su programación, sino
También una excelente obra para aprender y dominar las técnicas modernas de programación.
Luis Joyanes Aguilar
Director del Departamento de Lenguajes y Sistemas Informáticos e Zngeniená de Software
Universidad Pontificia de Salamanca campus Madrid
comentarios los lectores
Mucho mejor que cualquier otro libro de Java que haya visto. Esto se entiende "en orden de magnitud"... muy completo, con ejemplos directos y al grano, excelentes e inteligentes, sin embarullarse, lleno de explicaciones.... En contraste con muchos otros libros de Java lo encontró inusualmente maduro, consistente, intelectualmente honesto, bien escrito y preciso. En mi honesta opinión,
Un libro ideal para estudiar Java. Anatoly Vorobey, Universidad Technion, Haifa, Israel.
Uno de los mejores tutoriales de programación, que he visto en cualquier lenguaje. Joakim Ziegler,
REPARAR el operador del sistema.
Gracias por ese libro maravilloso, maravilloso en Java. Dr. Gavin Pillary, Registrador, King
Hospital Eduard VI11, Suráfrica.
Gracias de nuevo por este maravilloso libro. Yo estaba completamente perdido (soy un programador que no viene de C) pero tu libro me ha permitido avanzar con la misma velocidad con la que lo
él leyó. Es verdaderamente fácil entender los principios básicos y los conceptos desde el principio, en vez de tener que intentar construir todo el modelo conceptual mediante prueba y error.
Afortunadamente podré asistir a su seminario en un futuro no demasiado lejano. Randa11 R. Hawley, técnico de automatización, Eli Lilly & Co.
El mejor libro escrito de computadoras que haya visto jamás. Tom Holanda.
Éste es uno de los mejores libros que he leído sobre un lenguaje de programación... El mejor libro
sobre Java escrito jamás. Revindra Pai, Oracle Corporation, línea de productos SUNOS.
¡Éste es el mejor libro sobre Java que haya visto nunca! Ha hecho un gran trabajo. tu profundidad
es sorprendente. Compraré el libro en cuanto se publique. He estado aprendiendo Java desde octubre
del 96. He leído unos pocos libros y considerael tuyo uno que "SE DEBE LEER". En estos últimos
meses nos hemos centrado en un producto escrito totalmente en Java. Tu libro ha ayudado a consolidar algunos temas en los que andábamos confusos y ha ampliado mi base de conocimientos. Incluso el
usado algunos de tus ejemplos y explicaciones como información en mis entrevistas para ayudar al
equipo. He averiguado el conocimiento de Java que tienen preguntándoles por algunas de las cosas.
que he aprendido a partir de la lectura de tu libro (por ejemplo, la diferencia entre arrays y Vectores).
¡El libro es genial! Steve Wilkinson, especialista senior en personal, MCI Telecommunications.
Gran libro. El mejor libro de Java que he visto hasta la fecha. Jeff Sinlair, ingeniero de software, Kestral Computing.
Gracias por Piensa en Java. Ya era hora de que alguien fuera más allá de una mera descripción del
lenguaje para lograr un tutorial completo, penetrante, impactante y que no se centra en los fabricantes. He leído casi todos los demás -y sólo el tuyo y el de Patrick Winston han encontrado un lugar en mi corazón. Se lo estoy recomendando ya a los clientes. Gracias de nuevo. Richard Brooks,
consultor de Java, Sun Professional Services, Dallas.
Otros libros contemplan o abarcan el QUÉ de Java (describiendo la sintaxis y las bibliotecas) o el
CÓMO de Java (ejemplos de programación práctica). Piensa en Jaual es el único libro que conoce
' Thinking in Java (título original de la obra en inglés).
xxx Piensa en Java
co que explica el PORQUÉ de Java; por qué se diseñó de la manera que se hizo, por qué funciona
como lo hace, por qué en ocasiones no funciona, por qué es mejor que C++, por qué no lo es. Aunque hace un buen trabajo de enseñanza sobre el qué y el cómo del lenguaje, Piensa en Java es la
elección definitiva que toda persona interesada en Java tiene de hacer. Robert S. Stephenson.
Gracias por escribir un gran libro. Cuanto más lo leo más me gusta. A mis estudiantes también les
gusta. Chuck Iverson.
Sólo quiero comentar tu trabajo en Piensa en Java. Es la gente como tú la que dignifica el futuro
de Internet y simplemente quiero agradecerte el esfuerzo. Patrick Barrell, responsable de red
Mamco, QAF M@. Cª
La mayoría de los libros de Java que existen están bien para empezar, y la mayoría tienen material para
principiantes y muchos los mismos ejemplos. El tuyo es sin duda el mejor libro y más avanzado para
Pensar que he visto nunca. ¡Por favor, publícalo rápido! ... También compré Thinking in C++ simplemente por lo impresionado que me dejó Piensa en Java. George Laframboise, LightWorx Technology Consulting Inc.
Te escribí anteriormente con mis impresiones favorables relativas a Piensa en Java (un libro que empieza prominentemente donde hay que empezar). Y hoy que he podido medirme con Java con tu libro electrónico en mi mano virtual, debo decir (en mi mejor Chevy Chase de Modern Problems)
"¡Me gusta!". Muy informativo y explicativo, sin que parezca que se lee un texto sin sustancia. Cubres los aspectos más importantes y menos tratados del desarrollo de Java: los porqués. sean
Brady.
Tus ejemplos son claros y fáciles de entender. Tuviste cuidado con la mayoría de los detalles importantes de Java que no pueden encontrarse fácilmente en la débil documentación de Java. Y no malgastas el tiempo del lector con los hechos básicos que todo programador conoce. Kai Engert, Software Innovador, Alemania.
Soy un gran fan de Piensa en Java y lo he recomendado a mis asociados. A medida que avanzamos por
la versión electrónica de tu libro de Java, estoy averiguando que ha retenido el mismo alto nivel de
escritura. Peter R. Neuvald.
Un libro de Java MW BIEN escrito... Pienso que has hecho un GRAN trabajo con él. Como líder
de un grupo de interés especial en Java del área de Chicago, mencionó de forma favorable tu
libro y sitio web muy frecuentemente en mis últimas reuniones. Me gustaría usar Piensa en Java
como la base de cada reunión mensual del grupo, para poder ir repasando y discutiendo sucesivamente cada capítulo. Marcos Ertes.
Verdaderamente aprecio tu trabajo, y tu libro es bueno. Lo recomiendo aquí a nuestros usuarios y
estudiantes de doctorado. Hughes Leroy // Irisa-Inria Rennes Francia, jefa de Computación
Científica y Transferencia Industrial.
De acuerdo, sólo he leído unas 40 páginas de Piensa en Java, pero ya he averiguado que es el libro
de programación mejor escrito y más claro que haya visto jamás... Yo también soy escritor, por lo
Que probablemente soy un poco crítico. Tengo Piensa en Java encargado y ya no puedo esperar
más -soy bastante nuevo en temas de programación y no hago más que enfrentarme a curvas de
Comentarios de los lectores xxxi
aprendizaje en todas partes. Por tanto, esto no es más que un comentario rápido para agradecerte.
este trabajo tan excelente. Ya me había empezado a querer de tanto navegar por tanta y tanta prosa
de tantos y tantos libros de computadores - muchos incluso que venían con magníficas recomendaciones. Me siento muchísimo mejor ahora. Glenn Becker, EducadorAsociación Nacional de Teatro.
Gracias por permitirme disponer de este libro tan maravilloso. Lo he encontrado inmensamente útil
en el entendimiento final de lo que he experimentado -algo confuso anteriormente- con Java y
C++. Leer tu libro ha sido muy gratificante. Felix Bizaoui, Twin Oaks Industnes, Luisa, Virginia.
Debo felicitarte por tu excelente libro. He decidido echar un vistazo a Piensa en Java guiado por mi
experiencia en Thinking in C++, y no me ha defraudado. Jaco van der Merwe, especialista en software, DataFusion Systems Ltd., Steíienbosch, Suráfnca.
Este libro hace que todos los demás libros de Java que he leído parezcan un insulto o sin duda inútiles. 13rett g Porter, programador senior, Arte y Lógica.
He estado leyendo tu libro durante una semana o dos y lo he comparado con otros libros de Java
que leyó anteriormente. Tu libro parece tener un gran comienzo. He recomendado este libro a
muchos de mis amigos y todos ellos lo han calificado de excelente. Por favor, acepta mis felicitaciones por escribir un libro tan excelente. Rama Krishna Bhupathi, Ingeniería de Software, TCSI
Corporación, San José.
Simplemente quería decir lo "brillante" que es tu libro. Lo he estado usando como referencia principal durante mi trabajo de Java hecho en casa. He visto que la tabla de contenidos es justo la más
adecuada para localizar rápidamente la sección que se requiere en cada momento. También es genial ver un libro que no es simplemente una compilación de las API o que no trata al programador.
como un monigote. Grant Sayer, líder del grupo de componentes Java, Ceedata Systems Pty
Ltd., Australia.
~Gu~u! Un libro de Java profundo y legible. Hay muchos libros pobres (y debo admitir también que
un par de ellos buenos) de Java en el mercado, pero por lo que he visto, el tuyo es sin duda uno de
los mejores. John Root, desarrollador web, Departamento de la Seguridad Social, Londres.
*Acabo* de empezar Piensa en Java. Espero que sea bueno porque me gustó mucho Thinking in
C++ (que leí como programador ya experimentado en C++, intenté adelantarme a la curva de
aprendizaje). En parte estoy menos habituado a Java, pero espero que el libro me satisfaga igualmente. Eres un autor maravilloso. Kevin K. Lewis, tecnólogo, ObjectSpace Inc.
Creo que es un gran libro. He aprendido todo lo que sé de Java a partir de él. Gracias por hacerlo
disponible gratuitamente a través de Internet. Si no lo hubieras hecho no sabría nada de Java. pero
lo mejor es que tu libro no es un mero folleto publicitario de Java. También muestra sus lados negativos. TÚ has hecho aquí un gran trabajo. FrederikFix, Bélgica.
Siempre me han enganchado tus libros. Hace un par de años, cuando quería empezar con C++, fue
C++ Inside & Out el que me introdujo en el fascinante mundo de C++. Me ayudó a disponer de mejores oportunidades en la vida. Ahora, persiguiendo más conocimiento y cuando quería aprender.
Java, me introduje en Piensa en Java -sin dudar de que gracias a él ya no necesitaría ningún otro
libro. Simplemente fantástico. Es casi como volver a descubrirme a mí mismo a medida que avanza.
xxxii Piensa en Java
en el libro. Apenas hace un mes que he empezado con Java y mi corazón late gracias a ti. Ahora lo
entiendo todo mucho mejor. Anand Kumar S., ingeniero de Software Computervision, India.
Tu libro es una introducción general excelente. Peter Robinson, Universidad de Cambridge,
Laboratorio de Computación.
Es con mucho el mejor material al que he tenido acceso al aprender Java y simplemente quería que
supieras la suerte que he tenido de poder encontrar. ¡GRACIAS! Chuck Peterson, líder de producto, línea de productos de Internet, MS International.
Este libro es genial. Es el tercer libro de Java que empezó y ya recorrió prácticamente dos
tercios. Espero acabar éste. Me he enterado de su existencia porque se usa en algunas clases internas de Lucen Technologies y un amigo me ha dicho que el libro estaba en la Red. Buen trabajo.
Jerry Nowlin, M13, Tecnologías Lucent.
De los aproximadamente seis libros de Java que he acumulado hasta la fecha, tu Piensa en Java es
sin duda el mejor y el más claro. Michael Van Waas, médico, presidente, TMR Associates.
Simplemente quiero darte las gracias por Piensa en Java. ¡Qué libro tan maravilloso ha hecho! iY
¡Para qué mencionar el poder bajárselo gratis! Como estudiante creo que tus libros son de valor incalculable, tengo una copia de C++ Inside & Out, otro gran libro sobre C++), porque no sólo me enseñan el cómo hacerlo, sino que también los porqués, que sin duda son muy importantes a la hora
de sentar unas buenas bases en lenguajes como C++ y Java. Tengo aquí bastantes amigos a los que
les encanta programar como a mí, y les he hablado de tus libros. ¡Todos piensan que son geniales!
Por cierto, soy indonesia y vivo en Java. Ray Frederick Djajadinata, estudiante de la Universidad Trisakti, Yakarta.
El mero hecho de que hayas hecho que este trabajo esté disponible gratuitamente en la Red me deja
conmocionado. Pensé que debía decirte cuánto aprecio yrespeto lo que estás haciendo. Shane KeBouthillier, estudiante de Ingeniería en Informática, Universidad de Alberta, Canadá.
Tengo que decirte cuánto ansío leer tu columna mensual. Como novato en el mundo de la programación orientada a objetos, aprecio el tiempo y el grado de conocimiento que aportas en casi todos.
los temas elementales. He descargado tu libro, pero puedes apostar a que compraré una copia en
papel en cuanto se publique. Gracias por toda tu ayuda. Dan Cashmer, DC Ziegler & Co.
Simplemente quería felicitarte por el buen trabajo que has hecho. Primero me recorri la versión PDF
de Piensa en Java. Incluso antes de acabar de leerla, corrí a la tienda y compré Thinking in C++. Ahora que llevo en el negocio de la informática ocho años, como consultor, ingeniero de software, profesor/formador, y últimamente autónomo, creo que puedo decir que he visto suficiente (fíjate que no
digo haber visto "todo" sino suficiente). Sin embargo, estos libros hacen que mi novia me llame
"geek. No es que tenga nada contra el concepto en sí -simplemente pensaba que ya había dejado
atrás esta fase. Pero me veo a mí mismo disfrutando sinceramente de ambos libros, de una forma que
no había sentido con ningún otro libro que haya tocado o comprado hasta la fecha. Un estilo de escritura excelente, una introducción genial de todos los temas y mucha sabiduría en ambos textos.
Bien hecho. Simon Goland, simonsez@smartt.com, Simon Says Consulting, Inc.
Comentarios de los lectores xxxiii
¡Debo decir que tu Piensa en Java es genial! Es exactamente el tipo de documentación que buscaba. Especialmente las secciones sobre los buenos y malos diseños basados en Java. Dirk Dühr,
Lexikon Verlag, Bertelsmann AG, Alemania.
Gracias por escribir dos grandes libros (Thinking in C++, Piensa en Java). Me ha ayudado inmensamente en mi progresión en la programación orientada a objetos. Donald Lawon, Empresas DCL.
Gracias por tomarte el tiempo de escribir un libro de Java que ayuda verdaderamente. Si enseñas
hace que aprendas algo, tú ya debes estar más que satisfecho. Dominic Turner, soporte de GEAC.
Es el mejor libro de Java que he leído jamás -y he leído varios. Jean-Yves MENGANT, Jefe
Arquitecto de Software NAT-SYSTEM, París, Francia.
Piensa en Java proporciona la mejor cobertura y explicación. Muy fácil de leer, y quiero decir que
esto se extiende también a los fragmentos de código. Ron Chan, Ph. D., Expert Choice Ind.,
Pittsburg PA.
Tu libro es genial. He leído muchos libros de programación y el tuyo sigue añadiendo luz a la programación en mi mente. Ningjian Wang, ingeniero de sistemas de información, The Vanguard Group.
Piensa en Java es un libro excelente y legible. Se lo recomiendo a todos mis alumnos. doctor pablo
Gorman, Departamento de Ciencias de la Computación, Universidad de Otago, Dunedin, Nueva Zelanda.
Haces posible que exista el proverbial almuerzo gratuito, y no simplemente una comida basada en
sopa de pollo, sino una delicia de gourmet para aquellos que aprecian el buen software y los libros.
sobre él mismo. José Suriol, Corporación Scylax.
¡Gracias por la oportunidad de ver cómo este libro se convierte en una obra maestra! ES EL MEJOR libro de la materia que he leído o recorrido. Jeff Lapchinsky, programador, Net Result
Tecnologías.
Tu libro es conciso, accesible y gozoso de leer. Keith Ritchie, Investigación y desarrollo de Java
Equipo, KL Group Inc.
¡ES sin duda el mejor libro de Java que leyó! Daniel Ing.
¡ES el mejor libro de Java que he visto! Rich Hoffarth, arquitecto senior, West Group.
Gracias por un libro tan magnífico. Estoy disfrutando mucho a medida que leo capítulos. fred
Trimble, Actium Corporation.
Has llegado a la maestría en el arte de hacernos ver los detalles, despacio y con éxito. Haces que la
La lectura es MUY fácil y satisfactoria. Gracias por un tutorial tan verdaderamente maravilloso. Rajesh Rau, consultor de software.
¡Piensa en Java es un rock para el mundo libre! Miko O'Sullivan, presidente, Idocs Inc.
xxxiv Piensa en Java
Sobre pensar en C++:
¡El mejor libro! Ganador en 1995 del Jolt Award de la revista Software Development!
"Este libro es un tremendo logro. Deberías tener una copia en el estante. El capítulo sobre flujos
de E/S presenta el tratamiento más comprensible y fácil de entender sobre ese tema que jamás haya haya
visto."
Al Stevens
Editor, Revista Doctor Dobbs
"El libro de Eckel es el único que explica claramente cómo replantearse la construcción de programas para la orientación a objetos. Que el libro es también un tutorial excelente en las entradas y en
las salidas de C++ es un valor agregado."
Andres Binstock
Editor, revisión de Unix
"Bruce continúa deleitándome con esta introspección de C++, y Thinking in C++ es la mejor colección de ideas hasta la fecha. Si se desean respuestas rápidas a preguntas difíciles sobre C++, compre este libro tan sobresaliente."
Gary Entsminger
Autor, El Tao de los Objetos
"Thinking in C++" explora paciente y metódicamente los aspectos de cuándo y cómo usar los interlineado~, referencias, sobrecargas de operadores, herencia, y objetos dinámicos, además de temas
avanzados como el uso adecuado de plantillas, excepciones y la herencia múltiple. Todo el esfuerzo
se centra en un producto que engloba la propia filosofía de Eckel del diseño de objetos y programas.
Un libro que no debe faltar en la librería de un desarrollador de C++, Piensa en Jaua es el libro de
C++ que hay que tener si se están haciendo desarrollos serios con C++."
Richard Hale Shaw
Ayudante del Editor, Revista PC
Introducción
Como cualquier lenguaje humano, Java proporciona una forma de expresar conceptos. Si tiene éxito, la expresión media será significativamente más sencilla y
más flexible que las alternativas, a medida que los problemas crecen en tamaño
y complejidad.
No podemos ver Java como una simple colección de características -algunas de las características
no tienen sentido aislado. Se puede usar la suma de partes sólo si se está pensando en diseño, y no
simplemente en codificación. Y para entender Java así, hay que entender los problemas del lenguaje y de la programación en general. Este libro habla acerca de problemas de programación, por qué
son problemas y el enfoque que Java sigue para solucionarlos. Por consiguiente, algunas características que explícitas en cada capítulo se basan en cómo yo veo que se ha solucionado algún problema en particular con el lenguaje. Así, espero conducir poco a poco al lector, hasta el punto en que
Java se convierte en lengua casi materna.
Durante todo el tiempo, estará tomando la actitud de que el lector construye un modelo mental que
le permitirá desarrollar un entendimiento profundo del lenguaje; si se encuentra un rompecabezas se podrá
alimentar de éste al modelo para tratar de deducir la respuesta.
Prerrequisitos
Este libro asume que se tiene algo de familiaridad con la programación: se entiende que un programa es una colección de sentencias, la idea de una subrutina/función/macro, sentencias de control como "ir' y bucles estilo " while ", etc. Sin embargo, se podría haber aprendido esto en muchos
sitios, como, por ejemplo, la programación con un lenguaje de macros o el trabajo con una herramienta como Perl. A medida que se programa hasta el punto en que uno se siente cómodo con las
Ideas básicas de programación, se podrá ir trabajando a través de este libro. Por supuesto, el libro
Será más fácil para los programadores de C y aún más para los de C++, pero tampoco hay por qué.
excluirse a sí mismo cuando se desconocen estos lenguajes (aunque en este caso es necesario tener la voluntad de trabajar duro; además, el CD multimedia que acompaña a este texto te permitirá
conocer rápidamente los conceptos de la sintaxis de C necesarios para aprender Java). presentaré
los conceptos de la programación orientada a objetos (POO) y los mecanismos de control básicos
de Java, para tener conocimiento de ellos, y los primeros ejercicios implicarán las secuencias de flujo de control básico.
Aunque a menudo aparecerán referencias a aspectos de los lenguajes C y C++, no deben tomarse
como comentarios profundos, sino que tratan de ayudar a los programadores a poner Java en perspectiva con esos lenguajes, de los que, después de todo, es de los que desciende Java. Intentaré hacer que estas referencias sean lo más simples posibles, y explicar cualquier cosa que cree que una
persona que no haya programado nunca en C o C++ pueda desconocer.
xxxvi Piensa en Java
Aprendiendo Java
Casi a la vez que apareció mi primer libro Usando C++ (Osborne/McGraw-Hill, 1989), empecé a enseñar ese lenguaje. Enseñar lenguajes de programación se ha convertido en mi profesión; el vio
cabezas dudosas, caras en blanco y expresiones de rompecabezas en audiencias de todo el mundo desde
1989. A medida que empecé con formación in situ a grupos de gente más pequeños, descubre algo
en los ejercicios. Incluso aquelloslos que sonreían tenían pegas con muchos aspectos. Al dirigir la sesión de C++ en la Software Development Conference durante muchos años (y después la sesión de
Java), descubrí que tanto yo como otros oradores tendíamos a ofrecer a la audiencia, en general,
Muchos temas demasiado rápido. Por tanto, a través, tanto de la variedad del nivel de audiencia
como de la forma de presentar el material, siempre se acababa perdiendo parte de la audiencia. Quizás es pedir demasiado, pero dado que soy uno de ésos que se resisten a las conferencias tradicionales (y en la mayoría de casos, creo que esta resistencia proviene del aburrimiento), quería intentar algo que permitiera tener a todo el mundo enganchado.
Durante algún tiempo, creé varias presentaciones diferentes en poco tiempo. Por consiguiente, acabé aprendiendo a base de experimentación e iteración (una técnica que también funciona bien en
un diseño de un programa en Java). Eventualmente, desarrollé un curso usando todo lo que había
Algo que me gustaría hacer durante bastante tiempo. Descompone el problema de aprendizaje en pasos discretos, fáciles de digerir, y en un minutoario en máquina (la situación ideal de aprendizaje) hay ejercicios seguidos cada uno de pequeñas lecciones. Ahora doy cursos en seminarios públicos de Java, que pueden encontrarse en
http://www.BruceEckel.com. (El seminario introductorio también está disponible como un CD
ROM. En el sitio web se puede encontrar más información al respecto.)
La respuesta que voy obteniendo de cada seminario me ayuda a cambiar y reenfocar el material hasta que creo que funciona bien como medio docente. Pero este libro no es simplemente un conjunto
de notas de los seminarios -intenté empaquetar tanta información como pude en este conjunto de
páginas, estructurándola de forma que cada tema te vaya conduciendo al siguiente. Más que otra
cosa, el libro está diseñado para servir al lector solitario que se está enfrentando y dando golpes con
un nuevo lenguaje de programación.
Objetivos
Como en mi libro anterior Thinking in C++, este libro pretende estar estructurado en torno al proceso de enseñanza de un lenguaje. En particular, mi motivación es crear algo que me proporcione.
una forma de enseñar el lenguaje en mis propios seminarios. Cuando pienso en un capítulo del libro, lo pienso en términos de lo que constituiría una buena lección en un seminario. Mi objetivo es
lograr fragmentos que puedan enseñarse en un tiempo razonable, seguidos de ejercicios que sean
Fáciles de llevar a cabo en clase.
Mis objetivos en este libro son:
1. Presentar el material paso a paso de forma que se pueda digerir fácilmente cada concepto antes de avanzar.
Introducción xxxvii
2. Utilizar ejemplos que sean tan simples y cortos como se pueda. Esto evita en ocasiones problemas del "mundo real", pero descubrió que los principiantes suelen estar más.
contentos cuando pueden entender todos los detalles de un ejemplo que cuando se ven impresionados por el gran rango del problema que solucionan. Además, hay una limitación severa de cara a la cantidad de código que se puede absorber en una clase. Por ello, no dudaré
en recibir críticas por usar "ejemplos de juguete", sino que estoy deseoso de aceptarlas en aras
de lograr algo pedagógicamente útil.
3. Secuenciar cuidadosamente la presentación de características de forma que no se esté viendo
algo que aún no se ha expuesto. Por supuesto, esto no es siempre posible; en esas situaciones
sc da11 br-cves descr-ipcioiies iiitr-oductoi-ias.
4. Dar lo que yo considero que es importante que se entienda del lenguaje, en lugar de todo lo
Que se. Creo que hay una jerarquía de importancia de la información, y que hay hechos que
el 95% de los programadores nunca necesitarán saber y que simplemente confunden a la gente y añaden su percepción de la complejidad del lenguaje. Por tomar un ejemplo de C, si se
memoriza la tabla de precedencia de los operadores (algo que yo nunca hice) se puede escribir un código más inteligente. Pero si se piensa en ello, también confundirá la legibilidad y
mantenibilidad de ese código. Por tanto, hay que olvidarse de la precedencia, y usar paréntesis cuando las cosas no estén claras.
5. Mantener cada sección lo suficientemente enfocada de forma que el tiempo de exposición
-el tiempo entre periodos de ejercicios- sea pequeño. Esto no sólo mantiene más activas
las mentes de la audiencia, que están en un seminario en máquina, sino que también transmiten más sensación de avanzar.
6. Proporcionar una base sólida que permita entender los aspectos lo suficientemente bien como
para avanzar a cursos y libros más difíciles.
Documentación en línea
El lenguaje Java y las bibliotecas de Sun Microsystems (de descarga gratuita) vienen con su documentación en forma electrónica, legible utilizando un navegador web, y casi toda la implementación de
Java de un tercero tiene éste u otro sistema de documentación equivalente. Casi todos los libros publicados de Java, incorporan esta documentación. Por tanto, o ya se tiene, o se puede descargar, y a
menos que sea necesario, este libro no repetirá esa documentación pues es más rápido encontrar
las descripciones de las clases en el navegador web que buscarlas en un libro Cy la documentación
en línea probablemente estará más actualizado). Este libro proporcionará alguna descripción adicional.
de las clases sólo cuando sea necesario para complementar la documentación, de forma que se pueda entender algún ejemplo particular.
xxxviii Piensa en Java
Capítulos
Este libro se diseñó con una idea en la cabeza: la forma que tiene la gente de aprender Java. La realización de la audiencia de mis seminarios me ayudó a ver las partes difíciles que necesitaban.
aclaraciones. En las áreas en las que me volvía ambiguo e incluían varias características a la vez, descubrí -a través del proceso de presentación el material- que si se incluyen muchas características de
golpe, hay que explicarlas todas, y esto suele conducir fácilmente a la confusión por parte del alumno. Como resultado, tuvo bastantes problemas para presentar las características agrupadas de
tan pocas en pocas como me hasido posible.
El objetivo, por tanto, es que cada capítulo enseña una única característica, o un pequeño grupo de
características asociadas, sin pasar a características adicionales. De esa forrria se puede diger-ir- cada
fragmento en el contexto del conocimiento actual antes de continuar.
He aquí una breve descripción de los capítulos que contiene el libro, que corresponden a las conferencias y periodos de ejercicio en mis seminarios en máquina.
Capítulo 1: Introducción a los objetos
Este capítulo presenta un repaso de lo que es la programación orientada a objetos, incluyendo la respuesta a la cuestión básica "¿Qué es un objeto?", interfaz frente a implementación, abstracción y
encapsulación, mensajes y funciones, herencia y composición, y la importancia del polimorfismo.
También se obtendrá un repaso a los aspectos de la creación de objetos como los constructores, en
los que residen los objetos, dónde ponerlos una vez creados, y el mágico recolector de basura que
limpie los objetos cuando dejan de ser necesarios. Se presentarán otros aspectos, incluyendo el manejo de errores con excepciones, el multihilo para interfaces de usuario con buen grado de respuesta, y las redes e Internet. Se aprenderá qué convierte a Java en especial, por qué ha tenido tanto éxito, y también algo sobre análisis y diseño orientado a objetos.
Capítulo 2: Todo es un objeto
Este capítulo te lleva al punto donde tú puedas crear el primer programa en Java, por lo que debes dar
un repaso a lo esencial, incluyendo el concepto de referencia a un objeto; cómo crear un objeto; una
introducción de los tipos primitivos y arrays; el alcance y la forma en que destruye los objetos el recolector de basura; cómo en Java todo es un nuevo tipo de datos (clase) y cómo crear cada uno sus
clases propias; funciones, argumentos y valores de retorno; visibilidad de nombres y el uso de componentes de otras bibliotecas; la palabra clave estática; y los comentarios y documentación embebida.
Capítulo 3: Controlando el flujo
de los programas
Este capítulo comienza con todos los operadores que provienen de C y C++. Además, se descubrirán los fallos de los operadores comunes, la conversión de tipos, la promoción y la precedencia. Des-
Introducción xxxix
pués se presentan las operaciones básicas de control de flujo y selección existentes en casi todos los
lenguajes de programación: la opción con if-else; los bucles con while y for; cómo salir de un bucle
con break y continue, además de sus versiones etiquetadas en Java (que vienen a sustituir al "goto
perdido" en Java); la selección con switch. Aunque gran parte de este material tiene puntos comunes con el código de C y C++, hay algunas diferencias. Además, todos los ejemplos serán hechos
completamente en Java por lo que el lector podrá estar más entusiasmado con la apariencia de Java.
Capítulo 4: Inicialización y limpieza
Este capítulo comienza presentando el constructor, que garantiza una inicialización adecuada. La definición de constructor conduce al concepto de sobrecarga de funciones (puesto que puede haber
varios constructores). Este viene seguido de una discusión del proceso de limpieza, que no siempre
es tan simple como parece. Normalmente, simplemente se desecha un objeto cuando se ha terminado con él y el recolector de basura suele aparecer para liberar la memoria. Este apartado explora el
recolector de basura y algunas de sus idiosincrasias. El capítulo concluye con un vistazo más cercano a cómo se inicializan las cosas: inicialización automática de miembros, especificación de inicialización de miembros, el orden de inicialización, la inicialización estática y la inicialización de
matrices.
Capítulo Ocultando implementación
Este capítulo cubre la forma de empaquetar junto al código, y por qué algunas partes de una biblioteca están expuestas a la vez que otras partes están ocultas. Comienza repasando las palabras.
clave package e import, que llevan a cabo empaquetado a nivel de archivo y permiten construir bibliotecas de clases. Después de examinar el tema de las rutas de directorios y nombres de fichero. el
resto del capítulo echa un vistazo a las palabras clave public, private y protected, el concepto de
acceso "friendly", y qué significan los distintos niveles de control de acceso cuando se usan en los
conceptos distintos.
Capítulo 6: clases
El concepto de herencia es estándar en casi todos los lenguajes de POO. Es una forma de tomar una
clase existente y añadirla a su funcionalidad (además de cambiarla, que será tema del Capítulo 7).
La herencia es a menudo una forma de reutilizar código dejando igual la "clase base", y simplemente
parcheando los elementos aquí y allí hasta obtener lo deseado. Sin embargo, la herencia no es la
única forma de construir clases nuevas a partir de las existentes. También se puede empotrar un objeto dentro de una clase nueva con la composición. En este capítulo, se aprenderán estas dos formas.
de reutilizar código en Java, y cómo aplicarlas.
Capítulo 7: Polimorfismo
Cada uno por su cuenta, podría invertir varios meses para descubrir y entender el polimorfismo, claves en POO. A través de pequeños ejemplos simples, verás cómo crear una familia de tipos con
xl Piensa en Java
herencia y manipular objetos de esa familia a través de su clase base común. El polimorfismo de
Java permite tratar los objetos de una misma familia de forma genérica, lo que significa que la mayoría del código no tiene por qué depende de un tipo de información específica. Esto hace que los
los programas sean extensibles, por lo que se facilita y simplifica la construcción de programas y el
mantenimiento de código.
Capítulo 8: Interfaces y clases internas
Java proporciona una tercera forma de establecer una relación de reutilización a través de la interfaz, que es una abstracción pura de la interfaz de un objeto. La interfaz es más que una clase simple.
abstracta llevada al extremo, puesto que te permite hacer variaciones de la "herencia múltiple" de
C++, creando una clase sobre la que se puede hacer una conversión hacia arriba a más de una clase base.
A primera vista, las clases parecen un simple mecanismo de ocultación de código: se colocando clases
dentro de otras clases. Se aprenderá, sin embargo, que la clase interna hace más que eso -conoce
y puede comunicarse con la clase contenedora- y que el tipo de código que se puede escribir con
clases internas es más elegante y limpio, aunque es un concepto nuevo para la mayoría de la gente
y lleva tiempo llegar a estar cómodo utilizando el diseño clases internas.
Capítulo 9: Guardando tus objetos
Es un programa bastante simple que sólo tiene una cantidad fija de objetos de tiempo de vida conocido. En general, todos los programas irán creando objetos nuevos en distintos momentos, conocidos sólo cuando se está ejecutando el programa. Además, no se sabrá hasta el tiempo de ejecución.
la cantidad o incluso el tipo exacto de objetos que se necesitan. Para solucionar el problema de programación general, es necesario crear cualquier número de objetos, en cualquier momento y en
cualquier lugar. Este capítulo explora en profundidad la biblioteca de contenedores que proporciona Java 2 para almacenar objetos mientras se está trabajando con ellos: los simples arrays y contenedores más selectos (estructuras de datos) como ArrayList y HashMap.
Capítulo 10: Manejo de errores
con excepciones
La filosofía básica de Java es que el código mal formado no se ejecutará. En la medida en que sea
posible, el compilador detecta problemas, pero en ocasiones los problemas -debidos a errores del
programador o a condiciones de error naturales que ocurren como parte de la ejecución normal del
programa- pueden detectarse y ser gestionados sólo en el tiempo de ejecución. Java tiene el manejo
de excepciones para tratar todos los problemas que puedan surgir al ejecutar el programa. Este capítulo muestra cómo funcionan en Java las palabras clave try, catch, throw, throws y finalmente; cuando
se deben lanzar excepciones y qué hacer al capturarlas. Además, se verán las excepciones estándar de Java, cómo crear las tuyas propias, qué ocurre con las excepciones en los constructores y
cómo se ubican los gestores de excepciones.
Introducción xli
Capítulo 11: El sistema de E/S de Java
Teóricamente, se puede dividir cualquier programa en tres partes: entrada, proceso y salida. esto
implica que la E/S (entrada/salida) es una parte importante de la ecuación. En este capítulo se
Aprenderá las distintas clases que proporciona Java para leer y escribir ficheros, bloques de memoria y la consola. También se mostrará la distinción entre E/S "antigua" y "nueva". Además, este capítulo examina el proceso de tomar un objeto, pasarlo a una secuencia de bytes (de forma que pueda ser ubicado en el disco o enviado a través de una red) y reconstruirlo, lo que realiza.
serialización automática de objetos de Java. Además, se examinan las bibliotecas de compresión de Java, que se usan en el formato de archivos de Java CJAR).
Capítulo 12: Identificación de tipos en tiempo
de ejecución
La identificación de tipos en tiempo de ejecución (RTTI) te permite averiguar el tipo exacto de un
objeto cuando se tiene sólo una referencia al tipo base. Normalmente, se deseará ignorar intencionadamente el tipo exacto de un objeto y dejar que sea el mecanismo de asignación dinámica de Java.
(polimorfismo) el que implementa el comportamiento correcto para ese tipo. A menudo, esta información te permite llevar a cabo operaciones de casos especiales, más eficientemente. Este capitulo
Explica para qué existe la RTTI, cómo usarla y cómo librarse de él cuando sobra. Además, este capítulo presenta el mecanismo de reflectividad de Java.
Capítulo 13: Creación de ventanas y applets
Java viene con la biblioteca IGU Swing, que es un conjunto de clases que manejan las ventanas de
formato portátil. Estos programas con Windows pueden o bien ser applets o bien aplicaciones independientes. Este capítulo es una introducción a Swing y a la creación de applets de World Wide
Web. Se presenta la importante tecnología de los "JavaBeansn, fundamental para la creación de herramientas de construcción de programas de Desarrollo Rápido de Aplicaciones (RAD).
Capítulo 14: Hilos Múltiples
Java proporciona una utilidad preconstruida para el soporte de múltiples subtareas concurrentes denominadas hilos, que se ejecutan en un único programa. (A menos que se disponga de Múltiples procesadores en la máquina, los Múltiples hilos sólo son aparentes.) Aunque éstas pueden usarse en todas partes, los hilos son más lucidos cuando se intenta crear una interfaz de usuario con alto grado
de respuesta, de forma que, por ejemplo, no se evita que un usuario pueda presionar un botón o introducir datos mientras se está llevando a cabo algún procesamiento. Este capítulo echa un vistazo.
a la sintaxis y la semántica del multihilo en Java.
xlii Piensa en Java
Capítulo 15: Computación distribuida
Todas las características y bibliotecas de Java aparecen realmente cuando se empieza a escribir programas que funcionan en red. Este capítulo explora la comunicación a través de redes e Internet, y
las clases que proporciona Java para facilitar esta labor. Presenta los tan importantes conceptos de
Serulets y JSP (para programación en el lado servidor), junto con Java DataBase Connectiuity CJDBC)
y el Información de método remoto (RMI). Finalmente, hay una introducción a las nuevas tecnologías de
JINI, JauaSpaces y Enterprise JavaBeans (EJBS).
Apéndice A: Paso y retorno de objetos
Puesto que la única forma de hablar con los objetos en Java es mediante referencias, los conceptos
de paso de objetos a una función y de devolución de un objeto de una función tienen algunas consecuencias interesantes. Este apéndice explica lo que es necesario saber para gestionar objetos.
cuando se está entrando y saliendo de funciones, y también muestra la clase String, que usa un enfoque distinto al problema.
Apéndice B: La Interfaz Nativa de Java (JNI)
Un programa Java totalmente portátil tiene importantes pegas: la velocidad y la incapacidad.
para acceder a servicios específicos de la plataforma. Cuando se conoce la plataforma sobre la
que está ejecutando, es posible incrementar dramáticamente la velocidad de ciertas operaciones
construyendo como métodos nativos, que son funciones escritas en otro lenguaje de programación (actualmente, sólo están soportados C/C++). Este apéndice de una introducción más que
satisfactorio que debería ser capaz de crear ejemplos simples que sirvan de interfaz con código
sin Java.
Apéndice C: Guías de programación Java
Este apéndice contiene sugerencias para guiarle durante la realización del diseño de programas de
bajo nivel y la escritura de código.
Apéndice D: Lecturas recomendadas
Una lista de algunos libros sobre Java que encontró particularmente útiles.
tjercicios
He descubierto que los ejercicios simples son excepcionalmente útiles para completar el entendimiento de los estudiantes durante un seminario, por lo que se encontrará un conjunto de ellos al final de cada capítulo.
Introducción xliii
La mayoría de los ejercicios están diseñados para ser lo suficientemente sencillos como para poder ser
resueltos en un tiempo razonable en una situación de clase mientras que observa al profesor, asegurándose de que todos los alumnos asimilen el material. Algunos ejercicios son más avanzados
para evitar que los alumnos experimentados se aburran. La mayoría están diseñadas para ser resueltas en poco tiempo y probar y pulir el conocimiento. Algunos suponen un reto, pero ninguno
presenta dificultades excesivas. (Presumiblemente, cada uno podrá encontrarlos -o más probablemente te encontrarán ellos a ti.)
En el documento electrónico The Thinking in Java Annotated Solution Guide pueden encontrarse
soluciones a ejercicios seleccionados, disponibles por una pequeña tasa en http://www.BruceEckeI.com.
CD-ROM Multimedia
Hay dos CD multimedia asociados con este libro. El primero está en el propio libro: Thinking in C,
descritos al final del prefacio. que te preparan para el libro aportando velocidad en la sintaxis de C
necesario para poder entender Java.
Hay disponible un segundo CD ROM multimedia, basado en los contenidos del libro. Este CD-ROM
es un producto separado y contiene los contenidos enteros del seminario de formación "Hands-On
Java" de una semana de duración. Esto son grabaciones de conferencias de más de 15 horas que he
grabado, y sincronizado con cientos de diapositivas de información. Dado que el seminario se basa
en este libro, es el acompañamiento ideal.
El CD ROM contiene todas las conferencias (¡con la importante excepción de la atención personalizada!) de los seminarios de cinco días de inmersión total. Creemos que establece un nuevo estándar de calidad.
El CD ROM "Hands-On Java" está disponible sólo bajo pedido, que se cursa directamente del sitio
web http://llwww.BruceEckel.com.
código fuente
Todo el código fuente de este libro está disponible de modo gratuito sometiendo un copyright, distribuido como un paqueteúnico, visitando el sitio web http://www.BruceEcke1.com. Para asegurarse de
obtener la versión más actual, éste es el lugar oficial para distribución del código y de la versión
electronica del libro. Se pueden encontrar versiones espejo del código y del libro en otros sitios (algunos de éstos están referenciados en http://www. BruceEckel.com), pero habría que comprobar el
sitio oficial para asegurarse de obtener la edición más reciente. El código puede distribuirse en clases y en otras situaciones con multas educativas.
La meta principal del copyright es asegurar que el código fuente se cite adecuadamente, y prevenir
que el código se vuelva a publicar en medios impresos sin permiso. (Mientras se cite la fuente, utilizando los ejemplos del libro, no habrá problema en la mayoría de los medios.)
En cada fichero de código fuente, se encontrará una referencia a la siguiente nota de copyright:
xliv Piensa en Java
:! :CopiarDerecho.txt
Copyright (c) 2000 Bruce Eckel
Archivo de código fuente de la segunda edición del libro.
"Pensamiento en Java." Todos los derechos reservados EXCEPTO como
permitido por las siguientes declaraciones:
Puedes utilizar libremente este archivo.
para su propio trabajo (personal o comercial),
incluyendo modificaciones y distribución en
formato ejecutable únicamente. Se concede permiso para utilizar
este archivo en situaciones de aula, incluyendo su
uso en materiales de presentación, siempre y cuando el libro
Se cita como fuente "Thinking in Java".
Excepto en situaciones de aula, no puedes copiar
y distribuir este código; en cambio, la única
El punto de distribución es http://www.BruceEckel.com.
(y sitios espejo oficiales) donde está
disponible de forma gratuita. No puedes eliminar esto
derechos de autor y aviso. No puedes distribuir
versiones modificadas del código fuente en este
paquete. No puede utilizar este archivo en formato impreso.
medios sin el permiso expreso del
autor. Bruce Eckel no hace ninguna declaración sobre
la idoneidad de este software para cualquier propósito.
Se proporciona "tal cual" sin expresa o implícita
garantía de cualquier tipo, incluida cualquier garantía implícita
garantía de comerciabilidad, idoneidad para un
propósito particular o no infracción. La totalidad
riesgo en cuanto a la calidad y desempeño del
El software está contigo. Bruce Eckel y el
El editor no será responsable de ningún daño.
sufrido por usted o cualquier tercero como resultado de
utilizar o distribuir software. En ningún caso
Bruce Eckel o el editor serán responsables de cualquier
pérdida de ingresos, ganancias o datos, o por pérdida directa,
indirecta, especial, consecuente, incidental o
daños punitivos, cualquiera que sea su causa y con independencia de
La teoría de la responsabilidad, que surge del uso de
o incapacidad para utilizar software, incluso si Bruce Eckel
y el editor han sido informados de la
posibilidad de tales daños. ¿Debería el software
resulta defectuoso, usted asume el costo de todo1
servicio, reparación o corrección necesarios. Si usted
cree que ha encontrado un error, envíe el
corrección mediante el formulario que encontrará en
www.BruceEckel.com. (Por favor use el mismo
formulario para errores no relacionados con el código que se encuentran en el libro. )
///:-
Introducción xlv
El código puede usarse en proyectos y en clases (incluyendo materiales de presentación) mientras
se mantenga la observación de copyright que aparece en cada archivo fuente.
Estándares de codificación
En el texto de este libro, los identificadores (nombres de fimciones, variables y clases) están en negrita. La mayoría de las palabras clave también están en negrita, excepto en aquellos casos en que las palabras
se usan tanto que ponerlas en negrita podría volverse tedioso, como es el caso de la palabra "clase".
Para los ejemplos de este libro, utilice un estilo de codificación bastante particular. Este estilo sigue
al estilo que la propia Sun usa en prácticamente todo el código de sitio web (ver
http://]ava.sun.com/docs/codeconv/index.html), y parece que es1á suprimido por la mayoría de entornos de desarrollo Java. Si ha leído el resto de mis trabajos, también verá que el estilo de codificación de Sun coincide con el mío -esto me alegra, aunque no tenía nada que hacer con él. El aspecto del estilo de formato es bueno para lograr horas de tenso debate, por lo que simplemente diré
que no pretendo dictar un estilo correcto mediante mis ejemplos; tengo mi propia motivación para
usar el estilo que uso. Java es un lenguaje de programación de forma libre, se puede seguir usando
cualquier estilo con el que uno esté a gusto.
Los programas de este libro son archivos incluidos por el procesador de textos, directamente sacados de archivos compilados. Por tanto, los archivos de código impresos en este libro deben funcionar sin errores de compilador. Los errores que deben causar mensajes de error en el tiempo de
compilaciones están comentados o marcados mediante //!, por lo que pueden ser descubiertos fácilmente, y probados utilizando medios automáticos. Los errores descubiertos de los que ya se haya
informado al autor, aparecerán primero en el código fuente distribuido y posteriormente en actualizaciones del libro (que también aparecerán en el sitio web http:llwww.BruceEckel.com).
Versiones de Java
Generalmente confío en la implementación que Sun hace de Java como referencia para definir si un
determinado comportamiento es o no correcto.
Con el tiempo, Sun ha lanzado tres versiones principales de Java: la 1.0, la 1.1 y la 2 (que se llama
versión 2, incluso aunque las versiones del JDK de Sun siguen usando el esquema de numeración
de 1.2, 1.3, 1.4, etc.). La versión 2 parece llevar finalmente a Java a la gloria, especialmente en lo que
Concierne a las herramientas de interfaces. Este libro se centra en, y está probado con, Java 2, aunque en ocasiones hago concesiones a las características anteriores de Java 2, de forma que el código pueda compilarse bajo Linux (vía el JDK de Linux que estaba disponible en el momento de escribir el libro).
Si se necesita aprender versiones anteriores del lenguaje no cubiertas en esta edición, la primera
La edición del libro se puede descargar gratuitamente de http:llwww.BruceEckel.corn, y también está en
el CD adjunto a este libro.
xlvi Piensa en Java
Algo de lo que uno se dará cuenta es de que, cuando menciono versiones anteriores del lenguaje,
no utilice los números de subrevisión. En este libro me referiré sólo a Java 1.0, 1.1 y 2, para protegerme de errores tipográficos producidos por sub-revisiones posteriores de estos productos.
Seminarios y mi papel como mentor
Mi empresa proporciona seminarios de formación de cinco días, en máquina, públicos e in situ, basados en el material de este libro. El material determinado de cada capítulo representa una lección, seguido de un período de ejercicios guiados de forma que cada alumno recibe atención personal. Las
Las conferencias y las diapositivas del seminario introductorio también están en el CD ROM para proporcionales al menos alguna de la experiencia del seminario sin el viaje y el costo que conllevaría. Paraca
más información, visitando http:llwww.BruceEckel.corn.
Mi compañía también proporciona consultoría, servicios de orientación y acompañamiento para ayudar a guiar un proyecto a lo largo de su ciclo de desarrollo -especialmente indicado para el primer
proyecto en Java de una empresa.
Errores
Sin que importe cuántos trucos utilice un escritor para detectar errores, siempre hay alguno que se
Ahí queda y que algún lector encontrará.
Hay un formulario para remitir errores al principio de cada capítulo en la versión HTML del libro.
(y en el CD ROM unido al final de este libro, además de descargable de http:llwww.BruceEckel.corn)
y también en el propio sitio web, en la página correspondiente a este libro. Si se descubre algo que
Uno piense que puede ser un error, por favor, utilice el formulario para remitir el error junto con la
corrección sugerida. Si es necesario, incluya el archivo de código fuente original y cualquier modificación que se sugiera. Su ayuda será apreciada.
Nota sobre el diseño de la portada
La portada de Piensa en Java está inspirada en el American Arts & Crafts Movement, que se fundó.
al cambiar de siglo y alcanzó su cenit entre los años 1900 y 1920. Empezó en Inglaterra como una
reacción tanto a la producción de las máquinas de la Revolución Industrial y al estilo victoriano, excesivamente ornamental. Arts & Crafts hacía especial énfasis en el mero diseño, en las formas de la
naturaleza tal y como se ven en el movimiento del Art Nouveau, las manualidades y la importancia
del trabajo individual, y sin embargo sin renunciar al uso de herramientas modernas. Hay muchas
Réplicas con la situación de hoy en día: el cambio de siglo, la evolución de los principios puros de la
revolución de los computadores a algo más refinado y más significativo para las personas individuales, y el énfasis en el arte individual que hay en el software, frente a su simple fabricación.
Veo Java de esta misma forma: como un intento de elevar al programador más allá de la mecánica
de un sistema operativo y hacia el "arte del software".
Introducción xlvii
Tanto el autor como el diseñador del libro/portada (que han sido amigos desde la infancia) encuentran la inspiración en este movimiento, y ambos poseen muebles, lámparas y otros elementos.
que o bien son originales, o bien están inspirados en este período.
El otro tema de la cubierta sugiere una caja de colecciones que podría usar un naturalista para mostrar los especímenes de insectos que ha guardado. Estos insectos son objetos, ubicados dentro de
la caja de objetos. Los objetos caja están a su vez ubicados dentro del "objeto cubierta", que ilustra
el concepto fundamental de la agregación en la programación orientada a objetos. Por supuesto, un
programador no puede ayudar si no está produciendo "errores" en la asociación, y aquí los errores se
han capturado siendo finalmente confinados en una pequeña caja de muestra, como tratando de
mostrar la habilidad de Java para encontrar, mostrar y controlar los errores (lo cual es sin duda uno
de sus atributos más potentes).
Agradecimientos
En primer lugar, gracias a los asociados que han trabajado conmigo para dar seminarios, proporcionar consultoría y desarrollar productos de aprendizaje: Andrea Provaglio, Dave Bastlett (que también contribuyó significativamente al Capítulo 15), Bill Venners y Larry O'Brien. Aprecio tuyo
paciencia a medida que sigo intentando desarrollar el mejor modelo para que tipos tan independientes como nosotros podamos trabajar juntos. Gracias a Rolf André Klaedtke (Suiza); Martín
Vleck, Martin Byer, Vlada & Pavel Lahoda, Martin el Oso, y Hanka (Praga); y a Marco Cantu (Italia) por darme alojamiento durante mi primera gira seminario auto organizado por Europa.
Gracias a la Doyle Street Cohousing Community por soportarme durante los dos años que me llevó
escribir la primera edición de este libro (y por aguantarme en general). Muchas gracias a Kevin y
Sonda Donovan por subarrendarme su magnífico lugar en Creste Butte, Colorado, durante el verano mientras trabajaba en la primera edición del libro. Gracias también a los amigables residentes de
Crested Butte y al Rocky Mountain Biologial Laboratory que me hicieron sentir tan acogido.
Gracias a Claudette Moore de la Moore Literary Agency por su tremenda paciencia y perseverancia.
a la hora de lograr que yo hiciera exactamente lo que yo quería hacer.
Mis dos primeros libros se publicaron con Jeff Pepper como editor de Osborne/McGraw-Hill. jeff
apareció en el lugar oportuno y en la hora oportuna en Prentice-Hall y me ha allanado el camino y
ha hecho que ocurrió todo lo que tenía que ocurrir para que ésta se convierta en una experiencia
La publicación es agradable. Gracias, Jeff, significa mucho para mí.
Estoy especialmente en deuda con Gen Kiyooka y su compañía, Digigami, que me proporcionó gentilmente mi primer servidor web durante los muchos años iniciales de presencia en la Web. esto
constituyó una ayuda de valor incalculable.
Gracias a Cay Hostmann (coautor de Core Java, Prentice-Hall, 2000), D'Arcy Smith (Symantec) y
Paul Tyma (coautor de Java Primer Plus, The Waite Group, 1996), por ayudarme a aclarar conceptos sobre el lenguaje.
xlviii Piensa en Java
Gracias a la gente que ha hablado en mi curso de Java en la Software Development Conference, y a
los alumnos de mis cursos, que realizan las preguntas que necesito oír para poder hacer un material más claro.
Gracias espaciales a Larry y Tina O'Brien, que me ayudaron a volcar mis seminarios en el CD ROM
Java práctico original. (Puede encontrar más información en http:llwww.BruceEckel.com.)
Mucha gente me envió correcciones y estoy en deuda con todos ellos, pero envío gracias en particular a (por la primera edición): Kevin Raulerson (encontró cientos de errores enormes), Bob Resendes (simplemente increíble), John Pinto, Joe Dante, Jose Sharp (los tres son fabulosos), David
Coms (muchas correcciones gramaticales y aclaraciones), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennos P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson y otros muchos. El profesor Marc Meurrens puso gran cantidad de
esfuerzo en publicitar y hacer disponible la versión electrónica de la primera edición del libro en
toda Europa.
Ha habido muchísimos técnicos en mi vida que se han convertido en amigos y que también han
sido, tanto influyentes, como inusuales por el hecho de que hacen yoga y practican otras formas de
Ejercicio espiritual, que yo también encuentro muy instructivo e inspirador. Son Karig Borckschmidt, Gen Kiyooka y Andrea Provaglio, (que ayuda en el entendimiento de Java y en la programación general en Italia, y ahora en los Estados Unidos como un asociado del equipo MindView).
No es que me haya sorprendido mucho que entender Delphi me ayudará a entender Java, pues tienen muchas decisiones de diseño del lenguaje en común. Mis amigos de Delphi me proporcionaron
ayuda facilitándome a alcanzar profundidad en este entorno de programación tan maravilloso. Hijo
Marco Cantu (otro italiano -¿quizás aprender latín es una ayuda para entender los lenguajes de
programación?), Neil Rubenking (que solía hacer yoga, era vegetariano,... hasta que descubrió los
computadores) y por supuesto, Zack Urlocker, un colega de hace tiempo con el que me he movido
por todo el mundo.
Las opiniones y el soporte de mi amigo Richard Hale Shaw han sido de mucha ayuda (y la de Kim
también). Richard y yo pasamos muchos meses dando seminarios juntos e intentando averiguar cuál
era la experiencia de aprendizaje perfecta desde el punto de vista de los asistentes. Gracias a KoAnn
Vikoren, Eric Faurot, Marco Pardi, y el resto de equipo y tripulación de MFI. Gracias especialmente a Tara Arrowood, que me volvió a inspirar en las posibilidades de las conferencias.
El diseño del libro, de la portada y la foto de ésta fueron creados por mi amigo Daniel Hill-Harris.
autor y diseñador de renombre (http:llwww.Wil-Harris.com), que solía jugar con letras de goma en
el colegio mientras esperaba a que se inventaran los computadoresy los ordenadores personales, y
Se quejaba de que yo siempre estaría enmarañado con mis problemas de álgebra. Sin embargo,
he producido páginas listas para la cámara por mí mismo, por lo que los errores de tipografía son
míos. Para escribir el libro se us6 Microsoft 8 Word 97 para Windows, y para crear páginas listas para
fotógrafo en Adobe Acrobat; el libro se creó directamente a partir de los ficheros Acrobat PDE
(Como un tributo a la edad electrónica, estuve fuera en las dos ocasiones en que se produjo la versión final del libro -la primera edición se envío desde Capetown, Sudáfrica, y la segunda edición se
Introducción xlix
envío desde Praga.) La tipología del cuerpo es Georgia y los títulos están en Vérdana. La tipografia
de la portada es ITC Rennie Mackintosch.
Gracias a los vendedores que crearon los compiladores. Borland, el Blackdown Group (para Linux),
y por supuesto, Sun.
Gracias especiales a todos mis profesores y alumnos (que son a su vez mis profesores). la persona
que me enseñó a escribir fue Gabrielle Rico (autora de Writing the Natural Way, Putnam, 1985).
Siempre guardaré como un tesoro aquella terrorífica semana en Esalen.
El conjunto de amigos que me han ayudado incluyen, sin ser los únicos a: Andrew Binstock, Steve
Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinckely Barr, Hill Gates de Midnight
Revista de Ingeniería, Larry Constantine y Lucy Lockwood, Grez Perry, Dan Putterman, Christi
Westphal, GeneWang, Dave Mayer, David Intersiomne, Andrea Rosenfield, Claire Sawyers, más italianos (Laura Fallai, Corrado, ILSA y Cristina Guistozzi). Chris y Laura Strand, los Alrnquists, Brad
Jerbic, Marilyn Cvitanic, los Mabrys, los Haflingers, los Pollocks, Peter Vinci, las familias Rohhins,
las familias Moelter (y los McMillans), Michael Wilk, Dave Stoner, Laurie Adams, los Cranstons,
Larry Fogg, Mike y Karen Sequeiro, Gary Entsminger y Allison Brody, Kevin Donovan y Sonda Eastlack, Chester y Shannon Andersen, Joe Lordy, Dave y Brenda Bartlett, David Lee, los Rentschlers,
los Sudeks, Dick, Patty y Lee Eckel, Lynn y Todd y sus familias. Y por supuesto, papá y mamá.
Colaboradores Internet
Gracias a aquellos que me han ayudado a reescribir los ejemplos para usar la biblioteca Swing, y por
cualquier otra ayuda: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajes Jain, Ravi Manthena, Banu
Rajarnani, Jens Brandt, Mitin Shivaram, Malcolm Davis y todo el mundo que mostró su apoyo. Verdaderamente, esto me ayudó a dar el primer salto.

1: Introducción
a los objetos
La génesis de la revolución de los computadores se encontró en una máquina,
y por ello, la génesis de nuestros lenguajes de programación tiende a parecerse
a esa máquina.
Pero los computadores, más que máquinas, pueden considerarse como herramientas que permiten
ampliar la mente ("bicicletas para la mente", como se enorgullece de decir Steve Jobs), además de
un medio de expresión inherentemente diferente. Como resultado, las herramientas empiezan a parecerse menos a máquinas y más a partes de nuestra mente, al igual que ocurre con otros medios.
de expresión como la escritura, la pintura, la escultura, la animación o la filmación de películas. La
La programación orientada a objetos (POO) es una parte de este movimiento dirigida a utilizar los ordenadores como si de un medio de expresión se tratara.
Este capítulo introducirá al lector en los conceptos básicos de la POO, incluyendo un repaso a los métodos de desarrollo. Este capítulo y todo el libro, toman como premisa que el lector ha tenido experiencia en algún lenguaje de programación procedural (por procedimientos), sea C u otro lenguaje.
Si el lector considera que necesita una preparación mayor en programación y/o en la sintaxis de C
antes de enfrentarse al presente libro, se recomienda hacer uso del CD ROM formativo Thinking in
C: Foundations for C++ and Java, que se adjunta con el presente libro, y que puede encontrarse también con la URL, http://www. BruceEckel.com.
Este capítulo contiene material suplementario, o de trasfondo (antecedentes). Mucha gente no se siente cómoda cuando se enfrenta a la programación orientada a objetos si no entiende su contexto, a
grandes rasgos, previamente. Por ello, se presentan aquí numerosos conceptos con la intención de
proporcionar un repaso sólido a la POO. No obstante, también es frecuente encontrar a gente que
no acaba de comprender los conceptos hasta que tiene acceso a los mecanismos; estas personas
Suelen perderse si no se les ofrece algo de código que puedan manipular. Si el lector se siente identificado con este último grupo, estará ansioso por tomar contacto con el lenguaje en sí, por lo que
debe sentirse libre de saltarse este capítulo -lo cual no tiene por qué influir en la comprensión que
finalmente se adquiera del lenguaje o en la capacidad de escribir programas en él mismo. Sin embargo, tarde o temprano tendrá necesidades ocasionales de volver aquí, para completar sus nociones en aras de lograr una mejor comprensión de la importancia de l.os objetos y de la necesidad de
comprender cómo acometer diseños haciendo uso de ellos.
El progreso de la abstracción
Todos los lenguajes de programación proporcionan abstracciones. Puede incluso afirmar que la
La complejidad de los problemas a resolver es directamente proporcional a la clase (tipo) y calidad de
las abstracciones a utilizar, entendiendo por tipo "clase", aquello que se desea abstraer. El lenguaje
2 Piensa en Java
ensamblador es una pequeña abstracción de la máquina subyacente. Muchos de los lenguajes denominados "imperativos" desarrollados a continuación del antes mencionado ensamblador (como
Fortran, BASIC y C) eran abstracciones a su vez del lenguaje citado. Estos lenguajes supusieron una
gran mejora sobre el lenguaje ensamblador, pero su abstracción principal aún exigía pensar en términos de la estructura del computador más que en la del problema en sí a resolver. El programador
que haga uso de estos lenguajes debe establecer una asociación entre el modelo de la máquina (dentro del "espacio de la solución", que es donde se modela el problema, por ejemplo, un computador)
y el modelo del problema que de hecho trata de resolver (en el "espacio del problema", que es donde de hecho el problema existe). El esfuerzo necesario para establecer esta correspondencia, y el
hecho de que éste no es intrínseco al lenguaje de programación, es causa directa de que sea difícil
escribir programas, y de que éstos sean caros de mantener, además de fomentar, como efecto colateral (lateral), toda una la industria de "métodos de programación".
La alternativa al modelado de la máquina es modelar el problema que se trata de resolver. Idiomas
primitivos como LISP o APL eligen vistas parciales o particulares del mundo (considerando respectivamente que los problemas siempre se reducen a "listas" o a "algoritmos"). PROLOG convierte todos los problemas en cadenas de decisiones. Los lenguajes se han creado para programación basada en limitaciones o para programar exclusivamente mediante la manipulación de símbolos gráficos.
(aunque este último caso resultó ser excesivamente restrictivo). Cada uno de estos enfoques constituye una buena solución para determinadas clases (tipos) de problemas (aquéllos para cuya solución fueron diseñadas), pero cuando uno trata de sacarlos de su dominio resultan casi impracticables.
El enfoque orientado a objetos trata de ir más allá, proporcionando herramientas que permiten al
programador representa los elementos en el espacio del problema. Esta representación suele ser
lo suficientemente general como para evitar al programador limitarse a ningún tipo de problema específico. Nos referiremos a elementos del espacio del problema, denominando "objetos" a sus representaciones dentro del espacio de la solución (por supuesto, también serán necesarios otros objetos que no tienen su análogo dentro del espacio del problema). La idea es que el programa pueda
autoadaptarse al lingo del problema simplemente agregando nuevos tipos de objetos, de manera que
la mera lectura del código que describe la solución constituya la lectura de palabras que expresan
el problema. Se trata, en definitiva, de una abstracción del lenguaje mucho más flexible y potente.
que cualquiera que haya existido previamente. Por consiguiente, la PO0 permite al lector describir
el problema en términos del propio problema, en vez de en términos del sistema en el que se ejecutará el programa final. Sin embargo, sigue existiendo una conexión con el ordenador, pues cada
objeto puede parecer en sí un pequeño ordenador; tiene un estado, y se le puede pedir que lleve
a cabo determinadas operaciones. No obstante, esto no quiere decir que nos encontremos ante una
mala analogía del mundo real, al contrario, los objetos del mundo real también tienen características
y comportamientos.
Algunos diseñadores de lenguajes han dado por sentado que la programación orientada a objetos,
de por sí, no es adecuado para resolver de manera sencilla todos los problemas de programación, y
hacen referencia al uso de lenguajes de programación multiparadigmal.
' N. del autor: Ver Programación Multiparadigmática en Leda, por Timothy Budd (Addison-Wesley, 1995).
1: Introducción a los objetos 3
Alan Kay resumió las cinco características básicas de Smalltalk, el primer lenguaje de programación.
orientado a objetos que tuvo éxito, además de uno de los lenguajes en los que se basa Java. estas
características que constituyen un enfoque puro a la programación orientada a objetos:
Todo es un objeto. Piense en cualquier objeto como una variable: almacena datos, permite
que se le "hagan peticiones", pidiéndole que desempeñe por sí mismo determinadas operaciones, etc. En teoría, puede acogerse cualquier componente conceptual del problema a resolver (bien sean perros, edificios, servicios, etc.) y representarlos como objetos dentro de un
programa.
Un programa es un cúmulo de objetos que se dicen entre sí lo que tienen que hacer
mediante el envío de mensajes. Para hacer una petición a un objeto, basta con "enviarle un
mensaje". Más concretamente, puede considerarse que un mensaje en sí es una petición para
solicitar una llamada a una función que pertenece a un objeto en particular.
Cada objeto tiene su propia memoria, constituida por otros objetos. Dicho de otra manera, uno crea una nueva clase de objeto construyendo un paquete que contiene objetos ya
existentes. Por consiguiente, uno puede aumentar la complejidad de un programa, ocultándola tras la simplicidad de los propios objetos.
Todo objeto es de algún tipo. Cada objeto es un elemento de una clase, entendiendo por "clase" un sinónimo de "tipo". La característica más relevante de una clase la constituye "el conjunto de mensajes que se le pueden enviar".
Todos los objetos de determinado tipo pueden recibir los mismos mensajes. Ésta es una
afirmación de enorme trascendencia como se verá más tarde. Dado que un objeto de tipo "círculo" es también un objeto de tipo "polígono", se garantiza que todos los objetos "círculo"
aceptarán mensajes propios de "polígono". Esto permite la escritura de código que haga referencia a polígonos, y que de manera automática pueda manejar cualquier elemento que encaje con la descripción de "polígono". Esta capacidad de suplantación es uno de los conceptos.
más potentes de la POO.
Todo objeto tiene una interfaz.
Aristóteles fue probablemente el primero en estudiar cuidadosamente el concepto de tipo; hablaba de "la clase de los peces o la clase de los peces". La idea de que todos los objetos, aún
siendo únicos, son también parte de una clase de objetos, todos ellos con características y comportamientos en común, ya fue usado en el primer lenguaje orientado a objetos, Simula-67, que
ya incluye la palabra clave clase, que permite la introducción de un nuevo tipo dentro de un programa.
Simula, como su propio nombre indica, se creó para el desarrollo de simulaciones, como el clásico.
del cajero de un banco, en el que hay cajero, clientes, cuentas, transacciones y unidades monetarias
-un montón de "objetos". Todos los objetos que, con excepción de su estado, son idénticos durante la ejecución de un programa se agrupan en "clases de objetos", que es precisamente de donde
proviene la palabra clave clase. La creación de tipos abstractos de datos (clases) es un concepto divertido.
4 Piensa en Java
damental en la programación orientada a objetos. Los tipos abstractos de datos funcionan casi como
los tipos de datos propios del lenguaje: es posible la creación de variables de un tipo (que se denominan objetos o instancias en el dialecto propio de la orientación a objetos) y manipular estas variables (mediante el envío o recepción de mensajes; se envía un mensaje a un objeto y éste averigua que
debe hacer con él). Los miembros (elementos) de cada clase comparten algunos rasgos comunes:
toda cuenta tiene un saldo, todo cajero puede aceptar un ingreso, etc. Al mismo tiempo, cada miembro tiene su propio estado, cada cuenta tiene un saldo distinto, cada cajero tiene un nombre. Por
en consecuencia, los cajeros, clientes, cuentas, transacciones, etc. también pueden ser representados
mediante una entidad única en el programa del ordenador. Esta entidad es el objeto, y cada objeto pertenece a una clase particular que define sus características y comportamientos.
Por tanto, aunque en la programación orientada a objetos se crean nuevos tipos de datos, virtualmente todos los lenguajes de programación orientada a objetos hacen uso de la palabra clave "clase". Siempre que aparezca la palabra clave "tipo" puede sustituirse por "clase" (class) y viceversa2.
Dado que una clase describe a un conjunto de objetos con características (datos) y comportamientos (funcionalidad) idénticos, una clase es realmente un tipo de datos, porque un número en coma
flotante, por ejemplo, también tiene un conjunto de características y comportamientos. la diferencia
radica en que un programador define una clase para que encaje dentro de un problema en vez de
verse forzado a utilizar un tipo de datos existente que fue diseñado para representar una unidad de
almacenamiento en una máquina. Es posible extender el lenguaje de programación agregando nuevos tipos de datos específicos de las necesidades de cada problema. El sistema de programacion
acepta las nuevas clases y las cuida, y' asigna las comprobaciones que da a los tipos de datos predefinidos.
El enfoque orientado a objetos no se limita a la construcción de simulaciones. Uno puede estar de
De acuerdo o no con la afirmación de que todo programa es una simulación del sistema a diseñar, mientras que las técnicas de PO0 pueden reducir de manera sencilla un gran conjunto de problemas a
una solución sencilla.
Una vez que se establece una clase, pueden construirse tantos objetos de esa clase como se desee,
y manipularlos como si fueran elementos que existen en el problema que se trata de resolver. Pecado
duda, uno de los retos de la programación orientada a objetos es crear una correspondencia uno a
uno entre loselementos del espacio del problema y los objetos en el espacio de la solución.
Pero, ¿cómo se consigue que un objeto haga un trabajo útil para el programador? Debe de haber
una forma de hacer peticiones al objeto, de manera que éste desempeñe alguna tarea, como completar una transacción, dibujar algo en la pantalla o encender un interruptor. Además, cada objeto
sólo puede satisfacer determinadas peticiones. Las peticiones que se pueden hacer a un objeto se
encuentran definidas en su interfaz, y es el tipo de objeto el que determina la interfaz. un ejemplo
sencillo sería la representación de una bombilla:
Wgunas personas establecen una distinción entre ambos, remarcando que un tipo determina la interfaz, mientras que una clase es una implementación particular de una interfaz.
1: Introducción a los objetos 5
tipo
interfaz
Luz lz = nueva Luz() ;
lz. encender ( );
1 Luz l
La interfaz establece qm6 solicitudes pueden hacerse a un objeto particular Sin embargo, debe hacer
código en algún lugar que permita satisfacer esas peticiones. Este, junto con los datos ocultos, constituye la implementación. Desde el punto de vista de un lenguaje de programación procedimental, esto
No es tan complicado. Un tipo tiene una función asociada a cada posible petición, de manera que
cuando se hace una petición particular a un objeto, se invoca a esa función. Este proceso se suele
simplificar diciendo que se ha "enviado un mensaje" (hecho una petición) a un objeto, y el objeto
averigua qué debe hacer con el mensaje (ejecuta el código).
Aquí, el nombre del tipo o clase es Luz, el nombre del objeto Luz particular es lz, y las peticiones
que pueden hacerse a una Luz son encender, apagar, brillar o atenuar. Es posible crear una Luz definiendo una "referencia" (12) a ese objeto e invocando a nuevo para pedir un nuevo objeto de ese tipo.
Para enviar un mensaje al objeto, se menta el nombre del objeto y se conecta al mensaje de petición
mediante un punto. Desde el punto de vista de un usuario de una clase predefinida, éste es el no va
Más de la programación con objetos.
El diagrama mostrado anteriormente sigue el formato del Lenguaje de Modelado Unificado o
Lenguaje de modelado Un@ed (UML). Cada clase se representa mediante una caja, en la que el nombre del tipo se ubica en la parte superior, cualquier dato necesario para describirlo se coloca en la
parte central, y las funciones miembro (las funciones que pertenecen al objeto) en la parte inferior
de la caja. A menudo, solamente se muestra el nombre de la clase y las funciones públicas miembro en los diagramas de diseño UML, ocultando la parte central. Si únicamente interesan los nombres de las clases, tampoco es necesario mostrar la parte inferior de la caja.
La implementación oculta
Suele ser de gran utilidad descomponer el tablero de juego en creadores de clases (elementos que
crean nuevos tipos de datos) y programadores clientes3 (consumidores de clases que hacen uso de
los tipos de datos en sus aplicaciones). La meta del programador cliente es hacer uso de un gran
Repertorio de clases que le permitirán acometer el desarrollo de aplicaciones de manera rápida. La
Nota del autor: Término acuñado por mi amigo Scott Meyers.
6 Piensa en Java
meta del creador de clases es construir una clase que únicamente exponga lo que es necesario al
programador cliente, manteniendo oculto todo lo demás. ¿Por qué? Porque aquello que esté oculto no puede ser utilizado por el programador cliente, lo que significa que el creador de la clase
puede modificar la parte oculta a su voluntad, sin tener que preocuparse de cualquier impacto que
esta modificación pueda implicar. La parte oculta suele representar las interioridades de un objeto que podrían ser corrompidas por un programador cliente poco cuidadoso o ignorante, de
manera que mientras se mantiene oculta su implementación se reducen los errores en los programas.
En cualquier relación es importante determinar los límites relativos a todos los elementos involucrados. Al crear una biblioteca, se establece una relación con el programador cliente, que es también un programador, además de alguien que está construyendo una aplicación con las piezas que se encueriLrari e11 esta biblioteca, quizás con la intención de construir una biblioteca aún mayor.
Si todos los miembros de una clase están disponibles para todo el mundo, el cliente programador
puede hacer cualquier cosa con esa clase y no hay forma de imponer reglas. Incluso aunque prefiera que el cliente programador no pueda manipular alguno de los miembros de su clase, sin control de accesos, no hay manera de evitarlo. Todo se presenta desnudo al mundo.
Por ello, la primera razón que justifica el control de accesos es mantener las manos del programador cliente apartadas de las porciones que no deba manipular -partes que son necesarias para las
maquinaciones internas de los tipos de datos pero que no forman parte de la interfaz que los usuarios necesitan en aras de resolver sus problemas particulares. De hecho, éste es un servicio a los
usuarios que pueden así ver de manera sencilla aquello que es sencillo para ellos, y qué es lo que
pueden ignorar.
La segunda razón para un control de accesos es permitir al diseñador de bibliotecas cambiar el funcionamiento interno de la clase sin tener que preocuparse sobre cómo afectará al programador.
cliente. Por ejemplo, uno puede implementar una clase particular de manera sencilla para simplificar el desarrollo y posteriormente descubrir que tiene la necesidad de reescribirla para que se ejecute más rápidamente. Tanto la interfaz como la implementación están claramente separadas y
protegidas, esto puede ser acometido de manera sencilla.
Java usa tres palabras claves específicas para establecer los límites en una clase: public, private y protected. Su uso y significado son bastante evidentes. Estos mod$cadores de acceso determinan quién
puede usar las definiciones a las que preceden. La palabra public significa que las definiciones
Los siguientes están disponibles para todo el mundo. El término privado, por otro lado, significa que
nadie excepto el creador del tipo puede acceder a esas definiciones. Así, privado es un muro de ladrillos entre el creador y el programador cliente. Si alguien trata de acceder a un miembro privado,
obtendrá un error en el tiempo de compilación. La palabra clave protegida actúa como privada, con
la excepción de que una clase heredada tiene acceso a miembros protegidos pero no a los privados.
La herencia será definida algo más adelante.
Java también tiene un "acceso por defecto", que se utiliza cuando no se especifica ninguna de las palabras clave descritas en el párrafo anterior. Este modo de acceso se suele denominar "amistoso" o
amigable porque implica que las clases pueden acceder a los miembros amigos de otras clases que
1 : Introducción a los objetos 7
estén en el mismo paquete o paquete, sin embargo, fuera del paquete, estos miembros amigos se
convertir en privado.
Una vez que se ha creado y probado una clase, debería (idealmente) representar una unidad útil de
código. Resulta que esta reutilización no es siempre tan fácil de lograr como a muchos les gustaría;
producir un buen diseño suele requerir experiencia y una visión profunda de la problemática. pero si
se logra un diseño bueno, parece suplicar ser reutilizado. La reutilización de código es una de las
mayores ventajas que proporcionan los lenguajes de programación orientados a objetos.
La manera más simple de reutilizar una clase es simplemente usar un objeto de esa clase directamente, pero también es posible ubicar un objeto de esa clase dentro de otra clase. Esto es
lo que se denomina la "creación de un objeto miembro". La nueva clase puede construirse una
desde un número indefinido de otros objetos, de igual o distinto tipo, en cualquier combinación necesaria para lograr la funcionalidad deseada dentro de la nueva clase. Dado que uno está
construyendo una nueva clase a partir de otras ya existentes, a este concepto se le denomina
composición (o, de forma más general, agregación). La composición se suele representar mediante una relación "es-parte-de", como en "el motor es una parte de un coche" ("carro" en
Latinoamérica).
(Este diagrama UML indica la composición, y el rombo relleno indica que hay un coche.
Normalmente, lo representaré simplemente mediante una línea, sin el diamante, para indicar una
asociación4.)
La composición conlleva una gran carga de flexibilidad. Los objetos miembros de la nueva clase suelen ser privados, siendo inaccesibles a los programadores cliente que hacen uso de la clase.
Esto permite cambiar los miembros sin que ello afecte al código cliente ya existente. También es
posible cambiar los objetos en el tiempo de ejecución, para así cambiar de manera dinámica el comportamiento de un programa. La herencia, que se describe a continuación, no tiene esta.
flexibilidad, pues el compilador debe emplazar restricciones de tiempo de compilación en las clases
que se creen mediante la herencia.
Dado que la herencia es tan importante en la programación orientada a objetos, casi siempre se enfatiza mucho su uso, de manera que un programador novato puede llegar a pensar que hay que ha-
"ste ya suele ser un nivel de detalle suficiente para la gran mayoría de diagramas, de manera que no es necesario indicar de manera explícita si se está utilizando agregación o composición.
8 Piensa en Java
cer uso de la misma en todas partes. Este pensamiento puede provocar que se elaboren diseños.
poco elegantes y desmesuradamente complicados. Por el contrario, primero sería recomendable intentar hacer uso de la composición, mucho más simple y sencilla. Siguiendo esta filosofía se lograrán diseños mucho más limpios. Una vez que se tiene cierto nivel de experiencia, la detección de
los casos que precisan de la herencia se convierten en obvia.
Herencia: reutilizar interfaz
Por sí misma, la idea de objeto es una herramienta más que buena. Permite empaquetar datos y funcionalidad juntos por conexcepto, de manera que es posible representar cualquier idea del espacio del
problema en vez de verso forzado a utilizar idiomas propios de la máquina subyacente. Estos conceptos se expresan como las unidades fundamentales del lenguaje de programación haciendo uso
de la palabra clave class.
Parece una pena, sin embargo, acometer todo el problema para crear una clase y posteriormente
verse forzado a crear una nueva que podría tener una funcionalidad similar. Sería mejor si pudiéramos hacer uso de una clase ya existente, clonarla, y después hacer al "clon" las adiciones y modificaciones que sean necesarias. Efectivamente, esto se logra mediante la herencia, con la excepción
de que si se cambia la clase original (denominada la clase base, clase super o clase padre), el "clon"
modificado (denominado clase derivada, clase heredada, subclase o clase hijo) también reflejaría esos
cambios.
E Derivada
(La flecha de este diagrama UML apunta de la clase derivada a la clase base. Como se verá, puede
haber más de una clase derivada.)
Un tipo hace más que definir los límites de un conjunto de objetos; también tiene relaciones con
otros tipos. Dos tipos pueden tener características y comportamientos en común, pero un tipo puede contener más características que otro y también puede manipular más mensajes (o gestionarlos).
de manera distinta). La herencia expresa esta semejanza entre tipos haciendo uso del concepto de
tipos base y tipos derivados. Un tipo base contiene todas las características y comportamientos que
Comparten los tipos que de él se derivan. A partir del tipo base, es posible derivar otros tipos para
expresar las distintas maneras de llevar a cabo esta idea.
1 : Introducción a los objetos 9
Por ejemplo, una máquina de reciclaje de basura clasifica los desperdicios. El tipo base es "basura",
y cada desperdicio tiene su propio peso, valor, etc. y puede ser fragmentado, derretido o descompuesto. Así, se derivan tipos de basura más específicos que pueden tener características adicionales
(una botella tiene un color), o comportamientos (el aluminio se puede modelar, una lata de acero
tiene capacidades magnéticas). Además, algunos comportamientos pueden ser distintos (el valor del
papel depende de su tipo y condición). El uso de la herencia permite construir una jerarquía de tipos que expresa el problema que se trata de resolver en términos de los propios tipos.
Un segundo ejemplo es el clásico de la "figura geométrica" utilizado generalmente en sistemas de
Diseño por ordenador o en simulaciones de juegos. El tipo base es "figura" y cada una de ellas tiene un tamaño, color, posición, etc. Cada figura puede dibujarse, borrarse, moverse, colorearse, etc.
A partir de ésta, se pueden derivar (heredar) figuras específicas: círculos, cuadrados, triángulos,
etc., pudiendo tener cada uno de los cuales características y comportamientos adicionales. algunos
comportamientos pueden ser distintos, como pudiera ser el cálculo del área de los distintos tipos de
figuras. La jerarquía de tipos engloba tanto las similitudes como las diferencias entre las figuras.
1 Figura l
1 Círculo 1 1 Cuadrado " Triánguio 1
Representar la solución en los mismos términos que el problema es tremendamente beneficioso
puesto que no es necesario hacer uso de innumerables modelos intermedios para transformar una
descripción del problema en una descripción de la solución. Con los objetos, el modelo principal lo
constituye la jerarquía de tipos, de manera que se puede ir directamente de la descripción del sistema en el mundo real a la descripción del sistema en código. Sin duda, una de las dificultades que
tiene la gente con el diseño orientado a objetos es la facilidad con que se llega desde el principio al
final: las mentes entrenadas para buscar soluciones completas suelen verse aturdidas inicialmente
por esta simplicidad.
Al heredar a partir de un tipo existente, se crea un nuevo tipo. Este nuevo tipo contiene no sólo los
miembros del tipo existente (aunque los datos privados "private" están ocultos e inaccesibles) sino
Lo que es más importante, duplica la interfaz de la clase base. Es decir, todos los mensajes que pueden ser enviados a objetos de la clase base también pueden enviarse a los objetos de la clase derivada. Dado que sabemos el tipo de una clase en base a los mensajes que se le pueden enviar, la cla-
10 Piensa en Java
se deriva es del mismo tipo que la clase base. Así, en el ejemplo anterior, "un círculo en una figura". Esta equivalencia de tipos vía herencia es una de las pasarelas fundamentales que conducen al
comprensión del significado de la programación orientada a objetos.
Dado que, tanto la clase base como la derivada tienen la misma interfaz, debe haber alguna implementación que vaya junto con la interfaz. Es decir, debe haber algún código a ejecutar cuando un
objeto recibe un mensaje en particular. Si simplemente se hereda la clase sin hacer nada más, los
métodos de la interfaz de la clase base se trasladan directamente a la clase derivada. Esto significa
que los objetos de la clase derivada no sólo tienen el mismo tipo sino que tienen el mismo comportamiento, aunque este hecho no es particularmente interesante.
Hay dos formas de diferenciar una clase nueva derivada de la clase base original. El primero es bastante evidente: se añaden nuevas funciones a la clase derivada. Estas funciones nuevas no forman
parte de la interfaz de la clase base, lo que significa que la clase base simplemente no hacía todo lo
que ahora se deseaba, por lo que era necesario añadir nuevas funciones. Ese uso simple y primitivo.
rle la herencia es, en ocasiones, la solución perfecta a los problemas. Sin embargo, debería considerarse detenidamente la posibilidad de que la clase base llegue también a necesitar estas funciones adicionales. Este proceso iterativo y de descubrimiento de su diseño es bastante frecuente en la
Programación orientada a objetos.
Figura r-7
dibujar ()
borrar ()
obtenerColor()
establecerColor()
El Círculo 1 Cuadrado 1 m Triángulo
Girarvertical ()
GirarHorizontal ()
Aunque la herencia puede implicar en ocasiones (especialmente en Java, donde la palabra clave que
hace referencia a la misma es extends) que se van a agregar funcionalidades a una interfaz, esto no
Tiene por qué ser siempre así. La segunda y probablemente más importante manera de diferenciar
una nueva clase es variar el comportamiento de una función ya existente en la clase base. A esto se
le llama redefinición5 (anulación o superposición) de la función.
Para redefinir una función simplemente se crea una nueva definición de la función dentro de la clase derivada. De esta manera puede decirse que "se está utilizando la misma función de la interfaz
pero se desea que se comporte de manera distinta dentro del nuevo tipo".
' En el original overriding (N. del T.).
1: Introducción a los objetos 11
figura
dibujar ()
borrar ()
obtenerColor()
establecerColor()
m Círculo
dibujar ()
borrar () 1
Yo Triángulo
dibujar () 1 1 dibujar () 1
borrar () 1 1 borrar ()
La relación es-un frente a la relación
es-como-un
Es habitual que la herencia suscite un pequeño debate: ¿debería la herencia superponer sólo las
funciones de la clase base (sin agregar nuevas funciones miembro que no se encuentren en ésta)?
Esto significaría que el tipo derivado sea exactamente el mismo tipo que el de la clase base, puesto que tendría exactamente la misma interfaz. En consecuencia, es posible sustituir un objeto
de la clase derivada por otra de la clase base. A esto se le puede considerar sustitución pura, y a
menudo se le llama el principio de sustitución. De cierta forma, ésta es la manera ideal de tratar
la herencia. Habitualmente, a la relación entre la clase base y sus derivadas que sigue esta filosofía se le denomina relación es-un, pues es posible decir que "un círculo es un polígono". Una manera de probar la herencia es determinar si es posible aplicar la relación es-un a las clases en liza,
y tiene sentido.
Hay veces en las que es necesario agregar nuevos elementos a la interfaz del tipo derivado, extendiendo así la interfaz y creando un nuevo tipo. Éste también puede ser sustituido por el tipo base, pero la
La sustitución no es perfecta pues las nuevas funciones no serán accesibles desde el tipo base. Esta relación puede describirse como la relación es-como-un" el nuevo tipo tiene la interfaz del viejo pero además contiene otras funciones, así que no se puede decir que sean exactamente iguales. Considere
por ejemplo un acondicionador de aire. Supongamos que una casa está cableada y tiene las botoneras.
para refrescarla, es decir, tiene una interfaz que permite controlar la temperatura. Imagina que se
estropea el acondicionador de aire y se reemplaza por una bomba de calor que puede tanto enfriar
como calentar. La bomba de calor es como un acondicionador de aire, pero puede hacer más funciones.
Dado que el sistema de corilrol de la casa está diseñado exclusivamente para controlar el enfriado, se
encuentra restringida a la comunicación con la parte "enfriadora" del nuevo objeto. Es necesario ampliar la interfaz del nuevo objeto, y el sistema existente únicamente conoce la interfaz original.
Término acuñado por el autor.
12 Piensa en Java
1 Termostato 1 Controlla I Sistema de enfriado
1 enfriar O 1
1 Acondicionador de aire / 1 Bomba de Calor
enfriar ()ivada. Con la
experiencia, ambos casos irán pareciendo obvios.
Objetos intercambiables con
polimorfismo
Al tratar con las jerarquías de tipos, a menudo se desea tratar un objeto no como el tipo específico
del que es, sino como su tipo base. Esto permite escribir código que no depende de tipos específicos.
En el ejemplo de los polígonos, las funciones manipulan polígonos genéricos sin que importe si son
círculos, cuadrados, triángulos o cualquier otro polígono que no haya sido aún definido. Todos los polígono~ pueden dibujarse, borrarse y moverse, por lo que estas funciones simplemente envían un
mensaje a un objeto polígono; No se preocupan de qué base hace este objeto con el mensaje.
Este tipo de código no se ve afectado por la adición de nuevos tipos, y esta adición es la manera más
común de extender un programa orientado a objetos para que sea capaz de manejar nuevas situaciones. Por ejemplo, es posible derivar un nuevo subtipo de un polígono denominado pentágono sin
tener que modificar las funciones que solamente manipulan polígonos genéricos. esta capacidad
para extender un programa de manera sencilla derivando nuevos subtipos es importante, ya que mejora considerablemente los diseños a la vez que reduce el costo del mantenimiento de software.
Sin embargo, hay un problema a la hora dc tratar los objetos de tipos derivados como sus tipos base.
genéricos (los círculos como polígonos, las bicicletas como vehículos, los cormoranes como pájaros,
etc.). Si una función va a decir a un polígono genérico que la dibuje, o a un vehículo que genérico
se engrane, o a un pájaro genérico que se mueve, el compilador no puede determinar en tiempo de
1: Introducción a los objetos 13
Compilación con exactitud qué fragmento de código se ejecutará. Éste es el punto clave -cuando
se envía el mensaje, el programador no quiere saber qué fragmento de código se ejecutará; la función dibujar se puede aplicar de manera idéntica a un círculo, un cuadrado o un triángulo, y el objeto ejecutará el código correcto en función de su tipo específico. Si no es necesario saber qué fragmento de código se ejecutará, al agregar un nuevo subtipo, el código que se ejecutará puede ser diferente
sin necesidad de modificar la llamada a la función. Por consiguiente, el compilador no puede saber
exactamente qué fragmento de código se está ejecutando, ¿y qué es entonces lo que hace? Por ejemplo, en el diagrama siguiente, el objeto ControlaPájaros trabaja con objetos Pájaro genéricos, y no
sabe exactamente de qué tipo son. Esto es conveniente para la perspectiva de ControlaPájaros
pues no tiene que escribir código especial para determinar el tipo exacto de Pájaro con el que está
trabajando, ni el comportamiento de ese Pájaro. Entonces, ¿cómo es que cuando se invoca a mover() ignorando el tipo específico de Pájaro se dará el comportamiento correcto (un Ganso corre,
vuelta o nada,
7
¿Y un Pingüino corre o nada)?
?,Qué pasa al invocar a
F motor ()
l Ganso 1 1 Pingüino l I I
motor () 1 1 motor ()
La respuesta es una de las principales novedades en la programación orientada a objetos: el compilador iiu pudc liaccr uria llarriada a furiciúri eri el serilido lradicio~ial. La llarriada a íurici0ri generada por un compilador no-PO0 hace lo que se denomina una ligadura temprana, un término que puede que el lector no haya visto antes porque nunca pensó que se pudiera hacer de otra forma. esto
significa que el compilador genera una llamada a una función con nombre específico, y el montador
resuelve esta llamada a la dirección absoluta del código a ejecutar. En POO, el programa no puede
determine la dirección del código hasta el tiempo de ejecución, por lo que es necesario otro esquema
cuando se envía un mensaje a un objeto genérico.
Para resolver el problema, los lenguajes orientados a objetos usan el concepto de ligadura tardía. Alabama
enviar un mensaje a un objeto, no se determina el código invocado hasta el tiempo de ejecución. el
cornpilador se asegura de que la luriciím exisla y hace la comprobación de tipos de los argumentos
y del valor de retorno (un lenguaje en el que esto no se haga así se dice que es débilmente tipificado), pero se desconoce el código exacto a ejecutar.
Para llevar a cabo la ligadura tardía, Java utiliza un fragmento de código especial en vez de la llamada absoluta. Este código calcula la dirección del cuerpo de la función utilizando información almacenada en el objeto (este proceso se relata con detalle en el Capítulo 7). Por consiguiente, cada
objeto puede comportarse de manera distinta en función de los contenidos de ese fragmento de código.
14 Piensa en Java
digo especial. Cuando se envía un mensaje a un objeto, éste, de hecho, averigua qué es lo que debe
hacer con ese mensaje.
En algunos lenguajes (C++ en particular) debe establecerse explícitamente que se desea que una
función tenga la flexibilidad de las propiedades de la ligadura tardía. En estos lenguajes, por defecto, la correspondencia con las funciones miembro no se establece dinámicamente, por lo
Por supuesto, una vez que uno ve este diseño, está claro que la clase base "sistema de enfriado" no
es lo suficientemente general, y debería renombrarse a "sistema de control de temperatura" de manera que también pueda incluir calentamiento -punto en el que el principio de sustitución funcionará. Sin embargo, este diagrama es un ejemplo de lo que puede ocurrir en el diseño y en el mundo real.
Cuando se ve el principio de sustitución es fácil sentir que este principio (la sustitución pura) es la
única manera de hacer las cosas, y de hecho, es bueno para los diseños que funcionan así. Pero hay
veces que está claro que hay que agregar nuevas funciones a la interfaz de la clase derque es necesario recordar que hay que añadir ciertas palabras clave extra para lograr el polimorfismo.
Considere el ejemplo de los polígonos. La familia de clases (todas ellas basadas en la misma interfaz uniforme) ya fue representada anteriormente en este capítulo. Para demostrar el polimorfismo, se escribirá un único fragmento de código que ignora los detalles específicos de tipo y solamente hace referencia a la clase base. El código está desvinculado de información específica del tipo,
y por consiguiente es más fácil de escribir y entender. Y si se añade un nuevo tipo -por ejemplo un
Hexágono- mediante herencia, el código que se escribirá trabajará tan perfectamente con el nuevo
Polígono como lo hacia con los tipos ya exisle~iles, y por curisiguiente, el programa es Arrzpliable.
Si se escribe un método en Java (y pronto aprenderá el lector a hacerlo):
void hacerAlgo (Poligono p) {
pag. borrar() ;
//...
p.dibujar() ;
1
Esta función se entiende con cualquier Polígono, y por tanto, es independiente del tipo específico
de objeto que esté dibujando y borrando. En cualquier otro fragmento del programa se puede usar
la función hacerAlgo( ) :
Circulo c = nuevo Circulo() ;
Triángulo t = nuevo Triángulo () ;
Línea 1 = nueva Línea () ;
hacerAlgo (c) ;
hacerAlgo (t) ;
hacerAlgo (1) ;
Las llamadas a hacerAlgo( ) funcionan correctamente, independientemente del tipo de objeto.
De hecho, éste es un truco bastante divertido. Considere la línea:
Lo que está ocurriendo es que se está pasando un Círculo a una función que espera un Polígono.
Como un Círculo es un Polígono, puede ser tratado como tal por hacerAlgo(). Es decir, cualquier
mensaje que hacerAigo() pueda enviar a un Polígono, también podrá aceptarlo un Círculo. Por
tanto, obrar así es algo totalmente seguro y lógico.
A este proceso de tratar un tipo derivado como si fuera el tipo base se le llama conversión de tipos
(moldeado) hacia arriba7. El nombre moldear (cast) se utiliza en el sentimiento de moldear (convertir) un
' En el original inglés, casting.
1: Introducción a los objetos 15
molde, y es hacia arriba siguiendo la manera en que se representa en los diagramas la herencia, con
el tipo base en la parte superior y las derivadas colgando hacia abajo. Por consiguiente, hacer un moldeado (casting) a la clase base es moverse hacia arriba por el diagrama de herencias: moldeado hacia
arriba.
Un programa orientado a objetos siempre tiene algún moldeado hacia arriba pues ésta es la manera de desvincularse de tener que conocer el tipo exacto con que se trabaja en cada instante. si se
echa un vistazo al código de hacerAlgo() :
Obsérvese que no se dice "caso de ser un Círculo, hacer esto; caso de ser un Cuadrado, hacer esto
otro, etc.”. Si se escribe código que compruebe todos los tipos posibles que puede ser un Polígono,
el tipo de código se complica, además de hacerse necesario modificarlo cada vez que se añade un
Nuevo tipo de Polígono. Aquí, simplemente se dice que "en el caso de los polígonos, se sabe que es
posible aplicarles las operaciones de borrar() y dibujar(), eso sí, teniendo en cuenta todos los detalles de manera correcta".
Lo que más llama la atención del código de hacerAlgo() es que, de alguna manera, se hace lo correcto. Invocar a dibujar() para Círculo hace algo distinto que invocar a dibujar() para Cuadrado o
Iínea, pero cuando se envía el mensaje dibujar() a un Polígono anónimo, se da el comportamiento
correcto calculando en el tipo actual de Polígono. Esto es sorprendente porque, como se mencionó
Anteriormente, cuando el compilador de Java está compilando el código de hacerAlgo(), no puede saber exactamente qué tipos está manipulando. Por ello, generalmente, se espera que acabe invocando
a la versión de borrar() y dibujar() de la clase base Polígono y no a las específicas de Círculo,
Cuadrado y Iánea. Y sigue ocurriendo lo correcto por el polimorfismo. El compilador y el sistema de
tiempo real se hacen carga de los detalles; todo lo que hace falta saber es qué ocurre, y lo que es más
importante, cómo diseñar haciendo uso de ello. Al enviar un mensaje a un objeto, el objeto hará lo correcto, incluso cuando se vea involucrado el moldeado hacia arriba.
Clases base abstractas e interfaces.
A menudo es deseable que la clase base únicamente presente una interfaz para sus clases derivadas.
Es decir, no se desea que nadie crea objetos de la clase base, sino que sólo se hagan moldeados ha-
16 Piensa en Java
cia arriba de la misma manera que se pueda usar su interfaz. Esto se logra convertir esa clase en abstracta usando la palabra clave abstract. Si alguien trata de construir un objeto de una clase abstracta el compilador lo evita. Esto es una herramienta para fortalecer determinados diseños.
También es posible utilizar la palabra clave abstract para describir un método que no ha sido aún
implementar -indicando "he aquí una función interfaz para todos los tipos que se hereden de esta
clase, pero hasta la fecha no existe una implementación de la misma". Se puede crear un metodo
abstracto sólo dentro de una clase abstracta. Cuando se hereda la clase, debe implementarse el método o de lo contrario también la clase heredada se convierte en abstracto. La creación de métodos
abstractos permite poner un método en una interfaz sin verse forzado a proporcionar un fragmento de código, posiblemente sin significado, para ese método.
La palabra clave interfaz toma el concepto de clase abstracta un paso más allá, evitando totalmente las definiciones de funciones. La interfaz es una herramienta muy útil y utilizada, ya que proporciona la separación perfecta entre interfaz e implementación. Además. si se desea. es posible
Combina muchos elementos juntos mientras que no es posible heredar de múltiples clases normales o abstractas.
Localización de objetos y longevidad.
Técnicamente, la PO0 consiste simplemente en tipos de datos abstractos, herencia y polimorfismo,
aunque también hay otros aspectos no menos importantes. El resto de esta sección trata de analizar esos aspectos.
Uno de los factores más importantes es la manera de crear y destruir objetos. ¿Dónde están los datos de un objeto y cómo se controla su longevidad (tiempo de vida)? En este punto hay varias filosofías de trabajo. En C++ el enfoque principal es el control de la eficiencia, proporcionando una alternativa al programador. Para lograr un tiempo de ejecución óptimo, es posible determinar el
espacio de almacenamiento y la longevidad en tiempo de programación, ubicando los objetos en la
pila (creando las variables de ámbito o automático) o en el área de almacenamiento estático. De esta manera se prioriza la velocidad de la asignación y liberación de espacio de almacenamiento, cuyo control puede ser de gran valor en determinadas situaciones. Sin embargo, se sacrifica en flexibilidad
puesto que es necesario conocer la cantidad exacta de objetos, además de su longevidad y su tipo,
Mientras se escribe el programa. Si se está tratando de resolver un problema más general como un
diseño asistido por computadora, la gestión de un almacén o el control de tráfico aéreo, este enfoque
resulta demasiado restrictivo.
El segundo enfoque es crear objetos dinámicamente en un espacio de memoria denominado el montículo o montón (heap). En este enfoque, no es necesario conocer hasta tiempo de ejecución el número de objetos necesarios, cuál es su longevidad o a qué tipo exacto pertenecen. Estos aspectos se
deter-minar-án justo en el preciso momento en que se ejecuta el programa. Si se necesita un nuevo ob
Jeto, simplemente se construye en el montículo en el instante en que sea necesario. Dado que el almacenamiento se gestiona dinámicamente, en tiempo de ejecución, la cantidad de tiempo necesaria
1: Introducción a los objetos 17
asignar espacio de almacenamiento en el montículo es bastante mayor que el tiempo necesario
asigne espacio a la pila. (La creación de espacio en la pila suele consistir simplemente en una
instrucción al ensamblador que mueve hacia abajo el puntero de pila, y otra para moverlo de nuevo
hacia arriba.) El enfoque dinámico provoca generalmente el pensamiento lógico de que los objetos
Tenden a ser complicados, por lo que la sobrecarga debida a la localización del espacio de almacenamiento y su liberación no deben tener un impacto significativo en la creación del objeto. Es más,
esta mayor flexibilidad es esencial para resolver en general el problema de programación.
Java utiliza exclusivamente el segundo enfoque8. Cada vez que se desea crear un objeto se usa la palabra clave nueva para construir una instancia dinámica de ese objeto.
Hay otro aspecto, sin embargo, a considerar: la longevidad de un objeto. Con los lenguajes que permiten la creación de objetos en la pila, el compilador determina cuánto dura cada objeto y puede destruirlo cuando no sea necesario. Sin embargo, si se crea en el montículo, el compilador no tiene conocimiento alguno sobre su longevidad. En un lenguaje como C++ hay que determinar en tiempo de
programación cuándo destruir el objeto, lo cual puede conducir a fallos de memoria si no se hace de
manera correcta & este problema es bastante común en los programas en C++). Java proporciona un
recolector de basura que descubre automáticamente cuándo se ha dejado de utilizar un objeto, que
puede, por consiguiente, ser destruido. Un recolector de basura es muy conveniente, al reducir el número de aspectos a tener en cuenta, así como la cantidad de código a escribir. Y lo que es más importante, el recolector de basura proporciona un nivel de seguridad mucho mayor contra el problema.
de los fallos de memoria (que ha hecho abandonar más de un proyecto en Ctt).
El resto de esta sección se centra en factores adicionales relativos a la longevidad de los objetos y
su localización.
Colecciones e iteradores
Si se desconoce el número de objetos necesarios para resolver un problema en concreto o cuánto
Deben durar, también se desconocerá cómo almacenar esos objetos. ¿Cómo se puede saber el espacio a reservar?para los mismos? De hecho, no se puede, pues esa información se desconocerá hasta el tiempo de ejecución.
La solución a la mayoría de problemas de diseño en la orientación a objetos parece sorprendente: se
crea otro tipo de objeto. El nuevo tipo de objeto que resuelve este problema particular tiene referencias a otros objetos. Por supuesto, es posible hacer lo mismo con un array, disponible en la mayoría
de lenguajes. Pero hay más. Este nuevo objeto, generalmente llamado contenedor (llamado también colección, pero la biblioteca de Java usa este término con un sentido distinto así que este libro empleará
la palabra "contenedor"), se expandirá a sí mismo cuando sea necesario para albergar cuanto se coloque dentro del contenedor. Simplemente se crea el contenedor del objeto, y él se encarga de los detalles.
Afortunadamente, un buen lenguaje PO0 viene con un conjunto de contenedores como parte del
lenguaje propio. En C++, es parte de la Biblioteca Estándar C++ (Standard C++ Library), que en oca-
' Los tipos primitivos, de los que se hablará más adelante, son un caso especial.
18 Piensa en Java
siones se denomina la Standard Template Library, Biblioteca de plantillas estándar, (STL). Objeto
Pascal tiene contenedores en su Biblioteca de componentes visuales (VCL). Smalltalk tiene un conjunto de
contenedores muy completos, y Java también tiene contenedores en su biblioteca estándar. En algunas bibliotecas, se considera que un contenedor genérico es lo suficientemente bueno para todas las
necesidades, mientras que en otras (como en Java, por ejemplo) la biblioteca tiene distintos tipos de
contenedores para distintas necesidades: un vector (denominado en Java ArrayList) para acceso
consistente a todos los elementos, y una lista enlazada para inserciones consistentes en todos los
elementos, por ejemplo, con lo que es posible elegir el tipo particular que satisfaga las necesidades
de cada momento. Las bibliotecas de contenedores también suelen incluir conjuntos, colas, tablas.
de hasing, árboles, pilas, etc.
Todos los contenedores tienen alguna manera de introducir y extraer cosas; suele haber funciones para
add elementos a un contenedor, y otros para extraer de nuevo esos elementos. Pero sacar los elementos puede ser más problemático porque una función de selección única suele ser restrictiva. What
¿Ocurre si se desea manipular o comparar un conjunto de eleinerilos del co~ite~iedor y no u~io sdo?
La solución es un iterador, que es un objeto cuyo trabajo es seleccionar los elementos de dentro de un
contenedor y presentárselos al usuario del iterador. Como clase, también proporciona cierto nivel de
abstracción. Esta abstracción puede ser usada para separar los detalles del contenedor del código al
que éste está accediendo. El contenedor, a través del iterador, se llega a abstraer hasta convertirse en
una secuencia simple, que puede ser recorrida gracias al iterador sin tener que preocuparse de la estructura subyacente -es decir, sin preocuparse de si es un ArrayLBst (lista de arrays), un LinkedList
(lista enlazado), un Stack, (pila) u otra cosa. Esto proporciona la flexibilidad de cambiar fácilmente la
estructura de datos subyacente sin que el código de un programa se vea afectado. Java comenzó (es
las versiones 1.0 y 1.1) con un iterador estándar denominado Enumeration, para todas sus clases contenedor. Java 2 ha añadido una biblioteca mucho más completa de contenedores que contiene un iterador denominado Iterator mucho más potente que el antiguo Enumeration.
Desde el punto de vista del diseño, todo lo realmente necesario es una secuencia que puede ser manipulada en aras de resolver un problema. Si una secuencia de un sólo tipo satisface todas las necesidades de un problema, entonces no es necesario hacer uso de distintos tipos. Hay dos razones
por las que es necesaria una selección de contenedores. En primer lugar, los contenedores proporcionan distintos tipos de interfaces y comportamientos externos. Una pila tiene una interfaz y un
comportamiento distinto del de las colas, que son a su vez distintos de los conjuntos y las listas.
Cualquiera de estos podría proporcionar una solución mucho más flexible a un problema. En segundo lugar, distintos contenedores tienen distintas eficiencias en función de las operaciones. El mejor ejemplo está en ArrayList y LinkedList. Ambos son secuencias sencillas que pueden tener interfaces y comportamientos externos idénticos. Pero determinadas operaciones pueden tener
costes radicalmente distintos. Los accesos aleatorios a ArrayList tienen tiempos de acceso constantes; se invierte el mismo tiempo independientemente del elemento seleccionado. Sin embargo, en
una LinkedList mover de elemento en elemento a lo largo de la lista para seleccionar uno al azar
es altamente costoso, y es necesario muchísimo más tiempo para localizar un elemento cuanto más
se adelante se encuentre. Por otro lado, si se desea insertar un elemento en el medio de una secuencia, es mucho menos costoso hacerlo en un LinkedList queccn un ArrayList. Esta y otras operas
ciones tienen eficiencias distintas en función de la estructura de la secuencia subyacente. En la fase
de diseño, podría comenzarse con una LinkedList y, al primar el rendimiento, cambiar a un
1: Introducción a los objetos 19
Lista de arreglo. Dado que la abstracción se lleva a cabo a través de iteradores, es posible cambiar de uno
a otro con un impacto mínimo en el código.
Finalmente, debe recordarse que un contenedor es sólo un espacio de almacenamiento en el que colocar objetos. Si este espacio resuelve todas las necesidades, no importa realmente cómo esté implementado (concepto compartido con la mayoría de tipos de objetos). Si se está trabajando en un
entorno de programación que tiene una sobrecarga interna debido a otros factores, la diferencia
Los costos entre ArrayList y LinkedList podrían no importar. Con un único tipo de secuencia podría
valer. Incluso es posible imaginar la abstracción contenedora "perfecta", que pueda cambiar su implementación subyacente automáticamente en función de su uso.
La jerarquía de raíz única
Uno de los aspectos de la PO0 que se ha convertido especialmente destacado desde la irrupción
de C++ es si todas las clases en última instancia deben ser heredadas de una única clase base. es
Java (como virtualmente en todos los lenguajes PO0 ) la respuesta es "sí" y el nombre de esta última clase base es simplemente Object. Resulta que los beneficios de una jerarquía de raíz única son
enormes.
Todos los objetos en una jerarquía de raíz única tienen una interfaz en común, por lo que en última
instancia son del mismo tipo. La alternativa (proporcionada por C++) es el desconocimiento de que
todo pertenece al mismo tipo fundamental. Desde el punto de vista de la retrocompatibilidad, esto
encaja en el modelo de C mejor, y puede pensarse que es menos restrictivo, pero cuando se desea
Para hacer programación orientada a objetos puros, es necesario proporcionar una jerarquía completa para
lograr el mismo nivel de conveniencia intrínseco a otros lenguajes POO. Y en cualquier nueva biblioteca de clases que se adquiera, se utilizará alguna interfaz incompatible. hacer funcionar esta
nueva interfaz en un diseño lleva un gran esfuerzo (y posiblemente herencia múltiple). Así que ¿merece la pena la "flexibilidad" extra de C++? Si se necesita -si se dispone de una gran cantidad de
código en C- es más que valioso. Si se empieza de cero, otras alternativas, como Java, resultarán
mucho más productivas.
Puede garantizarse que todos los objetos de una jerarquía de raíz única (como la proporcionada por
Java) tienen cierta funcionalidad. Se sabe que es posible llevar a cabo ciertas operaciones básicas
con todos los objetos del sistema. Una clasificación de raíz única, junto con la creación de todos los objetos en el montículo, simplifica enormemente el paso de argumentos (uno de los temas más complicados de C++).
Una jerarquía de raíz única simplifica muchísimo la implementación de un recolector de basura (incluido en Java). El soporte necesario para el mismo puede instalarse en la clase base, y el recolector de basura podrá así enviar los mensajes apropiados a todos los objetos del sistema. Si no existiera este tipo de jerarquía rii la posibilidad de rriariipular un objeto a través de reierencias, sería muy
Difícil implementar un recolector de basura.
Dado que está garantizado que en el tiempo de ejecución la información de tipos está en todos los objetos, jamás será posible encontrar un objeto cuyo tipo no pueda ser determinado. Esto es especial
20 Piensa en Java
mente importante con operaciones a nivel de sistema, tales como el manejo de excepciones, además
de proporcionar una gran flexibilidad a la hora de programar.
Bibliotecas de colecciones y soporte al fácil
manejo de colecciones
Dado que un contenedor es una herramienta de uso frecuente, tiene sentido tener una biblioteca de
contenedores construidos para ser reutilizados, de manera que se puede elegir uno de la estantería
y enchufarlo en un programa determinado. Java proporciona una biblioteca de este tipo, que satisface la gran mayoría de necesidades.
Moldeado hacia abajo frente a plantillas/genéricos
Yara lograr que estos contenedores sean reutilizables, guarden un tipo universal en Java ya mencionado anteriormente: Object (Objeto). La jerarquía de raíz única implica que todo sea un Objeto,
de forma que un contenedor que tiene objetos de tipo Object puede contener de todo, logrando así
que los contenedores sean fáciles de reutilizar.
Para utilizar uno de estos contenedores, basta con añadirle referencias a objetos y finalmente preguntar por ellas. Pero dado que el contenedor sólo guarda objetos de tipo Object, al agregar una referencia al contenedor, se hace un moldeado hacia arriba a Object, perdiendo por consiguiente su
identidad. Al recuperarlo, se obtiene una referencia a Objeto y no una referencia al tipo que se había introducido. ¿Y cómo se convierte de nuevo en algo útil con la interfaz del objeto que se introduce en¿el contenedor?
En este caso, también se hace uso del moldeado, pero en esta ocasión en vez de hacerlo hacia arriba siguiendo la jerarquía de las herencias hacia un tipo más general, se hace hacia abajo, hacia un
tipo más específico. Esta forma de moldeado se denomina moldeado hacia abajo. Con el moldeado
hacia arriba, como se sabe, un Círculo, por ejemplo, es un tipo de Polígono, con lo que este tipo
de moldeado es seguro, pero lo que no se sabe es si un Objeto es un Círculo o un Polígono, por
lo que no es muy seguro hacer moldeado hacia abajo a menos que se sepa exactamente qué es lo
que se está manipulando.
Esto no es completamente peligroso, sin embargo, dado que si se hace un moldeado hacia abajo, a
un tipo erróneo, se mostrará un error de tiempo de ejecución denominado excepción, que se describirá en breve. Sin embargo, al recuperar referencias a objetos de un contenedor, es necesario tener
alguna manera de recordar exactamente lo que son para poder llevar a cabo correctamente un moldeado hacia abajo.
El moldeado hacia abajo y las comprobaciones en tiempo de ejecución requieren un tiempo extra
durante la ejecución del programa, además de un esfuerzo extra por parte del programador. 2No tendría sentido crear, de alguna manera, el contenedor de manera que conozca los tipos que guarda,
eliminando la necesidad de hacer moldeado hacia abajo y por tanto, de que aparezca algún error?
La solución la constituye los tipos parametrizados, que son clases que el compilador puede adaptarse automáticamente para que trabajen con tipos determinados. Por ejemplo, con un contenedor parametrizado, el compilador podría adaptar el propio contenedor para que solamente acepte y per-
1: Introducción a los objetos 21
mitiera la recuperación de Polígonos.
Los tipos parametrizados son un elemento importante en C++, en parte porque este lenguaje no tiene una clasificación de raíz única. En C++, la palabra clave que implementa los tipos parametrizados es
"plantilla". Java actualmente no tiene tipos parametrizados pues se puede lograr lo mismo -aunque de manera complicada- explotando la unicidad de raíz de su jerarquía. Sin embargo, una propuesta actualmente en curso para implementar tipos parametrizados utiliza una sintaxis muy similar a las plantillas (templates) de C++.
El dilema de las labores del hogar:
¿Quién limpia la casa?
Cada objeto requiere recursos simplemente para poder existir, principalmente memoria. cuando
un objeto deja de ser necesario debe ser eliminado de manera que estos recursos queden disponibles
para poder reutilizar. En situaciones de programación sencillas la cuestión de cuándo eliminar un
objeto no se antoja complicado: se crea el objeto, se utiliza mientras sea necesario y posteriormente
debe ser destruido. Sin embargo, no es difícil encontrar situaciones en las que esto se corriplica.
Supóngase, por ejemplo, que se está diseñando un sistema para gestionar el tráfico aéreo de un aeropuerto. (El mismo modelo podría funcionar también para gestionar paquetes en un almacén, o un
sistema de alquiler de vídeos, o una residencia canina.) A primera vista, parece simple: construir un
contenedor para albergar aviones, cree a continuación un nuevo avión y ubiquelo en el contenedor
(para cada avión que aparezca en la zona a controlar). En el momento de eliminación, se borra (suprime) simplemente el objeto aeroplano correcto cuando un avión sale de la zona barrida.
Pero quizás, se tiene otro sistema para guardar los datos de los aviones, datos que no requieren
inmediatamente, como atencion la funcion de control principal. Quizás, se trata de un registro del plan de
viaje de todos los pequeños aviones que abandonan el aeropuerto. Es decir, se dispone de un segundo contenedor de aviones pequeños, y siempre que se crea un objeto avión también se introduce en este segundo contenedor si se trata de un avión pequeño. Posteriormente, algún proceso en
segundo plano lleva a cabo operaciones con los objetos de este segundo contenedor cada vez que el
El sistema está ocioso.
Ahora el problema se complica: ¿cómo se sabe cuándo destruir los objetos? Cuando el programa
principal (el controlador) ha terminado de usar el objeto, puede que otra parte del sistema lo esté
usando (o lo vaya a usar en un futuro). Este problema surge en numerosas ocasiones, y los sistemas de programación (como C++) en los que los objetos deben borrarse explícitamente cuando acaba de usarlos, pueden volverse bastante complejos.
Con Java, el problema de vigilar que se libere la memoria se ha implementado en el rccolector de
basura (aunque no incluye otros aspectos de la supresión de objetos). El recolector "sabe" cuando
se ha dejado de utilizar un objeto y libera la memoria que ocupaba automáticamente. Esto (combinado con el hecho de que todos los objetos son heredados de la clase raíz única Object y con la
existencia de una única forma de crear objetos, en el montículo) hace que el proceso de programar
en Java sea mucho más sencillo que el hacerlo en C++. Henomuchas menos decisiones que tomar y
menos obstáculos que sortear.
22 Piensa en Java
Los recolectores de basura frente a la eficiencia y flexibilidad
Si todo esto es tan buena idea, ¿por qué no se hizo lo mismo en C++? Bien, por supuesto, hay un
precio que pagar por todas estas comodidades de programación, y este precio consiste en sobrecarga en tiempo de ejecución. Como se mencionó anteriormente, en C++ es posible crear objetos en
la pila, y en este caso, éstas se eliminan automáticamente (pero no se dispone de la flexibilidad de
crear tantos como se desee en tiempo de ejecución). La creación de objetos en la pila es la manera.
más eficiente de espacio asignar a los objetos y de liberarlo. La creación de objetos en el montículo.
Puede ser mucho más caro. Heredar siempre de una clase base y hacer que todas las llamadas
una función sean polimórficas también conlleva un pequeño peaje. Pero el recolector de basura es un
problema concreto pues nunca se sabe cuándo se va a poner en marcha y cuánto tiempo llevará
su ejecución. Esto significa que hay inconsistencias en los ratios (velocidad) de ejecución de los programas escritos en Java, por lo que éstos no pueden ser utilizados en determinadas situaciones,
como por ejemplo, cuando el tiempo de ejecución de un programa es uniformemente crítico. (Se trata de los programas denominados generalmente de tiempo real, aunque no todos los problemas de
programación en tiempo real son tan rígidos.)
Los diseñadores del lenguaje C++, trataron de ganarse a los programadores de C (en lo cual tuvieron bastante éxito), no quisieron añadir nuevas características al lenguaje que pudiesen influir en la
velocidad o el uso de C++ en cualquier situación en la que los programadores puedan decantarse
por C. Se logró la meta, pero a cambio de una mayor complejidad cuando se programa en C++. Java
Es más simple que C++, pero un cambio es menos eficiente y en ocasiones ni siquiera aplicable. Pecado
Sin embargo, para un porcentaje elevado de problemas de programación, Java es la mejor elección.
Manejo de excepciones:
tratar con errores
El manejo de errores ha sido, desde el principio de la existencia de los lenguajes de programación,
uno de los aspectos más difíciles de abordar. Dado que es muy complicado diseñar un buen
esquema de manejo de errores, muchos lenguajes simplemente ignoran este aspecto, pasando el
problema a los diseñadores de bibliotecas que suelen contestar con soluciones a medios que funcionan en la mayoría de situaciones, pero que pueden ser burladas de manera sencilla; es decir, simplemente ignorándolas. Un problema importante con la mayoría de los esquemas de tratamiento de
errores es que depende de la vigilancia del programador de cara al seguimiento de una convención preestablecida no especialmente promovida por el propio lenguaje. Si el programador no está
atento -cosa que ocurre muchas veces, especialmente si se tiene prisa- es posible olvidar estos
esquemas con relativa facilidad.
El manejo de excepciones está íntimamente relacionado con el lenguaje de programación y a veces
incluso con el sistema operativo. Una excepción es un objeto que es "lanzado", "arrojadowq desde el
lugar en que se produce el error, y que puede ser "capturado" por el gestor de excepción apropiado
Y N. del traductor: en inglés se emplea el verbo throw.
1: Introducción a los objetos 23
Diseñado para manejar ese tipo de error en concreto. Es como si la gestión de excepciones constituyera una causa de ejecución diferente, paralela, que puede tomarse cuando algo va mal. Y dado que
usa una causa de ejecución distinta, no tiene por qué interferir con el código de ejecución normal. Delaware
de esta manera el código es más simple de escribir puesto que no hay que estar comprobando los errores continuamente. Además, una excepción lanzada no es como un valor de error devuelto por una
función, o un indicador (bandera) que una función pone a uno para indicar que se ha dado cierto
condición de error (estos podrían ser ignorados). Una excepción no se puede ignorar, por lo que se
Garantiza que será tratado antes o después. Finalmente, las excepciones proporcionan una manera de
recuperarse de manera segura de una situación anormal. En vez de simplemente salir, muchas veces
es posible volver a poner las cosas en su sitio y reestablecer la ejecución del programa, logrando así
que estos sean mucho más robustos.
El manejo de excepciones de Java destaca entre los lenguajes de programación pues en Java, éste
se encuentra imbuido desde el principio, y es obligatorio utilizarlo. Si no se escribe un código de
manera que maneje excepciones correctamente, se obtendrá un mensaje de error en el tiempo de
compilación. Esta garantía de consistencia hace que la gestión de errores sea mucho más sencilla.
Es importante destacar el hecho de que el manejo de excepciones no es una característica orientada
a objetos, aunque en los lenguajes orientados a objetos las excepciones se suelan representarme
diante un objeto. El manejo de excepciones existe.